<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>代理模式 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 士不可以不弘毅，任重而道远 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Android/"><i class="fa "></i>Android</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Web/"><i class="fa "></i>Web</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Java/"><i class="fa "></i>Java</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="代理模式">
            
	            代理模式
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/Android">
            Android
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/设计模式" title='设计模式'>
                        设计模式
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/07/04</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>目标接口、代理对象、被代理的对象。</p>
<pre><code>/**
 * 银行办理业务 - 目标接口（业务）
 */
public interface IBank {
    /*** 申请办卡*/
    public void applyBank();

    /*** 挂失*/
    public void lostBank();
}

/**
 * 银行办理业务 - 代理对象 - 银行的业务员
 */
public class BankWorker implements IBank{
    private IBank bank;
    /**
     * 持有被代理的对象
     * @param bank
     */
    public BankWorker(IBank bank){
        this.bank = bank;
    }

    @Override
    public void applyBank() {
        System.out.println(&quot;开始受理&quot;);
        bank.applyBank();
        System.out.println(&quot;操作完毕&quot;);
    }

    @Override
    public void lostBank() {
        System.out.println(&quot;开始受理&quot;);
        bank.lostBank();
        System.out.println(&quot;操作完毕&quot;);
    }
}

/**
 * 银行办理业务 - 被代理的对象 - 我们
 */
public class Man implements IBank {
    private String name;

    public Man(String name) {
        this.name = name;
    }

    /**
     * 自己的一些操作
     */
    @Override
    public void applyBank() {
        System.out.println(name + &quot; 申请办卡&quot;);
    }

    @Override
    public void lostBank() {
        System.out.println(name + &quot; 申请挂失&quot;);
    }
}

public class Client {
    public static void main(String[] args){
        Man man = new Man(&quot;张三&quot;);
        BankWorker bankWorker = new BankWorker(man);
        bankWorker.applyBank();
    }
}
</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>形式</p>
<pre><code>Proxy.newProxyInstance(
    IBank.class.getClassLoader(),//ClassLoader
    new Class&lt;?&gt;[]{IBank.class},//目标接口
    null//InvocationHandler-关键
);
</code></pre><p>代码</p>
<pre><code>/**
 * 银行办理业务 - 动态代理 - InvocationHandler
 */
public class BankInvocationHandler implements InvocationHandler{
    /**
     * 被代理的对象
     */
    private Object mObject;

    public BankInvocationHandler(Object object){
        this.mObject = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 执行方法 ，目标接口调用的方法都会来到这里面
        // System.out.println(&quot;methodName = &quot;+method.getName());
        System.out.println(&quot;开始受理&quot;);
        // System.out.println(&quot;params = &quot;+args.toString());
        // 调用被代理对象的方法,这里其实调用的就是  man 里面的 applyBank 方法
        Object voidObject = method.invoke(mObject,args);
        System.out.println(&quot;操作完毕&quot;);
        return voidObject;
    }
}

public class Client {
    public static void main(String[] args) {
        Man man = new Man(&quot;张三&quot;);

        IBank bank =
                // 返回的是 IBank 的一个实例对象，这个对象是由 Java 给我们创建的 ,调用的是 jni
                (IBank) Proxy.newProxyInstance(
                        IBank.class.getClassLoader(), // ClassLoader
                        new Class&lt;?&gt;[]{IBank.class}, // 目标接口
                        new BankInvocationHandler(man) // InvocationHandler (这个类是关键)
                );
        // 当调用这个方法的时候会来到 BankInvocationHandler 的 invoke 方法
        bank.applyBank();
        bank.lostBank();
        bank.extraBank();
    }
}

/**
 * 银行办理业务 - 目标接口（业务）
 */
public interface IBank {
    /**
     * 申请办卡
     */
    public void applyBank();

    /**
     * 挂失
     */
    public void lostBank();

    /**
     * 额外业务
     */
    public void extraBank();
}

/**
 * 银行办理业务 - 被代理的对象 - 我们
 */
public class Man implements IBank {
    private String name;

    public Man(String name){
        this.name = name;
    }

    /**
     * 自己的一些操作
     */
    @Override
    public void applyBank() {
        System.out.println(name + &quot; 申请办卡&quot;);
    }

    @Override
    public void lostBank() {
        System.out.println(name + &quot; 申请挂失&quot;);
    }

    @Override
    public void extraBank() {
        System.out.println(name + &quot; 额外业务&quot;);
    }
}
</code></pre><h2 id="开发用到的地方"><a href="#开发用到的地方" class="headerlink" title="开发用到的地方"></a>开发用到的地方</h2><pre><code>Android 插件化架构之绕过 AndroidManifest 检测（动态代理）
Android 数据库实现数据的懒加载（静态代理）
Android MVP 架构设计（静态代理和动态代理）
Android Xutils 实现 View 事件注入（动态代理）
Android Retrofit 的 create 创建接口对象 （动态代理）
Android Framework 层的 AMS
Android Framework 层的 Binder 驱动
</code></pre><p>Retrofit的create</p>
<pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {
    // 验证当前类是否是接口
    Utils.validateServiceInterface(service);

    //有需要的话做方法缓存？
    if (validateEagerly) {
        eagerlyValidateMethods(service);
    }

    // 动态代理设计模式
    return (T) Proxy.newProxyInstance(service.getClassLoader(),
            new Class&lt;?&gt;[] { service }, new InvocationHandler() {

                private final Platform platform = Platform.get();

                @Override
                public Object invoke(Object proxy, Method method,
                        Object... args) throws Throwable {
                    //如果调用的方法是Object的
                    if (method.getDeclaringClass() == Object.class) {
                        return method.invoke(this, args);
                    }
                    // //默认进不来这个if ，平台判断 android java8 ios
                    if (platform.isDefaultMethod(method)) {
                        return platform.invokeDefaultMethod(method,
                                service, proxy, args);
                    }

                    // 重点*具体执行细节
                    // method:就是我们调用的具体的方法(例如：login方法) 去解析方法属性和参数属性吧？
                    ServiceMethod serviceMethod = loadServiceMethod(method);
                    // 解析完成之后，调用OKHttp框架执行请求
                    OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
                    // 这个最终是 ExecutorCallAdapterFactory 里面的 CallAdapter 所以最终返回的是 ExecutorCallbackCall
                    return serviceMethod.callAdapter.adapt(okHttpCall);
                }
            });
}
</code></pre><p>自己实现create的思路</p>
<pre><code>public &lt;T&gt; T create(Class&lt;T&gt; clazz){
    // 动态代理
    return (T) Proxy.newProxyInstance(clazz.getClassLoader(),
            new Class&lt;?&gt;[]{clazz}, new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    Log.e(&quot;TAG&quot;,method.getName());
                    // 如果要实现 Retrofit 一样的代码应该怎么办？
                    // 1. 解析方法的所有注解 比如 POST GET FormUrlEncoded 等等
                    // 2. 解析参数的所有注解 比如 FieldMap Part PartMap 等等
                    // 3. 封装成 Call 对象
                    // 4.返回的 Call 对象
                    return &quot;返回&quot;;
                }
            });
}
</code></pre><p>通过<code>Retrofit.create(class)</code>方法创建出Service interface的实例，从而使得Service中配置的方法变得可用，这是Retrofit代码结构的核心。</p>
<p><code>Retrofit.create(class)</code>方法内部，使用<code>Proxy.newProxyInstance()</code>方法创建Service实例。create方法会为参数中的interface创建一个对象，这个对象实现了interface中的每一个方法，并且每个方法的实现都是类似的：调用对象实例内部的一个<code>InvocationHandler</code>成员变量的<code>invoke()</code>方法，并把自己的方法信息传递进去。实质上就是动态代理：interface中的方法全部由一个另外设定的<code>InvocationHandler</code>对象来进行代理操作。并且，这些方法的具体实现是在运行时生成interface实例时才确定的，而不是在编译时。</p>
<p><code>invoke()</code>方法中创建interface实例，有三行关键代码：</p>
<p>1、ServiceMethod的创建：</p>
<pre><code>ServiceMethod&lt;Object, Object&gt; serviceMethod = （ServiceMethod&lt;Object, Object&gt;）loadServiceMethod(method);
</code></pre><p>这行代码负责读取interface中原方法的信息，包括返回值、方法注解、参数类型、参数注解，并将这些信息做初步分支。</p>
<p>2、OkHttpCall的创建</p>
<pre><code>OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre><p>OkHttpCall是<code>retrofit2.Call</code>的子类。这行代码负责将ServiceMethod封装进<code>retrofit2.Call</code>对象，这个对象可以在需要的时候，例如<code>enqueue()</code>方法被调用的时候，利用ServiceMethod中包含的信息来创建一个<code>okhttp3.Call</code>对象，并调用这个<code>okhttp3.Call</code>对象来进行网络请求的发起，然后对结果进行预处理，如类型转换。</p>
<p>3、<code>adapt()</code>方法</p>
<pre><code>return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre><p>这个方法会使用ServiceMethod中的callAdapter对象来把okHttpCall对象进行转换,生成一个新的<code>retrofit2.Call</code>对象，在这个新的Call对象中，后台线程发起的请求，会在相应返回后，从主线程中调用回调方法，实现线程的自动切换。</p>
<p>另外这个方法不止可以生成新的<code>retrofit2.Call</code>对象，也可以生成别的类型对象，例如RaJava的Obervable，来让Retrofit可以和RaJava结合使用。</p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="../../../../img/reward-alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="../../../../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2020/06/26/35.Android性能分析与优化/" class="next-post btn btn-default" title='Android性能分析与优化'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Android性能分析与优化</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态代理"><span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开发用到的地方"><span class="toc-text">开发用到的地方</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>