<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>数据结构和算法 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 士不可以不弘毅，任重而道远 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Android/"><i class="fa "></i>Android</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Web/"><i class="fa "></i>Web</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Java/"><i class="fa "></i>Java</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C/"><i class="fa "></i>C</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="数据结构和算法">
            
	            数据结构和算法
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/Java">
            Java
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/算法" title='算法'>
                        算法
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/07/06</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1、数据结构分类"><a href="#1、数据结构分类" class="headerlink" title="1、数据结构分类"></a>1、数据结构分类</h3><hr>
<p>数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据。</p>
<p>把数据结构分为逻辑结构和物理结构两大类。</p>
<p>逻辑结构分类：集合结构、线性结构、树形结构、图形结构。</p>
<p>物理结构：顺序存储结构、链式存储结构。</p>
<p>顺序存储结构：把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的<strong>数组就是顺序存储结构</strong>。<strong>查找快、插入删除慢</strong>。</p>
<p>链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。<strong>查找慢，增删快</strong>。</p>
<hr>
<h3 id="2、算法介绍"><a href="#2、算法介绍" class="headerlink" title="2、算法介绍"></a>2、算法介绍</h3><hr>
<p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。<strong>根据一定的条件，对一些数据进行计算，得到需要的结果</strong>。</p>
<p>一个优秀的算法追求以下两个目标：1.花最少的时间完成需求；2.占用最少的内存空间完成需求。</p>
<hr>
<h3 id="3、算法的时间复杂度"><a href="#3、算法的时间复杂度" class="headerlink" title="3、算法的时间复杂度"></a>3、算法的时间复杂度</h3><hr>
<p>算法的时间复杂度分析</p>
<p>事后分析估算方法：计算方法执行时间<code>System.currentTimeMillis()</code>。</p>
<p>事前分析估算方法：算法采用的策略和方案；问题的输入规模(所谓的问题输入规模就是输入量的多少)。最重要的就是把核心操作的次数和输入规模关联起来。</p>
<p>总结：随着输入规模的增大，算法的常数操作可以忽略不计。随着输入规模的增大，与最高次项相乘的常数可以忽略。最高次项的指数大的，随着n的增长，结果也会变得增长特别快。算法函数中n最高次幂越小，算法效率越高。</p>
<hr>
<h3 id="4、时间复杂度大O记法"><a href="#4、时间复杂度大O记法" class="headerlink" title="4、时间复杂度大O记法"></a>4、时间复杂度大O记法</h3><hr>
<p>执行次数=执行时间。用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。</p>
<p>大O阶的表示法有以下几个规则可以使用：</p>
<p>1.用常数1取代运行时间中的所有加法常数；</p>
<p>2.在修改后的运行次数中，只保留高阶项；</p>
<p>3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数。</p>
<p>复杂程度从低到高依次为：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)。</p>
<hr>
<h3 id="5、算法的空间复杂度"><a href="#5、算法的空间复杂度" class="headerlink" title="5、算法的空间复杂度"></a>5、算法的空间复杂度</h3><hr>
<p>数据类型 内存占用字节数：byte 1、short 2、int 4、long 8、float 4、double 8、boolean 1、char 2。</p>
<p>计算机访问内存的方式都是一次一个字节。</p>
<p>一个引用（机器地址）需要8个字节表示：</p>
<pre><code>Date date = new Date()；//则date这个变量需要占用8个字节来表示
</code></pre><p>创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。</p>
<p>一般内存的使用，如果不够8个字节，都会被自动填充为8字节。</p>
<p>java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。</p>
<pre><code>int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节
</code></pre><hr>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="1、Comparable接口"><a href="#1、Comparable接口" class="headerlink" title="1、Comparable接口"></a>1、Comparable接口</h3><hr>
<pre><code>public class Student implements Comparable&lt;Student&gt;{
    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; +
                &quot;, age=&quot; + age +
                &apos;}&apos;;
    }

    @Override
    public int compareTo(Student o) {
        return this.getAge()-o.getAge();
    }
}

public class TestComparable {

    public static void main(String[] args) {
        //创建两个Student对象，并调用getMax方法，完成测试
        Student s1 = new Student();
        s1.setUsername(&quot;张三&quot;);
        s1.setAge(18);

        Student s2 = new Student();
        s2.setUsername(&quot;李四&quot;);
        s2.setAge(20);

        Comparable max = getMax(s1, s2);
        System.out.println(max);
    }

    public static Comparable getMax(Comparable c1,Comparable c2){
        int result = c1.compareTo(c2);
        //如果result&lt;0,则c1比c2小；
        //如果result&gt;0，则c1比c2大；
        //如果result==0,则c1和c2一样大；
        if (result&gt;=0){
            return c1;
        }else{
            return c2;
        }
    }
}
</code></pre><hr>
<h3 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h3><hr>
<p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。最终最后位置的元素就是最大值。</p>
<pre><code>public class Bubble {
    /*
     *  对数组的元素进行排序
    */
    public static void sort(Comparable[] a){
        for(int i=a.length-1;i&gt;0;i--){
            for(int j=0;j&lt;i;j++){
                //比较索引j和索引j+1处的值
                if (greater(a[j],a[j+1])){
                    exch(a,j,j+1);
                }
            }
        }
    }

    /*
     *  比较v元素是否大于w元素
     */
    private static  boolean greater(Comparable v,Comparable w){
        return v.compareTo(w)&gt;0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}

public class BubbleTest {
    public static void main(String[] args) {
        Integer[] arr = {4,5,6,3,2,1};
        Bubble.sort(arr);

        System.out.println(Arrays.toString(arr));//{1,2,3,4,5,6}
    }
}
</code></pre><p>冒泡排序的时间复杂度为O(N^2)。</p>
<hr>
<h3 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h3><hr>
<p>每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引。然后交换第一个索引处和最小值所在的索引处的值。</p>
<pre><code>public class Selection {
    /*
       对数组中的元素进行排序
    */
    public static void sort(Comparable[] a){
        for(int i=0;i&lt;=a.length-2;i++){
            //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置
            int minIndex = i;
            for(int j=i+1;j&lt;a.length;j++){
                //需要比较最小索引minIndex处的值和j索引处的值；
                if (greater(a[minIndex],a[j])){
                    minIndex=j;
                }
            }
            //交换最小元素所在索引minIndex处的值和索引i处的值
            exch(a,i,minIndex);
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static  boolean greater(Comparable v,Comparable w){
        return v.compareTo(w)&gt;0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}

public class SelectionTest {
    public static void main(String[] args) {
        //原始数据
        Integer[] a = {4,6,8,7,9,2,10,1};
        Selection.sort(a);
        System.out.println(Arrays.toString(a));//{1,2,4,5,7,8,9,10}
    }
}
</code></pre><p>时间复杂度为O(N^2)。</p>
<hr>
<h3 id="4、插入排序"><a href="#4、插入排序" class="headerlink" title="4、插入排序"></a>4、插入排序</h3><hr>
<p>把所有的元素分为两组，已经排序的和未排序的；找到未排序的组中的第一个元素，向已经排序的组中进行插入；倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。类似打扑克牌时，新牌往手里牌的排序。</p>
<pre><code>public class Insertion {
    /*
       对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        for(int i=1;i&lt;a.length;i++){
            for(int j=i;j&gt;0;j--){
                //比较索引j处的值和索引j-1处的值，如果索引j-1处的值比索引j处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可；
                if (greater(a[j-1],a[j])){
                    exch(a,j-1,j);
                }else{
                    break;
                }
            }
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static  boolean greater(Comparable v,Comparable w){
        return v.compareTo(w)&gt;0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}

public class InsertionTest {
    public static void main(String[] args) {
        Integer[] a = {4,3,2,10,12,1,5,6};

        Insertion.sort(a);

        System.out.println(Arrays.toString(a));//{1,2,3,4,5,6,10,12}

    }
}
</code></pre><p>时间复杂度为O(N^2)。</p>
<hr>
<h3 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h3><hr>
<p>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；对分好组的每一组数据完成插入排序；减小增长量，最小减为1，重复第二步操作。</p>
<p>增长量h的确定：</p>
<pre><code>int h=1
while(h&lt;(数组长度/2)){
    h=2h+1
}
//循环结束后我们就可以确定h的最大值

//h的减小规则为：
h=h/2
</code></pre><p>代码</p>
<pre><code>public class Shell {
    /*
       对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        //1.根据数组a的长度，确定增长量h的初始值；
        int h = 1;
        while(h&lt;a.length/2){
            h=2*h+1;
        }
        //2.希尔排序
        while(h&gt;=1){
            //排序
            //2.1.找到待插入的元素
            for (int i=h;i&lt;a.length;i++){
                //2.2把待插入的元素插入到有序数列中
                for (int j=i;j&gt;=h;j-=h){

                    //待插入的元素是a[j],比较a[j]和a[j-h]
                    if (greater(a[j-h],a[j])){
                        //交换元素
                        exch(a,j-h,j);
                    }else{
                        //待插入元素已经找到了合适的位置，结束循环；
                        break;
                    }
                }
            }
            //减小h的值
            h= h/2;
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static  boolean greater(Comparable v,Comparable w){
        return v.compareTo(w)&gt;0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}

public class ShellTest {
    public static void main(String[] args) {
        Integer[] a = {9,1,2,5,7,4,8,6,3,5};
        Shell.sort(a);
        System.out.println(Arrays.toString(a));//{1,2,3,4,5,5,6,7,8,9}
    }
}
</code></pre><hr>
<h3 id="6、归并排序"><a href="#6、归并排序" class="headerlink" title="6、归并排序"></a>6、归并排序</h3><hr>
<p>尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。将相邻的两个子组进行合并成一个有序的大组；不断的重复步骤2，直到最终只有一个组为止。</p>
<pre><code>public class Merge {
    //归并所需要的辅助数组
    private static Comparable[] assist;

    /*
       比较v元素是否小于w元素
    */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w)&lt;0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }


    /*
           对数组a中的元素进行排序
        */
    public static void sort(Comparable[] a) {
        //1.初始化辅助数组assist；
        assist = new Comparable[a.length];
        //2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引；
        int lo=0;
        int hi=a.length-1;
        //3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序
        sort(a,lo,hi);
    }

    /*
    对数组a中从lo到hi的元素进行排序
     */
    private static void sort(Comparable[] a, int lo, int hi) {
        //做安全性校验；
        if (hi&lt;=lo){
            return;
        }

        //对lo到hi之间的数据进行分为两个组
        int mid = lo+(hi-lo)/2;//   5,9  mid=7

        //分别对每一组数据进行排序
        sort(a,lo,mid);
        sort(a,mid+1,hi);

        //再把两个组中的数据进行归并
        merge(a,lo,mid,hi);
    }

    /*
    对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并
     */
    private static void merge(Comparable[] a, int lo, int mid, int hi) {
        //定义三个指针
        int i=lo;
        int p1=lo;
        int p2=mid+1;

        //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处
        while(p1&lt;=mid &amp;&amp; p2&lt;=hi){
            //比较对应索引处的值
            if (less(a[p1],a[p2])){
                assist[i++] = a[p1++];
            }else{
                assist[i++]=a[p2++];
            }
        }

        //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处
        while(p1&lt;=mid){
            assist[i++]=a[p1++];
        }
        //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处
        while(p2&lt;=hi){
            assist[i++]=a[p2++];
        }
        //把辅助数组中的元素拷贝到原数组中
        for(int index=lo;index&lt;=hi;index++){
            a[index]=assist[index];
        }

    }

}

public class MergeTest {
    public static void main(String[] args) {
        Integer[] a = {8,4,5,7,1,3,6,2};
        Merge.sort(a);
        System.out.println(Arrays.toString(a));//{1,2,3,4,5,6,7,8}
    }
}
</code></pre><p>归并排序的时间复杂度为O(nlogn)。归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。</p>
<hr>
<h3 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h3><hr>
<p>首先设定一个分界值，通过该分界值将数组分成左右两部分；将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；</p>
<p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
<p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</p>
<p>切分原理：把一个数组切分成两个子数组的基本思想：</p>
<p>1.找一个基准值，用两个指针分别指向数组的头部和尾部；</p>
<p>2.先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；</p>
<p>3.再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；</p>
<p>4.交换当前左边指针位置和右边指针位置的元素；</p>
<p>5.重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。</p>
<pre><code>public class Quick {
    /*
      比较v元素是否小于w元素
   */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) &lt; 0;
    }

    /*
   数组元素i和j交换位置
    */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    //对数组内的元素进行排序
    public static void sort(Comparable[] a) {
        int lo = 0;
        int hi = a.length-1;
        sort(a,lo,hi);
    }

    //对数组a中从索引lo到索引hi之间的元素进行排序
    private static void sort(Comparable[] a, int lo, int hi) {
        //安全性校验
        if (hi&lt;=lo){
            return;
        }

        //需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）；
        int partition = partition(a, lo, hi);//返回的是分组的分界值所在的索引，分界值位置变换后的索引

        //让左子组有序
        sort(a,lo,partition-1);

        //让右子组有序
        sort(a,partition+1,hi);
    }

    //对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引
    public static int partition(Comparable[] a, int lo, int hi) {
       //确定分界值
        Comparable key = a[lo];
        //定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置
        int left=lo;
        int right=hi+1;

        //切分
        while(true){
            //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止
            while(less(key,a[--right])){
                if (right==lo){
                    break;
                }
            }

            //再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止
            while(less(a[++left],key)){
                if (left==hi){
                    break;
                }
            }
            //判断 left&gt;=right,如果是，则证明元素扫描完毕，结束循环，如果不是，则交换元素即可
            if (left&gt;=right){
                break;
            }else{
                exch(a,left,right);
            }
        }

        //交换分界值
        exch(a,lo,right);

       return right;
    }

}

public class QuickTest {
    public static void main(String[] args) {
        Integer[] a= {6, 1, 2, 7, 9, 3, 4, 5, 8};
        Quick.sort(a);
        System.out.println(Arrays.toString(a));//{1, 2, 3, 4, 5, 6, 7, 8, 9}
    }
}
</code></pre><p>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</p>
<p>快速排序的时间复杂度为O(nlogn)。</p>
<hr>
<h3 id="8、排序的稳定性"><a href="#8、排序的稳定性" class="headerlink" title="8、排序的稳定性"></a>8、排序的稳定性</h3><hr>
<p>数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。</p>
<p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。</p>
<p>稳定排序算法：冒泡排序、插入排序、归并排序。</p>
<p>不稳定的排序算法：选择排序、希尔排序、快速排序。</p>
<hr>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><hr>
<p>若A元素在B元素的前面，则称A为B的前驱元素。若B元素在A元素的后面，则称B为A的后继元素。</p>
<p>第一个数据元素没有前驱，这个数据元素被称为头结点；最后一个数据元素没有后继，这个数据元素被称为尾结点；除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。</p>
<p>线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。</p>
<hr>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><hr>
<p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p>
<p>基本API、扩容、缩容、SequenceList能支持foreach循环，则需要做如下操作：让SequenceList实现Iterable接口，重写iterator方法；在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法。</p>
<pre><code>public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;{
    //存储元素的数组
    private T[] eles;
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    public void clear(){
        this.N=0;
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
       return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线型表中添加元素t
    public void insert(T t){
        if (N==eles.length){
            resize(2*eles.length);
        }

        eles[N++]=t;
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        if (N==eles.length){
            resize(2*eles.length);
        }

        //先把i索引处的元素及其后面的元素依次向后移动一位
        for(int index=N;index&gt;i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素依次向前移动一位即可
        for(int index=i;index&lt;N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;

        if (N&lt;eles.length/4){
            resize(eles.length/2);
        }

        return current;
    }

    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for(int i=0;i&lt;N;i++){
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }

    //根据参数newSize，重置eles的大小
    public void resize(int newSize){
        //定义一个临时数组，指向原数组
        T[] temp=eles;
        //创建新数组
        eles=(T[])new Object[newSize];
        //把原数组的数据拷贝到新数组即可
        for(int i=0;i&lt;N;i++){
            eles[i]=temp[i];
        }
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private int cusor;
        public SIterator(){
            this.cusor=0;
        }
        @Override
        public boolean hasNext() {
            return cusor&lt;N;
        }

        @Override
        public Object next() {
            return eles[cusor++];
        }
    }
}
</code></pre><p>测试</p>
<pre><code>public class SequenceListTest {
    public static void main(String[] args) {
        //创建顺序表对象
        SequenceList&lt;String&gt; sl = new SequenceList&lt;&gt;(10);
        //测试插入
        sl.insert(&quot;姚明&quot;);
        sl.insert(&quot;科比&quot;);
        sl.insert(&quot;麦迪&quot;);
        sl.insert(1,&quot;詹姆斯&quot;);

        for (String s : sl) {
            System.out.println(s);
        }
        System.out.println(&quot;------------------------------------------&quot;);

        //测试获取
        String getResult = sl.get(1);
        System.out.println(&quot;获取索引1处的结果为：&quot;+getResult);
        //测试删除
        String removeResult = sl.remove(0);
        System.out.println(&quot;删除的元素是：&quot;+removeResult);
        //测试清空
        sl.clear();
        System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length());
    }
}
</code></pre><p>由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显。</p>
<p><strong>java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查、扩容、遍历等功能。</strong></p>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><hr>
<p>链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。</p>
<pre><code>public class Node&lt;T&gt; {
    //存储元素
    public T item;
    //指向下一个结点
    public Node next;

    public Node(T item, Node next) {
        this.item = item;
        this.next = next;
    }
}
public static void main(String[] args) throws Exception {
    //构建结点
    Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(11, null);
    Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(13, null);
    Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(12, null);
    Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(8, null);
    Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(9, null);
    //生成链表
    first.next = second;
    second.next = third;
    third.next = fourth;
    fourth.next = fifth;
}
</code></pre><hr>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><hr>
<p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p>实现基本API、遍历、链表的反转。</p>
<pre><code>public class LinkList&lt;T&gt; implements Iterable&lt;T&gt;{
    //记录头结点
    private Node head;
    //记录链表的长度
    private int N;
    //结点类
    private class Node {
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public LinkList() {
        //初始化头结点、
        this.head = new Node(null,null);
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear() {
        head.next=null;
        this.N=0;
    }

    //获取链表的长度
    public int length() {
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //获取指定位置i出的元素
    public T get(int i) {
        //通过循环,从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = head.next;
        for(int index=0;index&lt;i;index++){
            n=n.next;
        }
        return n.item;
    }

    //向链表中添加元素t
    public void insert(T t) {
        //找到当前最后一个结点
        Node n = head;
        while(n.next!=null){
            n=n.next;
        }
        //创建新结点，保存元素t
        Node newNode = new Node(t, null);
        //让当前最后一个结点指向新结点
        n.next=newNode;
        //元素的个数+1
        N++;
    }

    //向指定位置i出，添加元素t
    public void insert(int i, T t) {
        //找到i位置前一个结点
        Node pre = head;
        for(int index=0;index&lt;=i-1;index++){
            pre=pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点需要指向原来i位置的结点
        Node newNode = new Node(t, curr);
        //原来i位置的前一个节点指向新结点即可
        pre.next=newNode;
        //元素的个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回被删除的元素
    public T remove(int i) {
        //找到i位置的前一个节点
        Node pre = head;
        for(int index=0;index&lt;=i-1;i++){
            pre=pre.next;
        }
        //要找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //前一个结点指向下一个结点
        pre.next=nextNode;
        //元素个数-1
        N--;
        return curr.item;
    }

    //查找元素t在链表中第一次出现的位置
    public int indexOf(T t) {
        //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，就找到了
        Node n = head;
        for(int i=0;n.next!=null;i++){
            n=n.next;
            if (n.item.equals(t)){
                return i;
            }
        }
        return -1;
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new LIterator();
    }

    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }

    //用来反转整个链表
    public void reverse(){
        //判断当前链表是否为空链表，如果是空链表，则结束运行，如果不是，则调用重载的reverse方法完成反转
        if (isEmpty()){
            return;
        }
        reverse(head.next);
    }

    //反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr){
        if (curr.next==null){
            head.next=curr;
            return curr;
        }
        //递归的反转当前结点curr的下一个结点；返回值就是链表反转后，当前结点的上一个结点
        Node pre = reverse(curr.next);
        //让返回的结点的下一个结点变为当前结点curr；
        pre.next=curr;
        //把当前结点的下一个结点变为null
        curr.next=null;
        return curr;
    }
}
</code></pre><p>测试</p>
<pre><code>public class LinkListTest {
    public static void main(String[] args) {
        //创建顺序表对象
        LinkList&lt;String&gt; sl = new LinkList&lt;&gt;();
        //测试插入
        sl.insert(&quot;姚明&quot;);
        sl.insert(&quot;科比&quot;);
        sl.insert(&quot;麦迪&quot;);
        sl.insert(1,&quot;詹姆斯&quot;);
        for (String s : sl) {
            System.out.println(s);
        }
        System.out.println(&quot;------------------------------------------&quot;);

        //测试获取
        String getResult = sl.get(1);
        System.out.println(&quot;获取索引1处的结果为：&quot;+getResult);
        //测试删除
        String removeResult = sl.remove(0);
        System.out.println(&quot;删除的元素是：&quot;+removeResult);
        //测试清空
        sl.clear();
        System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length());
    }
}
</code></pre><hr>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><hr>
<p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p>实现基本API、遍历。</p>
<pre><code>public class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt; {
    //首结点
    private Node head;
    //最后一个结点
    private Node last;
    //链表的长度
    private int N;
    //结点类
    private class Node{
        public Node(T item, Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
        //存储数据
        public T item;
        //指向上一个结点
        public Node pre;
        //指向下一个结点
        public Node next;
    }

    public TowWayLinkList() {
       //初始化头结点和尾结点
        this.head = new Node(null,null,null);
        this.last=null;
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear(){
        this.head.next=null;
        this.head.pre=null;
        this.head.item=null;
        this.last=null;
        this.N=0;
    }

    //获取链表长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //获取第一个元素
    public T getFirst(){
        if (isEmpty()){
            return null;
        }
        return head.next.item;
    }

    //获取最后一个元素
    public T getLast(){
        if (isEmpty()){
            return null;
        }
        return last.item;
    }

    //插入元素t
    public void insert(T t){
        if (isEmpty()){
            //如果链表为空：
            //创建新的结点
            Node newNode = new Node(t,head, null);
            //让新结点称为尾结点
            last=newNode;
            //让头结点指向尾结点
            head.next=last;
        }else {
            //如果链表不为空
            Node oldLast = last;
            //创建新的结点
            Node newNode = new Node(t, oldLast, null);
            //让当前的尾结点指向新结点
            oldLast.next=newNode;
            //让新结点称为尾结点
            last = newNode;
        }
        //元素个数+1
        N++;
    }

    //向指定位置i处插入元素t
    public void insert(int i,T t){
        //找到i位置的前一个结点
        Node pre = head;
        for(int index=0;index&lt;i;index++){
            pre=pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点
        Node newNode = new Node(t, pre, curr);
        //让i位置的前一个结点的下一个结点变为新结点
        pre.next=newNode;
        //让i位置的前一个结点变为新结点
        curr.pre=newNode;
        //元素个数+1
        N++;
    }

    //获取指定位置i处的元素
    public T get(int i){
        Node n = head.next;
        for(int index=0;index&lt;i;index++){
            n=n.next;
        }
        return n.item;
    }

    //找到元素t在链表中第一次出现的位置
    public int indexOf(T t){
        Node n = head;
        for(int i=0;n.next!=null;i++){
            n=n.next;
            if (n.next.equals(t)){
                return i;
            }
        }
        return -1;
    }

    //删除位置i处的元素，并返回该元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for(int index=0;index&lt;i;index++){
            pre=pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode= curr.next;
        //让i位置的前一个结点的下一个结点变为i位置的下一个结点
        pre.next=nextNode;
        //让i位置的下一个结点的上一个结点变为i位置的前一个结点
        nextNode.pre=pre;
        //元素的个数-1
        N--;
        return curr.item;
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new TIterator();
    }

    private class TIterator implements Iterator{
        private Node n;
        public TIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
</code></pre><p>测试</p>
<pre><code>public class TowWayLinkListTest {
    public static void main(String[] args) {
        //创建双向链表对象
        TowWayLinkList&lt;String&gt; sl = new TowWayLinkList&lt;&gt;();
        //测试插入
        sl.insert(&quot;姚明&quot;);
        sl.insert(&quot;科比&quot;);
        sl.insert(&quot;麦迪&quot;);
        sl.insert(1,&quot;詹姆斯&quot;);
        for (String s : sl) {
            System.out.println(s);
        }
        System.out.println(&quot;--------------------------------------&quot;);
        System.out.println(&quot;第一个元素是：&quot;+sl.getFirst());
        System.out.println(&quot;最后一个元素是：&quot;+sl.getLast());
        System.out.println(&quot;------------------------------------------&quot;);
        //测试获取
        String getResult = sl.get(1);
        System.out.println(&quot;获取索引1处的结果为：&quot;+getResult);
        //测试删除
        String removeResult = sl.remove(0);
        System.out.println(&quot;删除的元素是：&quot;+removeResult);
        //测试清空
        sl.clear();
        System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length());
    }
}
</code></pre><p><strong>java中LinkedList集合也是使用双向链表实现，结点类有三个域，并提供了增删改查等相关方法。</strong></p>
<p>链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,同时它并没有涉及的元素的交换。</p>
<p>相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</p>
<hr>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><hr>
<p>快慢指针获取中间值。slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。</p>
<pre><code>public class FastSlowTest {
    public static void main(String[] args) throws Exception {
        //创建结点
        Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);
        Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);
        Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);
        Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);
        Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);
        Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);
        Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //查找中间值
        String mid = getMid(first);
        System.out.println(&quot;中间值为：&quot;+mid);
    }

    /**
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
    public static String getMid(Node&lt;String&gt; first) {
        //定义两个指针
        Node&lt;String&gt; fast = first;
        Node&lt;String&gt; slow = first;
        //使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值
        while(fast!=null &amp;&amp;fast.next!=null){
            //变化fast的值和slow的值
            fast = fast.next.next;
            slow=slow.next;
        }

        return slow.item;
    }

    //结点类
    private static class Node&lt;T&gt; {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
</code></pre><p>快慢指针检查是否有环。两个指针有速度差，那么迟早两个指针会相遇，只要相遇那么就说明有环。</p>
<pre><code>public class CircleListCheckTest {
    public static void main(String[] args) throws Exception {
        //创建结点
        Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);
        Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);
        Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);
        Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);
        Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);
        Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);
        Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
//        //产生环
//        seven.next = third;

        //判断链表是否有环
        boolean circle = isCircle(first);
        System.out.println(&quot;first链表中是否有环：&quot;+circle);
    }

    /**
     * 判断链表中是否有环
     * @param first 链表首结点
     * @return ture为有环，false为无环
     */
    public static boolean isCircle(Node&lt;String&gt; first) {
        //定义快慢指针
        Node&lt;String&gt; fast = first;
        Node&lt;String&gt; slow = first;
        //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
        while(fast!=null &amp;&amp; fast.next!=null){
            //变换fast和slow
            fast = fast.next.next;
            slow = slow.next;

            if (fast.equals(slow)){
                return true;
            }
        }
        return false;
    }

    //结点类
    private static class Node&lt;T&gt; {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
</code></pre><p>快慢指针查找有环链表入口。当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。</p>
<pre><code>public class CircleListInTest {
    public static void main(String[] args) throws Exception {
        Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);
        Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);
        Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);
        Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);
        Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);
        Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);
        Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //产生环
        seven.next = third;
        //查找环的入口结点
        Node&lt;String&gt; entrance = getEntrance(first);
        System.out.println(&quot;first链表中环的入口结点元素为：&quot;+entrance.item);
    }

    /**
     * 查找有环链表中环的入口结点
     * @param first 链表首结点
     * @return 环的入口结点
     */
    public static Node getEntrance(Node&lt;String&gt; first) {
        //定义快慢指针
        Node&lt;String&gt; fast = first;
        Node&lt;String&gt; slow = first;
        Node&lt;String&gt; temp = null;
        //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口
        while(fast!=null &amp;&amp; fast.next!=null){
            //变换快慢指针
            fast = fast.next.next;
            slow = slow.next;
            //判断快慢指针是否相遇
            if (fast.equals(slow)){
                temp = first;
                continue;
            }
            //让临时结点变换
            if (temp!=null){
                temp = temp.next;
                //判断临时指针是否和慢指针相遇
                if (temp.equals(slow)){
                    break;
                }
            }
        }
        return temp;
    }
    //结点类
    private static class Node&lt;T&gt; {
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
</code></pre><hr>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><hr>
<p>在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<hr>
<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><hr>
<p>构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；使用计数器count，记录当前报数的值；遍历链表，每循环一次，count++；判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0。</p>
<pre><code>public class JosephTest {
    public static void main(String[] args) {
        //解决约瑟夫问题
        //1.构建循环链表，包含41个结点，分别存储1~41之间的值
        //用来就首结点
        Node&lt;Integer&gt; first = null;
        //用来记录前一个结点
        Node&lt;Integer&gt; pre = null;
        for(int i = 1;i&lt;=41;i++){
            //如果是第一个结点
            if (i==1){
                first = new Node&lt;&gt;(i,null);
                pre = first;
                continue;
            }
            //如果不是第一个结点
            Node&lt;Integer&gt; newNode = new Node&lt;&gt;(i, null);
            pre.next=newNode;
            pre=newNode;
            //如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first,变为循环链表了
            if (i==41){
                pre.next=first;
            }
        }

        //2.需要count计数器，模拟报数
        int count=0;
        //3.遍历循环链表
        //记录每次遍历拿到的结点，默认从首结点开始
        Node&lt;Integer&gt; n = first;
        //记录当前结点的上一个结点
        Node&lt;Integer&gt; before = null;
        while(n!=n.next){
            //模拟报数
            count++;
            //判断当前报数是不是为3
            if (count==3){
                //如果是3，则把当前结点删除调用，打印当前结点，重置count=0，让当前结点n后移
                before.next=n.next;
                System.out.print(n.item+&quot;,&quot;);
                count=0;
                n=n.next;
            }else{
                //如果不是3，让before变为当前结点，让当前结点后移；
                before=n;
                n=n.next;
            }
        }
        //打印最后一个元素
        System.out.println(n.item);
    }

    //结点类
    private static class Node&lt;T&gt; {
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
</code></pre><hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><hr>
<p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p>
<p>我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。</p>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<p>压栈、弹栈、遍历。</p>
<pre><code>public class Stack&lt;T&gt; implements Iterable&lt;T&gt;{
    //记录首结点
    private Node head;
    //栈中元素的个数
    private int N;
    private class Node{
        public T item;
        public Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Stack() {
        this.head = new Node(null,null);
        this.N=0;
    }

    //判断当前栈中元素个数是否为0
    public boolean isEmpty(){
        return N==0;
    }

    //获取栈中元素的个数
    public int size(){
        return N;
    }

    //把t元素压入栈
    public void push(T t){
        //找到首结点指向的第一个结点
        Node oldFirst = head.next;
        //创建新结点
        Node newNode = new Node(t, null);
        //让首结点指向新结点
        head.next = newNode;
        //让新结点指向原来的第一个结点
        newNode.next=oldFirst;
        //元素个数+1；
        N++;
    }

    //弹出栈顶元素
    public T pop(){
        //找到首结点指向的第一个结点
        Node oldFirst = head.next;
        if (oldFirst==null){
            return null;
        }
        //让首结点指向原来第一个结点的下一个结点
        head.next=oldFirst.next;
        //元素个数-1；
        N--;
        return oldFirst.item;
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private Node n;
        public SIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}-
</code></pre><p>测试</p>
<pre><code>public class StackTest {
    public static void main(String[] args) {
        //创建栈对象
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        //测试压栈
        stack.push(&quot;a&quot;);
        stack.push(&quot;b&quot;);
        stack.push(&quot;c&quot;);
        stack.push(&quot;d&quot;);
        for (String item : stack) {
            System.out.println(item);
        }
        System.out.println(&quot;------------------------------&quot;);
        //测试弹栈
        String result = stack.pop();
        System.out.println(&quot;弹出的元素是：&quot;+result);
        System.out.println(&quot;剩余的元素个数：&quot;+stack.size());
    }
}
</code></pre><hr>
<h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><hr>
<p>给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</p>
<p>创建一个栈用来存储左括号；从左往右遍历字符串，拿到每一个字符；判断该字符是不是左括号，如果是，放入栈中存储；判断该字符是不是右括号，如果不是，继续下一次循环；如果该字符是右括号，则从栈中弹出一个元素t；判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号；循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配。</p>
<pre><code>public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = &quot;上海(长安)())&quot;;
        boolean match = isMatch(str);
        System.out.println(str+&quot;中的括号是否匹配：&quot;+match);
    }

    /**
     * 判断str中的括号是否匹配
     * @param str 括号组成的字符串
     * @return 如果匹配，返回true，如果不匹配，返回false
     */
    public static boolean isMatch(String str){
        //1.创建栈对象，用来存储左括号
        Stack&lt;String&gt; chars = new Stack&lt;&gt;();
        //2.从左往右遍历字符串
        for (int i = 0; i &lt; str.length(); i++) {
            String currChar = str.charAt(i)+ &quot;&quot;;

            //3.判断当前字符是否为左括号，如果是，则把字符放入到栈中
            if (currChar.equals(&quot;(&quot;)){
                chars.push(currChar);
            }else if(currChar.equals(&quot;)&quot;)){
                //4.继续判断当前字符是否是有括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null,如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号
                String pop = chars.pop();
                if (pop==null){
                    return false;
                }
            }

        }
        //5.判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配
        if (chars.size()==0){
            return true;
        }else{
            return false;
        }
    }
}
</code></pre><hr>
<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><hr>
<p>创建一个栈对象oprands存储操作数；从左往右遍历逆波兰表达式，得到每一个字符串；判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中；如果是运算符，则从oprands栈中弹出两个操作数o1,o2；使用该运算符计算o1和o2，得到结果result；把该结果压入oprands栈中 ；遍历结束后，拿出栈中最终的结果返回。</p>
<pre><code>public class ReversePolishNotationTest {

    public static void main(String[] args) {
        //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9
        String[] notation = {&quot;3&quot;, &quot;17&quot;, &quot;15&quot;, &quot;-&quot;, &quot;*&quot;, &quot;18&quot;, &quot;6&quot;, &quot;/&quot;, &quot;+&quot;};
        int result = caculate(notation);
        System.out.println(&quot;逆波兰表达式的结果为：&quot; + result);
    }

    /**
     * @param notaion 逆波兰表达式的数组表示方式
     * @return 逆波兰表达式的计算结果
     */
    public static int caculate(String[] notaion) {
        //1.定义一个栈，用来存储操作数
        Stack&lt;Integer&gt; oprands = new Stack&lt;&gt;();
        //2.从左往右遍历逆波兰表达式，得到每一个元素
        for (int i = 0; i &lt; notaion.length; i++) {
            String curr = notaion[i];
            //3.判断当前元素是运算符还是操作数
            Integer o1;
            Integer o2;
            Integer result;
            switch (curr) {
                case &quot;+&quot;:
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 + o1;
                    oprands.push(result);
                    break;
                case &quot;-&quot;:
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 - o1;
                    oprands.push(result);
                    break;
                case &quot;*&quot;:
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 * o1;
                    oprands.push(result);
                    break;
                case &quot;/&quot;:
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 / o1;
                    oprands.push(result);

                    break;
                default:
                    //5.操作数，把该操作数放入到栈中；
                    oprands.push(Integer.parseInt(curr));
                    break;
            }
        }
        //6.得到栈中最后一个元素，就是逆波兰表达式的结果
        int result = oprands.pop();
        return result;
    }
}
</code></pre><hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><hr>
<p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<hr>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><hr>
<p>插入、删除、遍历。</p>
<pre><code>public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{
    //记录首结点
    private Node head;
    //记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;
    private class Node{
        public T item;
        public Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
    public Queue() {
        this.head = new Node(null,null);
        this.last=null;
        this.N=0;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //返回队列中元素的个数
    public int size(){
        return N;
    }

    //向队列中插入元素t
    public void enqueue(T t){
        if (last==null){
            //当前尾结点last为null
            last= new Node(t,null);
            head.next=last;
        } else {
            //当前尾结点last不为null
            Node oldLast = last;
            last = new Node(t, null);
            oldLast.next=last;
        }
        //元素个数+1
        N++;
    }

    //从队列中拿出一个元素
    public T dequeue(){
        if (isEmpty()){
            return null;
        }
        Node oldFirst = head.next;
        head.next = oldFirst.next;
        N--;
        //因为出队列其实是在删除元素，因此如果队列中的元素被删除完了，需要重置last=null;
        if (isEmpty()){
            last=null;
        }
        return oldFirst.item;
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator{
        private Node n;

        public QIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
</code></pre><p>测试</p>
<pre><code>public class QueueTest {
    public static void main(String[] args) {
        //创建队列对象
        Queue&lt;String&gt; q = new Queue&lt;&gt;();
        //测试队列的enqueue方法
        q.enqueue(&quot;a&quot;);
        q.enqueue(&quot;b&quot;);
        q.enqueue(&quot;c&quot;);
        q.enqueue(&quot;d&quot;);
        for (String str : q) {
            System.out.println(str);
        }
        System.out.println(&quot;-------------------------------&quot;);
        //测试队列的dequeue方法
        String result = q.dequeue();
        System.out.println(&quot;出队列的元素是：&quot;+result);
        System.out.println(&quot;剩余的元素个数：&quot;+q.size());
    }
}
</code></pre><hr>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><hr>
<p>符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。<strong>符号表中，键具有唯一性</strong>。</p>
<hr>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><hr>
<pre><code>public class SymbolTable&lt;Key,Value&gt; {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;
    private class Node{
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;
        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public SymbolTable() {
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    //往符号表中插入键值对
    public void put(Key key,Value value){
        //符号表中已经存在了键为key的键值对，那么只需要找到该结点，替换值为value即可
        Node n = head;
        while(n.next!=null){
            //变换n
            n = n.next;
            //判断n结点存储的键是否为key，如果是，则替换n结点的值
            if (n.key.equals(key)){
                n.value = value;
                return;
            }
        }

        //如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部  head.next=新结点即可
        Node newNode = new Node(key, value, null);
        Node oldFirst = head.next;
        newNode.next = oldFirst;
        head.next = newNode;
        //元素个数+1；
        N++;
    }
    //删除符号表中键为key的键值对
    public void delete(Key key){
        //找到键为key的结点，把该结点从链表中删除
        Node n = head;
        while(n.next!=null){
            //判断n结点的下一个结点的键是否为key，如果是，就删除该结点
            if (n.next.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }
            //变换n
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while(n.next!=null){
            //变换n
            n = n.next;
            if (n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }
}
</code></pre><p>测试</p>
<pre><code>public class SymbolTableTest {
    public static void main(String[] args) {
        //创建符号表对象
        SymbolTable&lt;Integer, String&gt; symbolTable = new SymbolTable&lt;&gt;();
        //测试put方法（插入,替换）
        symbolTable.put(1,&quot;乔峰&quot;);
        symbolTable.put(2,&quot;虚竹&quot;);
        symbolTable.put(3,&quot;段誉&quot;);
        System.out.println(&quot;插入完毕后，元素的个数为:&quot;+symbolTable.size());

        symbolTable.put(2, &quot;慕容复&quot;);
        System.out.println(&quot;替换完毕后的元素的个数为:&quot;+symbolTable.size());

        //测试get方法
        System.out.println(&quot;替换完毕后，键2对应的值为:&quot;+symbolTable.get(2));

        //测试删除方法
        symbolTable.delete(2);
        System.out.println(&quot;删除完毕后，元素的个数:&quot;+symbolTable.size());
    }
}
</code></pre><hr>
<h3 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h3><hr>
<p>要根据键的大小进行排序，插入数据时要考虑顺序。</p>
<pre><code>public class OrderSymbolTable&lt;Key extends Comparable&lt;Key&gt;,Value&gt; {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;
    private class Node{
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;
        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public OrderSymbolTable() {
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    //往符号表中插入键值对
    public void put(Key key,Value value){
        //定义两个Node变量，分别记录当前结点和当前结点的上一个结点
        Node curr = head.next;
        Node pre = head;
        while(curr!=null &amp;&amp; key.compareTo(curr.key)&gt;0){
            //变换当前结点和前一个结点即可
            pre = curr;
            curr = curr.next;
        }
        //如果当前结点curr的键和要插入的key一样，则替换
        if (curr!=null &amp;&amp; key.compareTo(curr.key)==0){
            curr.value = value;
            return;
        }
        //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前
        Node newNode = new Node(key, value, curr);
        pre.next = newNode;
        //元素的个数+1；
        N++;

    }
    //删除符号表中键为key的键值对
    public void delete(Key key){
        //找到键为key的结点，把该结点从链表中删除

        Node n = head;
        while(n.next!=null){
            //判断n结点的下一个结点的键是否为key，如果是，就删除该结点
            if (n.next.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }
            //变换n
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while(n.next!=null){
            //变换n
            n = n.next;
            if (n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }
}
</code></pre><p>测试</p>
<pre><code>public class OrderSymbolTableTest {
    public static void main(String[] args) {
        //创建有序符号表对象
        OrderSymbolTable&lt;Integer, String&gt; table = new OrderSymbolTable&lt;&gt;();
        table.put(1,&quot;张三&quot;);
        table.put(2,&quot;李四&quot;);
        table.put(4,&quot;赵六&quot;);
        table.put(7,&quot;田七&quot;);
        table.put(3,&quot;王五&quot;);
    }
}
</code></pre><hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><hr>
<p>树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。树具有以下特点：每个结点有零个或多个子结点；没有父结点的结点为根结点；每一个非根结点只有一个父结点；每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树。</p>
<p>结点的度：一个结点含有的子树的个数称为该结点的度。</p>
<p>叶结点：度为0的结点称为叶结点，也可以叫做终端结点。</p>
<p>分支结点：度不为0的结点称为分支结点，也可以叫做非终端结点。</p>
<p>结点的层次：从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。</p>
<p>结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
<p>树的度：树中所有结点的度的最大值。</p>
<p>树的高度(深度)：树中结点的最大层次。</p>
<p>森林：m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树。</p>
<p>孩子结点：一个结点的直接后继结点称为该结点的孩子结点。</p>
<p>双亲结点(父结点)：一个结点的直接前驱称为该结点的双亲结点。</p>
<p>兄弟结点：同一双亲结点的孩子结点间互称兄弟结点。</p>
<p><strong>二叉树</strong>就是度不超过2的树(每个结点最多有两个子结点)。</p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是<strong>满二叉树</strong>。</p>
<p><strong>完全二叉树</strong>：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p>
<hr>
<h3 id="二叉查找树基于链表的实现"><a href="#二叉查找树基于链表的实现" class="headerlink" title="二叉查找树基于链表的实现"></a>二叉查找树基于链表的实现</h3><hr>
<p><strong>插入</strong>方法put实现思想：如果当前树中没有任何一个结点，则直接把新结点当做根结点使用。如果当前树不为空，则从根结点开始：如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><strong>查询</strong>方法get实现思想：从根节点开始：如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p><strong>删除</strong>方法delete实现思想：找到被删除结点；找到被删除结点右子树中的最小结点minNode；删除右子树中的最小结点；让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树；让被删除结点的父节点指向最小结点minNode。</p>
<p>查找<strong>最小键</strong>、查找<strong>最大键</strong>。</p>
<p>把树由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式：</p>
<p><strong>前序遍历</strong>：先访问根结点，然后再访问左子树，最后访问右子树。<strong>中序遍历</strong>：先访问左子树，中间访问根节点，最后访问右子树。<strong>后序遍历</strong>：先访问左子树，再访问右子树，最后访问根节点。</p>
<p>前序遍历步骤：把当前结点的key放入到队列中;找到当前结点的左子树，如果不为空，递归遍历左子树；找到当前结点的右子树，如果不为空，递归遍历右子树。</p>
<p>中序遍历实现步骤：找到当前结点的左子树，如果不为空，递归遍历左子树；把当前结点的key放入到队列中;找到当前结点的右子树，如果不为空，递归遍历右子树。</p>
<p>后序遍历实现步骤：找到当前结点的左子树，如果不为空，递归遍历左子树；找到当前结点的右子树，如果不为空，递归遍历右子树；把当前结点的key放入到队列中。</p>
<p><strong>层序遍历</strong>，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值。实现步骤：创建队列，存储每一层的结点；使用循环从队列中弹出一个结点：获取当前结点的key；如果当前结点的左子结点不为空，则把左子结点放入到队列中；如果当前结点的右子结点不为空，则把右子结点放入到队列中。</p>
<p><strong>最大深度</strong>：如果根结点为空，则最大深度为0；计算左子树的最大深度；计算右子树的最大深度；当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1。</p>
<pre><code>public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; {
    //记录根结点
    private Node root;
    //记录树中元素的个数
    private int N;
    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;
        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    //获取树中元素的个数
    public int size() {
        return N;
    }

    //向树中添加元素key-value
    public void put(Key key, Value value) {
        root = put(root, key, value);
    }

    //向指定的树x中添加key-value,并返回添加元素后新的树
    private Node put(Node x, Key key, Value value) {
        //如果x子树为空，
        if (x==null){
            N++;
            return new Node(key,value, null,null);
        }
        //如果x子树不为空
        //比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp&gt;0){
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = put(x.right,key,value);
        }else if(cmp&lt;0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = put(x.left,key,value);
        }else{
            //如果key等于x结点的键，则替换x结点的值为value即可
            x.value = value;
        }
        return x;
    }

    //查询树中指定key对应的value
    public Value get(Key key) {
        return get(root,key);
    }

    //从指定的树x中，查找key对应的值
    public Value get(Node x, Key key) {
        //x树为null
        if (x==null){
            return null;
        }
        //x树不为null
        //比较key和x结点的键的大小
        int cmp = key.compareTo(x.key);
        if (cmp&gt;0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.right,key);
        }else if(cmp&lt;0){
            //如果key小于x结点的键，则继续找x结点的左子树
            return get(x.left,key);
        }else{
            //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可
            return x.value;
        }
    }

    //删除树中key对应的value
    public void delete(Key key) {
        delete(root, key);
    }

    //删除指定树x中的key对应的value，并返回删除后的新树
    public Node delete(Node x, Key key) {
        //x树为null
        if (x==null){
            return null;
        }
        //x树不为null
        int cmp = key.compareTo(x.key);
        if (cmp&gt;0){
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = delete(x.right,key);
        }else if(cmp&lt;0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = delete(x.left,key);
        }else{
            //如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；
            //让元素个数-1
            N--;
            //得找到右子树中最小的结点
            if (x.right==null){
                return x.left;
            }
            if (x.left==null){
                return x.right;
            }
            Node minNode = x.right;
            while(minNode.left!=null){
                minNode = minNode.left;
            }
            //删除右子树中最小的结点
            Node n = x.right;
            while(n.left!=null){
                if (n.left.left==null){
                    n.left=null;
                }else{
                    //变换n结点即可
                    n = n.left;
                }
            }
            //让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            //让x结点的父结点指向minNode
            x = minNode;
        }
        return x;
    }

    //查找整个树中最小的键
    public Key min(){
        return min(root).key;
    }

    //在指定树x中找出最小键所在的结点
    private Node min(Node x){
        //需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点
        if (x.left!=null){
            return min(x.left);
        }else{
            return x;
        }
    }

    //在整个树中找到最大的键
    public Key max(){
        return max(root).key;
    }

    //在指定的树x中，找到最大的键所在的结点
    public Node max(Node x){
        //判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点
        if (x.right!=null){
            return max(x.right);
        }else{
            return x;
        }
    }

    //获取整个树中所有的键
    public Queue&lt;Key&gt; preErgodic(){
        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
        preErgodic(root, keys);
        return keys;
    }

    //获取指定树x的所有键，并放到keys队列中
    private void preErgodic(Node x,Queue&lt;Key&gt; keys){
        if (x==null){
            return;
        }
        //把x结点的key放入到keys中
        keys.enqueue(x.key);
        //递归遍历x结点的左子树
        if (x.left!=null){
            preErgodic(x.left,keys);
        }
        //递归遍历x结点的右子树
        if (x.right!=null){
            preErgodic(x.right,keys);
        }
    }

    //使用中序遍历获取树中所有的键
    public Queue&lt;Key&gt; midErgodic(){
        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
        midErgodic(root,keys);
        return keys;
    }

    //使用中序遍历，获取指定树x中所有的键，并存放到key中
    private void midErgodic(Node x,Queue&lt;Key&gt; keys){
        if (x==null){
            return;
        }
        //先递归，把左子树中的键放到keys中
        if (x.left!=null){
            midErgodic(x.left,keys);
        }
        //把当前结点x的键放到keys中
        keys.enqueue(x.key);
        //在递归，把右子树中的键放到keys中
        if(x.right!=null){
            midErgodic(x.right,keys);
        }
    }

    //使用后序遍历，把整个树中所有的键返回
    public Queue&lt;Key&gt; afterErgodic(){
        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
        afterErgodic(root,keys);
        return keys;
    }

    //使用后序遍历，把指定树x中所有的键放入到keys中
    private void afterErgodic(Node x,Queue&lt;Key&gt; keys){
        if (x==null){
            return ;
        }
        //通过递归把左子树中所有的键放入到keys中
        if (x.left!=null){
            afterErgodic(x.left,keys);
        }
        //通过递归把右子树中所有的键放入到keys中
        if (x.right!=null){
            afterErgodic(x.right,keys);
        }
        //把x结点的键放入到keys中
        keys.enqueue(x.key);
    }

    //使用层序遍历，获取整个树中所有的键
    public Queue&lt;Key&gt; layerErgodic(){
        //定义两个队列，分别存储树中的键和树中的结点
        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
        Queue&lt;Node&gt; nodes = new Queue&lt;&gt;();
        //默认，往队列中放入根结点
        nodes.enqueue(root);
        while(!nodes.isEmpty()){
            //从队列中弹出一个结点，把key放入到keys中
            Node n = nodes.dequeue();
            keys.enqueue(n.key);
            //判断当前结点还有没有左子结点，如果有，则放入到nodes中
            if (n.left!=null){
                nodes.enqueue(n.left);
            }
            //判断当前结点还有没有右子结点，如果有，则放入到nodes中
            if (n.right!=null){
                nodes.enqueue(n.right);
            }
        }
        return keys;
    }

    //获取整个树的最大深度
    public int maxDepth(){
        return maxDepth(root);
    }

    //获取指定树x的最大深度
    private int maxDepth(Node x){
        if (x==null){
            return 0;
        }
        //x的最大深度
        int max=0;
        //左子树的最大深度
        int maxL=0;
        //右子树的最大深度
        int maxR=0;
        //计算x结点左子树的最大深度
        if (x.left!=null){
            maxL = maxDepth(x.left);
        }
        //计算x结点右子树的最大深度
        if (x.right!=null){
            maxR = maxDepth(x.right);
        }
        //比较左子树最大深度和右子树最大深度，取较大值+1即可
        max = maxL&gt;maxR?maxL+1:maxR+1;
        return max;
    }
}
</code></pre><p>代码测试</p>
<pre><code>public class BinaryTreeTest {
    public static void main(String[] args) {
        //创建二叉查找树对象
        BinaryTree&lt;Integer, String&gt; tree = new BinaryTree&lt;&gt;();
        //测试插入
        tree.put(1,&quot;张三&quot;);
        tree.put(2,&quot;李四&quot;);
        tree.put(3,&quot;王五&quot;);
        System.out.println(&quot;插入完毕后元素的个数：&quot;+tree.size());
        //测试获取
        System.out.println(&quot;键2对应的元素是：&quot;+tree.get(2));
        //测试删除
        tree.delete(3);
        System.out.println(&quot;删除后的元素个数：&quot;+tree.size());
        System.out.println(&quot;删除后键3对应的元素:&quot;+tree.get(3));
    }
}
</code></pre><p>遍历测试</p>
<pre><code>public class BinaryTreeErgodicTest {

    /*//测试前序遍历
    public static void main(String[] args) {
        //创建树对象
        BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;();
        //往树中添加数据
        tree.put(&quot;E&quot;, &quot;5&quot;);
        tree.put(&quot;B&quot;, &quot;2&quot;);
        tree.put(&quot;G&quot;, &quot;7&quot;);
        tree.put(&quot;A&quot;, &quot;1&quot;);
        tree.put(&quot;D&quot;, &quot;4&quot;);
        tree.put(&quot;F&quot;, &quot;6&quot;);
        tree.put(&quot;H&quot;, &quot;8&quot;);
        tree.put(&quot;C&quot;, &quot;3&quot;);
        //遍历
        Queue&lt;String&gt; keys = tree.preErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+&quot;----&quot;+value);
        }
    }*/

    //测试中序遍历
   /* public static void main(String[] args) {
        //创建树对象
        BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;();
        //往树中添加数据
        tree.put(&quot;E&quot;, &quot;5&quot;);
        tree.put(&quot;B&quot;, &quot;2&quot;);
        tree.put(&quot;G&quot;, &quot;7&quot;);
        tree.put(&quot;A&quot;, &quot;1&quot;);
        tree.put(&quot;D&quot;, &quot;4&quot;);
        tree.put(&quot;F&quot;, &quot;6&quot;);
        tree.put(&quot;H&quot;, &quot;8&quot;);
        tree.put(&quot;C&quot;, &quot;3&quot;);
        //遍历
        Queue&lt;String&gt; keys = tree.midErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+&quot;----&quot;+value);
        }
    }*/

    //测试后序遍历
    /*public static void main(String[] args) {
        //创建树对象
        BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;();
        //往树中添加数据
        tree.put(&quot;E&quot;, &quot;5&quot;);
        tree.put(&quot;B&quot;, &quot;2&quot;);
        tree.put(&quot;G&quot;, &quot;7&quot;);
        tree.put(&quot;A&quot;, &quot;1&quot;);
        tree.put(&quot;D&quot;, &quot;4&quot;);
        tree.put(&quot;F&quot;, &quot;6&quot;);
        tree.put(&quot;H&quot;, &quot;8&quot;);
        tree.put(&quot;C&quot;, &quot;3&quot;);
        //遍历
        Queue&lt;String&gt; keys = tree.afterErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+&quot;----&quot;+value);
        }
    }*/

    //测试层序遍历
    public static void main(String[] args) {
        //创建树对象
        BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;();
        //往树中添加数据
        tree.put(&quot;E&quot;, &quot;5&quot;);
        tree.put(&quot;B&quot;, &quot;2&quot;);
        tree.put(&quot;G&quot;, &quot;7&quot;);
        tree.put(&quot;A&quot;, &quot;1&quot;);
        tree.put(&quot;D&quot;, &quot;4&quot;);
        tree.put(&quot;F&quot;, &quot;6&quot;);
        tree.put(&quot;H&quot;, &quot;8&quot;);
        tree.put(&quot;C&quot;, &quot;3&quot;);
        //遍历
        Queue&lt;String&gt; keys = tree.layerErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+&quot;----&quot;+value);
        }
    }
}
</code></pre><p>最大深度测试</p>
<pre><code>public class BinaryTreeMaxDepthTest {
    public static void main(String[] args) {
        //创建树对象
        BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;();
        //往树中添加数据
        tree.put(&quot;E&quot;, &quot;5&quot;);
        tree.put(&quot;B&quot;, &quot;2&quot;);
        tree.put(&quot;G&quot;, &quot;7&quot;);
        tree.put(&quot;A&quot;, &quot;1&quot;);
        tree.put(&quot;D&quot;, &quot;4&quot;);
        tree.put(&quot;F&quot;, &quot;6&quot;);
        tree.put(&quot;H&quot;, &quot;8&quot;);
        tree.put(&quot;C&quot;, &quot;3&quot;);
        int maxDepth = tree.maxDepth();
        System.out.println(maxDepth);
    }
}
</code></pre><hr>
<h3 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h3><hr>
<p>纸条对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up。</p>
<p>根结点为下折痕；每一个结点的左子结点为下折痕；每一个结点的右子结点为上折痕。</p>
<pre><code>public class PagerFoldingTest {

    public static void main(String[] args) {
        //模拟这只过程，产生树
        Node&lt;String&gt; tree = createTree(2);
        //遍历树，打印每个结点
        printTree(tree);
    }

    //通过模拟对折N次纸，产生树
    public static Node&lt;String&gt; createTree(int N){
        //定义根结点
        Node&lt;String&gt; root=null;
        for (int i = 0; i &lt; N; i++) {
            //1.当前是第一次对折
            if (i==0){
                root = new Node&lt;&gt;(&quot;down&quot;,null,null);
                continue;
            }
            //2.当前不是第一次对折
            //定义一个辅助队列，通过层序遍历的思想，找到叶子结点，叶子结点添加子节点
            Queue&lt;Node&gt; queue = new Queue&lt;&gt;();
            queue.enqueue(root);
            //循环遍历队列
            while(!queue.isEmpty()){
                //从队列中弹出一个结点
                Node&lt;String&gt; tmp = queue.dequeue();
                //如果有左子结点，则把左子结点放入到队列中
                if (tmp.left!=null){
                    queue.enqueue(tmp.left);
                }
                //如果有右子结点，则把右子结点放入到队列中
                if (tmp.right!=null){
                    queue.enqueue(tmp.right);
                }
                //如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可
                if (tmp.left==null &amp;&amp; tmp.right==null){
                    tmp.left = new Node&lt;String&gt;(&quot;down&quot;, null,null);
                    tmp.right = new Node&lt;String&gt;(&quot;up&quot;,null,null);
                }
            }
        }
        return root;
    }

    //打印树中每个结点到控制台
    public static void printTree(Node&lt;String&gt; root){
        //需要使用中序遍历完成
        if (root==null){
            return;
        }
        //打印左子树的每个结点
        if (root.left!=null){
            printTree(root.left);
        }
        //打印当前结点
        System.out.print(root.item+&quot; &quot;);
        //打印右子树的每个结点
        if (root.right!=null){
            printTree(root.right);
        }
    }

    //结点类
    private static class Node&lt;T&gt;{
        public T item;//存储元素
        public Node left;
        public Node right;
        public Node(T item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}
</code></pre><hr>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><hr>
<p>堆通常可以被看做是一棵<strong>完全二叉树</strong>的<strong>数组对象</strong>。</p>
<p>完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</p>
<p>二叉树的结点按照层级顺序放入数组中，<strong>根结点在位置1</strong>，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。</p>
<p><strong>如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。</strong></p>
<p><strong>每个结点都大于等于它的两个子结点</strong>。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟之前的二叉查找树是有区别的。</p>
<hr>
<h3 id="API实现"><a href="#API实现" class="headerlink" title="API实现"></a>API实现</h3><hr>
<p>如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。</p>
<p>当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。</p>
<pre><code>public class Heap&lt;T extends Comparable&lt;T&gt;&gt; {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public Heap(int capacity) {
        this.items= (T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])&lt;0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i,int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N]=t;
        swim(N);
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置
        while(k&gt;1){
            //比较当前结点和其父结点
            if (less(k/2,k)){
                exch(k/2,k);
            }
            k = k/2;
        }
    }

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax(){
        T max = items[1];
        //交换索引1处的元素和最大索引处的元素，让完全二叉树中最右侧的元素变为临时根结点
        exch(1,N);
        //最大索引处的元素删除掉
        items[N]=null;
        //元素个数-1
        N--;
        //通过下沉调整堆，让堆重新有序
        sink(1);
        return max;
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k){
        //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置
        while(2*k&lt;=N){
            //获取当前结点的子结点中的较大结点
            int max;//记录较大结点所在的索引
            if (2*k+1&lt;=N){
                if (less(2*k,2*k+1)){
                    max=2*k+1;
                }else{
                    max=2*k;
                }
            }else {
                max = 2*k;
            }
            //比较当前结点和较大结点的值
            if (!less(k,max)){
                break;
            }
            //交换k索引处的值和max索引处的值
            exch(k,max);
            //变换k的值
            k = max;
        }
    }

    public static void main(String[] args) {
        Heap&lt;String&gt; heap = new Heap&lt;String&gt;(20);
        heap.insert(&quot;A&quot;);
        heap.insert(&quot;B&quot;);
        heap.insert(&quot;C&quot;);
        heap.insert(&quot;D&quot;);
        heap.insert(&quot;E&quot;);
        heap.insert(&quot;F&quot;);
        heap.insert(&quot;G&quot;);
        String del;
        while((del=heap.delMax())!=null){
            System.out.print(del+&quot;,&quot;);
        }
    }
}
</code></pre><p>测试</p>
<pre><code>public class HeapTest {
    public static void main(String[] args) {
        //创建堆对象
        Heap&lt;String&gt; heap = new Heap&lt;&gt;(10);
        //往堆中存入字符串数据
        heap.insert(&quot;A&quot;);
        heap.insert(&quot;B&quot;);
        heap.insert(&quot;C&quot;);
        heap.insert(&quot;D&quot;);
        heap.insert(&quot;E&quot;);
        heap.insert(&quot;F&quot;);
        heap.insert(&quot;G&quot;);
        //通过循环从堆中删除数据
        String result = null;
        while((result = heap.delMax())!=null){
            System.out.print(result+&quot; &quot;);
        }
    }
}
</code></pre><hr>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="../../../../img/reward-alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="../../../../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2020/07/04/38.git/" class="next-post btn btn-default" title='Git'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Git</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、数据结构分类"><span class="toc-text">1、数据结构分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、算法介绍"><span class="toc-text">2、算法介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、算法的时间复杂度"><span class="toc-text">3、算法的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、时间复杂度大O记法"><span class="toc-text">4、时间复杂度大O记法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、算法的空间复杂度"><span class="toc-text">5、算法的空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Comparable接口"><span class="toc-text">1、Comparable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、冒泡排序"><span class="toc-text">2、冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、选择排序"><span class="toc-text">3、选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、插入排序"><span class="toc-text">4、插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、希尔排序"><span class="toc-text">5、希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、归并排序"><span class="toc-text">6、归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、快速排序"><span class="toc-text">7、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、排序的稳定性"><span class="toc-text">8、排序的稳定性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表"><span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表"><span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单向链表"><span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向链表"><span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快慢指针"><span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环链表"><span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#约瑟夫问题"><span class="toc-text">约瑟夫问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#括号匹配问题"><span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆波兰表达式求值"><span class="toc-text">逆波兰表达式求值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#符号表"><span class="toc-text">符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-1"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序符号表"><span class="toc-text">有序符号表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树基于链表的实现"><span class="toc-text">二叉查找树基于链表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#折纸问题"><span class="toc-text">折纸问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆"><span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API实现"><span class="toc-text">API实现</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>