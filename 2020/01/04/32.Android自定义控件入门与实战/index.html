<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>Android自定义控件入门与实战-读书笔记 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 士不可以不弘毅，任重而道远 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Android/"><i class="fa "></i>Android</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Web/"><i class="fa "></i>Web</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Java/"><i class="fa "></i>Java</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Android自定义控件入门与实战-读书笔记">
            
	            Android自定义控件入门与实战-读书笔记
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/Android">
            Android
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/自定义控件" title='自定义控件'>
                        自定义控件
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/01/04</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="第1章、绘图基础"><a href="#第1章、绘图基础" class="headerlink" title="第1章、绘图基础"></a>第1章、绘图基础</h2><h3 id="1-1、基本图形绘制"><a href="#1-1、基本图形绘制" class="headerlink" title="1.1、基本图形绘制"></a>1.1、基本图形绘制</h3><h4 id="1-1-1、概述"><a href="#1-1-1、概述" class="headerlink" title="1.1.1、概述"></a>1.1.1、概述</h4><p>在 Android中，Paint类就是画笔，而Canvas类就是纸，在这里叫作画布。</p>
<h4 id="1-1-2、画笔的基本设置"><a href="#1-1-2、画笔的基本设置" class="headerlink" title="1.1.2、画笔的基本设置"></a>1.1.2、画笔的基本设置</h4><p>Paint</p>
<pre><code>paint.setAntiAlias(true); //打开抗锯齿功能

paint.setColor(Color.RED); //设置画笔颜色

paint.setStyle(Paint.Style.FILL); //设置填充样式

paint.setStrokeWidth(50); //设置画笔宽度
</code></pre><p>ARGB</p>
<pre><code>A 代表透明度（Alpha）
R 代表红色值（Red）
G 代表绿色值（Green）
B 代表蓝色值（Blue）
</code></pre><p>设置填充样式，对于文字和几何图形都有效:</p>
<pre><code>Paint.Style.FILL//仅填充内部。
Paint.Style.FILL_AND_STROKE//填充内部和描边。
Paint.Style.STROKE//仅描边。
</code></pre><blockquote>
<p>FILL_AND_STROKE比FILL多了一个描边的宽度。    </p>
</blockquote>
<h4 id="1-1-3、Canvas使用基础"><a href="#1-1-3、Canvas使用基础" class="headerlink" title="1.1.3、Canvas使用基础"></a>1.1.3、Canvas使用基础</h4><p>demo地址</p>
<pre><code>com.vcredit.doview.chapter1.DrawShapeView
</code></pre><h5 id="1、画布背景设置"><a href="#1、画布背景设置" class="headerlink" title="1、画布背景设置"></a>1、画布背景设置</h5><pre><code>canvas.drawColor(int color)
canvas.drawARGB(int a, int r, int g, int b)
canvas.drawRGB(int r, int g, int b) //透明度Alpha的值取255
</code></pre><h5 id="2、画直线"><a href="#2、画直线" class="headerlink" title="2、画直线"></a>2、画直线</h5><pre><code>void drawLine(float startX, float startY, float stopX, float stopY, Paint paint)
</code></pre><p>直线的粗细是与setStrokeWidth有直接关系的。所以，paint.setStrokeWidth在Style起作用时，用于设置描边宽度；在Style不起作用时，用于设置画笔宽度。</p>
<h5 id="3、多条直线"><a href="#3、多条直线" class="headerlink" title="3、多条直线"></a>3、多条直线</h5><pre><code>void drawLines(float[] pts, Paint paint)
void drawLines(float[] pts, int offset, int count, Paint paint)
</code></pre><p>pts：点的集合。两个元素形成一个点，每两个点形成一条直线。</p>
<p>offset：pts集合中跳过的元素个数。</p>
<p>count：pts集合中参与绘制的元素个数。</p>
<pre><code>float[] pts = {10,10,100,100,200,200,400,400};
canvas.drawLines(pts,2,4,paint);
</code></pre><p>表示点(100,100)和(200,200)这两个点的连线。</p>
<h5 id="4、点"><a href="#4、点" class="headerlink" title="4、点"></a>4、点</h5><pre><code>void drawPoint(float x, float y, Paint paint)
</code></pre><p>点的大小只与setStrokeWidth(width)有关，而与setStyle无关。</p>
<h5 id="5、多个点"><a href="#5、多个点" class="headerlink" title="5、多个点"></a>5、多个点</h5><pre><code>void drawPoints(float[] pts, Paint paint)
void drawPoints(float[] pts, int offset, int count, Paint paint)
</code></pre><p>这几个参数的含义与多条直线中的参数含义相同。</p>
<h5 id="6、矩形工具类RectF和Rect"><a href="#6、矩形工具类RectF和Rect" class="headerlink" title="6、矩形工具类RectF和Rect"></a>6、矩形工具类RectF和Rect</h5><p>RectF与Rect中的方法、成员变量完全一样，都是根据4个点构造出一个矩形结构，唯一不同的是：RectF是用来保存float类型数值的矩形结构的；而Rect是用来保存int类型数值的矩形结构的。</p>
<pre><code>//RectF 的构造函数有如下4个，但最常用的还是第二个，即根据 4 个点构造出一个矩形。
RectF()
RectF(float left, float top, float right, float bottom)
RectF(RectF r)
RectF(Rect r)
//Rect的构造函数有如下3个。
Rect()
Rect(int left, int top, int right, int bottom)
Rect(Rect r)
</code></pre><p>一般而言，要构造一个矩形结构，可以通过以下两种方法来实现。</p>
<pre><code>//方法一：直接构造
Rect rect = new Rect(10,10,100,100);
//方法二：间接构造
Rect rect = new Rect();
rect.set(10,10,100,100);
</code></pre><h5 id="7、矩形"><a href="#7、矩形" class="headerlink" title="7、矩形"></a>7、矩形</h5><p>矩形的绘制方法</p>
<pre><code>void drawRect(float left, float top, float right, float bottom, Paint paint)
void drawRect(RectF rect, Paint paint)
void drawRect(Rect r, Paint paint)
</code></pre><h5 id="8、圆角矩形"><a href="#8、圆角矩形" class="headerlink" title="8、圆角矩形"></a>8、圆角矩形</h5><pre><code>void drawRoundRect(RectF rect, float rx, float ry, Paint paint)
</code></pre><p>rect：要绘制的矩形；rx：生成圆角的椭圆的X轴半径；ry：生成圆角的椭圆的Y轴半径。</p>
<p>drawRoundRect()函数不能针对每个角设置对应的椭圆，而只能统一设置4个角对应的椭圆。</p>
<h5 id="9、圆形"><a href="#9、圆形" class="headerlink" title="9、圆形"></a>9、圆形</h5><pre><code>void drawCircle(float cx, float cy, float radius, Paint paint)
</code></pre><p>参数是圆心和半径</p>
<h5 id="10、椭圆"><a href="#10、椭圆" class="headerlink" title="10、椭圆"></a>10、椭圆</h5><pre><code>void drawOval(RectF oval, Paint paint)
</code></pre><p>椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，以矩形的宽为椭圆的Y轴。</p>
<h5 id="11、弧"><a href="#11、弧" class="headerlink" title="11、弧"></a>11、弧</h5><pre><code>void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter,Paint paint)
</code></pre><p>弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧也是根据矩形来生成的。</p>
<p>oval：生成椭圆的矩形。startAngle：弧开始的角度，以 X 轴正方向为 0°。sweepAngle：弧持续的角度,顺时针方向为正值。</p>
<p>useCenter：是否有弧的两边。为true时，表示带有两边；为false时，只有一条弧。</p>
<h4 id="1-1-4、Rect与RectF"><a href="#1-1-4、Rect与RectF" class="headerlink" title="1.1.4、Rect与RectF"></a>1.1.4、Rect与RectF</h4><h5 id="1、是否包含点、矩形"><a href="#1、是否包含点、矩形" class="headerlink" title="1、是否包含点、矩形"></a>1、是否包含点、矩形</h5><pre><code>//判断是否包含某个点，如果在，则返回true；如果不在，则返回false。
boolean contains(int x, int y)
//rect.contains(mX, mY)

//判断是否包含某个矩形
Boolean contains(int left, int top, int right, int bottom)
boolean contains(Rect r)
</code></pre><blockquote>
<p>postInvalidate()和 nvalidate()函数都是用来重绘控件的，区别是invalidate()函数一定要在主线程中执行，否则就会报错；而postInvalidate()可以在任何线程中执行。因为在 postInvalidate()函数中就是利用handler给主线程发送刷新界面的消息来实现的，所以它可以在任何线程中执行而不会出错。postInvalidate()界面刷新速度可能没有直接调用invalidate()函数那么快。</p>
</blockquote>
<h5 id="2、判断两个矩形是否相交"><a href="#2、判断两个矩形是否相交" class="headerlink" title="2、判断两个矩形是否相交"></a>2、判断两个矩形是否相交</h5><pre><code>//这是Rect类的一个静态方法，如果相交则返回true，否则返回false。
static boolean intersects(Rect a, Rect b)
//还可以使用 Rect 类中自带的方法来判断当前 Rect 对象与其他矩形是否相交。
boolean intersects(int left, int top, int right, int bottom)

//判断相交并返回结果
//不仅会返回是否相交的结果，而且会把相交部分的矩形赋给当前Rect对象。如果两个矩形不相交，则当前Rect对象的值不变。
boolean intersect(int left, int top, int right, int bottom)
boolean intersect(Rect r)
</code></pre><h5 id="3、合并"><a href="#3、合并" class="headerlink" title="3、合并"></a>3、合并</h5><p>合并两个矩形的意思就是将两个矩形合并成一个矩形，即无论这两个矩形是否相交，取两个矩形最小左上角点作为结果矩形的左上角点，取两个矩形最大右下角点作为结果矩形的右下角点。如果要合并的两个矩形有一方为空，则将有值的一方作为最终结果。</p>
<pre><code>public void union(int left, int top, int right, int bottom)
public void union(Rect r)
</code></pre><p>合并矩形与某个点：先判断当前矩形与目标合并点的关系，如果不相交，则根据目标点(x,y)的位置，将目标点设置为当前矩形的左上角点或者右下角点。如果当前矩形是一个空矩形，则最后的结果矩形为([0,0],[x,y])，即结果矩形的左上角点为[0,0]，右下角点为[x,y]。</p>
<pre><code>public void union(int x, int y)
</code></pre><h4 id="1-1-5、Color"><a href="#1-1-5、Color" class="headerlink" title="1.1.5、Color"></a>1.1.5、Color</h4><blockquote>
<p>当需要重绘时就会调用onDraw()函数，所以在 onDraw()函数中创建的变量会一直被重复创建，这样会引起频繁的程序GC（回收内存），进而引起程序卡顿。所以一定要记住，在onDraw()函数中不能创建变量！一般在自定义控件的构造函数中创建变量，即在初始化时一次性创建。</p>
</blockquote>
<h3 id="1-2、路径"><a href="#1-2、路径" class="headerlink" title="1.2、路径"></a>1.2、路径</h3><h4 id="1-2-1、概述"><a href="#1-2-1、概述" class="headerlink" title="1.2.1、概述"></a>1.2.1、概述</h4><p>Path类就代表路径。在Canvas中绘制路径的方法</p>
<pre><code>void drawPath(Path path, Paint paint)
</code></pre><h4 id="1-2-2、直线路径"><a href="#1-2-2、直线路径" class="headerlink" title="1.2.2、直线路径"></a>1.2.2、直线路径</h4><pre><code>//(x1,y1)是直线的起始点
void moveTo(float x1, float y1)

//(x2,y2)是直线的终点，又是下一次绘制直线路径的起始点； lineTo()函数可以一直使用。
void lineTo(float x2, float y2)

//首尾点连接起来，形成闭环
void close()
</code></pre><h4 id="1-2-3、弧线路径"><a href="#1-2-3、弧线路径" class="headerlink" title="1.2.3、弧线路径"></a>1.2.3、弧线路径</h4><pre><code>//弧线是从椭圆上截取的一部分
void arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo)
//oval：生成椭圆的矩形。
//startAngle：弧开始的角度，以 X 轴正方向为 0°。sweepAngle：弧持续的角度。
//forceMoveTo 的含义是是否强制将弧的起始点作为绘制起始位置。
</code></pre><h4 id="1-2-4、addXXX系列函数"><a href="#1-2-4、addXXX系列函数" class="headerlink" title="1.2.4、addXXX系列函数"></a>1.2.4、addXXX系列函数</h4><p>addXXX系列函数可以让我们直接往Path中添加一些曲线，而不必考虑连贯性。</p>
<h5 id="添加矩形路径"><a href="#添加矩形路径" class="headerlink" title="添加矩形路径"></a>添加矩形路径</h5><pre><code>void addRect(float left, float top, float right, float bottom,Path.Direction dir)
void addRect(RectF rect, Path.Direction dir)
</code></pre><p>Path.Direction 参数有两个值。Path.Direction.CCW：是指创建逆时针方向的矩形路径。Path.Direction.CW：指创建顺时针方向的矩形路径。</p>
<h5 id="添加圆角矩形路径"><a href="#添加圆角矩形路径" class="headerlink" title="添加圆角矩形路径"></a>添加圆角矩形路径</h5><pre><code>void addRoundRect(RectF rect, float[] radii, Path.Direction dir)
void addRoundRect(RectF rect, float rx, float ry, Path.Direction dir)
</code></pre><p><code>float[] radii</code>：必须传入8个数值，分4组，第一组对应第一个角（左上角）的用来生成圆角的椭圆的横轴半径和纵轴半径。在第二个构造函数中，只能构建统一的圆角大小，rx：生成圆角的椭圆的横轴半径，ry：生成圆角的椭圆的纵轴半径。</p>
<h5 id="添加圆形路径"><a href="#添加圆形路径" class="headerlink" title="添加圆形路径"></a>添加圆形路径</h5><pre><code>void addCircle(float x, float y, float radius, Path.Direction dir)
</code></pre><p>x和y：圆心坐标；radius：圆半径。</p>
<h5 id="添加椭圆路径"><a href="#添加椭圆路径" class="headerlink" title="添加椭圆路径"></a>添加椭圆路径</h5><pre><code>void addOval(RectF oval, Path.Direction dir)
</code></pre><h5 id="添加弧形路径"><a href="#添加弧形路径" class="headerlink" title="添加弧形路径"></a>添加弧形路径</h5><pre><code>void addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle)
void addArc(RectF oval, float startAngle, float sweepAngle)
</code></pre><p>oval：生成椭圆的矩形;startAngle：弧开始的角度;sweepAngel：弧持续的角度。</p>
<h4 id="1-2-5、填充模式"><a href="#1-2-5、填充模式" class="headerlink" title="1.2.5、填充模式"></a>1.2.5、填充模式</h4><p>Path的填充模式是指填充Path的哪部分。</p>
<pre><code>//Path.FillType 表示 Path 的填充模式，它有 4 个枚举值。
FillType.WINDING：默认值，当两个图形相交时，取相交部分显示。
FillType.EVEN_ODD：取 path 所在并不相交的区域。
FillType.INVERSE_WINDING：取 path 的外部区域。
FillType.INVERSE_EVEN_ODD：取 path 的外部和相交区域。
</code></pre><p>在利用画笔填充图形时，填充的肯定是图形内部，而 path.setFillType()函数就是用来界定哪里算Path内部的算法，进而让Paint填充这部分图像。</p>
<h4 id="1-2-6、重置路径"><a href="#1-2-6、重置路径" class="headerlink" title="1.2.6、重置路径"></a>1.2.6、重置路径</h4><p>系统提供了两个重置路径的方法:</p>
<pre><code>void reset()
void rewind()
</code></pre><p>共同点是都会清空内部所保存的所有路径。</p>
<p>区别:<code>rewind()</code>函数不会清除内存，但会清除FillType；而<code>reset()</code>函数则会清除内存，但不会清除FillType。</p>
<h4 id="1-2-7、蜘蛛网状图示例"><a href="#1-2-7、蜘蛛网状图示例" class="headerlink" title="1.2.7、蜘蛛网状图示例"></a>1.2.7、蜘蛛网状图示例</h4><h3 id="1-3、文字"><a href="#1-3、文字" class="headerlink" title="1.3、文字"></a>1.3、文字</h3><h4 id="1-3-1、Paint设置"><a href="#1-3-1、Paint设置" class="headerlink" title="1.3.1、Paint设置"></a>1.3.1、Paint设置</h4><p>Paint与文字相关的设置:</p>
<pre><code>//普通设置
paint.setStrokeWidth(5); //设置画笔宽度
paint.setAntiAlias(true); //指定是否使用抗锯齿功能
paint.setStyle(Paint.Style.FILL); //绘图样式，对于文字和几何图形都有效
paint.setTextAlign(Align.CENTER); //设置文字对齐方式，取值为Align.CENTER、Align.LEFT 或 Align.RIGHT
paint.setTextSize(12); //设置文字大小
//样式设置
paint.setFakeBoldText(true); //设置是否为粗体文字
paint.setUnderlineText(true); //设置下画线
paint.setTextSkewX((float) -0.25); //字体水平倾斜度，默认为0，普通斜体字设为-0.25，负数代表向右倾斜
paint.setStrikeThruText(true); //设置带有删除线效果
//其他设置
paint.setTextScaleX(2); //水平方向拉伸，高度不变，表示拉伸倍数，默认为1表示不拉伸
</code></pre><h4 id="1-3-2、Canvas绘制文本"><a href="#1-3-2、Canvas绘制文本" class="headerlink" title="1.3.2、Canvas绘制文本"></a>1.3.2、Canvas绘制文本</h4><pre><code>//setTextAlign的显示与x、y的设置有关系
canvas.drawText(String text,Float x,Float y,Paint paint);
</code></pre><h5 id="1、普通绘制"><a href="#1、普通绘制" class="headerlink" title="1、普通绘制"></a>1、普通绘制</h5><pre><code>//参数(x,y)就是起始点坐标
void drawText(String text, float x, float y, Paint paint)

//start：表示起始绘制字符所在字符串中的索引。
//end：表示结束绘制字符所在字符串中的索引。x,y：起始点坐标。
void drawText(CharSequence text, int start, int end, float x, float y, Paint paint)
void drawText(String text, int start, int end, float x, float y, Paint paint)    

//绘制char类型的数组所组成的字符串。其他参数的含义如下。index：指定起始绘制字符的位置。
//count：指定从起始绘制字符开始绘制几个字符。x,y：起始点坐标。
void drawText(char[] text, int index, int count, float x, float y, Paint paint)
</code></pre><p>举例</p>
<pre><code>canvas.drawText(&quot;床前明月光&quot;,2,4, 10,100, paint);//明月
</code></pre><h5 id="2、逐个指定文字位置"><a href="#2、逐个指定文字位置" class="headerlink" title="2、逐个指定文字位置"></a>2、逐个指定文字位置</h5><p>指定每个要绘制的文字的具体位置</p>
<pre><code>void drawPosText(String text, float[] pos, Paint paint)
void drawPosText(char[] text, int index, int count, float[] pos, Paint paint)
</code></pre><p>index：第一个要绘制的文字的索引。count：要绘制的文字的个数。pos：要绘制的每个文字的具体位置，两个点确定一个文字的位置。</p>
<h5 id="3、沿路径绘制"><a href="#3、沿路径绘制" class="headerlink" title="3、沿路径绘制"></a>3、沿路径绘制</h5><pre><code>void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)
void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset,float vOffset, Paint paint)
</code></pre><p>hOffset：与路径起始点的水平偏移量。vOffset：与路径中心的垂直偏移量。</p>
<h4 id="1-3-3、设置字体样式"><a href="#1-3-3、设置字体样式" class="headerlink" title="1.3.3、设置字体样式"></a>1.3.3、设置字体样式</h4><p>在Paint中有一个函数是专门用来设置字体样式的。使用这个函数的前提是必须构造Typeface类的一个参数。</p>
<pre><code>Typeface setTypeface(Typeface typeface)
</code></pre><p>设置字体样式</p>
<pre><code>Typeface defaultFromStyle(int style)

//参数int style的取值如下。
Typeface.NORMAL：正常字体。
Typeface.BOLD：粗体。
Typeface.ITALIC：斜体。
Typeface.BOLD_ITALIC：粗斜体。
</code></pre><p>举例，设置粗斜体样式:</p>
<pre><code>Typeface typeface = Typeface.defaultFromStyle(Typeface.BOLD_ITALIC);
paint.setTypeface(typeface);
</code></pre><h3 id="1-4、Region"><a href="#1-4、Region" class="headerlink" title="1.4、Region"></a>1.4、Region</h3><p>Region译为“区域”，区域是一块任意形状的封闭图形。</p>
<h4 id="1-4-1、构造Region"><a href="#1-4-1、构造Region" class="headerlink" title="1.4.1、构造Region"></a>1.4.1、构造Region</h4><h5 id="直接构造"><a href="#直接构造" class="headerlink" title="直接构造"></a>直接构造</h5><pre><code>public Region(Region region) //复制一个 Region 的范围
public Region(Rect r) //创建一个矩形区域
public Region(int left, int top, int right, int bottom) //创建一个矩形区域
</code></pre><h5 id="间接构造"><a href="#间接构造" class="headerlink" title="间接构造"></a>间接构造</h5><p>间接构造主要是通过空构造函数与set系列函数相结合来实现的。</p>
<pre><code>//Region的空构造函数：
public Region()
//set 系列函数：
public void setEmpty() //置空
public boolean set(Region region)//利用新的区域替换原来的区域
public boolean set(Rect r)
public boolean set(int left, int top, int right, int bottom)
public boolean setPath(Path path, Region clip)//根据路径的区域与某区域的交集构造出新的区域
</code></pre><blockquote>
<p>无论调用set系列函数的Region是不是有区域值，当调用set系列函数后，原来的区域值就会被替换成set系列函数里的区域值。</p>
</blockquote>
<blockquote>
<p>利用setPath可以设置不规则区域</p>
</blockquote>
<h4 id="1-4-2、枚举区域——RegionIterator类"><a href="#1-4-2、枚举区域——RegionIterator类" class="headerlink" title="1.4.2、枚举区域——RegionIterator类"></a>1.4.2、枚举区域——RegionIterator类</h4><pre><code>//构造函数：根据区域构建对应的矩形集。
RegionIterator(Region region)
//获取下一个矩形，将结果保存在参数 Rect r 中。
boolean next(Rect r)
</code></pre><p>Canvas中没有直接绘制Region的函数，想要绘制一个区域，就只能通过RegionIterator类构造矩形集来逼近显示区域。</p>
<pre><code>private void drawRegion(Canvas canvas,Region rgn,Paint paint){
    RegionIterator iter = new RegionIterator(rgn);
    Rect r = new Rect();
    while (iter.next(r)) {
        canvas.drawRect(r, paint);
    }
}
</code></pre><h4 id="1-4-3、区域相交"><a href="#1-4-3、区域相交" class="headerlink" title="1.4.3、区域相交"></a>1.4.3、区域相交</h4><p>Region不是用来绘图的，Region最重要的功能在区域的相交操作中。</p>
<h5 id="union-函数"><a href="#union-函数" class="headerlink" title="union()函数"></a>union()函数</h5><pre><code>boolean union(Rect r)
</code></pre><p>该函数用于与指定矩形取并集，即将Rect所指定的矩形加入当前区域中。举例：</p>
<pre><code>Region region = new Region(10,10,200,100);
region.union(new Rect(10,10,50,300));
</code></pre><h5 id="区域操作"><a href="#区域操作" class="headerlink" title="区域操作"></a>区域操作</h5><p>方法一：</p>
<p>相交操作，并将结果赋给当前的Region对象。如果计算成功，则返回true；否则返回false。</p>
<pre><code>boolean op(Rect r, Op op)
boolean op(int left, int top, int right, int bottom, Op op)
boolean op(Region region, Op op)
</code></pre><p>Op参数值有如下6个：</p>
<pre><code>public enum Op {
    DIFFERENCE(0), //最终区域为region1区域，但是不包括与region2相交的区域
    INTERSECT(1), // 最终区域为region1与region2 相交的区域
    UNION(2), //最终区域为region1与region2组合在一起的区域
    XOR(3), //最终区域为region1和region2区域，但是不包括相交的区域
    REVERSE_DIFFERENCE(4),//最终区域为region2区域，但是不包括与region1相交的区域
    REPLACE(5); //最终区域为region2的区域
}
</code></pre><p>方法二：传入两个 Region 对象进行区域操作</p>
<pre><code>boolean op(Rect rect, Region region, Op op)
boolean op(Region region1, Region region2, Region.Op op)
</code></pre><h4 id="1-4-4、其他函数"><a href="#1-4-4、其他函数" class="headerlink" title="1.4.4、其他函数"></a>1.4.4、其他函数</h4><p>几个判断</p>
<pre><code>//该函数用于判断该区域是否为空
public boolean isEmpty();

//该函数用于判断该区域是否是一个矩阵。
public boolean isRect();

//该函数用于判断该区域是否是多个矩阵的组合。
public boolean isComplex();
</code></pre><p>getBound系列函数</p>
<pre><code>//这两个函数用于返回能够包裹当前路径的最小矩形。
public Rect getBounds()
public boolean getBounds(Rect r)

//这两个函数用于返回当前矩形所对应的 Path 对象。
public Path getBoundaryPath()
public boolean getBoundaryPath(Path path)
</code></pre><p>是否包含</p>
<pre><code>//该函数用于判断该区域是否包含某个点。
public boolean contains(int x, int y)

//这两个函数用于判断该区域是否包含某个矩形。
public boolean quickContains(Rect r)
public boolean quickContains(int left, int top, int right,int bottom)
</code></pre><p>是否相交</p>
<pre><code>//这两个函数用于判断该区域是否没有和指定矩形相交。
public boolean quickReject(Rect r)
public boolean quickReject(int left, int top, int right, int bottom);

//该函数用于判断该区域是否没有和指定区域相交。
public boolean quickReject(Region rgn);
</code></pre><p>平移变换</p>
<pre><code>//该函数用于将Region对象向X轴平移dx距离，向Y轴平移dy距离，并将结果赋给当前的Region对象。X轴向右是正方向，Y轴向下是正方向。
public void translate(int dx, int dy)

//与上一个函数不同的是，该函数将结果赋给dst对象，而当前Region对象的值保持不变。
public void translate(int dx, int dy, Region dst)
</code></pre><h3 id="1-5、Canvas（画布）"><a href="#1-5、Canvas（画布）" class="headerlink" title="1.5、Canvas（画布）"></a>1.5、Canvas（画布）</h3><p>除了在Canvas上绘图以外，还可以对画布进行变换及裁剪等操作。</p>
<h4 id="1-5-1、Canvas变换"><a href="#1-5-1、Canvas变换" class="headerlink" title="1.5.1、Canvas变换"></a>1.5.1、Canvas变换</h4><h5 id="平移（Translate）"><a href="#平移（Translate）" class="headerlink" title="平移（Translate）"></a>平移（Translate）</h5><p>右是X轴正方向，向下是Y轴正方向。</p>
<pre><code>void translate(float dx, float dy)
</code></pre><p>举例</p>
<pre><code>canvas.translate(100, 100);
Rect rect = new Rect(0,0,400,220);
canvas.drawRect(rect, paint);
</code></pre><h4 id="屏幕显示与Canvas的关系"><a href="#屏幕显示与Canvas的关系" class="headerlink" title="屏幕显示与Canvas的关系"></a>屏幕显示与Canvas的关系</h4><p>每次调用drawXXX系列函数来绘图时，都会产生一个全新的Canvas透明图层。调用平移、旋转等函数对Canvas进行了操作，不会对之前已经draw的产生影响。</p>
<h5 id="旋转（Rotate）"><a href="#旋转（Rotate）" class="headerlink" title="旋转（Rotate）"></a>旋转（Rotate）</h5><pre><code>//旋转的中心点是原点(0,0)
void rotate(float degrees)
//指定旋转的中心点坐标(px,py)
void rotate(float degrees, float px, float py)
</code></pre><h5 id="缩放（Scale）"><a href="#缩放（Scale）" class="headerlink" title="缩放（Scale）"></a>缩放（Scale）</h5><pre><code>//sx是小数表示缩小，sx是整数表示放大
public void scale(float sx, float sy)

//px,py表示缩放中心位置
public void scale(float sx, float sy, float px, float py)
</code></pre><h5 id="扭曲（Skew）"><a href="#扭曲（Skew）" class="headerlink" title="扭曲（Skew）"></a>扭曲（Skew）</h5><pre><code>//sx为X轴方向倾斜角度的正切值，比如在X轴方向上倾斜60°，tan60=1.732
void skew(float sx, float sy)
</code></pre><p>举例</p>
<pre><code>canvas.skew(1.732f,0);//X 轴倾斜 60°， Y 轴不变
</code></pre><h5 id="裁剪画布（clip系列函数）"><a href="#裁剪画布（clip系列函数）" class="headerlink" title="裁剪画布（clip系列函数）"></a>裁剪画布（clip系列函数）</h5><p>一旦Canvas被裁剪，就不能恢复。在使用clip系列函数时，需要禁用硬件加速功能，<code>setLayerType(LAYER_TYPE_SOFTWARE,null)</code>。</p>
<p>clip 系列函数如下：</p>
<pre><code>boolean clipPath(Path path)
boolean clipPath(Path path, Region.Op op)
boolean clipRect(Rect rect, Region.Op op)
boolean clipRect(RectF rect, Region.Op op)
boolean clipRect(int left, int top, int right, int bottom)
boolean clipRect(float left, float top, float right, float bottom)
boolean clipRect(RectF rect)
boolean clipRect(float left, float top, float right, float bottom, Region.Op op)
boolean clipRect(Rect rect)
boolean clipRegion(Region region)
boolean clipRegion(Region region, Region.Op op)
</code></pre><h4 id="1-5-2、画布的保存与恢复"><a href="#1-5-2、画布的保存与恢复" class="headerlink" title="1.5.2、画布的保存与恢复"></a>1.5.2、画布的保存与恢复</h4><h5 id="save-和restore-函数"><a href="#save-和restore-函数" class="headerlink" title="save()和restore()函数"></a>save()和restore()函数</h5><p>每次调用save()函数，都会先保存当前画布的状态，然后将其放入特定的栈中。每次调用restore()函数，都会把栈中顶层的画布状态取出来，并按照这个状态恢复当前的画布，然后在这个画布上作画。</p>
<h4 id="restoreToCount-int-saveCount-函数"><a href="#restoreToCount-int-saveCount-函数" class="headerlink" title="restoreToCount(int saveCount)函数"></a>restoreToCount(int saveCount)函数</h4><p>在利用save()函数保存画布时，会有一个int类型的返回值。该返回值是当前所保存的画布所在栈的索引。restoreToCount()函数就是一直出栈，直到指定索引的画布出栈为止，即将指定索引的画布作为当前画布。</p>
<pre><code>public void restoreToCount(int saveCount);
</code></pre><h4 id="1-5-3、圆形头像示例"><a href="#1-5-3、圆形头像示例" class="headerlink" title="1.5.3、圆形头像示例"></a>1.5.3、圆形头像示例</h4><h4 id="1-5-4、裁剪动画示例"><a href="#1-5-4、裁剪动画示例" class="headerlink" title="1.5.4、裁剪动画示例"></a>1.5.4、裁剪动画示例</h4><h3 id="1-6、控件的使用方法"><a href="#1-6、控件的使用方法" class="headerlink" title="1.6、控件的使用方法"></a>1.6、控件的使用方法</h3><h4 id="1-6-1、控件概述"><a href="#1-6-1、控件概述" class="headerlink" title="1.6.1、控件概述"></a>1.6.1、控件概述</h4><h4 id="1-6-2、通过XML引入控件"><a href="#1-6-2、通过XML引入控件" class="headerlink" title="1.6.2、通过XML引入控件"></a>1.6.2、通过XML引入控件</h4><p>通过XML引入控件，所调用的构造函数：</p>
<pre><code>public MyView(Context context, AttributeSet attrs) {
    super(context, attrs);
}
</code></pre><h4 id="1-6-3、动态添加控件"><a href="#1-6-3、动态添加控件" class="headerlink" title="1.6.3、动态添加控件"></a>1.6.3、动态添加控件</h4><pre><code>LinearLayout rootView = (LinearLayout)findViewById(R.id.root);
CustomView customView = new CustomView(this);
LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams (LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
rootView.addView(customView,layoutParams);
</code></pre><p>LayoutParams的作用就是设置控件的宽和高，对应的是XML中的<code>layout_width</code>和<code>layout_height</code>属性。</p>
<p>LayoutParams有三个构造函数:</p>
<pre><code>//指定具体的宽和高:LayoutParams.MATCH_PARENT或者具体值
public LayoutParams(int width, int height)
//从AttributeSet中提取出宽高等属性值
public LayoutParams(Context c, AttributeSet attrs)
//复制一份LayoutParams
public LayoutParams(LayoutParams source)
</code></pre><p>LinearLayout、FrameLayout、RelativeLayout都有各自的LayoutParams。</p>
<h5 id="addRule"><a href="#addRule" class="headerlink" title="addRule"></a>addRule</h5><p>RelativeLayout.LayoutParams的addRule()函数：第一个参数是指RelativeLayout的布局属性，第二个参数是指相对于哪个控件ID来布局。</p>
<pre><code>RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root);
CustomView customView = new CustomView(this);
RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
layoutParams.addRule(RelativeLayout.RIGHT_OF,R.id.text);
rootView.addView(customView, layoutParams);
</code></pre><h5 id="设置margin"><a href="#设置margin" class="headerlink" title="设置margin"></a>设置margin</h5><pre><code>LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT);
lp.setMargins(10, 20, 30, 40);
imageView.setLayoutParams(lp);
</code></pre><h5 id="设置layout-weight（方法一）"><a href="#设置layout-weight（方法一）" class="headerlink" title="设置layout_weight（方法一）"></a>设置layout_weight（方法一）</h5><p>构造函数    </p>
<pre><code>public LayoutParams(int width, int height, float weight)
</code></pre><p>示例：</p>
<pre><code>TextView tv_like = new TextView(this);
LinearLayout.LayoutParams LP_LIKE_MW = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
tv_like.setText(&quot;赞(8)&quot;);
tv_like.setTextSize(16);
layout_sub_Lin.addView(tv_like, LP_LIKE_MW);
</code></pre><h5 id="设置layout-weight（方法二）"><a href="#设置layout-weight（方法二）" class="headerlink" title="设置layout_weight（方法二）"></a>设置layout_weight（方法二）</h5><pre><code>LinearLayout rootView = (LinearLayout) findViewById(R.id.root);
CustomView customView = new CustomView(this);
LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
layoutParams.weight = 1.0f;
rootView.addView(customView, layoutParams);
</code></pre><h5 id="设置layout-gravity"><a href="#设置layout-gravity" class="headerlink" title="设置layout_gravity"></a>设置layout_gravity</h5><pre><code>LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.FILL_PARENT);
params.gravity = Gravity.TOP;
</code></pre><p>params.gravity的取值有<code>Gravity.TOP</code>、<code>Gravity.BOTTOM</code>、<code>Gravity.LEFT</code>、<code>Gravity.RIGHT</code>、<code>Gravity.CENTER_VERTICAL</code>、<code>Gravity.CENTER_HORIZONTAL</code>等这些属性值可<code>|</code>（或）运算符合并。</p>
<h5 id="设置android-gravity"><a href="#设置android-gravity" class="headerlink" title="设置android:gravity"></a>设置android:gravity</h5><p>分别给Button和rootView设置</p>
<pre><code>Button button = new Button(this);
button.setGravity(Gravity.TOP);
button.setText(&quot;btn&quot;);
rootView.addView(button, layoutParams);
rootView.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL);
</code></pre><h5 id="addView"><a href="#addView" class="headerlink" title="addView"></a>addView</h5><pre><code>public void addView(View child, int index)
</code></pre><p>在指定位置添加一个View控件，index的取值有-1、0和正数。当取值为-1时，表示在末尾添加一个View控件，此时的效果就与addView(View child)相同；当取值为0时，表示在容器顶端添加一个View控件；当取值为正数时，表示在对应的索引位置插入一个View控件。</p>
<h2 id="第2章、视国动画"><a href="#第2章、视国动画" class="headerlink" title="第2章、视国动画"></a>第2章、视国动画</h2><p>两种类型的动画：<code>View Animation</code>（视图动画）和<code>Property Animation</code>（属性动画）。其中，<code>View Animation</code>包括<code>Tween Animation</code>（补间动画）和<code>Frame Animation</code>（逐帧动画）;<code>Property Animation</code>包括<code>ValueAnimator</code>和<code>ObjectAnimator</code>。</p>
<h3 id="2-1、视图动画标签"><a href="#2-1、视图动画标签" class="headerlink" title="2.1、视图动画标签"></a>2.1、视图动画标签</h3><h4 id="2-1-1、概述"><a href="#2-1-1、概述" class="headerlink" title="2.1.1、概述"></a>2.1.1、概述</h4><p>alpha(渐变透)、scale(缩放)、translate(位置移动)、rotate(旋转)set(动画集)。</p>
<h5 id="配置XML动画文件"><a href="#配置XML动画文件" class="headerlink" title="配置XML动画文件"></a>配置XML动画文件</h5><pre><code>//首先加载动画
Animation animation = AnimationUtils.loadAnimation(Activity.this,R.a aim.scaleanim);
//然后利用View的startAnimation()函数开始动画
tv.startAnimation(animation);
</code></pre><h4 id="2-1-2、scale标签"><a href="#2-1-2、scale标签" class="headerlink" title="2.1.2、scale标签"></a>2.1.2、scale标签</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;700&quot;
    android:fillBefore=&quot;true&quot;
    android:fromXScale=&quot;1.0&quot;
    android:fromYScale=&quot;1.2&quot;
    android:pivotX=&quot;50%&quot;
    android:pivotY=&quot;50%&quot;
    android:repeatCount=&quot;1&quot;
    android:repeatMode=&quot;reverse&quot;
    android:toXScale=&quot;0.4&quot;
    android:toYScale=&quot;0.6&quot; /&gt;
</code></pre><p>android:fromXScale：动画起始时，控件在X轴方向上相对自身的缩放比例，浮点值，比如1.0 代表自身无变化，0.5代表缩小1倍，2.0代表放大1倍。</p>
<p>android:toXScale：动画结束时，控件在X轴方向上相对自身的缩放比例，浮点值。</p>
<p>android:fromYScale和android:toYScale类似。</p>
<p>android:pivotX：缩放起始点X轴坐标，可以是数值、百分数、百分数p三种样式，如50、50%、50%p。如果是数值，则表示在当前视图本身View的左上角，即原点处加上50px，作为缩放起始点X轴坐标；如果是50%，则表示在当前控件的左上角加上自己宽度的50%作为缩放起始点X轴坐标；如果是50%p，则表示在当前控件的左上角加上父控件宽度的50%作为缩放起始点X轴坐标。</p>
<p>android:pivotY：与android:pivotX一样用法。</p>
<h5 id="Animation继承属性"><a href="#Animation继承属性" class="headerlink" title="Animation继承属性"></a>Animation继承属性</h5><p>android:duration：用于设置完成一次动画的持续时间，以毫秒为单位。</p>
<p>android:fillAfter：如果设置为true，则控件动画结束时，将保持动画结束时的状态。</p>
<p>android:fillBefore：如果设置为true，则控件动画结束时，将还原到初始化状态。</p>
<p>android:fillEnabled：与android:fillBefore效果相同。</p>
<p>android:repeatCount：用于指定动画的重复次数，当取值为infinite时，表示无限循环。</p>
<p>android:repeatMode：用于设定重复的类型，有reverse和restart两个值。其中，reverse表示倒序回放：restart表示重放，并且必须与repeatCount一起使用才能看到效果。</p>
<p>android:interpolator：用于设定插值器，其实就是指定的动画效果，比如弹跳效果等。</p>
<h4 id="2-1-3、alpha标签"><a href="#2-1-3、alpha标签" class="headerlink" title="2.1.3、alpha标签"></a>2.1.3、alpha标签</h4><p>透明度动画效果。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;3000&quot;
    android:fillBefore=&quot;true&quot;
    android:fromAlpha=&quot;1.0&quot;
    android:toAlpha=&quot;0.1&quot;&gt;
&lt;/alpha&gt;
</code></pre><p>android:fromAlpha:开始时的透明度,android:toAlpha:结束时的透明度。0.0表示全透明，1.0表示完全不透明。</p>
<h4 id="2-1-4、rotate标签"><a href="#2-1-4、rotate标签" class="headerlink" title="2.1.4、rotate标签"></a>2.1.4、rotate标签</h4><p>旋转动画效果。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;3000&quot;
    android:fillAfter=&quot;true&quot;
    android:fromDegrees=&quot;0&quot;
    android:pivotX=&quot;100%&quot;
    android:pivotY=&quot;100%&quot;
    android:toDegrees=&quot;-650&quot;&gt;
&lt;/rotate&gt;
</code></pre><p>android:fromDegrees：动画开始旋转时的角度位置；android:toDegrees：动画结束时旋转到的角度位置。正值代表顺时针方向的度数，负值代表逆时针方向的度数。</p>
<p>android:pivotX：旋转中心点X轴坐标；android:pivotY：旋转中心点Y轴坐标。没有指定android:pivotX与android:pivotY属性，旋转中心点是默认的控件坐标原点，即控件左上角位置。</p>
<h4 id="2-1-5、translate标签"><a href="#2-1-5、translate标签" class="headerlink" title="2.1.5、translate标签"></a>2.1.5、translate标签</h4><p>位置移动动画效果。 </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;2000&quot;
    android:fromXDelta=&quot;0&quot;
    android:fromYDelta=&quot;0&quot;
    android:toXDelta=&quot;-80&quot;
    android:toYDelta=&quot;-80&quot;&gt;
&lt;/translate&gt;
</code></pre><p>android:fromXDelta：起始点X轴坐标，android:fromYDelta：起始点Y轴坐标，android:toXDelta：终点X轴坐标，android:toYDelta：终点Y轴坐标。可以是数值、百分数、百分数p三种样式。</p>
<h4 id="2-1-6、set标签"><a href="#2-1-6、set标签" class="headerlink" title="2.1.6、set标签"></a>2.1.6、set标签</h4><p>定义动画集。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;3000&quot;
    android:fillAfter=&quot;true&quot;&gt;
    &lt;alpha
        android:fromAlpha=&quot;0.0&quot;
        android:toAlpha=&quot;1.0&quot; /&gt;
    &lt;scale
        android:fromXScale=&quot;0.0&quot;
        android:fromYScale=&quot;0.0&quot;
        android:pivotX=&quot;50%&quot;
        android:pivotY=&quot;50%&quot;
        android:toXScale=&quot;1.4&quot;
        android:toYScale=&quot;1.4&quot; /&gt;
    &lt;rotate
        android:fromDegrees=&quot;0&quot;
        android:pivotX=&quot;50%&quot;
        android:pivotY=&quot;50%&quot;
        android:toDegrees=&quot;720&quot; /&gt;
&lt;/set&gt;
</code></pre><p>在set标签中设直repeateCount属性是无效的，必须对每个动画单独设直才有作用。</p>
<h3 id="2-2、视图动画的代码实现"><a href="#2-2、视图动画的代码实现" class="headerlink" title="2.2、视图动画的代码实现"></a>2.2、视图动画的代码实现</h3><h4 id="2-2-1、概述"><a href="#2-2-1、概述" class="headerlink" title="2.2.1、概述"></a>2.2.1、概述</h4><pre><code>setDuration(long)
setFillAfter(boolean)
setFillBefore(boolean)
setFillEnabled(boolean)
setRepeatCount(int)
setRepeatMode(int)
setlnterpolator(lnterpolator)
</code></pre><p>setRepeatMode(int）取值为Animation.RESTART或者Animation.REVERSE;setRepeatCount(int）用于设置循环次数，当设置为Animation.INFINITE时，表示无限循环。</p>
<h4 id="2-2-2、ScaleAnimation"><a href="#2-2-2、ScaleAnimation" class="headerlink" title="2.2.2、ScaleAnimation"></a>2.2.2、ScaleAnimation</h4><pre><code>ScaleAnimation(float fromX , float toX, float fromY , float toY)
ScaleAnimation(float fromX , float toX , float fromY , float toY , float pivotX, float pivotY)
ScaleAnimation(float fromX , float toX , float fromY , float toY, intpivotXType,float pivotXVal ue , int pivotYType , float pivotYValue)
</code></pre><p>pivotXType的取值有三个：<code>Animation.ABSOLUTE</code>、<code>Animation.RELATIVE_TO_SELF</code>和<code>Animation.RELATIVE_TO_PARENT</code>。对应的是<code>android:pivotX</code>中的三种取值样式:数值、百分数、百分数p。</p>
<pre><code>ScaleAnimation scaleAnim = new ScaleAnimation(O.Of , 1.4f, O.Of, 1.4f, Animation.RELATIVE_TO_SELF , 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
scaleAnim.setDuration(700);
tv.startAnimation(scaleAnim);
</code></pre><h4 id="2-2-3、AlphaAnimation"><a href="#2-2-3、AlphaAnimation" class="headerlink" title="2.2.3、AlphaAnimation"></a>2.2.3、AlphaAnimation</h4><pre><code>AlphaAnimation(Context context , AttributeSet attrs)
AlphaAnimation(float fromAlpha , float toAlpha)
</code></pre><p>示例</p>
<pre><code>AlphaAnimation alphaAnim = new AlphaAnimation(1.Of, 0.1f);
alphaAnim.setDuration(3000);
alphaAnim.setFillBefore(true);
tv.startAnimation(alphaAnim);
</code></pre><h4 id="2-2-4、RotateAnimation"><a href="#2-2-4、RotateAnimation" class="headerlink" title="2.2.4、RotateAnimation"></a>2.2.4、RotateAnimation</h4><pre><code>RotateAnimation(Context context , AttributeSet attrs)
RotateAnimation(float fromDegrees , float toDegrees)
RotateAnimation(float fromDegrees , float toDegrees , float pivotX,float pivotY)
RotateAnimation (float fromDegrees , float toDegrees , int pivotXType , float pivotXValue , int pivotYType , float pivotYValue)
</code></pre><p>示例</p>
<pre><code>RotateAnimation rotateAnim = new RotateAnimation(0 , -650, Animation.RELATIVE_TO_SELF, O.5f , Animation.RELATIVE_TO_SELF , 0.5f);
rotateAnim.setDuration(3000);
rotateAnim.setFillAfter(true);
tv.startAnimation(rotateAnim);
</code></pre><h4 id="2-2-5、TranslateAnimation"><a href="#2-2-5、TranslateAnimation" class="headerlink" title="2.2.5、TranslateAnimation"></a>2.2.5、TranslateAnimation</h4><pre><code>TranslateAnimation(Context context , AttributeSet attrs)
TranslateAnimation(float fromXDelta ,float toXDelta, float fromYDelta, float toYDelta)
TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue , int fromYType , float fromYValue , int toYType , float toYValue)
</code></pre><p>示例</p>
<pre><code>TranslateAnimation translateAnim = new TranslateAnimation(Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80);
translateAnim.setDuration(2000);
translateAnim.setFillBefore(true);
tv.startAnimation(translateAnim);
</code></pre><h4 id="2-2-6、AnimationSet"><a href="#2-2-6、AnimationSet" class="headerlink" title="2.2.6、AnimationSet"></a>2.2.6、AnimationSet</h4><p>构造函数</p>
<pre><code>AnimationSet(Context context, AttributeSet attrs)
AnimationSet(boolean shareinterpolator)
</code></pre><p>shareinterpolator当取值为true，在AnimationSet类中定义一个插值器（Interpolator）其下面的所有动画共用该插值器；当取值为false，则表示其下面的动画定义各自的插值器。</p>
<p>增加动画的函数为：</p>
<pre><code>public void addAnimation(Animation a)
</code></pre><p>示例</p>
<pre><code>Animation alpha_Anim = new AlphaAnimation(1.0f, 0.1f);
Animation scale_Anim = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
Animation rotate_Anim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
AnimationSet setAnim = new AnimationSet(true);
setAnim.addAnimation(alpha_Anim);
setAnim.addAnimation(scale_Anim);
setAnim.addAnimation(rotate_Anim);
setAnim.setDuration(3000);
setAnim.setFillAfter(true);
tv.startAnimation(setAnim);
</code></pre><h4 id="2-2-7、Animation"><a href="#2-2-7、Animation" class="headerlink" title="2.2.7、Animation"></a>2.2.7、Animation</h4><pre><code>//取消动画
void cancel()
//将控件重置到动画开始前状态
void reset()
//设置动画监昕
void setAnimationListener(Animation.AnimationListener listener)
</code></pre><p>监听：</p>
<pre><code>scaleAnim.setAnimationListener(new Animation.AnimationListener() {
    @Override
    public void onAnimationStart(Animation animation) {
    }
    @Override
    public void onAnimationEnd(Animation animation) {
    }
    @Override
    public void onAnimationRepeat(Animation animation) {
    }
});
</code></pre><h3 id="2-3、插值器初探"><a href="#2-3、插值器初探" class="headerlink" title="2.3、插值器初探"></a>2.3、插值器初探</h3><p>Interpolator只是一个接口，通过实现这个接口就可以自定义动画的变化速率。</p>
<p>使用：</p>
<pre><code>//xml中
android:interpolator=”@android:anim/accelerate_interpolator”
//代码
alphaAnim.setinterpolator(new LinearInterpolator());
</code></pre><h4 id="2-3-1、AccelerateDeceleratelnterpolator"><a href="#2-3-1、AccelerateDeceleratelnterpolator" class="headerlink" title="2.3.1、AccelerateDeceleratelnterpolator"></a>2.3.1、AccelerateDeceleratelnterpolator</h4><p>加速减速插值器，表示在开始与结束的地方速率改变比较慢，在中间的时候加速。效果是先加速后减速。</p>
<h4 id="2-3-2、Acceleratelnterpolator"><a href="#2-3-2、Acceleratelnterpolator" class="headerlink" title="2.3.2、Acceleratelnterpolator"></a>2.3.2、Acceleratelnterpolator</h4><p>动画开始的地方速率改变比较慢，然后开始加速。动画一直是加速的。</p>
<h4 id="2-3-3、Deceleratelntelnterpolator"><a href="#2-3-3、Deceleratelntelnterpolator" class="headerlink" title="2.3.3、Deceleratelntelnterpolator"></a>2.3.3、Deceleratelntelnterpolator</h4><p>动画开始的一瞬间加速到最大值，然后逐渐变慢。</p>
<h4 id="2-3-4、Linearlnterpolator"><a href="#2-3-4、Linearlnterpolator" class="headerlink" title="2.3.4、Linearlnterpolator"></a>2.3.4、Linearlnterpolator</h4><p>动画的速率始终保持恒定。</p>
<h4 id="2-3-5、Bouncelnterpolator"><a href="#2-3-5、Bouncelnterpolator" class="headerlink" title="2.3.5、Bouncelnterpolator"></a>2.3.5、Bouncelnterpolator</h4><p>弹跳插值器，模拟了控件自由落地后回弹的效果。</p>
<h4 id="2-3-6、Anticipatelnterpolator"><a href="#2-3-6、Anticipatelnterpolator" class="headerlink" title="2.3.6、Anticipatelnterpolator"></a>2.3.6、Anticipatelnterpolator</h4><p>动画开始后，会先往动画反方向移动一段距离，再应用动画。</p>
<p>Anticipatelnterpolator还有一个构造函数：</p>
<pre><code>public Anticipateinterpolator(float tension)
</code></pre><p>参数<code>tension</code>对应的XML属性为<code>android:tension</code>，表示张力值，默认值为2，值越大，初始的偏移量越大，而且速度越快。</p>
<h4 id="2-3-7、Overshootlnterpolator"><a href="#2-3-7、Overshootlnterpolator" class="headerlink" title="2.3.7、Overshootlnterpolator"></a>2.3.7、Overshootlnterpolator</h4><p>结束偏移插值器，表示在动画结束时，沿动画方向继续运动一段距离后再结束动画。</p>
<p>Overshootlnterpolator也有另一个构造函数：</p>
<pre><code>public Overshootinterpolator(float tension）
</code></pre><p>参数<code>tension</code>对应的XML属性为<code>android:tension</code>，表示张力值，默认值为2，值越大，结束时的偏移量越大，而且速度越快。</p>
<h4 id="2-3-8、AnticipateOvershootlnterpolator"><a href="#2-3-8、AnticipateOvershootlnterpolator" class="headerlink" title="2.3.8、AnticipateOvershootlnterpolator"></a>2.3.8、AnticipateOvershootlnterpolator</h4><p>AnticipateOvershootlnterpolator是Anticipatelnterpolator与Overshootlnterpolator的合体，即在动画开始时向前偏移一段距离，在动画结束时向后偏移一段距离。</p>
<p>AnticipateOvershootlnterpolator也有其他的构造函数</p>
<pre><code>public AnticipateOvershootlnterpolator(float tension)
public AnticipateOvershootlnterpolator(float tension, float extraTension)
</code></pre><p>tension默认值为2，extraTension默认值为1.5。 </p>
<h4 id="2-3-9、Cyclelnterpolator"><a href="#2-3-9、Cyclelnterpolator" class="headerlink" title="2.3.9、Cyclelnterpolator"></a>2.3.9、Cyclelnterpolator</h4><p>循环插值器，表示动画循环播放特定的次数，速率沿正弦曲线改变。</p>
<p>Cyclelnterpolator的构造函数如下：</p>
<pre><code>public Cycleinterpolator(float cycles)
</code></pre><p>参数cycles表示循环次数。</p>
<h3 id="2-4、动画示例"><a href="#2-4、动画示例" class="headerlink" title="2.4、动画示例"></a>2.4、动画示例</h3><h4 id="2-4-1、镜头由远及近效果"><a href="#2-4-1、镜头由远及近效果" class="headerlink" title="2.4.1、镜头由远及近效果"></a>2.4.1、镜头由远及近效果</h4><h4 id="2-4-2、加载框效果"><a href="#2-4-2、加载框效果" class="headerlink" title="2.4.2、加载框效果"></a>2.4.2、加载框效果</h4><h4 id="2-4-3、扫描动画效果"><a href="#2-4-3、扫描动画效果" class="headerlink" title="2.4.3、扫描动画效果"></a>2.4.3、扫描动画效果</h4><p>用<code>Animation.setStartOffset(int time）</code>来延迟各个动画的开始时间。</p>
<h3 id="2-5、逐帧动画"><a href="#2-5、逐帧动画" class="headerlink" title="2.5、逐帧动画"></a>2.5、逐帧动画</h3><p>Frame Animation</p>
<h4 id="2-5-1、XML实现"><a href="#2-5-1、XML实现" class="headerlink" title="2.5.1、XML实现"></a>2.5.1、XML实现</h4><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><p>XML文件放置在<code>／res</code>下的drawable目录中：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot;&gt;
    &lt;item
        android:drawable=&quot;@drawable/list_icon_gif_playing1&quot;
        android:duration=&quot;60&quot; /&gt;
    &lt;item
        android:drawable=&quot;@drawable/list_icon_gif_playing2&quot;
        android:duration=&quot;60&quot; /&gt;
    &lt;item
        android:drawable=&quot;@drawable/list_icon_gif_playing3&quot;
        android:duration=&quot;60&quot; /&gt;
    &lt;item
        android:drawable=&quot;@drawable/list_icon_gif_playing4&quot;
        android:duration=&quot;60&quot; /&gt;
    &lt;item
        android:drawable=&quot;@drawable/list_icon_gif_playing5&quot;
        android:duration=&quot;60&quot; /&gt;
&lt;/animation-list&gt;
</code></pre><p><code>android:oneshot</code>如果定义为true，那么此动画只会执行1次;如果定义为false，则一直循环。</p>
<p>然后给ImageView设置动画资源。可以通过<code>android:src</code>实现，也可以通过<code>android:background</code>实现。</p>
<pre><code>android:background=&quot;@drawable/playing_ani&quot;
//或者
android:src=&quot;@drawable/playing_ani&quot;
</code></pre><p>最后代码中开始动画</p>
<pre><code>AnimationDrawable anim = (AnimationDrawable) image.getDrawable();
anim.start();
</code></pre><p>当我们通过<code>android:src＝””</code>设置动画资源时，对应的取出方式是<code>image.getDrawable()</code>如果我们通过<code>android:background=””</code>设置动画资源，那么对应的取出方式就是<code>image.getBackground()</code>。</p>
<h5 id="2、音乐播放示例"><a href="#2、音乐播放示例" class="headerlink" title="2、音乐播放示例"></a>2、音乐播放示例</h5><h5 id="3、AnimationDrawable类"><a href="#3、AnimationDrawable类" class="headerlink" title="3、AnimationDrawable类"></a>3、AnimationDrawable类</h5><p>AnimationDrawable有下面几个常用函数</p>
<pre><code>void start()//开始播放逐帧动画
void stop()//停止播放逐帧动画
int getDuration(int index）//得到指定index的帧的持续时间
Drawable getFrame(int index）//得到指定index的帧所对应的Drawable对象
int getNumberOfFrames()//得到当前AnimationDrawable的所有帧数量
boolean isRunning() //判断当前AnimationDrawable是否正在播放
void setOneShot(boolean oneShot）//设置AnimationDrawable是否执行一次，true表示执行一次，false表示循环播放
boolean isOneShot() //判断当前AnimationDrawable是否执行一次，true表示执行一次，返回false表示循环播放。
void addFrame(Drawable frame,int duration）//为AnimationDrawable添加1帧，并设置持续时间。
</code></pre><h4 id="2-5-2、代码实现"><a href="#2-5-2、代码实现" class="headerlink" title="2.5.2、代码实现"></a>2.5.2、代码实现</h4><pre><code>&lt;ImageView
    android:id=&quot;@+id/frame_iv&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;/&gt;
</code></pre><p>代码</p>
<pre><code>AnimationDrawable anim = new AnimationDrawable();
for (int i = 1; i &lt;= 14; i++) {
    int id = getResources().getIdentifier(&quot;list_icon_gif_playing&quot; + i,&quot;drawable&quot;, getPackageName());
    Drawable drawable = getResources().getDrawable(id);
    anim.addFrame(drawable, 60);
}
anim.setOneShot(false);
image.setBackgroundDrawable(anim);
anim.start();
</code></pre><p>getldentifier()函数的完整声明如下：</p>
<pre><code>int getldentifier(String name, String defType, String defPackage)

//获得string
getResources().getldentifier(”name”,”string”, packdgeName);
//获得array中的数组：
getResources().getidentifier(”name”,”array”, packdgeName);
</code></pre><h2 id="第3章、属性动画"><a href="#第3章、属性动画" class="headerlink" title="第3章、属性动画"></a>第3章、属性动画</h2><h3 id="3-1、ValueAnimator的基本使用"><a href="#3-1、ValueAnimator的基本使用" class="headerlink" title="3.1、ValueAnimator的基本使用"></a>3.1、ValueAnimator的基本使用</h3><h4 id="3-1-1、概述"><a href="#3-1-1、概述" class="headerlink" title="3.1.1、概述"></a>3.1.1、概述</h4><p>View Animation中的动画类命名都是XXXXAnimation，而Property Animation中的动画类命名都是XXXXAnimator。</p>
<p>视图动画仅能对指定的控件做动画，而属性动画是通过改变控件的某一属性值来做动画的。</p>
<h4 id="3-1-2、ValueAnimator的简单使用"><a href="#3-1-2、ValueAnimator的简单使用" class="headerlink" title="3.1.2、ValueAnimator的简单使用"></a>3.1.2、ValueAnimator的简单使用</h4><p>ValueAnimator不会对控件执行任何操作，我们可以给它设定从哪个值运动到哪个值，通过监听这些值的渐变过程来自己操作控件。</p>
<pre><code>//创建实例
ValueAnimator animator = ValueAnimator.ofInt(0, 400);
animator.setDuration(1000);
//添加监昕事件
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        int curValue = (Integer)animation.getAnimatedValue() ;
        Log.d(&quot;qijian&quot;,&quot;curValue:&quot; + curValue);
    }
});
//开启动画
animator.start();
</code></pre><p>改变控件位置</p>
<pre><code>view.layout();
</code></pre><h4 id="3-1-3、常用函数"><a href="#3-1-3、常用函数" class="headerlink" title="3.1.3、常用函数"></a>3.1.3、常用函数</h4><pre><code>public static ValueAnimator ofint (int... values)
public static ValueAnimator ofFloat(float... values)

//设置动画时长，单位是毫秒
ValueAnimator setDuration(long duration)
//获取 ValueAnimator 在运动时当前运动点的值
Object getAnimatedValue()
//开始动画
void start()
//设置循环次数，设置为ValueAnimator.INFINITE表示无限循环
void setRepeatCount(int value)
//设置循环模式有ValueAnimator.RESTART和ValueAnimator.REVERSE
void setRepeatMode(int value)
//取消动画
void cancel()
</code></pre><blockquote>
<p>重复次数为INFINITE的动画，当Activity结束的时候，必须调用cancel()函数取消动画，否则动画将无限循环，从而导致View无法释放，进一步导致整个Activity无法释放，最终引起内存泄漏。</p>
</blockquote>
<pre><code>//监听动画过程中值的实时变化,添加方法为:public void addUpdateListener(AnimatorUpdateListener listener)
public static interface AnimatorUpdateListener {
    void onAnimationUpdate(ValueAnimator animation);
}

//听动画变化时的4个状态,添加方法为:public void addListener(AnimatorListener listener)
public static interface AnimatorListener {
    void onAnimationStart(Animator animation);
    void onAnimationEnd(Animator animation);
    void onAnimationCancel(Animator animation);
    void onAnimationRepeat(Animator animation);
}
</code></pre><p>移除监听</p>
<pre><code>void removeUpdateListener(AnimatorUpdateListener listener);
void removeAllUpdateListeners();

void removeListener(AnimatorListener listener);
void removeAllListeners();
</code></pre><p>其他不常用函数</p>
<pre><code>//延时多久开始，单位是毫秒
public void setStartDelay(long startDelay)
//完全克隆一个ValueAnimator实例，包括它所有的设置以及所有对监听器代码的处理
public void Animatorclone()
</code></pre><h4 id="3-1-4、弹跳加载申效果示例"><a href="#3-1-4、弹跳加载申效果示例" class="headerlink" title="3.1.4、弹跳加载申效果示例"></a>3.1.4、弹跳加载申效果示例</h4><p>通过<code>setTop(int top）</code>函数将控件移动到当前位置。这里需要说明的是，<code>getTop</code>和<code>setTop</code>函数所得到的和设置的坐标都是相对父控件的坐标位置。</p>
<h3 id="3-2、自定义插值器与Evaluator"><a href="#3-2、自定义插值器与Evaluator" class="headerlink" title="3.2、自定义插值器与Evaluator"></a>3.2、自定义插值器与Evaluator</h3><p>对于Animator而言，不仅可以设置插值器，还可以设置Evaluator。</p>
<h4 id="3-2-1、自定义插值器"><a href="#3-2-1、自定义插值器" class="headerlink" title="3.2.1、自定义插值器"></a>3.2.1、自定义插值器</h4><p>系统插值器实现的接口：</p>
<pre><code>public interface TimeInterpolator {
    float getInterpolation(float input);
}
</code></pre><p>参数input:取值范围是0～1，表示当前动画的进度，只与时间有关，取0时表示动画刚开始，取1时表示动画结束。</p>
<p>返回值：表示当前实际想要显示的进度。取值可以超过1，也可以小于0。超过1表示己经超过目标值，小于0表示小于开始位置。</p>
<p>自定义插值器，只需实现<code>Timelnterpolator</code>接口就可以了。</p>
<h4 id="3-2-2、Evaluator"><a href="#3-2-2、Evaluator" class="headerlink" title="3.2.2、Evaluator"></a>3.2.2、Evaluator</h4><p>流程：oflnt(0,400）定义动画数值区间 -&gt; 插值器(返面当前数值进度，如0.2) -&gt; Evaluator(根据数值进度计算当前值) -&gt; 监听器退回(在AnimatorUpdatelistener中返回)。</p>
<p>Evaluator用于将从插值器返回的数值进度转换成对应的数值。</p>
<pre><code>public class IntEvaluator Implements TypeEvaluator&lt;Integer&gt; {
    public Integer evaluate(float fraction , Integer startValue , Integer endValue) {
        int startint = startValue;
        return (int) (startint + fraction * (endValue - startint));
    }
}
</code></pre><p><code>fraction</code>参数就是插值器中的返回值，表示当前动画的数值进度，以小数表示。<code>startValue</code>和<code>endValue</code>分别对应<code>oflnt(int start,int end）</code>函数中<code>start</code>和<code>end</code>的数值。返回值就是在<code>AnimatorUpdateListener</code>监听器中通过<code>animation.getAnimatedValue()</code>函数得到的数值。</p>
<p>使用</p>
<pre><code>animator.setEvaluator(new IntEvaluator());
</code></pre><p>所以既可以通过重写插值器改变数值进度来改变数值位置，也可以通过改变Evaluator中数值进度所对应的具体数值来改变数值位置。</p>
<h5 id="ArgbEvaluator"><a href="#ArgbEvaluator" class="headerlink" title="ArgbEvaluator"></a>ArgbEvaluator</h5><p>除 <code>IntEvaluator</code> 和 <code>FloatEvaluator</code> 外，还有一个名为 <code>ArgbEvaluator</code>，它是用来实现颜色值过渡转换的。</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofInt(0xffffff00,0xff0000ff);
animator.setEvaluator(new ArgbEvaluator());
animator.setDuration(3000);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    public void onAnimationUpdate(ValueAnimator animation) {
        int curValue = (Integer) animation.getAnimatedValue();
        tv.setBackgroundColor(curValue);
    }
});
animator.start();
</code></pre><h3 id="3-3、ValueAnimator进阶ofObject"><a href="#3-3、ValueAnimator进阶ofObject" class="headerlink" title="3.3、ValueAnimator进阶ofObject"></a>3.3、ValueAnimator进阶ofObject</h3><pre><code>public static ValueAnimator ofObject(TypeEvaluator evaluator, Object ...values)
</code></pre><h4 id="TextView中的字母从A变化到Z实例"><a href="#TextView中的字母从A变化到Z实例" class="headerlink" title="TextView中的字母从A变化到Z实例"></a>TextView中的字母从A变化到Z实例</h4><h4 id="3-3-2、示例：抛物动画"><a href="#3-3-2、示例：抛物动画" class="headerlink" title="3.3.2、示例：抛物动画"></a>3.3.2、示例：抛物动画</h4><h3 id="3-4、ObjectAnimator"><a href="#3-4、ObjectAnimator" class="headerlink" title="3.4、ObjectAnimator"></a>3.4、ObjectAnimator</h3><h4 id="3-4-1、概述"><a href="#3-4-1、概述" class="headerlink" title="3.4.1、概述"></a>3.4.1、概述</h4><p><code>ObjectAnimator</code>是派生自<code>ValueAnimator</code>的，所以<code>ValueAnimator</code>中所能使用的函数在<code>ObjectAnimator</code>中都可以正常使用。</p>
<pre><code>public static ObjectAnimator ofFloat(Object target,String propertyName,float ...values)
</code></pre><p>在View中，有关动画共有下面几组set函数。</p>
<pre><code>// 1. 透明 度： alpha
public void setAlpha(float alpha)
// 2. 旋转度数 ： rotation 、 rotationX 、 rotationY
public void setRotation(float rotation)
public void setRotationX(float rotationX)
public void setRotationY(float rotationY)
// 3. 平移 ： translationX 、 translationY
public void setTranslationX(float translationX)
public void setTranslationY(float translationY)
// 4. 缩放 ： scaleX 、 scaleY
public void setScaleX(float scaleX)
public void setScaleY(float scaleY)
</code></pre><h4 id="3-4-2、ObjectAnimator动画原理"><a href="#3-4-2、ObjectAnimator动画原理" class="headerlink" title="3.4.2、ObjectAnimator动画原理"></a>3.4.2、ObjectAnimator动画原理</h4><p><code>ofFloat(tv, &quot;scaleY&quot;,0,3,1）</code>(定义动画对象及区间） —&gt; 插值器(返面当前数值进度，如0.2) -&gt; Evaluator(根据数值进度计算当前值) -&gt; 调用set函数(根据属性拼装set函数并反射调用，并将当前值作为参数传入)。</p>
<p>ObjectAnimator 只负责把动画过程中的数值传到对应属性的set函数中就结束了。</p>
<h4 id="3-4-3、自定义ObjectAnimator属性"><a href="#3-4-3、自定义ObjectAnimator属性" class="headerlink" title="3.4.3、自定义ObjectAnimator属性"></a>3.4.3、自定义ObjectAnimator属性</h4><p>抛物动画例子</p>
<h4 id="3-4-4、何时需要实现对应属性的get函数"><a href="#3-4-4、何时需要实现对应属性的get函数" class="headerlink" title="3.4.4、何时需要实现对应属性的get函数"></a>3.4.4、何时需要实现对应属性的get函数</h4><p>当动画只有一个过渡值时，系统才会调用对应属性的get函数来得到动画的初始值。当不存在get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。</p>
<h4 id="3-4-5、常用函数"><a href="#3-4-5、常用函数" class="headerlink" title="3.4.5、常用函数"></a>3.4.5、常用函数</h4><pre><code>//设置动画时长，单位是毫秒
ValueAnimator setDuration(long duration)

//获取 ValueAnimator 在运动时，当前运动点的值
Object getAnimatedValue () ;

//开始动画
void start ()

//设置循环次数，设置为 INFINITE 表示无限循环
void setRepeatCount(int value)

//设置循环模式，value 取值有 RESTART 和 REVERSE
void setRepeatMode （Int value)

//取消动画
void cancel()

//监听动画变化时的实时值
//添加方法为 public void addUpdateListener(AnimatorUpdateListener listener
public static interface AnimatorUpdateListener {
    void onAnimatorUpdate(ValueAnimator animation);
)

//监听器二 ： 监听动画变化时的 4 种状态
//添加方法为 public void addListener(AnimatorListener listener)
public static interface AnimatorListener {
    void onAnimationStart(Animator animation);
    void onAnimationEnd(Animator animation);
    void onAnimationCancel(Animator animation);
    void onAnimationRepeat(Animator animation);
}

//设置插值器
public void setInterpolator(Timeinterpolator value)
//设置 Evaluator
public void setEvaluator(TypeEvaluator value)
</code></pre><h3 id="3-5、组合动画AnimatorSet"><a href="#3-5、组合动画AnimatorSet" class="headerlink" title="3.5、组合动画AnimatorSet"></a>3.5、组合动画AnimatorSet</h3><h4 id="3-5-1、playSequentially与playTogether"><a href="#3-5-1、playSequentially与playTogether" class="headerlink" title="3.5.1、playSequentially与playTogether"></a>3.5.1、playSequentially与playTogether</h4><p>playSequentially：动画依次播放，playTogether：所有动画一起开始。</p>
<p>playTogether和playSequentially函数在开始动画时，只是把每个控件的动画激活，至于每个控件自身的动画是否延时、是否无限循环，只与控件自身的动画设定有关，与playTogether和 playSequentially函数无关，它们只负责到时间后激活动画。</p>
<p>playSequentially函数只有在上一个控件做完动画以后，才会激活下一个控件的动画。如果上一个控件的动画是无限循环的，那么下一个控件就别再指望能做动画了。</p>
<h4 id="3-5-2、AnimatorSet-Builde"><a href="#3-5-2、AnimatorSet-Builde" class="headerlink" title="3.5.2、AnimatorSet.Builde"></a>3.5.2、AnimatorSet.Builde</h4><pre><code>//表示要播放哪个动画
public Builder play (Animator anim)
//和前面的动画一起执行
public Builder with(Animator anim)
//先执行这个动画，再执行前面的动画
public Builder before (Animator aηim)
//在执行前面的动画后才执行该动画
public Builder after(Animator anim)
//延迟 n 毫秒之后执行动画
public Builder after(long delay)
</code></pre><h4 id="3-5-3、AnimatorSet监昕器"><a href="#3-5-3、AnimatorSet监昕器" class="headerlink" title="3.5.3、AnimatorSet监昕器"></a>3.5.3、AnimatorSet监昕器</h4><pre><code>public void addListener(AnimatorListener listener);
</code></pre><h4 id="3-5-4、常用函数"><a href="#3-5-4、常用函数" class="headerlink" title="3.5.4、常用函数"></a>3.5.4、常用函数</h4><pre><code>//设置单次动画时长
public AnimatorSet setDuration(long duration);
//设置插值器
public void setinterpolator(Timeinterpolator interpolator)
//设置 ObjectAnimator 动画目标控件
public void setTarget(Object target)
</code></pre><p>在AnimatorSet中设置以后，会覆盖单个ObjectAnimator中的设置。</p>
<pre><code>//设置延时开始动画时长
public void setStartDelay(long startDelay)
</code></pre><p>不会覆盖单个动画的延时，而且仅针对性地延长AnimatorSet的激活时间。</p>
<h4 id="3-5-5、示例：路径动画"><a href="#3-5-5、示例：路径动画" class="headerlink" title="3.5.5、示例：路径动画"></a>3.5.5、示例：路径动画</h4><h3 id="3-6、Animator动画的XML实现"><a href="#3-6、Animator动画的XML实现" class="headerlink" title="3.6、Animator动画的XML实现"></a>3.6、Animator动画的XML实现</h3><p>在 XML 中与 Animator 对应的有三个标签:</p>
<pre><code>&lt;animator/＞:对应ValueAnimator
&lt;objectAnimator/＞ 对应ObjectAnimator
&lt;set/＞对应 AnimatorSet 

ValueAnimator valueAnimator = (ValueAnimator)Animatorinflater.loadAnimator(MyActivity.this , R.animator.animator);
valueAnimator.start();

ObjectAnimator animator = (ObjectAnimator) Animatorinflater.loadAnimator(MyActivity.this , R.animator.object_animator);
animator.setTarget(mTvl);
animator.start();
</code></pre>
    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="../../../../img/reward-alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="../../../../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2020/03/07/33.JNI入门/" class="pre-post btn btn-default" title='JNI入门'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">JNI入门</span>
        </a>
    
    
        <a href="/2019/12/23/31.ConstraintLayout布局/" class="next-post btn btn-default" title='ConstraintLayout布局详解'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">ConstraintLayout布局详解</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第1章、绘图基础"><span class="toc-text">第1章、绘图基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、基本图形绘制"><span class="toc-text">1.1、基本图形绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1、概述"><span class="toc-text">1.1.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2、画笔的基本设置"><span class="toc-text">1.1.2、画笔的基本设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3、Canvas使用基础"><span class="toc-text">1.1.3、Canvas使用基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、画布背景设置"><span class="toc-text">1、画布背景设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、画直线"><span class="toc-text">2、画直线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、多条直线"><span class="toc-text">3、多条直线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、点"><span class="toc-text">4、点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、多个点"><span class="toc-text">5、多个点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6、矩形工具类RectF和Rect"><span class="toc-text">6、矩形工具类RectF和Rect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7、矩形"><span class="toc-text">7、矩形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8、圆角矩形"><span class="toc-text">8、圆角矩形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9、圆形"><span class="toc-text">9、圆形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10、椭圆"><span class="toc-text">10、椭圆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11、弧"><span class="toc-text">11、弧</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4、Rect与RectF"><span class="toc-text">1.1.4、Rect与RectF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、是否包含点、矩形"><span class="toc-text">1、是否包含点、矩形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、判断两个矩形是否相交"><span class="toc-text">2、判断两个矩形是否相交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、合并"><span class="toc-text">3、合并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5、Color"><span class="toc-text">1.1.5、Color</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2、路径"><span class="toc-text">1.2、路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1、概述"><span class="toc-text">1.2.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2、直线路径"><span class="toc-text">1.2.2、直线路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3、弧线路径"><span class="toc-text">1.2.3、弧线路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4、addXXX系列函数"><span class="toc-text">1.2.4、addXXX系列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#添加矩形路径"><span class="toc-text">添加矩形路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#添加圆角矩形路径"><span class="toc-text">添加圆角矩形路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#添加圆形路径"><span class="toc-text">添加圆形路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#添加椭圆路径"><span class="toc-text">添加椭圆路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#添加弧形路径"><span class="toc-text">添加弧形路径</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5、填充模式"><span class="toc-text">1.2.5、填充模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6、重置路径"><span class="toc-text">1.2.6、重置路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-7、蜘蛛网状图示例"><span class="toc-text">1.2.7、蜘蛛网状图示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3、文字"><span class="toc-text">1.3、文字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1、Paint设置"><span class="toc-text">1.3.1、Paint设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2、Canvas绘制文本"><span class="toc-text">1.3.2、Canvas绘制文本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、普通绘制"><span class="toc-text">1、普通绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、逐个指定文字位置"><span class="toc-text">2、逐个指定文字位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、沿路径绘制"><span class="toc-text">3、沿路径绘制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3、设置字体样式"><span class="toc-text">1.3.3、设置字体样式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4、Region"><span class="toc-text">1.4、Region</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1、构造Region"><span class="toc-text">1.4.1、构造Region</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#直接构造"><span class="toc-text">直接构造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#间接构造"><span class="toc-text">间接构造</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2、枚举区域——RegionIterator类"><span class="toc-text">1.4.2、枚举区域——RegionIterator类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3、区域相交"><span class="toc-text">1.4.3、区域相交</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#union-函数"><span class="toc-text">union()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#区域操作"><span class="toc-text">区域操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4、其他函数"><span class="toc-text">1.4.4、其他函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5、Canvas（画布）"><span class="toc-text">1.5、Canvas（画布）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1、Canvas变换"><span class="toc-text">1.5.1、Canvas变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#平移（Translate）"><span class="toc-text">平移（Translate）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#屏幕显示与Canvas的关系"><span class="toc-text">屏幕显示与Canvas的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#旋转（Rotate）"><span class="toc-text">旋转（Rotate）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缩放（Scale）"><span class="toc-text">缩放（Scale）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扭曲（Skew）"><span class="toc-text">扭曲（Skew）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#裁剪画布（clip系列函数）"><span class="toc-text">裁剪画布（clip系列函数）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2、画布的保存与恢复"><span class="toc-text">1.5.2、画布的保存与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#save-和restore-函数"><span class="toc-text">save()和restore()函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restoreToCount-int-saveCount-函数"><span class="toc-text">restoreToCount(int saveCount)函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3、圆形头像示例"><span class="toc-text">1.5.3、圆形头像示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4、裁剪动画示例"><span class="toc-text">1.5.4、裁剪动画示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6、控件的使用方法"><span class="toc-text">1.6、控件的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1、控件概述"><span class="toc-text">1.6.1、控件概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2、通过XML引入控件"><span class="toc-text">1.6.2、通过XML引入控件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3、动态添加控件"><span class="toc-text">1.6.3、动态添加控件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#addRule"><span class="toc-text">addRule</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置margin"><span class="toc-text">设置margin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置layout-weight（方法一）"><span class="toc-text">设置layout_weight（方法一）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置layout-weight（方法二）"><span class="toc-text">设置layout_weight（方法二）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置layout-gravity"><span class="toc-text">设置layout_gravity</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置android-gravity"><span class="toc-text">设置android:gravity</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addView"><span class="toc-text">addView</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第2章、视国动画"><span class="toc-text">第2章、视国动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、视图动画标签"><span class="toc-text">2.1、视图动画标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1、概述"><span class="toc-text">2.1.1、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#配置XML动画文件"><span class="toc-text">配置XML动画文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2、scale标签"><span class="toc-text">2.1.2、scale标签</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Animation继承属性"><span class="toc-text">Animation继承属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3、alpha标签"><span class="toc-text">2.1.3、alpha标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4、rotate标签"><span class="toc-text">2.1.4、rotate标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5、translate标签"><span class="toc-text">2.1.5、translate标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6、set标签"><span class="toc-text">2.1.6、set标签</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、视图动画的代码实现"><span class="toc-text">2.2、视图动画的代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1、概述"><span class="toc-text">2.2.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2、ScaleAnimation"><span class="toc-text">2.2.2、ScaleAnimation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3、AlphaAnimation"><span class="toc-text">2.2.3、AlphaAnimation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4、RotateAnimation"><span class="toc-text">2.2.4、RotateAnimation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5、TranslateAnimation"><span class="toc-text">2.2.5、TranslateAnimation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6、AnimationSet"><span class="toc-text">2.2.6、AnimationSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7、Animation"><span class="toc-text">2.2.7、Animation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、插值器初探"><span class="toc-text">2.3、插值器初探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1、AccelerateDeceleratelnterpolator"><span class="toc-text">2.3.1、AccelerateDeceleratelnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2、Acceleratelnterpolator"><span class="toc-text">2.3.2、Acceleratelnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3、Deceleratelntelnterpolator"><span class="toc-text">2.3.3、Deceleratelntelnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4、Linearlnterpolator"><span class="toc-text">2.3.4、Linearlnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5、Bouncelnterpolator"><span class="toc-text">2.3.5、Bouncelnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-6、Anticipatelnterpolator"><span class="toc-text">2.3.6、Anticipatelnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-7、Overshootlnterpolator"><span class="toc-text">2.3.7、Overshootlnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-8、AnticipateOvershootlnterpolator"><span class="toc-text">2.3.8、AnticipateOvershootlnterpolator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-9、Cyclelnterpolator"><span class="toc-text">2.3.9、Cyclelnterpolator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、动画示例"><span class="toc-text">2.4、动画示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1、镜头由远及近效果"><span class="toc-text">2.4.1、镜头由远及近效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2、加载框效果"><span class="toc-text">2.4.2、加载框效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3、扫描动画效果"><span class="toc-text">2.4.3、扫描动画效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5、逐帧动画"><span class="toc-text">2.5、逐帧动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1、XML实现"><span class="toc-text">2.5.1、XML实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、概述"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、音乐播放示例"><span class="toc-text">2、音乐播放示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、AnimationDrawable类"><span class="toc-text">3、AnimationDrawable类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2、代码实现"><span class="toc-text">2.5.2、代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第3章、属性动画"><span class="toc-text">第3章、属性动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、ValueAnimator的基本使用"><span class="toc-text">3.1、ValueAnimator的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1、概述"><span class="toc-text">3.1.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2、ValueAnimator的简单使用"><span class="toc-text">3.1.2、ValueAnimator的简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3、常用函数"><span class="toc-text">3.1.3、常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4、弹跳加载申效果示例"><span class="toc-text">3.1.4、弹跳加载申效果示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2、自定义插值器与Evaluator"><span class="toc-text">3.2、自定义插值器与Evaluator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1、自定义插值器"><span class="toc-text">3.2.1、自定义插值器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2、Evaluator"><span class="toc-text">3.2.2、Evaluator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArgbEvaluator"><span class="toc-text">ArgbEvaluator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3、ValueAnimator进阶ofObject"><span class="toc-text">3.3、ValueAnimator进阶ofObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TextView中的字母从A变化到Z实例"><span class="toc-text">TextView中的字母从A变化到Z实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2、示例：抛物动画"><span class="toc-text">3.3.2、示例：抛物动画</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4、ObjectAnimator"><span class="toc-text">3.4、ObjectAnimator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1、概述"><span class="toc-text">3.4.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2、ObjectAnimator动画原理"><span class="toc-text">3.4.2、ObjectAnimator动画原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3、自定义ObjectAnimator属性"><span class="toc-text">3.4.3、自定义ObjectAnimator属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4、何时需要实现对应属性的get函数"><span class="toc-text">3.4.4、何时需要实现对应属性的get函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5、常用函数"><span class="toc-text">3.4.5、常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5、组合动画AnimatorSet"><span class="toc-text">3.5、组合动画AnimatorSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1、playSequentially与playTogether"><span class="toc-text">3.5.1、playSequentially与playTogether</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2、AnimatorSet-Builde"><span class="toc-text">3.5.2、AnimatorSet.Builde</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3、AnimatorSet监昕器"><span class="toc-text">3.5.3、AnimatorSet监昕器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4、常用函数"><span class="toc-text">3.5.4、常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5、示例：路径动画"><span class="toc-text">3.5.5、示例：路径动画</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6、Animator动画的XML实现"><span class="toc-text">3.6、Animator动画的XML实现</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>