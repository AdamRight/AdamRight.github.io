<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>python基础 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 士不可以不弘毅，任重而道远 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Android/"><i class="fa "></i>Android</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Web/"><i class="fa "></i>Web</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Java/"><i class="fa "></i>Java</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C/"><i class="fa "></i>C</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/iOS/"><i class="fa "></i>iOS</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/python/"><i class="fa "></i>python</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="python基础">
            
	            python基础
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/python" title='python'>
                        python
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/09/05</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr>
<p>数据都是临时存储在内存中，为了更快速的查找或使用这个数据，通常我们把这个数据在内存中存储之后定义一个名称，这个名称就是变量。</p>
<p>变量就是一个存储数据的时候当前数据所在的内存地址的名字而已。</p>
<p>定义变量：</p>
<pre><code>变量名 = 值

my_name = &apos;TOM&apos;
print(my_name)#TOM
</code></pre><hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><hr>
<p>数据类型</p>
<ul>
<li>整型：int</li>
<li>浮点型：float</li>
<li>字符串：str</li>
<li>布尔型：bool</li>
<li>列表：list</li>
<li>元组：tuple</li>
<li>集合：set</li>
<li>字典：dict</li>
</ul>
<blockquote>
<p>检测数据类型的方法：<code>type()</code></p>
</blockquote>
<pre><code>a = 1
print(type(a))  # &lt;class &apos;int&apos;&gt; -- 整型

b = 1.1
print(type(b))  # &lt;class &apos;float&apos;&gt; -- 浮点型

c = True
print(type(c))  # &lt;class &apos;bool&apos;&gt; -- 布尔型

d = &apos;12345&apos;
print(type(d))  # &lt;class &apos;str&apos;&gt; -- 字符串

e = [10, 20, 30]
print(type(e))  # &lt;class &apos;list&apos;&gt; -- 列表

f = (10, 20, 30)
print(type(f))  # &lt;class &apos;tuple&apos;&gt; -- 元组

h = {10, 20, 30}
print(type(h))  # &lt;class &apos;set&apos;&gt; -- 集合

g = {&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 20}
print(type(g))  # &lt;class &apos;dict&apos;&gt; -- 字典
</code></pre><hr>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><hr>
<table>
<thead>
<tr>
<th style="text-align:center">格式符号</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">有符号的十进制整数</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">字符</td>
</tr>
<tr>
<td style="text-align:center">%u</td>
<td style="text-align:center">无符号十进制整数</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">八进制整数</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">十六进制整数（小写ox）</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">十六进制整数（大写OX）</td>
</tr>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">科学计数法（小写’e’）</td>
</tr>
<tr>
<td style="text-align:center">%E</td>
<td style="text-align:center">科学计数法（大写’E’）</td>
</tr>
<tr>
<td style="text-align:center">%g</td>
<td style="text-align:center">%f和%e的简写</td>
</tr>
<tr>
<td style="text-align:center">%G</td>
<td style="text-align:center">%f和%E的简写</td>
</tr>
</tbody>
</table>
<blockquote>
<p>技巧</p>
</blockquote>
<ul>
<li>%06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出</li>
<li>%.2f，表示小数点后显示的小数位数。</li>
<li><p>格式化字符串除了%s，还可以写为<code>f&#39;{表达式}&#39;</code></p>
<pre><code>age = 18
name = &apos;TOM&apos;
weight = 75.5
student_id = 1

# 我的名字是TOM
print(&apos;我的名字是%s&apos; % name)

# 我的学号是0001
print(&apos;我的学号是%4d&apos; % student_id)

# 我的体重是75.50公斤
print(&apos;我的体重是%.2f公斤&apos; % weight)

# 我的名字是TOM，明年19岁了
print(&apos;我的名字是%s，明年%d岁了&apos; % (name, age + 1))

# 我的名字是TOM，明年19岁了
print(f&apos;我的名字是{name}, 明年{age + 1}岁了&apos;)
</code></pre></li>
</ul>
<hr>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><hr>
<pre><code>input(&quot;提示信息&quot;)
</code></pre><p>在Python中，<code>input</code>会把接收到的任意用户输入的数据都当做字符串处理。</p>
<pre><code>password = input(&apos;请输入您的密码：&apos;)
print(f&apos;您输入的密码是{password}&apos;)
# &lt;class &apos;str&apos;&gt;
print(type(password))
</code></pre><hr>
<h2 id="转换数据类型"><a href="#转换数据类型" class="headerlink" title="转换数据类型"></a>转换数据类型</h2><hr>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int(x [,base ])</td>
<td style="text-align:center">将x转换为一个整数</td>
</tr>
<tr>
<td style="text-align:center">float(x)</td>
<td style="text-align:center">将x转换为一个浮点数</td>
</tr>
<tr>
<td style="text-align:center">complex(real [,imag ])</td>
<td style="text-align:center">创建一个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td style="text-align:center">str(x )</td>
<td style="text-align:center">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:center">repr(x )</td>
<td style="text-align:center">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td style="text-align:center">eval(str )</td>
<td style="text-align:center">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:center">tuple(s )</td>
<td style="text-align:center">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:center">list(s )</td>
<td style="text-align:center">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:center">chr(x )</td>
<td style="text-align:center">将一个整数转换为一个Unicode字符</td>
</tr>
<tr>
<td style="text-align:center">ord(x )</td>
<td style="text-align:center">将一个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td style="text-align:center">hex(x )</td>
<td style="text-align:center">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td style="text-align:center">oct(x )</td>
<td style="text-align:center">将一个整数转换为一个八进制字符串</td>
</tr>
<tr>
<td style="text-align:center">bin(x )</td>
<td style="text-align:center">将一个整数转换为一个二进制字符串</td>
</tr>
</tbody>
</table>
<pre><code># 1. float() -- 转换成浮点型
num1 = 1
print(float(num1))
print(type(float(num1)))

# 2. str() -- 转换成字符串类型
num2 = 10
print(type(str(num2)))

# 3. tuple() -- 将一个序列转换成元组
list1 = [10, 20, 30]
print(tuple(list1))
print(type(tuple(list1)))

# 4. list() -- 将一个序列转换成列表
t1 = (100, 200, 300)
print(list(t1))
print(type(list(t1)))

# 5. eval() -- 将字符串中的数据转换成Python表达式原本类型
str1 = &apos;10&apos;
str2 = &apos;[1, 2, 3]&apos;
str3 = &apos;(1000, 2000, 3000)&apos;
print(type(eval(str1)))
print(type(eval(str2)))
print(type(eval(str3)))
</code></pre><hr>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
<td>1 + 1 输出结果为 2</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
<td>1-1 输出结果为 0</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
<td>2 * 2 输出结果为 4</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
<td>10 / 2 输出结果为 5</td>
</tr>
<tr>
<td style="text-align:center">//</td>
<td style="text-align:center">整除</td>
<td>9 // 4 输出结果为2</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取余</td>
<td>9 % 4 输出结果为 1</td>
</tr>
<tr>
<td style="text-align:center">**</td>
<td style="text-align:center">指数</td>
<td>2 *<em> 4 输出结果为 16，即 2 </em> 2 <em> 2 </em> 2</td>
</tr>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">小括号</td>
<td>小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9</td>
</tr>
</tbody>
</table>
<p>多个变量赋值</p>
<pre><code>num1, float1, str1 = 10, 0.5, &apos;hello world&apos;
print(num1)
print(float1)
print(str1)
</code></pre><p>多变量赋相同值</p>
<pre><code>a = b = 10
print(a)
print(b)
</code></pre><table>
<thead>
<tr>
<th>运算符</th>
<th>逻辑表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>x and y</td>
<td>布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。</td>
<td>True and False， 返回 False。</td>
</tr>
<tr>
<td>or</td>
<td>x or y</td>
<td>布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。</td>
<td>False or True， 返回 True。</td>
</tr>
<tr>
<td>not</td>
<td>not x</td>
<td>布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td>not True 返回 False, not False 返回 True</td>
</tr>
</tbody>
</table>
<p>数字之间的逻辑运算</p>
<pre><code>a = 0
b = 1
c = 2

# and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字
print(a and b)  # 0
print(b and a)  # 0
print(b and c)  # 2
print(c and b)  # 1

# or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字
print(a or b)  # 1
print(a or c)  # 2
print(b or c)  # 1
</code></pre><hr>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><hr>
<p>语法：</p>
<pre><code>if 条件1:
    代码...
    ......
elif 条件2：
    代码
    ......
......
else:
    以上条件都不成立执行执行的代码
</code></pre><p>实例：</p>
<pre><code>age = int(input(&apos;请输入您的年龄：&apos;))
if age &lt; 18:
    print(f&apos;您的年龄是{age},童工一枚&apos;)
elif (age &gt;= 18) and (age &lt;= 60):
    print(f&apos;您的年龄是{age},合法工龄&apos;)
elif age &gt; 60:
    print(f&apos;您的年龄是{age},可以退休&apos;)
</code></pre><hr>
<h3 id="猜拳游戏"><a href="#猜拳游戏" class="headerlink" title="猜拳游戏"></a>猜拳游戏</h3><hr>
<pre><code># 导入random模块
import random

# 计算电脑出拳的随机数字
computer = random.randint(0, 2)
print(computer)

player = int(input(&apos;请出拳：0-石头，1-剪刀，2-布：&apos;))

# 玩家胜利 p0:c1 或 p1:c2 或 p2:c0
if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0):
    print(&apos;玩家获胜&apos;)
# 平局：玩家 == 电脑
elif player == computer:
    print(&apos;平局&apos;)
else:
    print(&apos;电脑获胜&apos;)
</code></pre><hr>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><hr>
<p>语法：</p>
<pre><code>值1 if 条件 else 值2

a = 1
b = 2
c = a if a &gt; b else b
print(c)
</code></pre><hr>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><hr>
<p>while的语法</p>
<pre><code>while 条件:
    代码
    ......
</code></pre><p>计算1-100累加和：</p>
<pre><code>i = 1
result = 0
while i &lt;= 100:
    result += i
    i += 1
print(result)#5050
</code></pre><hr>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><hr>
<p>语法</p>
<pre><code>for 临时变量 in 序列:
    代码
    ......
</code></pre><p>使用</p>
<pre><code>str1 = &apos;HelloWorld&apos;
for i in str1:
    print(i)
</code></pre><hr>
<h3 id="while…else"><a href="#while…else" class="headerlink" title="while…else"></a>while…else</h3><hr>
<p>语法</p>
<pre><code>while 条件:
    代码
else:
    循环正常结束之后要执行的代码
</code></pre><blockquote>
<p>所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。</p>
</blockquote>
<blockquote>
<p>因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。</p>
</blockquote>
<hr>
<h3 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h3><hr>
<p>语法</p>
<pre><code>for 临时变量 in 序列:
    代码
    ...
else:
    循环正常结束之后要执行的代码
</code></pre><blockquote>
<p>break终止循环不会执行else下方缩进的代码。continue退出循环的方式，执行else下方缩进的代码。</p>
</blockquote>
<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="三引号字符串"><a href="#三引号字符串" class="headerlink" title="三引号字符串"></a>三引号字符串</h3><hr>
<pre><code>name3 = &apos;&apos;&apos; Tom &apos;&apos;&apos;
name4 = &quot;&quot;&quot; Rose &quot;&quot;&quot;
a = &apos;&apos;&apos; i am Tom, 
        nice to meet you! &apos;&apos;&apos;

b = &quot;&quot;&quot; i am Rose, 
        nice to meet you! &quot;&quot;&quot;
</code></pre><blockquote>
<p>注意：三引号形式的字符串支持换行。</p>
</blockquote>
<hr>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><hr>
<blockquote>
<p>注意：字符串下标从0开始。</p>
</blockquote>
<p>切片语法</p>
<pre><code>序列[开始位置下标:结束位置下标:步长]
</code></pre><blockquote>
<p>注意:不包含结束位置下标对应的数据， 正负整数均可；步长是选取间隔，正负整数均可，默认步长为1。</p>
</blockquote>
<pre><code>name = &quot;abcdefg&quot;

print(name[2:5:1])  # cde
print(name[2:5])  # cde
print(name[:5])  # abcde
print(name[1:])  # bcdefg
print(name[:])  # abcdefg
print(name[::2])  # aceg
print(name[:-1])  # abcdef, 负1表示倒数第一个数据
print(name[-4:-1])  # def
print(name[::-1])  # gfedcba
</code></pre><hr>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><hr>
<p>检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则返回-1。</p>
<pre><code>#开始和结束位置下标可以省略，表示在整个字符串序列中查找
字符串序列.find(子串, 开始位置下标, 结束位置下标)

mystr = &quot;hello world and Python&quot;
print(mystr.find(&apos;and&apos;))  # 12
print(mystr.find(&apos;and&apos;, 15, 30))  # -1
print(mystr.find(&apos;ands&apos;))  # -1
</code></pre><p>rfind()和find()功能相同，但查找方向为右侧开始。</p>
<hr>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><hr>
<p>检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则报异常。</p>
<pre><code>#开始和结束位置下标可以省略，表示在整个字符串序列中查找。
字符串序列.index(子串, 开始位置下标, 结束位置下标)

mystr = &quot;hello world and Python&quot;
print(mystr.index(&apos;and&apos;))  # 12
print(mystr.index(&apos;ands&apos;))  # 报错
</code></pre><p>rindex()index()功能相同，但查找方向为右侧开始。</p>
<hr>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><hr>
<p>返回某个子串在字符串中出现的次数。</p>
<pre><code>#开始和结束位置下标可以省略，表示在整个字符串序列中查找。
字符串序列.count(子串, 开始位置下标, 结束位置下标)

mystr = &quot;hello world and Python&quot;
print(mystr.count(&apos;and&apos;))  # 1
print(mystr.count(&apos;ands&apos;))  # 0
</code></pre><hr>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><hr>
<p>替换</p>
<pre><code>#替换次数如果查出子串出现次数，则替换次数为该子串出现次数。
字符串序列.replace(旧子串, 新子串, 替换次数)

mystr = &quot;hello world and Python and&quot;

# 结果：hello world he Python he
print(mystr.replace(&apos;and&apos;, &apos;he&apos;))
# 结果：hello world he Python he
print(mystr.replace(&apos;and&apos;, &apos;he&apos;, 10))
# 结果：hello world and Python and
print(mystr)
</code></pre><blockquote>
<p>注意：数据按照是否能直接修改分为可变类型和不可变类型两种。字符串类型的数据修改的时候不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型。</p>
</blockquote>
<hr>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><hr>
<p>按照指定字符分割字符串。</p>
<pre><code>字符串序列.split(分割字符, num)
</code></pre><blockquote>
<p>注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。</p>
</blockquote>
<pre><code>mystr = &quot;hello world and Python and it&quot;

# [&apos;hello world &apos;, &apos; Python &apos;, &apos; it&apos;]
print(mystr.split(&apos;and&apos;))
# [&apos;hello world &apos;, &apos; Python &apos;, &apos; it&apos;]
print(mystr.split(&apos;and&apos;, 2))
# [&apos;hello&apos;, &apos;world&apos;, &apos;and&apos;, &apos;Python&apos;, &apos;and&apos;, &apos;it&apos;]
print(mystr.split(&apos; &apos;))
# [&apos;hello&apos;, &apos;world&apos;, &apos;and Python and it&apos;]
print(mystr.split(&apos; &apos;, 2))
</code></pre><blockquote>
<p>注意：如果分割字符是原有字符串中的子串，分割后则丢失该子串。</p>
</blockquote>
<hr>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><hr>
<p>用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。</p>
<pre><code>字符或子串.join(多字符串组成的序列)

list1 = [&apos;mm&apos;, &apos;nn&apos;, &apos;bb&apos;, &apos;vv&apos;]
t1 = (&apos;aa&apos;, &apos;b&apos;, &apos;cc&apos;, &apos;ddd&apos;)
# 结果：mm_nn_bb_vv
print(&apos;_&apos;.join(list1))
# 结果：aa...b...cc...ddd
print(&apos;...&apos;.join(t1))
</code></pre><hr>
<h3 id="capitalize"><a href="#capitalize" class="headerlink" title="capitalize"></a>capitalize</h3><hr>
<p>将字符串第一个字符转换成大写。</p>
<pre><code>mystr = &quot;hello world and Python and it&quot;
# 结果：Hello world and python and it
print(mystr.capitalize())
</code></pre><blockquote>
<p>注意：capitalize()函数转换后，只字符串第一个字符大写，其他的字符全都小写。</p>
</blockquote>
<hr>
<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><hr>
<p>将字符串每个单词首字母转换成大写。</p>
<pre><code>mystr = &quot;hello world and Python and it&quot;
# 结果：Hello World And Python And It
print(mystr.title())
</code></pre><hr>
<h3 id="lower和upper"><a href="#lower和upper" class="headerlink" title="lower和upper"></a>lower和upper</h3><hr>
<p>lower()：将字符串中大写转小写。</p>
<pre><code>mystr = &quot;hello world and Python and it&quot;
# 结果：hello world and python and it
print(mystr.lower())
</code></pre><p>upper()：将字符串中小写转大写。</p>
<pre><code>mystr = &quot;hello world and Python and it&quot;
# 结果：HELLO WORLD AND PYTHON AND IT
print(mystr.upper())
</code></pre><hr>
<h3 id="lstrip和rstrip和strip"><a href="#lstrip和rstrip和strip" class="headerlink" title="lstrip和rstrip和strip"></a>lstrip和rstrip和strip</h3><hr>
<p>lstrip()：删除字符串左侧空白字符。</p>
<p>rstrip()：删除字符串右侧空白字符。</p>
<p>strip()：删除字符串两侧空白字符。</p>
<hr>
<h3 id="ljust和rjust和center"><a href="#ljust和rjust和center" class="headerlink" title="ljust和rjust和center"></a>ljust和rjust和center</h3><hr>
<p>ljust()：返回一个原字符串左对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串。</p>
<p>rjust()：返回一个原字符串右对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。</p>
<p>center()：返回一个原字符串居中对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。</p>
<pre><code>mystr = &quot;hello world and Python and it&quot;
# 结果：hello world and Python and it.......
print(mystr.ljust(36,&apos;.&apos;))
# 结果：.......hello world and Python and it
print(mystr.rjust(36,&apos;.&apos;))
# 结果：...hello world and Python and it....
print(mystr.center(36,&apos;.&apos;))
</code></pre><hr>
<h3 id="startswith和endswith"><a href="#startswith和endswith" class="headerlink" title="startswith和endswith"></a>startswith和endswith</h3><hr>
<p>startswith()：检查字符串是否是以指定子串开头，是则返回True，否则返回False。如果设置开始和结束位置下标，则在指定范围内检查。</p>
<pre><code>字符串序列.startswith(子串, 开始位置下标, 结束位置下标)

mystr = &quot;hello world and Python and it&quot;
# 结果：True
print(mystr.startswith(&apos;hello&apos;))
# 结果False
print(mystr.startswith(&apos;hello&apos;, 5, 20))
</code></pre><p>endswith()：检查字符串是否是以指定子串结尾，是则返回True，否则返回False。如果设置开始和结束位置下标，则在指定范围内检查。</p>
<pre><code>字符串序列.endswith(子串, 开始位置下标, 结束位置下标)

mystr = &quot;hello world and Python and it&quot;
# 结果：True
print(mystr.endswith(&apos;it&apos;))
# 结果：False
print(mystr.endswith(&apos;Python&apos;, 2, 20))
</code></pre><hr>
<h3 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha"></a>isalpha</h3><hr>
<p>如果字符串至少有一个字符并且所有字符都是字母则返回True, 否则返回 False。</p>
<pre><code>mystr1 = &apos;hello&apos;
mystr2 = &apos;hello12345&apos;

# 结果：True
print(mystr1.isalpha())
# 结果：False
print(mystr2.isalpha())
</code></pre><hr>
<h3 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit"></a>isdigit</h3><hr>
<p>如果字符串只包含数字则返回True否则返回 False。</p>
<pre><code>mystr1 = &apos;aaa12345&apos;
mystr2 = &apos;12345&apos;

# 结果： False
print(mystr1.isdigit())
# 结果：False
print(mystr2.isdigit())
</code></pre><hr>
<h3 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum"></a>isalnum</h3><hr>
<p>如果字符串至少有一个字符并且所有字符都是字母或数字则返回True,否则返回False。</p>
<pre><code>mystr1 = &apos;aaa12345&apos;
mystr2 = &apos;12345-&apos;

# 结果：True
print(mystr1.isalnum())
# 结果：False
print(mystr2.isalnum())
</code></pre><hr>
<h3 id="isspace"><a href="#isspace" class="headerlink" title="isspace"></a>isspace</h3><hr>
<p>如果字符串中只包含空白，则返回True，否则返回False。</p>
<pre><code>mystr1 = &apos;1 2 3 4 5&apos;
mystr2 = &apos;     &apos;

# 结果：False
print(mystr1.isspace())
# 结果：True
print(mystr2.isspace())
</code></pre><hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><hr>
<p>列表可以一次性存储多个数据，且可以为不同数据类型。可以对这些数据进行的操作有：增、删、改、查。</p>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><hr>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(name_list[0])  # Tom
print(name_list[1])  # Lily
print(name_list[2])  # Rose
</code></pre><hr>
<h3 id="index-1"><a href="#index-1" class="headerlink" title="index"></a>index</h3><hr>
<p>返回指定数据所在位置的下标 。</p>
<pre><code>列表序列.index(数据, 开始位置下标, 结束位置下标)

name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(name_list.index(&apos;Lily&apos;, 0, 2))  # 1
</code></pre><blockquote>
<p>注意：如果查找的数据不存在则报错。</p>
</blockquote>
<hr>
<h3 id="count-1"><a href="#count-1" class="headerlink" title="count"></a>count</h3><hr>
<p>统计指定数据在当前列表中出现的次数。</p>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(name_list.count(&apos;Lily&apos;))  # 1
</code></pre><hr>
<h3 id="len"><a href="#len" class="headerlink" title="len"></a>len</h3><hr>
<p>访问列表长度，即列表中数据的个数。</p>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(len(name_list))  # 3
</code></pre><hr>
<h3 id="in和not-in"><a href="#in和not-in" class="headerlink" title="in和not in"></a>in和not in</h3><hr>
<p>in：判断指定数据在某个列表序列，如果在返回True，否则返回False</p>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]

# 结果：True
print(&apos;Lily&apos; in name_list)
# 结果：False
print(&apos;Lilys&apos; in name_list)
</code></pre><p>not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False</p>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]

# 结果：False
print(&apos;Lily&apos; not in name_list)
# 结果：True
print(&apos;Lilys&apos; not in name_list)
</code></pre><hr>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><hr>
<p>列表结尾追加数据。</p>
<pre><code>列表序列.append(数据)

name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.append(&apos;xiaoming&apos;)
# 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, &apos;xiaoming&apos;]
print(name_list)
</code></pre><blockquote>
<p>列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，<strong>故列表为可变类型数据</strong>。</p>
</blockquote>
<p>如果append()追加的数据是一个序列，则追加整个序列到列表</p>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.append([&apos;xiaoming&apos;, &apos;xiaohong&apos;])
# 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, [&apos;xiaoming&apos;, &apos;xiaohong&apos;]]
print(name_list)
</code></pre><hr>
<h3 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h3><hr>
<p>列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表。</p>
<pre><code>列表序列.extend(数据)

#单个数据
name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.extend(&apos;xiaoming&apos;)
# 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, &apos;x&apos;, &apos;i&apos;, &apos;a&apos;, &apos;o&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;]
print(name_list)

​#序列数据
name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.extend([&apos;xiaoming&apos;, &apos;xiaohong&apos;])
# 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, &apos;xiaoming&apos;, &apos;xiaohong&apos;]
print(name_list)
</code></pre><hr>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><hr>
<p>指定位置新增数据。</p>
<pre><code>列表序列.insert(位置下标, 数据)

name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.insert(1, &apos;xiaoming&apos;)
# 结果：[&apos;Tom&apos;, &apos;xiaoming&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(name_list)
</code></pre><hr>
<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><hr>
<pre><code>#del 目标

name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
# 结果：报错提示：name &apos;name_list&apos; is not defined
del name_list
print(name_list)

​#删除指定数据
name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
del name_list[0]
# 结果：[&apos;Lily&apos;, &apos;Rose&apos;]
print(name_list)
</code></pre><hr>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><hr>
<p>删除指定下标的数据(默认为最后一个)，并返回该数据。</p>
<pre><code>#列表序列.pop(下标)

name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
del_name = name_list.pop(1)
# 结果：Lily
print(del_name)
# 结果：[&apos;Tom&apos;, &apos;Rose&apos;]
print(name_list)
</code></pre><hr>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><hr>
<p>移除列表中某个数据的第一个匹配项。</p>
<pre><code>#列表序列.remove(数据)

name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.remove(&apos;Rose&apos;)
# 结果：[&apos;Tom&apos;, &apos;Lily&apos;]
print(name_list)
</code></pre><hr>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><hr>
<p>清空列表</p>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list.clear()
print(name_list) # 结果： []
</code></pre><hr>
<h3 id="修改指定下标数据"><a href="#修改指定下标数据" class="headerlink" title="修改指定下标数据"></a>修改指定下标数据</h3><hr>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_list[0] = &apos;aaa&apos;
# 结果：[&apos;aaa&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(name_list)
</code></pre><hr>
<h3 id="逆置reverse"><a href="#逆置reverse" class="headerlink" title="逆置reverse"></a>逆置reverse</h3><hr>
<pre><code>num_list = [1, 5, 2, 3, 6, 8]
num_list.reverse()
# 结果：[8, 6, 3, 2, 5, 1]
print(num_list)
</code></pre><hr>
<h3 id="排序sort"><a href="#排序sort" class="headerlink" title="排序sort"></a>排序sort</h3><hr>
<pre><code>列表序列.sort( key=None, reverse=False)
</code></pre><blockquote>
<p>注意：reverse表示排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）</p>
</blockquote>
<pre><code>num_list = [1, 5, 2, 3, 6, 8]
num_list.sort()
# 结果：[1, 2, 3, 5, 6, 8]
print(num_list)
</code></pre><hr>
<h3 id="复制copy"><a href="#复制copy" class="headerlink" title="复制copy"></a>复制copy</h3><hr>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
name_li2 = name_list.copy()
# 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
print(name_li2)
</code></pre><hr>
<h3 id="while遍历列表"><a href="#while遍历列表" class="headerlink" title="while遍历列表"></a>while遍历列表</h3><hr>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
i = 0
while i &lt; len(name_list):
    print(name_list[i])
    i += 1
</code></pre><hr>
<h3 id="for遍历列表"><a href="#for遍历列表" class="headerlink" title="for遍历列表"></a>for遍历列表</h3><hr>
<pre><code>name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;]
for i in name_list:
    print(i)
</code></pre><hr>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><hr>
<p>一个元组可以存储多个数据，<strong>元组内的数据是不能修改的</strong>。元组特点：定义元组使用小括号，且逗号隔开各个数据，数据可以是不同的数据类型。</p>
<pre><code>#多个数据元组
t1 = (10, 20, 30)

#单个数据元组
t2 = (10,)
print(type(t2))  # tuple

t3 = (20)
print(type(t3))  # int
</code></pre><blockquote>
<p>注意：如果定义的元组只有一个数据，那么这个数据后面也要添加逗号，否则数据类型为唯一的这个数据的数据类型。</p>
</blockquote>
<p>按下标查找数据</p>
<pre><code>tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;)
print(tuple1[0])  # aa
</code></pre><p>index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index方法相同。</p>
<pre><code>tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;)
print(tuple1.index(&apos;aa&apos;))  # 0
</code></pre><p>count()：统计某个数据在当前元组出现的次数。</p>
<pre><code>tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;)
print(tuple1.count(&apos;bb&apos;))  # 2
</code></pre><p>len()：统计元组中数据的个数。</p>
<pre><code>tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;)
print(len(tuple1))  # 4
</code></pre><blockquote>
<p>注意：元组内的直接数据如果修改则立即报错</p>
</blockquote>
<blockquote>
<p>但是如果元组里面有列表，修改列表里面的数据则是支持的，故自觉很重要。</p>
</blockquote>
<pre><code>tuple2 = (10, 20, [&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;], 50, 30)
print(tuple2[2])  # 访问到列表
# 结果：(10, 20, [&apos;aaaaa&apos;, &apos;bb&apos;, &apos;cc&apos;], 50, 30)
tuple2[2][0] = &apos;aaaaa&apos;
print(tuple2)
</code></pre><hr>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><hr>
<p>字典里面的数据是以键值对形式出现，字典数据和数据顺序没有关系，即字典不支持下标，后期无论数据如何变化，只需要按照对应的键的名字查找数据即可。</p>
<p>字典特点：符号为大括号；数据为键值对形式出现；各个键值对之间用逗号隔开。</p>
<pre><code># 有数据字典
dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
# 空字典
dict2 = {}
</code></pre><p>一般称冒号前面的为键(key)，简称k；冒号后面的为值(value)，简称v。</p>
<hr>
<h3 id="增和改"><a href="#增和改" class="headerlink" title="增和改"></a>增和改</h3><hr>
<p>写法：字典序列[key] = 值</p>
<blockquote>
<p>注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。</p>
</blockquote>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}

dict1[&apos;name&apos;] = &apos;Rose&apos;
# 结果：{&apos;name&apos;: &apos;Rose&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
print(dict1)

dict1[&apos;id&apos;] = 110
# {&apos;name&apos;: &apos;Rose&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;, &apos;id&apos;: 110}
print(dict1)
</code></pre><blockquote>
<p>注意：<strong>字典为可变类型</strong>。</p>
</blockquote>
<hr>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><hr>
<p>del()/del：删除字典或删除字典中指定键值对。</p>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}

del dict1[&apos;gender&apos;]
# 结果：{&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20}
print(dict1)
</code></pre><p>clear()：清空字典</p>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
dict1.clear()
print(dict1)  # {}
</code></pre><hr>
<h3 id="key值查找"><a href="#key值查找" class="headerlink" title="key值查找"></a>key值查找</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
print(dict1[&apos;name&apos;])  # Tom
print(dict1[&apos;id&apos;])  # 报错
</code></pre><blockquote>
<p>如果当前查找的key存在，则返回对应的值；否则则报错。</p>
</blockquote>
<hr>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><hr>
<pre><code>字典序列.get(key, 默认值)
</code></pre><blockquote>
<p>注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。</p>
</blockquote>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
print(dict1.get(&apos;name&apos;))  # Tom
print(dict1.get(&apos;id&apos;, 110))  # 110
print(dict1.get(&apos;id&apos;))  # None
</code></pre><hr>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
print(dict1.keys())  # dict_keys([&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;])
</code></pre><hr>
<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
print(dict1.values())  # dict_values([&apos;Tom&apos;, 20, &apos;男&apos;])
</code></pre><hr>
<h3 id="items"><a href="#items" class="headerlink" title="items"></a>items</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
print(dict1.items())  # dict_items([(&apos;name&apos;, &apos;Tom&apos;), (&apos;age&apos;, 20), (&apos;gender&apos;, &apos;男&apos;)])
</code></pre><hr>
<h3 id="遍历字典的key"><a href="#遍历字典的key" class="headerlink" title="遍历字典的key"></a>遍历字典的key</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
for key in dict1.keys():
    print(key)
</code></pre><hr>
<h3 id="遍历字典的value"><a href="#遍历字典的value" class="headerlink" title="遍历字典的value"></a>遍历字典的value</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
for value in dict1.values():
    print(value)
</code></pre><hr>
<h3 id="遍历字典的元素"><a href="#遍历字典的元素" class="headerlink" title="遍历字典的元素"></a>遍历字典的元素</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
for item in dict1.items():
    print(item)
</code></pre><hr>
<h3 id="遍历字典的键值对"><a href="#遍历字典的键值对" class="headerlink" title="遍历字典的键值对"></a>遍历字典的键值对</h3><hr>
<pre><code>dict1 = {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;}
for key, value in dict1.items():
    print(f&apos;{key} = {value}&apos;)
</code></pre><hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><hr>
<p>创建集合使用<code>{}</code>或<code>set()</code>，但是如果要创建空集合只能使用<code>set()</code>，因为<code>{}</code>用来创建空字典。</p>
<pre><code>s1 = {10, 20, 30, 40, 50}
print(s1)#{40, 10, 50, 20, 30}

s2 = {10, 30, 20, 10, 30, 40, 30, 50}
print(s2)#{40, 10, 50, 20, 30}

s3 = set(&apos;abcdefg&apos;)
print(s3)

s4 = set()
print(type(s4))  # set

s5 = {}
print(type(s5))  # dict
</code></pre><p>特点：集合可以去掉重复数据；集合数据是无序的，故不支持下标。</p>
<hr>
<h3 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h3><hr>
<p>add()</p>
<pre><code>s1 = {10, 20}
s1.add(100)
s1.add(10)
print(s1)  # {100, 10, 20}
</code></pre><blockquote>
<p>因为集合有去重功能，所以，当向集合内追加的数据是当前集合已有数据的话，则不进行任何操作。</p>
</blockquote>
<p>update(), 追加的数据是序列。</p>
<pre><code>s1 = {10, 20}
# s1.update(100)  # 报错
s1.update([100, 200])
s1.update(&apos;abc&apos;)
print(s1)
</code></pre><hr>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><hr>
<p>remove()，删除集合中的指定数据，如果数据不存在则报错。</p>
<pre><code>s1 = {10, 20}

s1.remove(10)
print(s1)
s1.remove(10)  # 报错
print(s1)
</code></pre><p>discard()，删除集合中的指定数据，如果数据不存在也不会报错。</p>
<pre><code>s1 = {10, 20}

s1.discard(10)
print(s1)

s1.discard(10)
print(s1)
</code></pre><p>pop()，随机删除集合中的某个数据，并返回这个数据。</p>
<pre><code>s1 = {10, 20, 30, 40, 50}
del_num = s1.pop()
print(del_num)
print(s1)
</code></pre><hr>
<h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><hr>
<p>in：判断数据在集合序列。not in：判断数据不在集合序列</p>
<pre><code>s1 = {10, 20, 30, 40, 50}

print(10 in s1)
print(10 not in s1)
</code></pre><hr>
<h2 id="公共操作"><a href="#公共操作" class="headerlink" title="公共操作"></a>公共操作</h2><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><hr>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">支持的容器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">合并</td>
<td style="text-align:center">字符串、列表、元组</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">字符串、列表、元组</td>
</tr>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:center">元素是否存在</td>
<td style="text-align:center">字符串、列表、元组、字典</td>
</tr>
<tr>
<td style="text-align:center">not in</td>
<td style="text-align:center">元素是否不存在</td>
<td style="text-align:center">字符串、列表、元组、字典</td>
</tr>
</tbody>
</table>
<hr>
<p><code>+</code>:</p>
<pre><code># 1. 字符串 
str1 = &apos;aa&apos;
str2 = &apos;bb&apos;
str3 = str1 + str2
print(str3)  # aabb

# 2. 列表 
list1 = [1, 2]
list2 = [10, 20]
list3 = list1 + list2
print(list3)  # [1, 2, 10, 20]

# 3. 元组 
t1 = (1, 2)
t2 = (10, 20)
t3 = t1 + t2
print(t3)  #(1, 2, 10, 20)
</code></pre><hr>
<p><code>*</code>:</p>
<pre><code># 1. 字符串
print(&apos;-&apos; * 10)  # ----------

# 2. 列表
list1 = [&apos;hello&apos;]
print(list1 * 4)  # [&apos;hello&apos;, &apos;hello&apos;, &apos;hello&apos;, &apos;hello&apos;]

# 3. 元组
t1 = (&apos;world&apos;,)
print(t1 * 4)  # (&apos;world&apos;, &apos;world&apos;, &apos;world&apos;, &apos;world&apos;)
</code></pre><hr>
<p><code>in</code>或<code>not in</code>:</p>
<pre><code># 1. 字符串
print(&apos;a&apos; in &apos;abcd&apos;)  # True
print(&apos;a&apos; not in &apos;abcd&apos;)  # False

# 2. 列表
list1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
print(&apos;a&apos; in list1)  # True
print(&apos;a&apos; not in list1)  # False

# 3. 元组
t1 = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;)
print(&apos;aa&apos; in t1)  # False
print(&apos;aa&apos; not in t1)  # True
</code></pre><hr>
<h3 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h3><hr>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len()</td>
<td>计算容器中元素个数</td>
</tr>
<tr>
<td>del 或 del()</td>
<td>删除</td>
</tr>
<tr>
<td>max()</td>
<td>返回容器中元素最大值</td>
</tr>
<tr>
<td>min()</td>
<td>返回容器中元素最小值</td>
</tr>
<tr>
<td>range(start, end, step)</td>
<td>生成从start到end的数字，步长为 step，供for循环使用</td>
</tr>
<tr>
<td>enumerate()</td>
<td>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</td>
</tr>
</tbody>
</table>
<hr>
<p>len()</p>
<pre><code># 1. 字符串
str1 = &apos;abcdefg&apos;
print(len(str1))  # 7

# 2. 列表
list1 = [10, 20, 30, 40]
print(len(list1))  # 4

# 3. 元组
t1 = (10, 20, 30, 40, 50)
print(len(t1))  # 5

# 4. 集合
s1 = {10, 20, 30}
print(len(s1))  # 3

# 5. 字典
dict1 = {&apos;name&apos;: &apos;Rose&apos;, &apos;age&apos;: 18}
print(len(dict1))  # 2
</code></pre><hr>
<p>del()</p>
<pre><code># 1. 字符串
str1 = &apos;abcdefg&apos;
del str1
print(str1)#error

# 2. 列表
list1 = [10, 20, 30, 40]
del(list1[0])
print(list1)  # [20, 30, 40]
</code></pre><hr>
<p>max()</p>
<pre><code># 1. 字符串
str1 = &apos;abcdefg&apos;
print(max(str1))  # g

# 2. 列表
list1 = [10, 20, 30, 40]
print(max(list1))  # 40
</code></pre><hr>
<p>min()</p>
<pre><code># 1. 字符串
str1 = &apos;abcdefg&apos;
print(min(str1))  # a

# 2. 列表
list1 = [10, 20, 30, 40]
print(min(list1))  # 10
</code></pre><hr>
<p>range()</p>
<pre><code># 1 2 3 4 5 6 7 8 9
for i in range(1, 10, 1):
    print(i)

# 1 3 5 7 9
for i in range(1, 10, 2):
    print(i)

# 0 1 2 3 4 5 6 7 8 9
for i in range(10):
    print(i)
</code></pre><blockquote>
<p>注意：range()生成的序列不包含end数字。</p>
</blockquote>
<hr>
<p>enumerate()</p>
<pre><code>enumerate(可遍历对象, start=0)
</code></pre><blockquote>
<p>注意：start参数用来设置遍历数据的下标的起始值，默认为0。</p>
</blockquote>
<pre><code>list1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]

for i in enumerate(list1):
    print(i)#(0, &apos;a&apos;)(1, &apos;b&apos;)(2, &apos;c&apos;)(4, &apos;e&apos;)

for index, char in enumerate(list1, start=1):
    print(f&apos;下标是{index}, 对应的字符是{char}&apos;)#下标是1, 对应的字符是a...
</code></pre><hr>
<h3 id="容器类型转换"><a href="#容器类型转换" class="headerlink" title="容器类型转换"></a>容器类型转换</h3><hr>
<p>tuple()：将某个序列转换成元组</p>
<pre><code>list1 = [10, 20, 30, 40, 50, 20]
s1 = {100, 200, 300, 400, 500}

print(tuple(list1))#(10, 20, 30, 40, 50, 20)
print(tuple(s1))#(100, 200, 300, 400, 500)
</code></pre><p>list()：将某个序列转换成列表</p>
<pre><code>t1 = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;)
s1 = {100, 200, 300, 400, 500}

print(list(t1))#[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]
print(list(s1))#[100, 200, 300, 400, 500]
</code></pre><p>set()：将某个序列转换成集合</p>
<pre><code>list1 = [10, 20, 30, 40, 50, 20]
t1 = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;)

print(set(list1))#{40, 10, 50, 20, 30}
print(set(t1))#{&apos;c&apos;, &apos;d&apos;, &apos;a&apos;, &apos;b&apos;, &apos;e&apos;}
</code></pre><blockquote>
<p>注意：集合可以快速完成列表去重；集合不支持下标</p>
</blockquote>
<hr>
<h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><hr>
<p>用一个表达式创建一个有规律的列表或控制一个有规律列表。列表推导式又叫列表生成式。</p>
<p>创建一个0-10的列表。</p>
<pre><code>#while循环实现
# 1. 准备一个空列表
list1 = []
# 2. 书写循环，依次追加数字到空列表list1中
i = 0
while i &lt; 10:
    list1.append(i)
    i += 1
print(list1)

#for循环实现
list1 = []
for i in range(10):
    list1.append(i)
print(list1)

#列表推导式实现
list1 = [i for i in range(10)]
print(list1)
</code></pre><hr>
<p>带if的列表推导式</p>
<p>创建0-10的偶数列表:</p>
<pre><code>#range()步长实现
list1 = [i for i in range(0, 10, 2)]
print(list1)

#if实现
list1 = [i for i in range(10) if i % 2 == 0]
print(list1)
</code></pre><hr>
<p>多个for循环实现列表推导式</p>
<p>创建列表如下：</p>
<pre><code>[(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
</code></pre><p>代码如下：</p>
<pre><code>list1 = [(i, j) for i in range(1, 3) for j in range(3)]
print(list1)
</code></pre><hr>
<h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><hr>
<p>如下两个列表，如何快速合并为一个字典？</p>
<pre><code>list1 = [&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;]
list2 = [&apos;Tom&apos;, 20, &apos;man&apos;]
</code></pre><p>字典推导式作用：快速合并列表为字典或提取字典中目标数据。</p>
<p>创建一个字典：字典key是1-5数字，value是这个数字的2次方：</p>
<pre><code>dict1 = {i: i**2 for i in range(1, 5)}
print(dict1)  # {1: 1, 2: 4, 3: 9, 4: 16}
</code></pre><p>将两个列表合并为一个字典：</p>
<pre><code>list1 = [&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;]
list2 = [&apos;Tom&apos;, 20, &apos;man&apos;]
dict1 = {list1[i]: list2[i] for i in range(len(list1))}
print(dict1)
</code></pre><p>提取字典中目标数据</p>
<pre><code>counts = {&apos;MBP&apos;: 268, &apos;HP&apos;: 125, &apos;DELL&apos;: 201, &apos;Lenovo&apos;: 199, &apos;acer&apos;: 99}

# 需求：提取上述电脑数量大于等于200的字典数据
count1 = {key: value for key, value in counts.items() if value &gt;= 200}
print(count1)  # {&apos;MBP&apos;: 268, &apos;DELL&apos;: 201}
</code></pre><hr>
<h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><hr>
<p>创建一个集合，数据为下方列表的2次方。</p>
<pre><code>list1 = [1, 1, 2]
</code></pre><p>代码如下：</p>
<pre><code>list1 = [1, 1, 2]
set1 = {i ** 2 for i in list1}
print(set1)  # {1, 4}
</code></pre><blockquote>
<p>注意：集合有数据去重功能。</p>
</blockquote>
<hr>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><hr>
<p>函数就是将一段具有独立功能的代码块整合到一个整体并命名，在需要的位置调用这个名称即可完成对应的需求。函数在开发过程中，可以更高效的实现代码重用。</p>
<p>定义函数：</p>
<pre><code>def 函数名(参数):
    代码1
    代码2
    ......
</code></pre><p>调用函数</p>
<pre><code>函数名(参数)
</code></pre><blockquote>
<p>注意：不同的需求，参数可有可无。在Python中，函数必须先定义后使用。<strong>一定是先定义函数，后调用函数。</strong></p>
</blockquote>
<p>代码</p>
<pre><code>def sum_num(a, b):
    return a + b
# 用result变量保存函数返回值
result = sum_num(1, 2)
print(result)
</code></pre><p>函数的说明文档help(函数名)</p>
<pre><code>def sum_num(a, b):
    &quot;&quot;&quot; 求和函数 &quot;&quot;&quot;
    return a + b
help(sum_num)
</code></pre><hr>
<h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><hr>
<p>变量作用域指的是变量生效的范围，主要分为两类：局部变量和全局变量。</p>
<p>局部变量：定义在函数体内部的变量，即只在函数体内部生效。局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。</p>
<p>全局变量：指的是在函数体内、外都能生效的变量。</p>
<pre><code>a = 100
def testA():
    print(a)
def testB():
    a = 200
    print(a)
testA()  # 100
testB()  # 200
print(f&apos;全局变量a = {a}&apos;)  # 全局变量a = 100
</code></pre><p>在<code>testB</code>函数内部的<code>a = 200</code>中的变量a是在修改全局变量<code>a</code>吗？不是。<code>testB</code>函数内部的<code>a = 200</code>是定义了一个局部变量。</p>
<p>如何在函数体内部修改全局变量？</p>
<pre><code>a = 100

def testA():
    print(a)

def testB():
    # global 关键字声明a是全局变量
    global a
    a = 200
    print(a)

testA()  # 100
testB()  # 200
print(f&apos;全局变量a = {a}&apos;)  # 全局变量a = 200
</code></pre><hr>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><hr>
<p>如果一个函数要有多个返回值，该如何书写代码？</p>
<pre><code>def return_num():
    return 1, 2

result = return_num()
print(result)  # (1, 2)
</code></pre><blockquote>
<p>注意：<code>return a, b</code>写法，返回多个数据的时候，默认是元组类型。return后面可以连接列表、元组或字典，以返回多个值。</p>
</blockquote>
<hr>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><hr>
<p>位置参数：调用函数时根据函数定义的参数位置来传递参数。</p>
<pre><code>def user_info(name, age, gender):
    print(f&apos;您的名字是{name}, 年龄是{age}, 性别是{gender}&apos;)
user_info(&apos;TOM&apos;, 20, &apos;男&apos;)
</code></pre><blockquote>
<p>注意：传递和定义参数的顺序及个数必须一致。</p>
</blockquote>
<p>关键字参数：函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，<strong>同时也清除了参数的顺序需求</strong>。</p>
<pre><code>def user_info(name, age, gender):
    print(f&apos;您的名字是{name}, 年龄是{age}, 性别是{gender}&apos;)


user_info(&apos;Rose&apos;, age=20, gender=&apos;女&apos;)
user_info(&apos;小明&apos;, gender=&apos;男&apos;, age=16)
</code></pre><p>注意：<strong>函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。</strong></p>
<p>缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。</p>
<pre><code>def user_info(name, age, gender=&apos;男&apos;):
    print(f&apos;您的名字是{name}, 年龄是{age}, 性别是{gender}&apos;)
user_info(&apos;TOM&apos;, 20)
user_info(&apos;Rose&apos;, 18, &apos;女&apos;)
</code></pre><p>不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。</p>
<pre><code>def user_info(*args):
    print(args)

# (&apos;TOM&apos;,)
user_info(&apos;TOM&apos;)
# (&apos;TOM&apos;, 18)
user_info(&apos;TOM&apos;, 18)
</code></pre><blockquote>
<p>注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。</p>
</blockquote>
<p>包裹关键字传递</p>
<pre><code>def user_info(**kwargs):
    print(kwargs)

# {&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 18, &apos;id&apos;: 110}
user_info(name=&apos;TOM&apos;, age=18, id=110)
</code></pre><blockquote>
<p>综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。</p>
</blockquote>
<hr>
<h3 id="拆包和交换变量值"><a href="#拆包和交换变量值" class="headerlink" title="拆包和交换变量值"></a>拆包和交换变量值</h3><hr>
<p>拆包：元组</p>
<pre><code>def return_num():
    return 100, 200

num1, num2 = return_num()
print(num1)  # 100
print(num2)  # 200
</code></pre><p>拆包：字典</p>
<pre><code>dict1 = {&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 18}
a, b = dict1

# 对字典进行拆包，取出来的是字典的key
print(a)  # name
print(b)  # age

print(dict1[a])  # TOM
print(dict1[b])  # 18
</code></pre><p>交换变量值</p>
<p>交换两个变量的值。借助第三变量存储数据。</p>
<pre><code># 1. 定义中间变量
c = 0
# 2. 将a的数据存储到c
c = a
# 3. 将b的数据20赋值到a，此时a = 20
a = b
#4. 将之前c的数据10赋值到b，此时b = 10
b = c
print(a)  # 20
print(b)  # 10
</code></pre><p>交换两个变量的值。方法二</p>
<pre><code>a, b = 1, 2
a, b = b, a
print(a)  # 2
print(b)  # 1
</code></pre><hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr>
<p>在python中，值是靠引用来传递来的。<strong>我们可以用<code>id()</code>来判断两个变量是否为同一个值的引用。</strong> 我们可以将id值理解为那块内存的地址标识。</p>
<pre><code># 1. int类型
a = 1
b = a
print(b)  # 1
print(id(a))  # 140708464157520
print(id(b))  # 140708464157520
a = 2
print(b)  # 1,说明int类型为不可变类型 
print(id(a))  # 140708464157552，此时得到是的数据2的内存地址
print(id(b))  # 140708464157520

# 2. 列表
aa = [10, 20]
bb = aa
print(id(aa))  # 2325297783432
print(id(bb))  # 2325297783432
aa.append(30)
print(bb)  # [10, 20, 30], 列表为可变类型
print(id(aa))  # 2325297783432
print(id(bb))  # 2325297783432
</code></pre><p>引用当做实参，代码如下：</p>
<pre><code>def test1(a):
    print(a)
    print(id(a))
    a += a
    print(a)
    print(id(a))

# int：计算前后id值不同
b = 100
test1(b)

# 列表：计算前后id值相同
c = [11, 22]
test1(c)
</code></pre><hr>
<h3 id="可变和不可变类型"><a href="#可变和不可变类型" class="headerlink" title="可变和不可变类型"></a>可变和不可变类型</h3><hr>
<p>所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变。</p>
<p>可变类型：列表、字典、集合。</p>
<p>不可变类型：整型、浮点型、字符串、元组。</p>
<hr>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><hr>
<p>3以内数字累加和</p>
<pre><code># 3 + 2 + 1
def sum_numbers(num):
    # 1.如果是1，直接返回1 -- 出口
    if num == 1:
        return 1
    # 2.如果不是1，重复执行累加并返回结果
    return num + sum_numbers(num-1)
sum_result = sum_numbers(3)
# 输出结果为6
print(sum_result)
</code></pre><hr>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><hr>
<p>如果一个函数有一个返回值，并且只有一句代码，可以使用lambda简化。</p>
<p>lambda语法</p>
<pre><code>lambda 参数列表 ： 表达式
</code></pre><blockquote>
<p>注意：lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用。lambda表达式能接收任何数量的参数但只能返回一个表达式的值。</p>
</blockquote>
<pre><code># 函数
def fn1():
    return 200

print(fn1)
print(fn1())

# lambda表达式,无参数
fn2 = lambda: 100
print(fn2)
print(fn2())
</code></pre><blockquote>
<p>注意：直接打印lambda表达式，输出的是此lambda的内存地址</p>
</blockquote>
<p>计算a + b</p>
<pre><code>def add(a, b):
    return a + b
result = add(1, 2)
print(result)

#lambda实现,有参数
fn1 = lambda a, b: a + b
print(fn1(1, 2))
</code></pre><p>lambda的参数形式，默认参数</p>
<pre><code>fn1 = lambda a, b, c=100: a + b + c
print(fn1(10, 20))
</code></pre><p>可变参数：<code>*args</code></p>
<pre><code>fn1 = lambda *args: args
print(fn1(10, 20, 30))
</code></pre><blockquote>
<p>注意：这里的可变参数传入到lambda之后，返回值为元组。</p>
</blockquote>
<p>可变参数：<code>**kwargs</code></p>
<pre><code>fn1 = lambda **kwargs: kwargs
print(fn1(name=&apos;python&apos;, age=20))
</code></pre><p>lambda的应用，带判断的lambda</p>
<pre><code>fn1 = lambda a, b: a if a &gt; b else b
print(fn1(1000, 500))
</code></pre><p>lambda的应用，列表数据按字典key的值排序</p>
<pre><code>students = [
    {&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 20},
    {&apos;name&apos;: &apos;ROSE&apos;, &apos;age&apos;: 19},
    {&apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 22}
]

# 按name值升序排列
students.sort(key=lambda x: x[&apos;name&apos;])
print(students)

# 按name值降序排列
students.sort(key=lambda x: x[&apos;name&apos;], reverse=True)
print(students)

# 按age值升序排列
students.sort(key=lambda x: x[&apos;age&apos;])
print(students)
</code></pre><hr>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><hr>
<p><strong>把函数作为参数传入，这样的函数称为高阶函数</strong>，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。</p>
<p>体验高阶函数:</p>
<pre><code>#数字求绝对值计算
abs(-10)  # 10

#数字的四舍五入计算
round(1.2)  # 1
round(1.9)  # 2

#需求：任意两个数字，按照指定要求整理数字后再进行求和计算。

#方法1
def add_num(a, b):
    return abs(a) + abs(b)
result = add_num(-1, 2)
print(result)  # 3

#方法2
def sum_num(a, b, f):
    return f(a) + f(b)
result = sum_num(-1, 2, abs)
print(result)  # 3
</code></pre><blockquote>
<p>注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
</blockquote>
<hr>
<p>内置高阶函数map():map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。</p>
<pre><code>#计算`list1`序列中各个数字的2次方。

list1 = [1, 2, 3, 4, 5]
def func(x):
    return x ** 2
result = map(func, list1)
print(result)  # &lt;map object at 0x0000013769653198&gt;
print(list(result))  # [1, 4, 9, 16, 25]
</code></pre><hr>
<p>reduce():reduce(func，lst)，<strong>其中func必须有两个参数</strong>。每次func计算的结果继续和序列的下一个元素做累积计算。</p>
<pre><code>#计算`list1`序列中各个数字的累加和。
import functools
list1 = [1, 2, 3, 4, 5]
def func(a, b):
    return a + b
result = functools.reduce(func, list1)
print(result)  # 15
</code></pre><hr>
<p>filter():filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个filter对象。如果要转换为列表, 可以使用list()来转换。</p>
<pre><code>list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
def func(x):
    return x % 2 == 0
result = filter(func, list1)
print(result)  # &lt;filter object at 0x0000017AF9DC3198&gt;
print(list(result))  # [2, 4, 6, 8, 10]
</code></pre><hr>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><hr>
<p>文件操作的作用就是把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力。</p>
<p>关闭文件 <code>f.close()</code>。</p>
<p>打开一个已经存在的文件，或者创建一个新文件，语法如下：</p>
<pre><code>open(name, mode)
#name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。
#mode：设置打开文件的模式(访问模式)：只读、写入、追加等。
</code></pre><p>打开文件模式</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td style="text-align:center">rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td style="text-align:center">r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td style="text-align:center">rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td style="text-align:center">wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td style="text-align:center">w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td style="text-align:center">wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td style="text-align:center">ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td style="text-align:center">a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td style="text-align:center">ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
<hr>
<p>写:</p>
<pre><code>#语法
对象对象.write(&apos;内容&apos;)

# 1. 打开文件
f = open(&apos;test.txt&apos;, &apos;w&apos;)
# 2.文件写入
f.write(&apos;hello world&apos;)
# 3. 关闭文件
f.close()
</code></pre><blockquote>
<p>注意：<code>w</code>和<code>a</code>模式：如果文件不存在则创建该文件；如果文件存在，<code>w</code>模式先清空再写入，<code>a</code>模式直接末尾追加。<code>r</code>模式：如果文件不存在则报错。</p>
</blockquote>
<hr>
<p>读：</p>
<p>read()</p>
<pre><code>文件对象.read(num)
</code></pre><blockquote>
<p>num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。</p>
</blockquote>
<p>readlines()：可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。</p>
<pre><code>f = open(&apos;test.txt&apos;)
content = f.readlines()
# [&apos;hello world\n&apos;, &apos;abcdefg\n&apos;, &apos;aaa\n&apos;, &apos;bbb\n&apos;, &apos;ccc&apos;]
print(content)
# 关闭文件
f.close()
</code></pre><p>readline()一次读取一行内容。</p>
<pre><code>f = open(&apos;test.txt&apos;)
content = f.readline()
print(f&apos;第一行：{content}&apos;)
content = f.readline()
print(f&apos;第二行：{content}&apos;)
</code></pre><p>seek()：用来移动文件指针。</p>
<pre><code>文件对象.seek(偏移量, 起始位置)
#起始位置：0：文件开头；1：当前位置；2：文件结尾
</code></pre><hr>
<p>文件备份：用户输入当前目录下任意文件名，程序完成对该文件的备份功能(备份文件名为xx[备份]后缀，例如：test[备份].txt)。</p>
<pre><code>old_name = input(&apos;请输入您要备份的文件名：&apos;)

# 提取文件后缀点的下标
index = old_name.rfind(&apos;.&apos;)
# print(index)  # 后缀中.的下标
# print(old_name[:index])  # 源文件名（无后缀）
# 组织新文件名 旧文件名 + [备份] + 后缀
new_name = old_name[:index] + &apos;[备份]&apos; + old_name[index:]
# 打印新文件名（带后缀）
# print(new_name)

# 打开文件
old_f = open(old_name, &apos;rb&apos;)
new_f = open(new_name, &apos;wb&apos;)
# 将源文件数据写入备份文件
while True:
    con = old_f.read(1024)
    if len(con) == 0:
        break
    new_f.write(con)

# 关闭文件
old_f.close()
new_f.close()
</code></pre><hr>
<p>文件和文件夹的操作:在Python中文件和文件夹的操作要借助os模块里面的相关功能，具体步骤如下：</p>
<pre><code>#导入os模块
import os

#使用os模块相关功能
os.函数名()
</code></pre><p>文件重命名</p>
<pre><code>os.rename(目标文件名, 新文件名)
</code></pre><p>删除文件</p>
<pre><code>os.remove(目标文件名)
</code></pre><p>创建文件夹</p>
<pre><code>os.mkdir(文件夹名字)
</code></pre><p>删除文件夹</p>
<pre><code>os.rmdir(文件夹名字)
</code></pre><p>获取当前目录</p>
<pre><code>os.getcwd()
</code></pre><p>改变默认目录</p>
<pre><code>os.chdir(目录)
</code></pre><p>获取目录列表</p>
<pre><code>os.listdir(目录)
</code></pre><hr>
<p>批量修改文件名，既可添加指定字符串，又能删除指定字符串。</p>
<pre><code>import os

# 设置重命名标识：如果为1则添加指定字符，flag取值为2则删除指定字符
flag = 1
# 获取指定目录
dir_name = &apos;./&apos;

# 获取指定目录的文件列表
file_list = os.listdir(dir_name)
# print(file_list)

# 遍历文件列表内的文件
for name in file_list:
    # 添加指定字符
    if flag == 1:
        new_name = &apos;Python-&apos; + name
    # 删除指定字符
    elif flag == 2:
        num = len(&apos;Python-&apos;)
        new_name = name[num:]

    # 打印新文件名，测试程序正确性
    print(new_name)

    # 重命名
    os.rename(dir_name+name, dir_name+new_name)
</code></pre><hr>
<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><hr>
<p>面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。</p>
<p>类和对象的关系：用类去创建一个对象。</p>
<hr>
<p>定义类:Python2中类分为：经典类 和 新式类。</p>
<pre><code>class 类名():
    代码
    ......

class Washer():
    def wash(self):
        print(&apos;我会洗衣服&apos;)
</code></pre><blockquote>
<p>注意：类名要满足标识符命名规则，同时遵循大驼峰命名习惯。</p>
</blockquote>
<p>经典类：不由任意内置类型派生出的类，称之为经典类</p>
<pre><code>class 类名:
    代码
    ......
</code></pre><hr>
<p>创建对象：对象又名实例。</p>
<pre><code>对象名 = 类名()

# 创建对象
haier1 = Washer()

# &lt;__main__.Washer object at 0x0000018B7B224240&gt;
print(haier1)

# haier对象调用实例方法
haier1.wash()
</code></pre><blockquote>
<p>注意：创建对象的过程也叫实例化对象。</p>
</blockquote>
<hr>
<p>self指的是调用该函数的对象。</p>
<pre><code># 1. 定义类
class Washer():
    def wash(self):
        print(&apos;我会洗衣服&apos;)
        # &lt;__main__.Washer object at 0x0000024BA2B34240&gt;
        print(self)

# 2. 创建对象
haier1 = Washer()
# &lt;__main__.Washer object at 0x0000018B7B224240&gt;
print(haier1)
# haier1对象调用实例方法
haier1.wash()

haier2 = Washer()
# &lt;__main__.Washer object at 0x0000022005857EF0&gt;
print(haier2)
</code></pre><blockquote>
<p>注意：打印对象和self得到的结果是一致的，都是当前对象的内存中存储地址。</p>
</blockquote>
<hr>
<p>类外面添加对象属性</p>
<pre><code>对象名.属性名 = 值

haier1.width = 500
haier1.height = 800
</code></pre><p>类外面获取对象属性</p>
<pre><code>对象名.属性名

print(f&apos;haier1洗衣机的宽度是{haier1.width}&apos;)
print(f&apos;haier1洗衣机的高度是{haier1.height}&apos;)
</code></pre><p>类里面获取对象属性</p>
<pre><code>self.属性名

# 定义类
class Washer():
    def print_info(self):
        # 类里面获取实例属性
        print(f&apos;haier1洗衣机的宽度是{self.width}&apos;)
        print(f&apos;haier1洗衣机的高度是{self.height}&apos;)

# 创建对象
haier1 = Washer()

# 添加实例属性
haier1.width = 500
haier1.height = 800
haier1.print_info()
</code></pre><hr>
<h3 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h3><hr>
<p>在Python中，<code>__xx__()</code>的函数叫做魔法方法，指的是具有特殊功能的函数。</p>
<hr>
<p><code>__init__()</code>方法的作用：初始化对象。</p>
<pre><code>class Washer():

    # 定义初始化功能的函数
    def __init__(self):
        # 添加实例属性
        self.width = 500
        self.height = 800

    def print_info(self):
        # 类里面调用实例属性
        print(f&apos;洗衣机的宽度是{self.width}, 高度是{self.height}&apos;)

haier1 = Washer()
haier1.print_info()
</code></pre><blockquote>
<p>注意：<code>__init__()</code>方法，在创建一个对象时默认被调用，不需要手动调用。<code>__init__(self)</code>中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。</p>
</blockquote>
<hr>
<p>带参数的<code>__init__()</code>：</p>
<pre><code>class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def print_info(self):
        print(f&apos;洗衣机的宽度是{self.width}&apos;)
        print(f&apos;洗衣机的高度是{self.height}&apos;)

haier1 = Washer(10, 20)
haier1.print_info()

haier2 = Washer(30, 40)
haier2.print_info()
</code></pre><hr>
<p> <code>__str__()</code>：当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了<code>__str__</code>方法，那么就会打印从在这个方法中return的数据。</p>
<pre><code>class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def __str__(self):
        return &apos;这是海尔洗衣机的说明书&apos;


haier1 = Washer(10, 20)
# 这是海尔洗衣机的说明书
print(haier1)
</code></pre><hr>
<p><code>__del__()</code>：当删除对象时，python解释器也会默认调用<code>__del__()</code>方法。</p>
<pre><code>class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def __del__(self):
        print(f&apos;{self}对象已经被删除&apos;)

haier1 = Washer(10, 20)
# &lt;__main__.Washer object at 0x0000026118223278&gt;对象已经被删除
del haier1
</code></pre><hr>
<h2 id="面向对象之继承"><a href="#面向对象之继承" class="headerlink" title="面向对象之继承"></a>面向对象之继承</h2><hr>
<p>经典类或旧式类：不由任意内置类型派生出的类，称之为经典类。</p>
<pre><code>class 类名:
    代码
    ......
</code></pre><p>新式类</p>
<pre><code>class 类名(object):
  代码
</code></pre><p>Python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，具体如下：</p>
<pre><code># 父类A
class A(object):
    def __init__(self):
        self.num = 1

    def info_print(self):
        print(self.num)

# 子类B
class B(A):
    pass

result = B()
result.info_print()  # 1
</code></pre><blockquote>
<p>在Python中，所有类默认继承object类，object类是顶级类或基类；其他子类叫做派生类。</p>
</blockquote>
<hr>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><hr>
<pre><code># 1. 师父类
class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

# 2. 徒弟类
class Prentice(Master):
    pass

# 3. 创建对象daqiu
daqiu = Prentice()
# 4. 对象访问实例属性
print(daqiu.kongfu)
# 5. 对象调用实例方法
daqiu.make_cake()
</code></pre><hr>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><hr>
<p>所谓多继承意思就是一个类同时继承了多个父类。</p>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

# 创建学校类
class School(object):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class Prentice(School, Master):
    pass

daqiu = Prentice()
print(daqiu.kongfu)
daqiu.make_cake()
</code></pre><blockquote>
<p>注意：当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。</p>
</blockquote>
<hr>
<h3 id="子类重写父类同名方法和属性"><a href="#子类重写父类同名方法和属性" class="headerlink" title="子类重写父类同名方法和属性"></a>子类重写父类同名方法和属性</h3><hr>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class School(object):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

# 独创配方
class Prentice(School, Master):
    def __init__(self):
        self.kongfu = &apos;[独创煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

daqiu = Prentice()
print(daqiu.kongfu)
daqiu.make_cake()
print(Prentice.__mro__)
</code></pre><blockquote>
<p>子类和父类具有同名属性和方法，默认使用子类的同名属性和方法。</p>
</blockquote>
<hr>
<h3 id="子类调用父类的同名方法和属性"><a href="#子类调用父类的同名方法和属性" class="headerlink" title="子类调用父类的同名方法和属性"></a>子类调用父类的同名方法和属性</h3><hr>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class School(object):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class Prentice(School, Master):
    def __init__(self):
        self.kongfu = &apos;[独创煎饼果子配方]&apos;

    def make_cake(self):
        # 如果是先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化
        self.__init__()
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

    # 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化
    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

daqiu = Prentice()
daqiu.make_cake()
daqiu.make_master_cake()
daqiu.make_school_cake()
daqiu.make_cake()
</code></pre><hr>
<h3 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h3><hr>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class School(object):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class Prentice(School, Master):
    def __init__(self):
        self.kongfu = &apos;[独创煎饼果子配方]&apos;

    def make_cake(self):
        self.__init__()
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

# 徒孙类
class Tusun(Prentice):
    pass

xiaoqiu = Tusun()
xiaoqiu.make_cake()
xiaoqiu.make_school_cake()
xiaoqiu.make_master_cake()
</code></pre><hr>
<h3 id="super-调用父类方法"><a href="#super-调用父类方法" class="headerlink" title="super()调用父类方法"></a>super()调用父类方法</h3><hr>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class School(Master):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

        # 方法2.1
        # super(School, self).__init__()
        # super(School, self).make_cake()

        # 方法2.2
        super().__init__()
        super().make_cake()

class Prentice(School):
    def __init__(self):
        self.kongfu = &apos;[独创煎饼果子技术]&apos;

    def make_cake(self):
        self.__init__()
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

    # 子类调用父类的同名方法和属性：把父类的同名属性和方法再次封装
    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

    # 一次性调用父类的同名属性和方法
    def make_old_cake(self):
        # 方法一：代码冗余；父类类名如果变化，这里代码需要频繁修改
        # Master.__init__(self)
        # Master.make_cake(self)
        # School.__init__(self)
        # School.make_cake(self)

        # 方法二: super()
        # 方法2.1 super(当前类名, self).函数()
        # super(Prentice, self).__init__()
        # super(Prentice, self).make_cake()

        # 方法2.2 super().函数()
        super().__init__()
        super().make_cake()

daqiu = Prentice()
daqiu.make_old_cake()
</code></pre><blockquote>
<p>注意：使用super() 可以自动查找父类。调用顺序遵循 <code>__mro__</code> 类属性的顺序。比较适合单继承使用。</p>
</blockquote>
<hr>
<h3 id="私有权限"><a href="#私有权限" class="headerlink" title="私有权限"></a>私有权限</h3><hr>
<p>定义私有属性和方法</p>
<p>在Python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类。</p>
<p>设置私有权限的方法：在属性名和方法名前面加上两个下划线__。</p>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class School(object):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class Prentice(School, Master):
    def __init__(self):
        self.kongfu = &apos;[独创煎饼果子配方]&apos;
        # 定义私有属性
        self.__money = 2000000

    # 定义私有方法
    def __info_print(self):
        print(self.kongfu)
        print(self.__money)

    def make_cake(self):
        self.__init__()
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

# 徒孙类
class Tusun(Prentice):
    pass

daqiu = Prentice()
# 对象不能访问私有属性和私有方法
# print(daqiu.__money)
# daqiu.__info_print()

xiaoqiu = Tusun()
# 子类无法继承父类的私有属性和私有方法
# print(xiaoqiu.__money)  # 无法访问实例属性__money
# xiaoqiu.__info_print()
</code></pre><blockquote>
<p>注意：私有属性和私有方法只能在类里面访问和修改。</p>
</blockquote>
<hr>
<p>获取和修改私有属性值</p>
<p>在Python中，一般定义函数名<code>get_xx</code>用来获取私有属性，定义<code>set_xx</code>用来修改私有属性值。</p>
<pre><code>class Master(object):
    def __init__(self):
        self.kongfu = &apos;[古法煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class School(object):
    def __init__(self):
        self.kongfu = &apos;[school煎饼果子配方]&apos;

    def make_cake(self):
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

class Prentice(School, Master):
    def __init__(self):
        self.kongfu = &apos;[独创煎饼果子配方]&apos;
        self.__money = 2000000

    # 获取私有属性
    def get_money(self):
        return self.__money

    # 修改私有属性
    def set_money(self):
        self.__money = 500

    def __info_print(self):
        print(self.kongfu)
        print(self.__money)

    def make_cake(self):
        self.__init__()
        print(f&apos;运用{self.kongfu}制作煎饼果子&apos;)

    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

# 徒孙类
class Tusun(Prentice):
    pass

daqiu = Prentice()
xiaoqiu = Tusun()
# 调用get_money函数获取私有属性money的值
print(xiaoqiu.get_money())
# 调用set_money函数修改私有属性money的值
xiaoqiu.set_money()
print(xiaoqiu.get_money())
</code></pre><hr>
<h2 id="面向对象之其他"><a href="#面向对象之其他" class="headerlink" title="面向对象之其他"></a>面向对象之其他</h2><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><hr>
<p>封装：将属性和方法书写到类的里面的操作即为封装，封装可以为属性和方法添加私有权限。</p>
<p>继承：子类默认继承父类的所有属性和方法，子类可以重写父类属性和方法。</p>
<p>多态：传入不同的对象，产生不同的结果</p>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><hr>
<p>多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）。</p>
<p>多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果</p>
<pre><code>class Dog(object):
    def work(self):  # 父类提供统一的方法，哪怕是空方法
        print(&apos;指哪打哪...&apos;)

class ArmyDog(Dog):  # 继承Dog类
    def work(self):  # 子类重写父类同名方法
        print(&apos;追击敌人...&apos;)

class DrugDog(Dog):
    def work(self):
        print(&apos;追查毒品...&apos;)

class Person(object):
    def work_with_dog(self, dog):  # 传入不同的对象，执行不同的代码，即不同的work函数
        dog.work()

ad = ArmyDog()
dd = DrugDog()
daqiu = Person()
daqiu.work_with_dog(ad)
daqiu.work_with_dog(dd)
</code></pre><hr>
<h3 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h3><hr>
<p>类属性就是类对象所拥有的属性，它被该类的所有实例对象所共有。类属性可以使用类对象或实例对象访问。</p>
<pre><code>class Dog(object):
    tooth = 10

wangcai = Dog()
xiaohei = Dog()
print(Dog.tooth)  # 10
print(wangcai.tooth)  # 10
print(xiaohei.tooth)  # 10
</code></pre><hr>
<h3 id="修改类属性"><a href="#修改类属性" class="headerlink" title="修改类属性"></a>修改类属性</h3><hr>
<p>类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了一个实例属性。</p>
<pre><code>class Dog(object):
    tooth = 10

wangcai = Dog()
xiaohei = Dog()

# 修改类属性
Dog.tooth = 12
print(Dog.tooth)  # 12
print(wangcai.tooth)  # 12
print(xiaohei.tooth)  # 12

# 不能通过对象修改属性，如果这样操作，实则是创建了一个实例属性
wangcai.tooth = 20
print(Dog.tooth)  # 12
print(wangcai.tooth)  # 20
print(xiaohei.tooth)  # 12
</code></pre><hr>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><hr>
<pre><code>class Dog(object):
    def __init__(self):
        self.age = 5

    def info_print(self):
        print(self.age)

wangcai = Dog()
print(wangcai.age)  # 5
# print(Dog.age)  # 报错：实例属性不能通过类访问
wangcai.info_print()  # 5
</code></pre><hr>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><hr>
<p>类方法特点:需要用装饰器<code>@classmethod</code>来标识其为类方法，对于类方法，<strong>第一个参数必须是类对象</strong>，一般以<code>cls</code>作为第一个参数。</p>
<p>当方法中需要使用类对象(如访问私有类属性等)时，定义类方法。类方法一般和类属性配合使用。</p>
<pre><code>class Dog(object):
    __tooth = 10

    @classmethod
    def get_tooth(cls):
        return cls.__tooth

wangcai = Dog()
result = wangcai.get_tooth()
print(result)  # 10
</code></pre><hr>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><hr>
<p>静态方法特点：需要通过装饰器<code>@staticmethod</code>来进行修饰，<strong>静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）</strong>。静态方法也能够通过 <strong>实例对象</strong> 和 <strong>类对象</strong> 去访问。</p>
<p>当方法中 <strong>既不需要使用实例对象</strong>(如实例对象，实例属性)，<strong>也不需要使用类对象</strong> (如类属性、类方法、创建实例等)时，定义静态方法。取消不需要的参数传递，有利于减少不必要的内存占用和性能消耗。</p>
<pre><code>class Dog(object):
    @staticmethod
    def info_print():
        print(&apos;这是一个狗类，用于创建狗实例....&apos;)

wangcai = Dog()
# 静态方法既可以使用对象访问又可以使用类访问
wangcai.info_print()
Dog.info_print()
</code></pre><hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><hr>
<p>当检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常”。</p>
<p>例如：以<code>r</code>方式打开一个不存在的文件。</p>
<pre><code>open(&apos;test.txt&apos;, &apos;r&apos;)
</code></pre><p>异常的写法</p>
<pre><code>try:
    可能发生错误的代码
except:
    如果出现异常执行的代码
</code></pre><p>需求：尝试以<code>r</code>模式打开文件，如果文件不存在，则以<code>w</code>方式打开。</p>
<pre><code>try:
    f = open(&apos;test.txt&apos;, &apos;r&apos;)
except:
    f = open(&apos;test.txt&apos;, &apos;w&apos;)
</code></pre><hr>
<p>捕获指定异常</p>
<pre><code>try:
    可能发生错误的代码
except 异常类型:
    如果捕获到该异常类型执行的代码
</code></pre><hr>
<p>捕获多个指定异常：当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。</p>
<pre><code>try:
    print(1/0)
except (NameError, ZeroDivisionError):
    print(&apos;有错误&apos;)
</code></pre><hr>
<p>捕获异常描述信息</p>
<pre><code>try:
    print(num)
except (NameError, ZeroDivisionError) as result:
    print(result)
</code></pre><hr>
<p>捕获所有异常：Exception是所有程序异常类的父类。</p>
<pre><code>try:
    print(num)
except Exception as result:
    print(result)
</code></pre><hr>
<p>异常的else：else表示的是如果没有异常要执行的代码。</p>
<pre><code>try:
    print(1)
except Exception as result:
    print(result)
else:
    print(&apos;我是else，是没有异常的时候执行的代码&apos;)
</code></pre><hr>
<p>异常的finally:finally表示的是无论是否异常都要执行的代码，例如关闭文件。</p>
<pre><code>try:
    f = open(&apos;test.txt&apos;, &apos;r&apos;)
except Exception as result:
    f = open(&apos;test.txt&apos;, &apos;w&apos;)
else:
    print(&apos;没有异常，真开心&apos;)
finally:
    f.close()
</code></pre><hr>
<p>自定义异常:在Python中，抛出自定义异常的语法为<code>raise 异常类对象</code>。</p>
<p>需求：密码长度不足，则报异常（用户输入密码，如果输入的长度不足3位，则报错，即抛出自定义异常，并捕获该异常）。</p>
<pre><code># 自定义异常类，继承Exception
class ShortInputError(Exception):
    def __init__(self, length, min_len):
        self.length = length
        self.min_len = min_len

    # 设置抛出异常的描述信息
    def __str__(self):
        return f&apos;你输入的长度是{self.length}, 不能少于{self.min_len}个字符&apos;

def main():
    try:
        con = input(&apos;请输入密码：&apos;)
        if len(con) &lt; 3:
            raise ShortInputError(len(con), 3)
    except Exception as result:
        print(result)
    else:
        print(&apos;密码已经输入完成&apos;)
main()
</code></pre><hr>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><hr>
<p>Python模块(Module)，是一个Python文件，以 <code>.py</code> 结尾，包含了 Python 对象定义和Python语句。</p>
<p>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p>
<p>导入模块的方式</p>
<ul>
<li>import 模块名</li>
<li>from 模块名 import 功能名</li>
<li>from 模块名 import *</li>
<li>import 模块名 as 别名</li>
<li>from 模块名 import 功能名 as 别名</li>
</ul>
<hr>
<p>import</p>
<pre><code># 1. 导入模块
import 模块名
import 模块名1, 模块名2...
# 2. 调用功能
模块名.功能名()

//体验
import math
print(math.sqrt(9))  # 3.0
</code></pre><hr>
<p>from..import..</p>
<pre><code>from 模块名 import 功能1, 功能2, 功能3...

//体验
from math import sqrt
print(sqrt(9))
</code></pre><hr>
<p>from .. import *</p>
<pre><code>from 模块名 import *

//体验
from math import *
print(sqrt(9))
</code></pre><hr>
<p>as定义别名</p>
<pre><code># 模块定义别名
import 模块名 as 别名
# 功能定义别名
from 模块名 import 功能 as 别名

//体验
# 模块别名
import time as tt
tt.sleep(2)
print(&apos;hello&apos;)

# 功能别名
from time import sleep as sl
sl(2)
print(&apos;hello&apos;)
</code></pre><hr>
<h3 id="制作模块"><a href="#制作模块" class="headerlink" title="制作模块"></a>制作模块</h3><hr>
<p>制作模块:在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。<strong>也就是说自定义模块名必须要符合标识符命名规则。</strong></p>
<p>新建一个Python文件，命名为<code>my_module1.py</code>，并定义<code>testA</code>函数。</p>
<pre><code>def testA(a, b):
    print(a + b)
</code></pre><p>在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息。例如，在<code>my_module1.py</code>文件中添加测试代码。</p>
<pre><code>def testA(a, b):
    print(a + b)
testA(1, 1)
</code></pre><p>此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>testA</code>函数的调用。</p>
<p>解决办法如下：</p>
<pre><code>def testA(a, b):
    print(a + b)

# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行testA函数调用
if __name__ == &apos;__main__&apos;:
    testA(1, 1)
</code></pre><p>调用模块</p>
<pre><code>import my_module1
my_module1.testA(1, 1)
</code></pre><hr>
<h3 id="模块定位顺序"><a href="#模块定位顺序" class="headerlink" title="模块定位顺序"></a>模块定位顺序</h3><hr>
<p>如果使用<code>from .. import ..</code>或<code>from .. import *</code>导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是后面导入的模块的功能。</p>
<pre><code># 模块1代码
def my_test(a, b):
    print(a + b)

# 模块2代码
def my_test(a, b):
    print(a - b)

# 导入模块和调用功能代码
from my_module1 import my_test
from my_module2 import my_test

# my_test函数是模块2中的函数
my_test(1, 1)
</code></pre><p>当导入一个模块，Python解析器对模块位置的搜索顺序是：</p>
<ol>
<li>当前目录</li>
<li>如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>
<li>如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/</li>
</ol>
<p>模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p>
<ul>
<li>注意<ul>
<li>自己的文件名不要和已有模块名重复，否则导致模块功能无法使用</li>
<li><code>使用from 模块名 import 功能</code>的时候，如果功能名字重复，调用到的是最后定义或导入的功能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="all"><a href="#all" class="headerlink" title="__all__"></a><code>__all__</code></h3><hr>
<p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素。</p>
<pre><code># my_module1模块代码
__all__ = [&apos;testA&apos;]
def testA():
    print(&apos;testA&apos;)

def testB():
    print(&apos;testB&apos;)

# 导入模块的文件代码
from my_module1 import *
testA()
testB()# 报错
</code></pre><hr>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><hr>
<p>包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为<code>__init__.py</code> 文件，那么这个文件夹就称之为包。</p>
<p>制作包：[New] — [Python Package] — 输入包名 — [OK] — 新建功能模块(有联系的模块)。</p>
<p>注意：新建包后，包内部会自动创建<code>__init__.py</code>文件，这个文件控制着包的导入行为。</p>
<p>新建包<code>mypackage</code>，新建包内模块：<code>my_module1</code> 和 <code>my_module2</code>，模块内代码如下</p>
<pre><code># my_module1
print(1)
def info_print1():
    print(&apos;my_module1&apos;)

# my_module2
print(2)
def info_print2():
    print(&apos;my_module2&apos;)
</code></pre><p>导入包</p>
<pre><code># 方法一
import 包名.模块名
包名.模块名.目标

# 体验
import my_package.my_module1
my_package.my_module1.info_print1()


#方法二：必须在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块列表。
from 包名 import *
模块名.目标

# 体验
from my_package import *
my_module1.info_print1()
</code></pre><hr>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="../../../../img/reward-alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="../../../../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2020/08/29/40.从oc到swift/" class="next-post btn btn-default" title='从oc到swift'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">从oc到swift</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入"><span class="toc-text">输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转换数据类型"><span class="toc-text">转换数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if语句"><span class="toc-text">if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本使用"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#猜拳游戏"><span class="toc-text">猜拳游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三元运算符"><span class="toc-text">三元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-text">while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环"><span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while…else"><span class="toc-text">while…else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for…else"><span class="toc-text">for…else</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三引号字符串"><span class="toc-text">三引号字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片"><span class="toc-text">切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index"><span class="toc-text">index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count"><span class="toc-text">count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replace"><span class="toc-text">replace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split"><span class="toc-text">split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#capitalize"><span class="toc-text">capitalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#title"><span class="toc-text">title</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lower和upper"><span class="toc-text">lower和upper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lstrip和rstrip和strip"><span class="toc-text">lstrip和rstrip和strip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ljust和rjust和center"><span class="toc-text">ljust和rjust和center</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#startswith和endswith"><span class="toc-text">startswith和endswith</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isalpha"><span class="toc-text">isalpha</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isdigit"><span class="toc-text">isdigit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isalnum"><span class="toc-text">isalnum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isspace"><span class="toc-text">isspace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表"><span class="toc-text">列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#下标"><span class="toc-text">下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-1"><span class="toc-text">index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-1"><span class="toc-text">count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#len"><span class="toc-text">len</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in和not-in"><span class="toc-text">in和not in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append"><span class="toc-text">append</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extend"><span class="toc-text">extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert"><span class="toc-text">insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#del"><span class="toc-text">del</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop"><span class="toc-text">pop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-text">remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear"><span class="toc-text">clear</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改指定下标数据"><span class="toc-text">修改指定下标数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆置reverse"><span class="toc-text">逆置reverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序sort"><span class="toc-text">排序sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制copy"><span class="toc-text">复制copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while遍历列表"><span class="toc-text">while遍历列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for遍历列表"><span class="toc-text">for遍历列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元组"><span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典"><span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#增和改"><span class="toc-text">增和改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删"><span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key值查找"><span class="toc-text">key值查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-text">get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keys"><span class="toc-text">keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#values"><span class="toc-text">values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#items"><span class="toc-text">items</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历字典的key"><span class="toc-text">遍历字典的key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历字典的value"><span class="toc-text">遍历字典的value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历字典的元素"><span class="toc-text">遍历字典的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历字典的键值对"><span class="toc-text">遍历字典的键值对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#增加数据"><span class="toc-text">增加数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除数据"><span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找数据"><span class="toc-text">查找数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#公共操作"><span class="toc-text">公共操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符-1"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公共方法"><span class="toc-text">公共方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器类型转换"><span class="toc-text">容器类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推导式"><span class="toc-text">推导式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列表推导式"><span class="toc-text">列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典推导式"><span class="toc-text">字典推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合推导式"><span class="toc-text">集合推导式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数基础"><span class="toc-text">函数基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数提高"><span class="toc-text">函数提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量作用域"><span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的返回值"><span class="toc-text">函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数"><span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拆包和交换变量值"><span class="toc-text">拆包和交换变量值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变和不可变类型"><span class="toc-text">可变和不可变类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda表达式"><span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高阶函数"><span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件操作"><span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象基础"><span class="toc-text">面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#魔法方法"><span class="toc-text">魔法方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象之继承"><span class="toc-text">面向对象之继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单继承"><span class="toc-text">单继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多继承"><span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类重写父类同名方法和属性"><span class="toc-text">子类重写父类同名方法和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类调用父类的同名方法和属性"><span class="toc-text">子类调用父类的同名方法和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多层继承"><span class="toc-text">多层继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-调用父类方法"><span class="toc-text">super()调用父类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有权限"><span class="toc-text">私有权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象之其他"><span class="toc-text">面向对象之其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象三大特性"><span class="toc-text">面向对象三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类属性和实例属性"><span class="toc-text">类属性和实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改类属性"><span class="toc-text">修改类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类方法"><span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块"><span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#制作模块"><span class="toc-text">制作模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块定位顺序"><span class="toc-text">模块定位顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#all"><span class="toc-text">__all__</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包"><span class="toc-text">包</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>