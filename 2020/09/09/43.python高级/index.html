<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>python高级 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 士不可以不弘毅，任重而道远 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Android/"><i class="fa "></i>Android</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Web/"><i class="fa "></i>Web</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Java/"><i class="fa "></i>Java</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C/"><i class="fa "></i>C</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/iOS/"><i class="fa "></i>iOS</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/python/"><i class="fa "></i>python</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="python高级">
            
	            python高级
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/python" title='python'>
                        python
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/09/09</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h2><hr>
<p>多任务是指在同一时间内执行多个任务，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。</p>
<p>多任务的执行方式：并发和并行。</p>
<p>并发:在一段时间内交替去执行任务。</p>
<p>并行:对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。</p>
<p>一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。</p>
<hr>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><hr>
<p>进程使用：</p>
<pre><code>#导入进程包
import multiprocessing
#创建子进程并指定执行的任务
sub_process = multiprocessing.Process (target=任务名)
#启动进程执行任务
sub_process.start()
</code></pre><hr>
<p>Process进程类的说明：</p>
<pre><code>group：指定进程组，目前只能使用None
target：执行的目标任务名
name：进程名字
args：以元组方式给执行任务传参
kwargs：以字典方式给执行任务传参
</code></pre><p>Process创建的实例对象的常用方法:</p>
<pre><code>start()：启动子进程实例（创建子进程）
join()：等待子进程执行结束
terminate()：不管任务是否完成，立即终止子进程
</code></pre><p>Process创建的实例对象的常用属性:</p>
<pre><code>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数
</code></pre><hr>
<p>代码：</p>
<pre><code>import multiprocessing
import time

# 跳舞任务
def dance():
    for i in range(5):
        print(&quot;跳舞中...&quot;)
        time.sleep(0.2)
# 唱歌任务
def sing():
    for i in range(5):
        print(&quot;唱歌中...&quot;)
        time.sleep(0.2)

if __name__ == &apos;__main__&apos;:
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)
    sing_process = multiprocessing.Process(target=sing)
    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
</code></pre><hr>
<h3 id="进程编号"><a href="#进程编号" class="headerlink" title="进程编号"></a>进程编号</h3><hr>
<p>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。</p>
<p>获取进程编号的两种操作:获取当前进程编号和获取当前父进程编号。</p>
<hr>
<p>获取当前进程编号</p>
<pre><code>os.getpid() 
</code></pre><p>示例代码:</p>
<pre><code>import multiprocessing
import time
import os

# 跳舞任务
def dance():
    # 获取当前进程的编号
    print(&quot;dance:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;dance:&quot;, multiprocessing.current_process())
    for i in range(5):
        print(&quot;跳舞中...&quot;)
        time.sleep(0.2)
        # 扩展:根据进程编号杀死指定进程
        os.kill(os.getpid(), 9)

# 唱歌任务
def sing():
    # 获取当前进程的编号
    print(&quot;sing:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;sing:&quot;, multiprocessing.current_process())
    for i in range(5):
        print(&quot;唱歌中...&quot;)
        time.sleep(0.2)

if __name__ == &apos;__main__&apos;:
    # 获取当前进程的编号
    print(&quot;main:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;main:&quot;, multiprocessing.current_process())
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)
    sing_process = multiprocessing.Process(target=sing)
    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
</code></pre><p>运行结果：</p>
<pre><code>main: 10796
main: &lt;_MainProcess name=&apos;MainProcess&apos; parent=None started&gt;
dance: 2388
dance: &lt;Process name=&apos;myprocess1&apos; parent=10796 started&gt;
跳舞中...
sing: 2220
sing: &lt;Process name=&apos;Process-2&apos; parent=10796 started&gt;
唱歌中...
唱歌中...
唱歌中...
唱歌中...
唱歌中...
</code></pre><hr>
<p>获取当前父进程编号</p>
<pre><code>os.getppid()
</code></pre><p>示例代码:</p>
<pre><code>import multiprocessing
import time
import os

# 跳舞任务
def dance():
    # 获取当前进程的编号
    print(&quot;dance:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;dance:&quot;, multiprocessing.current_process())
    # 获取父进程的编号
    print(&quot;dance的父进程编号:&quot;, os.getppid())
    for i in range(5):
        print(&quot;跳舞中...&quot;)
        time.sleep(0.2)
        # 扩展:根据进程编号杀死指定进程
        os.kill(os.getpid(), 9)

# 唱歌任务
def sing():
    # 获取当前进程的编号
    print(&quot;sing:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;sing:&quot;, multiprocessing.current_process())
    # 获取父进程的编号
    print(&quot;sing的父进程编号:&quot;, os.getppid())
    for i in range(5):
        print(&quot;唱歌中...&quot;)
        time.sleep(0.2)

if __name__ == &apos;__main__&apos;:
    # 获取当前进程的编号
    print(&quot;main:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;main:&quot;, multiprocessing.current_process())
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)
    sing_process = multiprocessing.Process(target=sing)
    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
</code></pre><p>运行结果：</p>
<pre><code>main: 4832
main: &lt;_MainProcess name=&apos;MainProcess&apos; parent=None started&gt;
dance: 14372
dance: &lt;Process name=&apos;myprocess1&apos; parent=4832 started&gt;
sing: 8948
sing: &lt;Process name=&apos;Process-2&apos; parent=4832 started&gt;
dance的父进程编号: 4832
跳舞中...
sing的父进程编号: 4832
唱歌中...
唱歌中...
唱歌中...
唱歌中...
唱歌中...
</code></pre><hr>
<h3 id="进程执行带有参数的任务"><a href="#进程执行带有参数的任务" class="headerlink" title="进程执行带有参数的任务"></a>进程执行带有参数的任务</h3><hr>
<p>Process类执行任务并给任务传参数有两种方式:<code>args</code> 表示以元组的方式给执行任务传参;<code>kwargs</code> 表示以字典方式给执行任务传参。</p>
<hr>
<p>args参数的使用，示例代码:</p>
<pre><code>import multiprocessing
import time

# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)

if __name__ == &apos;__main__&apos;:
    # 创建子进程
    # args: 以元组的方式给任务传入参数
    sub_process = multiprocessing.Process(target=task, args=(5,))
    sub_process.start()
</code></pre><p><strong>元组方式传参一定要和参数的顺序保持一致。</strong></p>
<hr>
<p>kwargs参数的使用,示例代码:</p>
<pre><code>import multiprocessing
import time

# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)

if __name__ == &apos;__main__&apos;:
    # 创建子进程
    # kwargs: 表示以字典方式传入参数
    sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})
    sub_process.start()
</code></pre><p><strong>字典方式传参字典中的key一定要和参数名保持一致。</strong></p>
<hr>
<h3 id="进程的注意点"><a href="#进程的注意点" class="headerlink" title="进程的注意点"></a>进程的注意点</h3><hr>
<p><strong>进程之间不共享全局变量：子线程和主线程之间，以及子线程和子线程之间都不共享。</strong>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</p>
<p>主进程会等待所有的子进程执行结束再结束。</p>
<p>守护主进程就是主进程退出子进程销毁不再执行。</p>
<pre><code>子进程对象.daemon = True
</code></pre><p>子进程销毁:子进程执行结束。</p>
<pre><code># 让子进程销毁
子进程对象.terminate()
</code></pre><p>保证主进程正常退出的示例代码:</p>
<pre><code>import multiprocessing
import time

# 定义进程所需要执行的任务
def task():
    for i in range(10):
        print(&quot;任务执行中...&quot;)
        time.sleep(0.2)

if __name__ == &apos;__main__&apos;:
    # 创建子进程
    sub_process = multiprocessing.Process(target=task)
    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程
    # sub_process.daemon = True
    sub_process.start()
    time.sleep(0.5)
    print(&quot;over&quot;)
    # 让子进程销毁
    sub_process.terminate()
    exit()
    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出
    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁
</code></pre><hr>
<h3 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h3><hr>
<p>线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p>
<p>多线程的使用</p>
<pre><code>#导入线程模块
import threading
#创建子线程并指定执行的任务
sub_thread = threading.Thread(target=任务名)
#启动线程执行任务
sub_thread.start()
</code></pre><p>线程类Thread参数说明</p>
<pre><code>group: 线程组，目前只能使用None
target: 执行的目标任务名
args: 以元组的方式给执行任务传参
kwargs: 以字典方式给执行任务传参
name: 线程名，一般不用设置
</code></pre><p>代码</p>
<pre><code>import threading
import time

# 唱歌任务
def sing():
    # 扩展：获取当前线程
    # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread())
    for i in range(3):
        print(&quot;正在唱歌...%d&quot; % i)
        time.sleep(1)

# 跳舞任务
def dance():
    # 扩展：获取当前线程
    # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread())
    for i in range(3):
        print(&quot;正在跳舞...%d&quot; % i)
        time.sleep(1)

if __name__ == &apos;__main__&apos;:
    # 扩展： 获取当前线程
    # print(&quot;当前执行的线程为：&quot;, threading.current_thread())
    # 创建唱歌的线程
    # target： 线程执行的函数名
    sing_thread = threading.Thread(target=sing)
    # 创建跳舞的线程
    dance_thread = threading.Thread(target=dance)
    # 开启线程
    sing_thread.start()
    dance_thread.start()
</code></pre><hr>
<h3 id="线程执行带有参数的任务"><a href="#线程执行带有参数的任务" class="headerlink" title="线程执行带有参数的任务"></a>线程执行带有参数的任务</h3><hr>
<p>Thread类执行任务并给任务传参数有两种方式:args表示以元组的方式给执行任务传参;kwargs表示以字典方式给执行任务传参。</p>
<p>元组方式传参(args)，元组方式传参一定要和参数的顺序保持一致：</p>
<pre><code>import threading
import time

# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)

if __name__ == &apos;__main__&apos;:
    # 创建子线程
    # args: 以元组的方式给任务传入参数
    sub_thread = threading.Thread(target=task, args=(5,))
    sub_thread.start()
</code></pre><p>字典方式传参(kwargs),字典方式传参字典中的key一定要和参数名保持一致:</p>
<pre><code>import threading
import time

# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)

if __name__ == &apos;__main__&apos;:
    # 创建子线程
    # kwargs: 表示以字典方式传入参数
    sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3})
    sub_thread.start()
</code></pre><hr>
<h3 id="线程的注意点"><a href="#线程的注意点" class="headerlink" title="线程的注意点"></a>线程的注意点</h3><hr>
<p>线程之间执行是无序的，它是由cpu调度决定的，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。</p>
<p>进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。</p>
<p>主线程会等待所有的子线程执行结束再结束。</p>
<p>守护主线程:主线程退出子线程销毁不再执行。</p>
<pre><code>#设置守护主线程有两种方式：
threading.Thread(target=show_info, daemon=True)
线程对象.setDaemon(True)
</code></pre><p>线程之间共享全局变量，多线程同时对全局变量操作数据会发生错误。</p>
<p>全局变量数据错误的解决办法:线程同步: 保证同一时刻只能有一个线程去操作全局变量。</p>
<p>线程同步的方式:线程等待(join)；互斥锁。</p>
<p>线程等待的示例代码:</p>
<pre><code># 启动线程
first_thread.start()
# 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程
# 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行
first_thread.join()
# 启动线程
second_thread.start()
</code></pre><hr>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><hr>
<p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</p>
<p>互斥锁使用步骤:</p>
<pre><code># 创建锁
mutex = threading.Lock()
# 上锁
mutex.acquire()
...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...
# 释放锁
mutex.release()
</code></pre><p>acquire和release方法之间的代码同一时刻只能有一个线程去操作。如果在调用acquire方法的时候，其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。</p>
<p>示例代码：</p>
<pre><code>import threading

# 定义全局变量
g_num = 0
# 创建全局互斥锁
lock = threading.Lock()

# 循环一次给全局变量加1
def sum_num1():
    # 上锁
    lock.acquire()
    for i in range(1000000):
        global g_num
        g_num += 1
    print(&quot;sum1:&quot;, g_num)
    # 释放锁
    lock.release()

# 循环一次给全局变量加1
def sum_num2():
    # 上锁
    lock.acquire()
    for i in range(1000000):
        global g_num
        g_num += 1
    print(&quot;sum2:&quot;, g_num)
    # 释放锁
    lock.release()

if __name__ == &apos;__main__&apos;:
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)
    # 启动线程
    first_thread.start()
    second_thread.start()
    # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待
    # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行
</code></pre><p>互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题。使用互斥锁会影响代码的执行效率，多任务改成了单任务执行。互斥锁如果没有使用好容易出现死锁的情况。</p>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><hr>
<p>死锁: 一直等待对方释放锁的情景就是死锁。死锁的结果会造成应用程序的停止响应，不能再处理其它任务了。</p>
<pre><code>import threading
import time

# 创建互斥锁
lock = threading.Lock()

# 根据下标去取值， 保证同一时刻只能有一个线程去取值
def get_value(index):
    # 上锁
    lock.acquire()
    print(threading.current_thread())
    my_list = [3,6,8,1]
    if index &gt;= len(my_list):
        print(&quot;下标越界:&quot;, index)
        # 当下标越界需要释放锁，让后面的线程还可以取值
        lock.release()
        return
    value = my_list[index]
    print(value)
    time.sleep(0.2)
    # 释放锁
    lock.release()

if __name__ == &apos;__main__&apos;:
    # 模拟大量线程去执行取值操作
    for i in range(30):
        sub_thread = threading.Thread(target=get_value, args=(i,))
        sub_thread.start()
</code></pre><hr>
<h3 id="进程和线程的对比"><a href="#进程和线程的对比" class="headerlink" title="进程和线程的对比"></a>进程和线程的对比</h3><hr>
<p>线程是依附在进程里面的，没有进程就没有线程。一个进程默认提供一条线程，进程可以创建多个线程。</p>
<p>多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。</p>
<p>多进程可以使用cpu的多核运行，多线程可以共享全局变量。</p>
<p>线程不能单独执行必须依附在进程里面。</p>
<p>进程之间不共享全局变量。</p>
<p>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步。</p>
<hr>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP客户端程序开发"><a href="#TCP客户端程序开发" class="headerlink" title="TCP客户端程序开发"></a>TCP客户端程序开发</h3><hr>
<p>TCP客户端程序开发步骤：创建客户端套接字对象、和服务端套接字建立连接、发送数据、接收数据、关闭客户端套接字。</p>
<p>socket类：</p>
<pre><code>#导入socket模块 
import socket

#创建客户端socket对象 
socket.socket(AddressFamily, Type)
</code></pre><p>参数说明:AddressFamily表示IP地址类型, 分为TPv4和IPv6。Type 表示传输协议类型。</p>
<p>方法说明:</p>
<pre><code>connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号
send(data) 表示发送数据，data是二进制数据
recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度
</code></pre><p>示例代码：</p>
<pre><code>import socket

if __name__ == &apos;__main__&apos;:
    # 创建tcp客户端套接字
    # 1. AF_INET：表示ipv4
    # 2. SOCK_STREAM: tcp传输协议
    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 和服务端应用程序建立连接
    tcp_client_socket.connect((&quot;192.168.52.1&quot;, 8080))
    # 代码执行到此，说明连接建立成功
    # 准备发送的数据
    send_data = &quot;你好服务端，我是客户端!&quot;.encode(&quot;gbk&quot;)
    # 发送数据
    tcp_client_socket.send(send_data)
    # 接收数据, 这次接收的数据最大字节数是1024
    recv_data = tcp_client_socket.recv(1024)
    # 返回的直接是服务端程序发送的二进制数据
    print(recv_data)
    # 对数据进行解码
    recv_content = recv_data.decode(&quot;gbk&quot;)
    print(&quot;接收服务端的数据为:&quot;, recv_content)
    # 关闭套接字
    tcp_client_socket.close()
    #str.encode(编码格式) 表示把字符串编码成为二进制
    #data.decode(编码格式) 表示把二进制解码成为字符串
</code></pre><hr>
<h3 id="TCP服务端程序开发"><a href="#TCP服务端程序开发" class="headerlink" title="TCP服务端程序开发"></a>TCP服务端程序开发</h3><hr>
<p>TCP服务端程序开发步骤回顾:创建服务端端套接字对象、绑定端口号、设置监听、等待接受客户端的连接请求、接收数据、发送数据、关闭套接字。</p>
<p>socket类：</p>
<pre><code>#导入 socket 模块
import socket
#创建服务端 socket 对象
socket.socket(AddressFamily, Type)
</code></pre><p>参数说明:AddressFamily表示IP地址类型, 分为TPv4和IPv6。Type表示传输协议类型。</p>
<p>方法说明:</p>
<pre><code>bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。
listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。
accept() 表示等待接受客户端的连接请求
send(data) 表示发送数据，data 是二进制数据
recv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度
</code></pre><p>示例代码：</p>
<pre><code>import socket

if __name__ == &apos;__main__&apos;:
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用，让程序退出端口号立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 给程序绑定端口号
    tcp_server_socket.bind((&quot;&quot;, 8989))
    # 设置监听
    # 128:最大等待建立连接的个数， 提示： 目前是单任务的服务端，同一时刻只能服务与一个客户端，后续使用多任务能够让服务端同时服务与多个客户端，
    # 不需要让客户端进行等待建立连接
    # listen后的这个套接字只负责接收客户端连接请求，不能收发消息，收发消息使用返回的这个新套接字来完成
    tcp_server_socket.listen(128)
    # 等待客户端建立连接的请求, 只有客户端和服务端建立连接成功代码才会解阻塞，代码才能继续往下执行
    # 1. 专门和客户端通信的套接字： service_client_socket
    # 2. 客户端的ip地址和端口号： ip_port
    service_client_socket, ip_port = tcp_server_socket.accept()
    # 代码执行到此说明连接建立成功
    print(&quot;客户端的ip地址和端口号:&quot;, ip_port)
    # 接收客户端发送的数据, 这次接收数据的最大字节数是1024
    recv_data = service_client_socket.recv(1024)
    # 获取数据的长度
    recv_data_length = len(recv_data)
    print(&quot;接收数据的长度为:&quot;, recv_data_length)
    # 对二进制数据进行解码
    recv_content = recv_data.decode(&quot;gbk&quot;)
    print(&quot;接收客户端的数据为:&quot;, recv_content)
    # 准备发送的数据
    send_data = &quot;ok, 问题正在处理中...&quot;.encode(&quot;gbk&quot;)
    # 发送数据给客户端
    service_client_socket.send(send_data)
    # 关闭服务与客户端的套接字， 终止和客户端通信的服务
    service_client_socket.close()
    # 关闭服务端的套接字, 终止和客户端提供建立连接请求的服务
    tcp_server_socket.close()
</code></pre><p>说明:当客户端和服务端建立连接后，服务端程序退出后端口号不会立即释放，需要等待大概1-2分钟。</p>
<p>解决办法有两种:更换服务端端口号;设置端口号复用(推荐使用)，也就是说让服务端程序退出后端口号立即释放。</p>
<p>设置端口号复用的代码如下:</p>
<pre><code># 参数1: 表示当前套接字
# 参数2: 设置端口号复用选项
# 参数3: 设置端口号复用选项对应的值
tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
</code></pre><hr>
<h3 id="TCP网络应用程序的注意点"><a href="#TCP网络应用程序的注意点" class="headerlink" title="TCP网络应用程序的注意点"></a>TCP网络应用程序的注意点</h3><hr>
<p>当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先建立连接。</p>
<p>TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。</p>
<p>TCP 服务端程序必须绑定端口号，否则客户端找不到这个 TCP 服务端程序。</p>
<p>listen 后的套接字是被动套接字，只负责接收新的客户端的连接请求，不能收发消息。</p>
<p>当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个新的套接字，收发客户端消息使用该套接字。</p>
<p>关闭 accept 返回的套接字意味着和这个客户端已经通信完毕。</p>
<p>关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。</p>
<p>当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0，服务端可以通过返回数据的长度来判断客户端是否已经下线，反之服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0。</p>
<hr>
<h3 id="多任务版TCP服务端程序开发"><a href="#多任务版TCP服务端程序开发" class="headerlink" title="多任务版TCP服务端程序开发"></a>多任务版TCP服务端程序开发</h3><hr>
<p>完成多任务，可以使用线程，比进程更加节省内存资源。</p>
<p>实现步骤：</p>
<ol>
<li>编写一个TCP服务端程序，循环等待接受客户端的连接请求。</li>
<li>当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。</li>
<li>把创建的子线程设置成为守护主线程，防止主线程无法退出。</li>
</ol>
<p>示例代码:</p>
<pre><code>import socket
import threading

# 处理客户端的请求操作
def handle_client_request(service_client_socket, ip_port):
    # 循环接收客户端发送的数据
    while True:
        # 接收客户端发送的数据
        recv_data = service_client_socket.recv(1024)
        # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败
        # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据
        if recv_data:
            print(recv_data.decode(&quot;gbk&quot;), ip_port)
            # 回复
            service_client_socket.send(&quot;ok，问题正在处理中...&quot;.encode(&quot;gbk&quot;))
        else:
            print(&quot;客户端下线了:&quot;, ip_port)
            break
    # 终止和客户端进行通信
    service_client_socket.close()

if __name__ == &apos;__main__&apos;:
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用，让程序退出端口号立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind((&quot;&quot;, 9090))
    # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求
    tcp_server_socket.listen(128)
    # 循环等待接收客户端的连接请求
    while True:
        # 等待接收客户端的连接请求
        service_client_socket, ip_port = tcp_server_socket.accept()
        print(&quot;客户端连接成功:&quot;, ip_port)
        # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息
        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))
        # 设置守护主线程
        sub_thread.setDaemon(True)
        # 启动子线程
        sub_thread.start()
    # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行
    # tcp_server_socket.close()
</code></pre><hr>
<h3 id="socket之send和recv原理剖析"><a href="#socket之send和recv原理剖析" class="headerlink" title="socket之send和recv原理剖析"></a>socket之send和recv原理剖析</h3><hr>
<p>当创建一个TCP socket对象的时候会有一个发送缓冲区和一个接收缓冲区，这个发送和接收缓冲区指的就是内存中的一片空间。</p>
<p>send原理剖析：send是不是直接把数据发给服务端?不是，要想发数据，必须得通过网卡发送数据，应用程序是无法直接通过网卡发送数据的，它需要调用操作系统接口，也就是说，应用程序把发送的数据先写入到发送缓冲区(内存中的一片空间)，再由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡。</p>
<p>recv原理剖析：recv是不是直接从客户端接收数据?不是，应用软件是无法直接通过网卡接收数据的，它需要调用操作系统接口，由操作系统通过网卡接收数据，把接收的数据写入到接收缓冲区(内存中的一片空间），应用程序再从接收缓存区获取客户端发送的数据。</p>
<p>不管是recv还是send都不是直接接收到对方的数据和发送数据到对方，发送数据会写入到发送缓冲区，接收数据是从接收缓冲区来读取，发送数据和接收数据最终是由操作系统控制网卡来完成。</p>
<hr>
<h2 id="静态Web服务器"><a href="#静态Web服务器" class="headerlink" title="静态Web服务器"></a>静态Web服务器</h2><h3 id="启动python自带静态Web服务"><a href="#启动python自带静态Web服务" class="headerlink" title="启动python自带静态Web服务"></a>启动python自带静态Web服务</h3><hr>
<p>静态Web服务器：可以为发出请求的浏览器提供静态文档的程序。</p>
<p>搭建Python自带的静态Web服务器</p>
<pre><code>python -m http.server 端口号
</code></pre><p>-m表示运行包里面的模块，执行这个命令的时候，需要进入你自己指定静态文件的目录，然后通过浏览器就能访问对应的html文件了，这样一个静态的web服务器就搭建好了。</p>
<hr>
<h3 id="开发自己的静态Web服务器"><a href="#开发自己的静态Web服务器" class="headerlink" title="开发自己的静态Web服务器"></a>开发自己的静态Web服务器</h3><hr>
<p>实现步骤:编写一个TCP服务端程序、获取浏览器发送的http请求报文数据、读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。</p>
<p>示例代码：</p>
<pre><code>import socket

if __name__ == &apos;__main__&apos;:
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用, 程序退出端口立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind((&quot;&quot;, 9000))
    # 设置监听
    tcp_server_socket.listen(128)
    while True:
        # 等待接受客户端的连接请求
        new_socket, ip_port = tcp_server_socket.accept()
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)
        print(recv_client_content)
        with open(&quot;static/index.html&quot;, &quot;rb&quot;) as file:
            # 读取文件数据
            file_data = file.read()
        # 响应行
        response_line = &quot;HTTP/1.1 200 OK\r\n&quot;
        # 响应头
        response_header = &quot;Server: PWS1.0\r\n&quot;
        # 响应体
        response_body = file_data
        # 拼接响应报文
        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
        # 发送数据
        new_socket.send(response_data)
        # 关闭服务与客户端的套接字
        new_socket.close()
</code></pre><hr>
<h3 id="开发自己的静态Web服务器返回指定页面数据"><a href="#开发自己的静态Web服务器返回指定页面数据" class="headerlink" title="开发自己的静态Web服务器返回指定页面数据"></a>开发自己的静态Web服务器返回指定页面数据</h3><hr>
<p>返回指定页面数据的实现步骤:获取用户请求资源的路径；根据请求资源的路径，读取指定文件的数据；组装指定文件数据的响应报文，发送给浏览器；判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器。</p>
<pre><code>import socket

def main():
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用, 程序退出端口立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind((&quot;&quot;, 9000))
    # 设置监听
    tcp_server_socket.listen(128)
    while True:
        # 等待接受客户端的连接请求
        new_socket, ip_port = tcp_server_socket.accept()
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print(&quot;关闭浏览器了&quot;)
            new_socket.close()
            return
        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)
        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)
        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == &quot;/&quot;:
            request_path = &quot;/index.html&quot;
        try:
            # 动态打开指定文件
            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:
                file_data = file.read()
            # 响应体
            response_body = file_data
            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            # 响应体
            response_body = file_data
            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><hr>
<h3 id="静态Web服务器-多任务版"><a href="#静态Web服务器-多任务版" class="headerlink" title="静态Web服务器-多任务版"></a>静态Web服务器-多任务版</h3><hr>
<p>多任务版web服务器程序的实现步骤:当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。把创建的子线程设置成为守护主线程，防止主线程无法退出。</p>
<pre><code>import socket
import threading

# 处理客户端的请求
def handle_client_request(new_socket):
    # 代码执行到此，说明连接建立成功
    recv_client_data = new_socket.recv(4096)
    if len(recv_client_data) == 0:
        print(&quot;关闭浏览器了&quot;)
        new_socket.close()
        return
    # 对二进制数据进行解码
    recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)
    print(recv_client_content)
    # 根据指定字符串进行分割， 最大分割次数指定2
    request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)
    # 获取请求资源路径
    request_path = request_list[1]
    print(request_path)
    # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
    if request_path == &quot;/&quot;:
        request_path = &quot;/index.html&quot;
    try:
        # 动态打开指定文件
        with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:
            # 读取文件数据
            file_data = file.read()
    except Exception as e:
        # 请求资源不存在，返回404数据
        # 响应行
        response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
        # 响应头
        response_header = &quot;Server: PWS1.0\r\n&quot;
        with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:
            file_data = file.read()
        # 响应体
        response_body = file_data
        # 拼接响应报文
        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
        # 发送数据
        new_socket.send(response_data)
    else:
        # 响应行
        response_line = &quot;HTTP/1.1 200 OK\r\n&quot;
        # 响应头
        response_header = &quot;Server: PWS1.0\r\n&quot;
        # 响应体
        response_body = file_data
        # 拼接响应报文
        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
        # 发送数据
        new_socket.send(response_data)
    finally:
        # 关闭服务与客户端的套接字
        new_socket.close()

# 程序入口函数
def main():
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用, 程序退出端口立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind((&quot;&quot;, 9000))
    # 设置监听
    tcp_server_socket.listen(128)
    while True:
        # 等待接受客户端的连接请求
        new_socket, ip_port = tcp_server_socket.accept()
        print(ip_port)
        # 当客户端和服务器建立连接程，创建子线程
        sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,))
        # 设置守护主线程
        sub_thread.setDaemon(True)
        # 启动子线程执行对应的任务
        sub_thread.start()

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><hr>
<h3 id="静态Web服务器-面向对象开发"><a href="#静态Web服务器-面向对象开发" class="headerlink" title="静态Web服务器-面向对象开发"></a>静态Web服务器-面向对象开发</h3><hr>
<p>实现步骤:把提供服务的Web服务器抽象成一个类(HTTPWebServer)；提供Web服务器的初始化方法，在初始化方法里面创建socket对象；提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。</p>
<pre><code>import socket
import threading

# 定义web服务器类
class HttpWebServer(object):
    def __init__(self):
        # 创建tcp服务端套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置端口号复用, 程序退出端口立即释放
        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        # 绑定端口号
        tcp_server_socket.bind((&quot;&quot;, 9000))
        # 设置监听
        tcp_server_socket.listen(128)
        # 保存创建成功的服务器套接字
        self.tcp_server_socket = tcp_server_socket

    # 处理客户端的请求
    @staticmethod
    def handle_client_request(new_socket):
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print(&quot;关闭浏览器了&quot;)
            new_socket.close()
            return
        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)
        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)
        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == &quot;/&quot;:
            request_path = &quot;/index.html&quot;
        try:
            # 动态打开指定文件
            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:
                file_data = file.read()
            # 响应体
            response_body = file_data
            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            # 响应体
            response_body = file_data
            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

    # 启动web服务器进行工作
    def start(self):
        while True:
            # 等待接受客户端的连接请求
            new_socket, ip_port = self.tcp_server_socket.accept()
            # 当客户端和服务器建立连接程，创建子线程
            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))
            # 设置守护主线程
            sub_thread.setDaemon(True)
            # 启动子线程执行对应的任务
            sub_thread.start()

# 程序入口函数
def main():
    # 创建web服务器对象
    web_server = HttpWebServer()
    # 启动web服务器进行工作
    web_server.start()

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><hr>
<h3 id="命令行启动动态绑定端口号"><a href="#命令行启动动态绑定端口号" class="headerlink" title="命令行启动动态绑定端口号"></a>命令行启动动态绑定端口号</h3><hr>
<p>实现步骤:获取执行python程序的终端命令行参数;判断参数的类型，设置端口号必须是整型;给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号。</p>
<pre><code>import socket
import threading
import sys

# 定义web服务器类
class HttpWebServer(object):
    def __init__(self, port):
        # 创建tcp服务端套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置端口号复用, 程序退出端口立即释放
        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        # 绑定端口号
        tcp_server_socket.bind((&quot;&quot;, port))
        # 设置监听
        tcp_server_socket.listen(128)
        # 保存创建成功的服务器套接字
        self.tcp_server_socket = tcp_server_socket

    # 处理客户端的请求
    @staticmethod
    def handle_client_request(new_socket):
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print(&quot;关闭浏览器了&quot;)
            new_socket.close()
            return
        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)
        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)
        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == &quot;/&quot;:
            request_path = &quot;/index.html&quot;
        try:
            # 动态打开指定文件
            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:
                file_data = file.read()
            # 响应体
            response_body = file_data
            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            # 响应体
            response_body = file_data
            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

    # 启动web服务器进行工作
    def start(self):
        while True:
            # 等待接受客户端的连接请求
            new_socket, ip_port = self.tcp_server_socket.accept()
            # 当客户端和服务器建立连接程，创建子线程
            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))
            # 设置守护主线程
            sub_thread.setDaemon(True)
            # 启动子线程执行对应的任务
            sub_thread.start()

# 程序入口函数
def main():
    print(sys.argv)
    # 判断命令行参数是否等于2,
    if len(sys.argv) != 2:
        print(&quot;执行命令如下: python3 xxx.py 8000&quot;)
        return
    # 判断字符串是否都是数字组成
    if not sys.argv[1].isdigit():
        print(&quot;执行命令如下: python3 xxx.py 8000&quot;)
        return
    # 获取终端命令行参数
    port = int(sys.argv[1])
    # 创建web服务器对象
    web_server = HttpWebServer(port)
    # 启动web服务器进行工作
    web_server.start()

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><hr>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>数据库就是存储和管理数据的仓库，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。</p>
<p>数据库的分类：关系型数据库和非关系型数据库。</p>
<p>关系型数据库:是指采用了关系模型来组织数据的数据库，简单来说，关系模型指的就是二维表格模型。</p>
<p>关系型数据库中核心元素：数据行、数据列、数据表、数据库(数据表的集合)。</p>
<p>常用的关系型数据库:Oracle、Microsoft SQL Server、MySQL、SQLite。</p>
<p>非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。</p>
<p>常用的非关系型数据库:MongoDB、Redis。</p>
<p>数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件。</p>
<p>SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。</p>
<p>SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。</p>
<p>SQL语言主要分为：</p>
<pre><code>DQL：数据查询语言，用于对数据进行查询，如select
DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete
TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback
DCL：数据控制语言，进行授权与权限回收，如grant、revoke
DDL：数据定义语言，进行数据库、表的管理等，如create、drop
</code></pre><p>对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可。SQL语言不区分大小写。</p>
<hr>
<h3 id="数据类型和约束"><a href="#数据类型和约束" class="headerlink" title="数据类型和约束"></a>数据类型和约束</h3><hr>
<p>数据库中的数据保存在数据表中，在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，比如:数据类型和约束。</p>
<p>数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。</p>
<p>常用数据类型如下:</p>
<pre><code>整数：int，bit
小数：decimal
字符串：varchar,char
日期时间: date, time, datetime
枚举类型(enum)
</code></pre><ol>
<li>decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.</li>
<li>char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为’ab ‘，3表示字符数</li>
<li>varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’，3表示字符数</li>
<li>对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.</li>
<li>字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客</li>
</ol>
<p>数据约束<br>约束是指数据在数据类型限定的基础上额外增加的要求.</p>
<p>常见的约束如下:</p>
<pre><code>主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.
非空 not null: 此字段不允许填写空值.
惟一 unique: 此字段的值不允许重复.
默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.
外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.
</code></pre><p>整数类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节大小</th>
<th>有符号范围(Signed)</th>
<th>无符号范围(Unsigned)</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1</td>
<td>-128 ~ 127</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768 ~ 32767</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608 ~ 8388607</td>
<td>0 ~ 16777215</td>
</tr>
<tr>
<td>INT/INTEGER</td>
<td>4</td>
<td>-2147483648 ~2147483647</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
<td>0 ~ 18446744073709551615</td>
</tr>
</tbody>
</table>
<p>字符串：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>固定长度，小型数据</td>
<td>身份证号、手机号、电话、密码</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>可变长度，小型数据</td>
<td>姓名、地址、品牌、型号</td>
</tr>
<tr>
<td>TEXT</td>
<td>可变长度，字符个数大于 4000</td>
<td>存储小型文章或者新闻</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>可变长度， 极大型文本数据</td>
<td>存储极大型文本数据</td>
</tr>
</tbody>
</table>
<p>时间类型：</p>
<p>|类型|    字节大小    |示例|<br>|DATE|    4|    ‘2020-01-01’|<br>|TIME|    3    |’12:29:59’|<br>|DATETIME|    8|    ‘2020-01-01 12:29:59’|<br>|YEAR|    1    |’2017’|<br>|TIMESTAMP|    4    |’1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC|</p>
<hr>
<h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><hr>
<hr>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="../../../../img/reward-alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="../../../../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2020/09/09/42.Linux命令/" class="next-post btn btn-default" title='Linux命令'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Linux命令</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#多任务编程"><span class="toc-text">多任务编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程编号"><span class="toc-text">进程编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程执行带有参数的任务"><span class="toc-text">进程执行带有参数的任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的注意点"><span class="toc-text">进程的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的使用"><span class="toc-text">多线程的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程执行带有参数的任务"><span class="toc-text">线程执行带有参数的任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的注意点"><span class="toc-text">线程的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程的对比"><span class="toc-text">进程和线程的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络编程"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP客户端程序开发"><span class="toc-text">TCP客户端程序开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP服务端程序开发"><span class="toc-text">TCP服务端程序开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP网络应用程序的注意点"><span class="toc-text">TCP网络应用程序的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多任务版TCP服务端程序开发"><span class="toc-text">多任务版TCP服务端程序开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket之send和recv原理剖析"><span class="toc-text">socket之send和recv原理剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态Web服务器"><span class="toc-text">静态Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动python自带静态Web服务"><span class="toc-text">启动python自带静态Web服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自己的静态Web服务器"><span class="toc-text">开发自己的静态Web服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自己的静态Web服务器返回指定页面数据"><span class="toc-text">开发自己的静态Web服务器返回指定页面数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态Web服务器-多任务版"><span class="toc-text">静态Web服务器-多任务版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态Web服务器-面向对象开发"><span class="toc-text">静态Web服务器-面向对象开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行启动动态绑定端口号"><span class="toc-text">命令行启动动态绑定端口号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型和约束"><span class="toc-text">数据类型和约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navicat"><span class="toc-text">Navicat</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>