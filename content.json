{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"python","slug":"41.python","date":"2020-09-05T14:17:33.777Z","updated":"2020-09-05T16:32:04.844Z","comments":false,"path":"2020/09/05/41.python/","link":"","permalink":"http://yoursite.com/2020/09/05/41.python/","excerpt":"","text":"变量 数据都是临时存储在内存中，为了更快速的查找或使用这个数据，通常我们把这个数据在内存中存储之后定义一个名称，这个名称就是变量。 变量就是一个存储数据的时候当前数据所在的内存地址的名字而已。 定义变量： 变量名 = 值 my_name = &apos;TOM&apos; print(my_name)#TOM 数据类型 数据类型 整型：int 浮点型：float 字符串：str 布尔型：bool 列表：list 元组：tuple 集合：set 字典：dict 检测数据类型的方法：type() a = 1 print(type(a)) # &lt;class &apos;int&apos;&gt; -- 整型 b = 1.1 print(type(b)) # &lt;class &apos;float&apos;&gt; -- 浮点型 c = True print(type(c)) # &lt;class &apos;bool&apos;&gt; -- 布尔型 d = &apos;12345&apos; print(type(d)) # &lt;class &apos;str&apos;&gt; -- 字符串 e = [10, 20, 30] print(type(e)) # &lt;class &apos;list&apos;&gt; -- 列表 f = (10, 20, 30) print(type(f)) # &lt;class &apos;tuple&apos;&gt; -- 元组 h = {10, 20, 30} print(type(h)) # &lt;class &apos;set&apos;&gt; -- 集合 g = {&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 20} print(type(g)) # &lt;class &apos;dict&apos;&gt; -- 字典 输出 格式符号 转换 %s 字符串 %d 有符号的十进制整数 %f 浮点数 %c 字符 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写ox） %X 十六进制整数（大写OX） %e 科学计数法（小写’e’） %E 科学计数法（大写’E’） %g %f和%e的简写 %G %f和%E的简写 技巧 %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出 %.2f，表示小数点后显示的小数位数。 格式化字符串除了%s，还可以写为f&#39;{表达式}&#39; age = 18 name = &apos;TOM&apos; weight = 75.5 student_id = 1 # 我的名字是TOM print(&apos;我的名字是%s&apos; % name) # 我的学号是0001 print(&apos;我的学号是%4d&apos; % student_id) # 我的体重是75.50公斤 print(&apos;我的体重是%.2f公斤&apos; % weight) # 我的名字是TOM，明年19岁了 print(&apos;我的名字是%s，明年%d岁了&apos; % (name, age + 1)) # 我的名字是TOM，明年19岁了 print(f&apos;我的名字是{name}, 明年{age + 1}岁了&apos;) 输入 input(&quot;提示信息&quot;) 在Python中，input会把接收到的任意用户输入的数据都当做字符串处理。 password = input(&apos;请输入您的密码：&apos;) print(f&apos;您输入的密码是{password}&apos;) # &lt;class &apos;str&apos;&gt; print(type(password)) 转换数据类型 函数 说明 int(x [,base ]) 将x转换为一个整数 float(x) 将x转换为一个浮点数 complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个Unicode字符 ord(x ) 将一个字符转换为它的ASCII整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 bin(x ) 将一个整数转换为一个二进制字符串 # 1. float() -- 转换成浮点型 num1 = 1 print(float(num1)) print(type(float(num1))) # 2. str() -- 转换成字符串类型 num2 = 10 print(type(str(num2))) # 3. tuple() -- 将一个序列转换成元组 list1 = [10, 20, 30] print(tuple(list1)) print(type(tuple(list1))) # 4. list() -- 将一个序列转换成列表 t1 = (100, 200, 300) print(list(t1)) print(type(list(t1))) # 5. eval() -- 将字符串中的数据转换成Python表达式原本类型 str1 = &apos;10&apos; str2 = &apos;[1, 2, 3]&apos; str3 = &apos;(1000, 2000, 3000)&apos; print(type(eval(str1))) print(type(eval(str2))) print(type(eval(str3))) 运算符 运算符 描述 实例 + 加 1 + 1 输出结果为 2 - 减 1-1 输出结果为 0 * 乘 2 * 2 输出结果为 4 / 除 10 / 2 输出结果为 5 // 整除 9 // 4 输出结果为2 % 取余 9 % 4 输出结果为 1 ** 指数 2 * 4 输出结果为 16，即 2 2 2 2 () 小括号 小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9 多个变量赋值 num1, float1, str1 = 10, 0.5, &apos;hello world&apos; print(num1) print(float1) print(str1) 多变量赋相同值 a = b = 10 print(a) print(b) 运算符 逻辑表达式 描述 实例 and x and y 布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 True and False， 返回 False。 or x or y 布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。 False or True， 返回 True。 not not x 布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not True 返回 False, not False 返回 True 数字之间的逻辑运算 a = 0 b = 1 c = 2 # and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字 print(a and b) # 0 print(b and a) # 0 print(b and c) # 2 print(c and b) # 1 # or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字 print(a or b) # 1 print(a or c) # 2 print(b or c) # 1 if语句基本使用 语法： if 条件1: 代码... ...... elif 条件2： 代码 ...... ...... else: 以上条件都不成立执行执行的代码 实例： age = int(input(&apos;请输入您的年龄：&apos;)) if age &lt; 18: print(f&apos;您的年龄是{age},童工一枚&apos;) elif (age &gt;= 18) and (age &lt;= 60): print(f&apos;您的年龄是{age},合法工龄&apos;) elif age &gt; 60: print(f&apos;您的年龄是{age},可以退休&apos;) 猜拳游戏 # 导入random模块 import random # 计算电脑出拳的随机数字 computer = random.randint(0, 2) print(computer) player = int(input(&apos;请出拳：0-石头，1-剪刀，2-布：&apos;)) # 玩家胜利 p0:c1 或 p1:c2 或 p2:c0 if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0): print(&apos;玩家获胜&apos;) # 平局：玩家 == 电脑 elif player == computer: print(&apos;平局&apos;) else: print(&apos;电脑获胜&apos;) 三元运算符 语法： 值1 if 条件 else 值2 a = 1 b = 2 c = a if a &gt; b else b print(c) 循环while while的语法 while 条件: 代码 ...... 计算1-100累加和： i = 1 result = 0 while i &lt;= 100: result += i i += 1 print(result)#5050 for循环 语法 for 临时变量 in 序列: 代码 ...... 使用 str1 = &apos;HelloWorld&apos; for i in str1: print(i) while…else 语法 while 条件: 代码 else: 循环正常结束之后要执行的代码 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。 for…else 语法 for 临时变量 in 序列: 代码 ... else: 循环正常结束之后要执行的代码 break终止循环不会执行else下方缩进的代码。continue退出循环的方式，执行else下方缩进的代码。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"从oc到swift","slug":"40.从oc到swift","date":"2020-08-29T08:31:43.733Z","updated":"2020-09-05T10:54:34.364Z","comments":false,"path":"2020/08/29/40.从oc到swift/","link":"","permalink":"http://yoursite.com/2020/08/29/40.从oc到swift/","excerpt":"","text":"Objective-C介绍 OC程序的源文件后缀名为.m。 m代表message，代表OC的消息机制。OC语言完全兼容C语言，所以在.m文件中可以写C语言的任何代码，甚至C++的代 码也可以写在.m文件下。 #import 指令:同一个文件，无论被#import多少次，在预编译的时候只会包含1次。包括#import &quot;&quot;和#import &lt;&gt;。 .m是Objective-C的源文件。.mm是Objective-C++的源文件。 .h是头文件，包含方法，属性的声明。.m是类的实现文件，参与编译的文件，用来实现类中声明的方法。 Boolean类型数据允许取值true或false,也可以是0或非0的整数替代true和false。 @try { //可能出错的代码块 } @catch (NSException *exception) { // 一旦出了错 可以的补救代码。 } @finally { //无论出错不出错都会执行的代 } 面向对象设计四个个主要特征: 抽象性、 封装性、 多态性、 继承性。 NSLog NSLog 是printf函数的增强版 NSLog(@&quot;Hello World!&quot;); @&quot;&quot;这个符号表示将一个C的字符串转化为OC中的字符串对象NSString。 OC字符串必须使用@符号开头。@符号放置的位置在双引号外面。在打印OC字符串的时候使用格式控制符%@ 。NSString类型的指针变量只能存储OC字符串常量的地址。 OC中大部分的关键字都是以@开头的,比如@interface,@implementation,@end。 类 .h文件为类的声明文件，用于声明成员变量、方法。类的声明使用关键字 @interface和@end。.h中的方法只是做一个声明，并不对方法进行实现。 .m：类的实现文件，用于实现.h中声明的方法。类的实现使用关键字 @implementation和@end。 方法的声明和实现，都必须以+ 或者 - 开头。 +表示类方法（静态方法）, -表示对象方法（动态方法）。 在.h中声明的所有方法作用域都是public类型，不能更改。 成员变量的常用作用域有3种: @public 全局都可以访问 @protected 只能在类内部和子类中访问 @private 只能在类内部访问 创建对象 创建对象的写法 类名 * 对象名 = [类名 new]; 只要是用new操作符定义的实体就会在堆内存中开辟一个新的空间。1）在堆中开辟一段存储空间 2）初始化成员变量（写在类声明大括号中的属性就叫做成员变量，也叫做实例变量） 3）返回开辟空间的首地址。 访问对象的属性可以用： 对象-&gt;对象成员； 方法 oc没有严格的方法重载. 在oc中方法名不允许相同。 OC中的方法分为：对象方法和类方法。 对象方法：对象方法以-开头如-（void）xx ;对象方法只能由对象来调用;对象方法中可以访问当前对象的成员变量;调用格式[对象名 对象方法名] 。凡事类型都用()括起来。 类方法：以+开头如+（void）xxx;类方法只能由类来调用;类方法中不能访问实例变量(成员变量)，因为类方法由类来调用，并没有创建存储空间来存储类中的成员变量;调用格式：[类名 类方法名]。 有参方法，冒号也是方法名的一部分 //返回值类型 void ; 方法名run: : :，参数有3个，都是int型的，参数的参数名 steps km times - (void)run:(int)steps :(int)km :(int)times; // 声明三个带参数的方法，方法名是 runWith: andWith: andWith: - (void)runWith:(int)steps andWith:(int)km andWith:(int)times; 有参方法的调用： //[对象名 方法名 参数] [zhansgan eat:@&quot;辣条&quot;]; // [对象名 方法名:参数:参数]; [zhansgan run:3 :10 :5]; [zhansgan runWith:5 andWith:20 andWith:2]; 对象的存储 类创建对象，每个对象在内存中都占据一定的存储空间，每个对象都有一份属于自己的单独的成员变量，所有的对象公用类的成员方法，方法在整个内存中只有一份，类本身在内存中占据一份存储空间，类的方法存储于此。 每一个对象都包含一个isa指针，这个指针指向当前对象所属的类。 当调用方法的时候如[p eat] 表示给p所指向的对象发送一条eat消息，表示要调用对象的eat方法，此时对象会顺着内部的isa指针找到存储于类中的方法，开始执行，此时方法所修改的所有的信息，都是对应的对象的。 pragma mark #pragma mark -//“-”后面不能随手敲个空格 #pragma mark 分组（标识）名称 常见错误 @interface @end和@implementation @end不能嵌套包含。 只有类的声明没有类的实现，会报错。 NSString NSString是Objective-C中核心处理字符串的类之一。 创建常量字符串，注意使用“@”符号： NSString * str = @&quot;hahahaha&quot;; NSString * str2 = [[NSString alloc] initWithString:str]; 创建空字符串，给予赋值： NSString * str1 = [NSString new ]; str1 = @&quot;啊哈哈哈&quot;; 创建格式化字符串：占位符（由一个%加一个字符组成）： NSString * str3 = [NSString stringWithFormat:@&quot;图片 xxxx %02d- %02d.jpg&quot;,9,1]; NSLog(@&quot;Hello, World! %@ &quot;,str3);//图片 xxxx %09- %01.jpg 计算字符串长度 NSLog(@&quot;字符串的长度 %ld&quot;, [str2 length]); 对象与对象之间的关系 一个对象作为另外1个对象的成员变量 //女孩有一部手机 @interface Girl :NSObject { Phone *_phone; } @end //女孩用手机打电话 @interface Girl :NSObject - (void)callWithPhone:(Phone *)phone; @end 组合关系:1个对象是由多个对象组合起来的。比如：计算机对象，是由主板对象、CPU对象、内存对象、硬盘对象组合起来的。 依赖关系：就是一个对象要1件事情的时候必须有另一个对象。比如，B类是A类⽅方法的参数，我们就说A类依赖于B类。 关联关系:当一个对象拥有另外一个对象的时候, 当B对象为A对象的成员变量的时候,B对象与A对象之间存在一种关联关系。 面向对象设计原则 单一职责原则、开放封闭原则 类方法OC中的方法分为两种 对象方法 以“-”减号开头的方法就是对象方法。对象方法的调用，必须创建对象，然后通过对象名去调用。 声明 -（返回值类型）方法名：（参数类型）参数名称； - (void)square : (int)num; 类方法 以+加号开头的方法叫做类方法。这个方法不依赖于对象，不需要创建对象来调用，而是直接使用类名调用。 +（返回值类型）方法名：（参数类型）参数名称； + (void)square : (int)num; 类方法使用注意事项： 1. 类方法中不能访问成员变量。 2. 类方法和对象方法可以同名。 3. 类方法中不能通过self调用同名方法，会死循环。 4. 对象方法当中可以通过类名直接调用类方法。 5. 在没有属性时，建议使用类方法。 匿名对象没有名字的对象。 self关键字 self是一个指针变量，用于在方法中指向调用该方法的对象。 self的应用场景 1）用在类方法中，代表当前类。 2）用在对象方法中，代表当前对象。 3）访问成员变量：self-&gt;成员变量。 self使用注意 在对象方法中 【self 对象方法】； // 死循环 在类方法中 【self 对象方法】； // 死循环 封装封装:把复杂的数据或者操作进行隐藏,只操作数据或者方法的接口。封装的好处:隐藏成员变量，不让外部直接访问，提高安全性。控制外界访问成员权限。 set方法 命名规范：方法名必须以set开头。set后面跟成员变量名称，成员变量的首字母必须大写。返回值一定是void。一定要接收一个参数，而且参数类型跟成员变量类型一致。形参的名称不能跟成员变量名一样。 - (void)set成员变量名 (首字母大写，去掉下划线) : (成员变量类型)成员变量名称 （去掉下划线）； - (void)setAge:(int)age; get方法 命名规范：肯定有返回值，返回值类型肯定与成员变量类型一致。方法名跟成员变量名一样。不需要接收任何参数 格式： - （成员变量类型）成员变量名称（去掉下划线）; - (int) age; 使用 // Student类的声明 @interface Student : NSObject { int _age; } - (void)setAge:(int)newAge;//set方法 - (int)age;//get方法 @end //Student类实现: @implementation Student //setter方法实现 - (void)setAge:(int)newAge { _age = newAge; } //getter方法 - (int)age { return _age; } @end 调用: Student *s = [Student new]; // 设置age的值 [s setAge:10]; // 取出age的值 int age = [s age]; // 输出 NSLog(@&quot;age is %d&quot;, age); 类的继承和派生 OC中的继承是单继承:也就是说一个类只能一个父类,不能继承多个父类。子类不能定义和父类同名的成员变量,但是可以继承父类的变量。 基类的私有属性@private能被继承,不能被使用。@public公有成员能被继承,也能被外部方法访问。@protected保护成员能够被继承、在子类中使用,但不能够被外部函数访问。在@interface @end之间声明的成员变量如果不做特别的说明,那么其默认是 protected的。 在类的实现即.m文件，@implementation中也可以声明成员变量,是@private的。 方法的重写：从父类继承的方法,可能这个方法并不适合子类,可以在子类中重写父类的方法。 @interface Animal : NSObject { int _tuiNum; //腿的个数 int _eyeNum; //眼睛个数 } -(void)setTuiNum:(int)tuiNum; -(int)tuiNum; -(void)setEyeNum:(int)eyeNum; -(int)eyeNum; -(void)eat; -(void)run; @end #import &quot;Animal.h&quot; @interface Dog : Animal { } -(void)eat; //覆盖父类的eat的方法 @end 重写之后,父类的对象调用父类的方法;子类的对象,调用子类的方法,不会引起冲突。从父类继承的方法,不适用于子类时,可以直接声明父类的同名方法,并定义。不用考虑父类中,方法已存在的问题。 重写后,子类可以通过super调用父类的方法。 - （void）eat { [super eat]; } 私有方法 OC中并没有像Java中提供的私有方法,OC中的私有,可以理解为相对私有。 方法在.m中实现,不在.h中声明,此时该方法被称为私有方法:私有方法不可以被子类继承 @interface MyClass { // 添加变量 } - (void)PublicMethod;//公共方法,可以被继承类继承 @end // 而在类的.m文件中,直接实现的方法： - (void)PrivateMethod { //// } @end 多态 多态:同一种行为,对于不同的事物具有不同的表现形式。多态的条件:有继承关系、有方法重写。 父类的声明变量指向子类对象。如果存在多态,父类是可以访问子类特有的方法。 类对象的用法 可以用来调用方法 Dog *d = [Dog new]; Dog *d1 = [Dog new]; Class c = [d1 class]; // 用类名调用类方法 [Dog test]; [c test]; 可以用来初始化对象 Class c = [Dog class]; [c test]; // 用类对象创建对象 Dog *d = [c new]; [d eat]; SEL方法选择器 SEL类型作用:可以定义变量；可以用来作为方法的形参；可以用来作为方法的实参。 Static关键 static修饰局部变量:延长布局变量的生命周期。 static修饰全局变量:当前变量只能在当前文件中使用。 static修饰函数:函数只能在当前文件中使用。 使用static修饰实例变量是不被允许的。 使用static修饰方法也是不被允许的。 使用static@interface和@end之间是不被允许的（写局部变量本来就不被允许）。 //狗类的声明 static int m=10; //此句话也可以放到.m中 @interface Dog:NSObject { int _speed; } -(void)run; @end // Dog.m文件内容 #import &quot;Dog.h&quot; #pragma mark 狗类的实现 @implementation Dog -(void)run{ //定义局部静态变量 m static int m=10; NSLog(@&quot;m = %d&quot;,m); m++; } @end 注意Static型全局变量的可见性,局限于当前.m文件，其他的文件中的类,无法访问到该变量。 点语法 点语法是编译器特性，当编译器看到对象使用点语法，会自动把点语法转换为调用set或get方法的形式。 Student *stu = [Student new]; // 设置age的值 stu.age = 10; // 等价于[stu setAge:10]; // 取出age的值 int age = stu.age; // 等价于int age = [stu age]; // 输出 NSLog(@&quot;age is %i&quot;, age); self在set方法中使用 - (void)setAge:(int)age { self.age = age; } 错误用法，会死循环。 上面的代码相当于： - (void)setAge:(int)age { [self setAge:age]; } self在get方法中使用 - (int)age { return self.age; } 错误用法：死循环。 相当于： - (int)age { return [self age]; } property关键字 @property是编译器的指令。它告诉编译器,声明属性的set、get方法。好处是:免去我们手工书写get和set方法繁琐的代码。 格式： @property 类型 方法名 @property int age; //相当于进行了age的set和get方法的声明 -(void)setAge:(int)age; -(int)age; synthesize关键字 如果@synthesize变量名要先在.h文件中声明 @property int age; .h -(void)setAge:(int)age; -(int)age; .m @synthesize age;展开形式如下: -(void)setAge:(int)age { self-&gt;age = age; } -(int)age { return age; } @property和@synthesize搭配使用,用于简化set和get方法的定义和实现。 id类型 id类型应用场景 //狗的类,狗继承自动物 Dog *dog = [Dog new]; [dog run]; //定义多态类型 NSObjcet *dog1 = [Dog new]; [(Dog *)dog run]; //定义id类型 id dog2 = [Dog new]; [obj run]; id作为成员变量 // 类的声明 @interface Person : NSObject @property int age; @property id obj; // 可以接收任何对象 @end // 类的实现 @implementation Person @end // main函数 int main() { Person *p = [Person new]; [p setObj:@&quot;小王子&quot;]; NSLog(@&quot;%d&quot;,[p obj]); return 0; } 构造方法 构造方法:用来初始化对象实例变量值的方法,是个对象方法,-开头。 完整的创建一个可用的对象: Person *p=[Person new]; new方法的内部会分别调用两个方法来完成3件事情:使用alloc方法来分配存储空间(返回分配的对象);使用init方法来对对象进行初始化；返回对象的首地址。 可以把new方法拆开如下:调用类方法+alloc分配存储空间,返回未经初始化的对象 Person *p1=[Person alloc]; 调用对象方法-init进行初始化,返回对象本身 Person *p2=[p1 init]; 以上两个过程整合为一句: Person *p=[[Person alloc] init]; init方法就是构造方法,是用来初始化对象的方法,注意这是一个对象方法,以减号开头。默认初始化完毕后,所有成员变量的值都为0。 自定义构造方法的代码实现 问题1：给Hero类定义一个构造方法,自定义名字信息。 // 声明 @property NSString *name; - (instancetype)initWithName:(NSString *)name； // 实现 - (instancetype)initWithName:(NSString *)name { if (self = [super init]) { _name = name; } return self; } @end 问题2：给Hero类定义一个构造方法,自定义名字信息和年龄。 // 声明 @property NSString *name; @property int age; - (instancetype)initWithName:(NSString *)name andAge:(int)age； // 实现 - (instancetype)initWithName:(NSString *)name andAge:(int)age { if (self = [super init]) { _name = name; _age = age; } return self; } @end NSMutableArray 数组长度不固定，可以随便往里面添加或者删除元素。 创建可变数组 NSMutableArray *arrayM = [NSMutableArray array]; 数组添加成员 - (void)addObject:(ObjectType)object; 删除数组成员 // 用成员名进行删除 - (void)removeObject:(ObjectType)object; // 删除指定位置的元素 - (void)removeObjectAtIndex:(NSUInteger)index; iOS https://github.com/dequan1331/HybridPageKit","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"数据结构和算法","slug":"37.数据结构和算法","date":"2020-07-06T14:19:40.708Z","updated":"2020-07-30T14:36:21.822Z","comments":false,"path":"2020/07/06/37.数据结构和算法/","link":"","permalink":"http://yoursite.com/2020/07/06/37.数据结构和算法/","excerpt":"","text":"介绍1、数据结构分类 数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据。 把数据结构分为逻辑结构和物理结构两大类。 逻辑结构分类：集合结构、线性结构、树形结构、图形结构。 物理结构：顺序存储结构、链式存储结构。 顺序存储结构：把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。查找快、插入删除慢。 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。查找慢，增删快。 2、算法介绍 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。根据一定的条件，对一些数据进行计算，得到需要的结果。 一个优秀的算法追求以下两个目标：1.花最少的时间完成需求；2.占用最少的内存空间完成需求。 3、算法的时间复杂度 算法的时间复杂度分析 事后分析估算方法：计算方法执行时间System.currentTimeMillis()。 事前分析估算方法：算法采用的策略和方案；问题的输入规模(所谓的问题输入规模就是输入量的多少)。最重要的就是把核心操作的次数和输入规模关联起来。 总结：随着输入规模的增大，算法的常数操作可以忽略不计。随着输入规模的增大，与最高次项相乘的常数可以忽略。最高次项的指数大的，随着n的增长，结果也会变得增长特别快。算法函数中n最高次幂越小，算法效率越高。 4、时间复杂度大O记法 执行次数=执行时间。用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。 大O阶的表示法有以下几个规则可以使用： 1.用常数1取代运行时间中的所有加法常数； 2.在修改后的运行次数中，只保留高阶项； 3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数。 复杂程度从低到高依次为：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)。 5、算法的空间复杂度 数据类型 内存占用字节数：byte 1、short 2、int 4、long 8、float 4、double 8、boolean 1、char 2。 计算机访问内存的方式都是一次一个字节。 一个引用（机器地址）需要8个字节表示： Date date = new Date()；//则date这个变量需要占用8个字节来表示 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 一般内存的使用，如果不够8个字节，都会被自动填充为8字节。 java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。 int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节 排序1、Comparable接口 public class Student implements Comparable&lt;Student&gt;{ private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Student{&quot; + &quot;username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;}&apos;; } @Override public int compareTo(Student o) { return this.getAge()-o.getAge(); } } public class TestComparable { public static void main(String[] args) { //创建两个Student对象，并调用getMax方法，完成测试 Student s1 = new Student(); s1.setUsername(&quot;张三&quot;); s1.setAge(18); Student s2 = new Student(); s2.setUsername(&quot;李四&quot;); s2.setAge(20); Comparable max = getMax(s1, s2); System.out.println(max); } public static Comparable getMax(Comparable c1,Comparable c2){ int result = c1.compareTo(c2); //如果result&lt;0,则c1比c2小； //如果result&gt;0，则c1比c2大； //如果result==0,则c1和c2一样大； if (result&gt;=0){ return c1; }else{ return c2; } } } 2、冒泡排序 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。最终最后位置的元素就是最大值。 public class Bubble { /* * 对数组的元素进行排序 */ public static void sort(Comparable[] a){ for(int i=a.length-1;i&gt;0;i--){ for(int j=0;j&lt;i;j++){ //比较索引j和索引j+1处的值 if (greater(a[j],a[j+1])){ exch(a,j,j+1); } } } } /* * 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w){ return v.compareTo(w)&gt;0; } /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j){ Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; } } public class BubbleTest { public static void main(String[] args) { Integer[] arr = {4,5,6,3,2,1}; Bubble.sort(arr); System.out.println(Arrays.toString(arr));//{1,2,3,4,5,6} } } 冒泡排序的时间复杂度为O(N^2)。 3、选择排序 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引。然后交换第一个索引处和最小值所在的索引处的值。 public class Selection { /* 对数组中的元素进行排序 */ public static void sort(Comparable[] a){ for(int i=0;i&lt;=a.length-2;i++){ //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置 int minIndex = i; for(int j=i+1;j&lt;a.length;j++){ //需要比较最小索引minIndex处的值和j索引处的值； if (greater(a[minIndex],a[j])){ minIndex=j; } } //交换最小元素所在索引minIndex处的值和索引i处的值 exch(a,i,minIndex); } } /* 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w){ return v.compareTo(w)&gt;0; } /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j){ Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; } } public class SelectionTest { public static void main(String[] args) { //原始数据 Integer[] a = {4,6,8,7,9,2,10,1}; Selection.sort(a); System.out.println(Arrays.toString(a));//{1,2,4,5,7,8,9,10} } } 时间复杂度为O(N^2)。 4、插入排序 把所有的元素分为两组，已经排序的和未排序的；找到未排序的组中的第一个元素，向已经排序的组中进行插入；倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。类似打扑克牌时，新牌往手里牌的排序。 public class Insertion { /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a){ for(int i=1;i&lt;a.length;i++){ for(int j=i;j&gt;0;j--){ //比较索引j处的值和索引j-1处的值，如果索引j-1处的值比索引j处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可； if (greater(a[j-1],a[j])){ exch(a,j-1,j); }else{ break; } } } } /* 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w){ return v.compareTo(w)&gt;0; } /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j){ Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; } } public class InsertionTest { public static void main(String[] args) { Integer[] a = {4,3,2,10,12,1,5,6}; Insertion.sort(a); System.out.println(Arrays.toString(a));//{1,2,3,4,5,6,10,12} } } 时间复杂度为O(N^2)。 5、希尔排序 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；对分好组的每一组数据完成插入排序；减小增长量，最小减为1，重复第二步操作。 增长量h的确定： int h=1 while(h&lt;(数组长度/2)){ h=2h+1 } //循环结束后我们就可以确定h的最大值 //h的减小规则为： h=h/2 代码 public class Shell { /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a){ //1.根据数组a的长度，确定增长量h的初始值； int h = 1; while(h&lt;a.length/2){ h=2*h+1; } //2.希尔排序 while(h&gt;=1){ //排序 //2.1.找到待插入的元素 for (int i=h;i&lt;a.length;i++){ //2.2把待插入的元素插入到有序数列中 for (int j=i;j&gt;=h;j-=h){ //待插入的元素是a[j],比较a[j]和a[j-h] if (greater(a[j-h],a[j])){ //交换元素 exch(a,j-h,j); }else{ //待插入元素已经找到了合适的位置，结束循环； break; } } } //减小h的值 h= h/2; } } /* 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w){ return v.compareTo(w)&gt;0; } /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j){ Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; } } public class ShellTest { public static void main(String[] args) { Integer[] a = {9,1,2,5,7,4,8,6,3,5}; Shell.sort(a); System.out.println(Arrays.toString(a));//{1,2,3,4,5,5,6,7,8,9} } } 6、归并排序 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。将相邻的两个子组进行合并成一个有序的大组；不断的重复步骤2，直到最终只有一个组为止。 public class Merge { //归并所需要的辅助数组 private static Comparable[] assist; /* 比较v元素是否小于w元素 */ private static boolean less(Comparable v, Comparable w) { return v.compareTo(w)&lt;0; } /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a) { //1.初始化辅助数组assist； assist = new Comparable[a.length]; //2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引； int lo=0; int hi=a.length-1; //3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序 sort(a,lo,hi); } /* 对数组a中从lo到hi的元素进行排序 */ private static void sort(Comparable[] a, int lo, int hi) { //做安全性校验； if (hi&lt;=lo){ return; } //对lo到hi之间的数据进行分为两个组 int mid = lo+(hi-lo)/2;// 5,9 mid=7 //分别对每一组数据进行排序 sort(a,lo,mid); sort(a,mid+1,hi); //再把两个组中的数据进行归并 merge(a,lo,mid,hi); } /* 对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并 */ private static void merge(Comparable[] a, int lo, int mid, int hi) { //定义三个指针 int i=lo; int p1=lo; int p2=mid+1; //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处 while(p1&lt;=mid &amp;&amp; p2&lt;=hi){ //比较对应索引处的值 if (less(a[p1],a[p2])){ assist[i++] = a[p1++]; }else{ assist[i++]=a[p2++]; } } //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处 while(p1&lt;=mid){ assist[i++]=a[p1++]; } //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处 while(p2&lt;=hi){ assist[i++]=a[p2++]; } //把辅助数组中的元素拷贝到原数组中 for(int index=lo;index&lt;=hi;index++){ a[index]=assist[index]; } } } public class MergeTest { public static void main(String[] args) { Integer[] a = {8,4,5,7,1,3,6,2}; Merge.sort(a); System.out.println(Arrays.toString(a));//{1,2,3,4,5,6,7,8} } } 归并排序的时间复杂度为O(nlogn)。归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。 7、快速排序 首先设定一个分界值，通过该分界值将数组分成左右两部分；将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值； 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。 切分原理：把一个数组切分成两个子数组的基本思想： 1.找一个基准值，用两个指针分别指向数组的头部和尾部； 2.先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置； 3.再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置； 4.交换当前左边指针位置和右边指针位置的元素； 5.重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。 public class Quick { /* 比较v元素是否小于w元素 */ private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } //对数组内的元素进行排序 public static void sort(Comparable[] a) { int lo = 0; int hi = a.length-1; sort(a,lo,hi); } //对数组a中从索引lo到索引hi之间的元素进行排序 private static void sort(Comparable[] a, int lo, int hi) { //安全性校验 if (hi&lt;=lo){ return; } //需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）； int partition = partition(a, lo, hi);//返回的是分组的分界值所在的索引，分界值位置变换后的索引 //让左子组有序 sort(a,lo,partition-1); //让右子组有序 sort(a,partition+1,hi); } //对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引 public static int partition(Comparable[] a, int lo, int hi) { //确定分界值 Comparable key = a[lo]; //定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置 int left=lo; int right=hi+1; //切分 while(true){ //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止 while(less(key,a[--right])){ if (right==lo){ break; } } //再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止 while(less(a[++left],key)){ if (left==hi){ break; } } //判断 left&gt;=right,如果是，则证明元素扫描完毕，结束循环，如果不是，则交换元素即可 if (left&gt;=right){ break; }else{ exch(a,left,right); } } //交换分界值 exch(a,lo,right); return right; } } public class QuickTest { public static void main(String[] args) { Integer[] a= {6, 1, 2, 7, 9, 3, 4, 5, 8}; Quick.sort(a); System.out.println(Arrays.toString(a));//{1, 2, 3, 4, 5, 6, 7, 8, 9} } } 快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。 快速排序的时间复杂度为O(nlogn)。 8、排序的稳定性 数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。 如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。 稳定排序算法：冒泡排序、插入排序、归并排序。 不稳定的排序算法：选择排序、希尔排序、快速排序。 线性表 若A元素在B元素的前面，则称A为B的前驱元素。若B元素在A元素的后面，则称B为A的后继元素。 第一个数据元素没有前驱，这个数据元素被称为头结点；最后一个数据元素没有后继，这个数据元素被称为尾结点；除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。 线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。 顺序表 顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。 基本API、扩容、缩容、SequenceList能支持foreach循环，则需要做如下操作：让SequenceList实现Iterable接口，重写iterator方法；在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法。 public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;{ //存储元素的数组 private T[] eles; //记录当前顺序表中的元素个数 private int N; //构造方法 public SequenceList(int capacity){ //初始化数组 this.eles=(T[])new Object[capacity]; //初始化长度 this.N=0; } //将一个线性表置为空表 public void clear(){ this.N=0; } //判断当前线性表是否为空表 public boolean isEmpty(){ return N==0; } //获取线性表的长度 public int length(){ return N; } //获取指定位置的元素 public T get(int i){ return eles[i]; } //向线型表中添加元素t public void insert(T t){ if (N==eles.length){ resize(2*eles.length); } eles[N++]=t; } //在i元素处插入元素t public void insert(int i,T t){ if (N==eles.length){ resize(2*eles.length); } //先把i索引处的元素及其后面的元素依次向后移动一位 for(int index=N;index&gt;i;index--){ eles[index]=eles[index-1]; } //再把t元素放到i索引处即可 eles[i]=t; //元素个数+1 N++; } //删除指定位置i处的元素，并返回该元素 public T remove(int i){ //记录索引i处的值 T current = eles[i]; //索引i后面元素依次向前移动一位即可 for(int index=i;index&lt;N-1;index++){ eles[index]=eles[index+1]; } //元素个数-1 N--; if (N&lt;eles.length/4){ resize(eles.length/2); } return current; } //查找t元素第一次出现的位置 public int indexOf(T t){ for(int i=0;i&lt;N;i++){ if (eles[i].equals(t)){ return i; } } return -1; } //根据参数newSize，重置eles的大小 public void resize(int newSize){ //定义一个临时数组，指向原数组 T[] temp=eles; //创建新数组 eles=(T[])new Object[newSize]; //把原数组的数据拷贝到新数组即可 for(int i=0;i&lt;N;i++){ eles[i]=temp[i]; } } @Override public Iterator&lt;T&gt; iterator() { return new SIterator(); } private class SIterator implements Iterator{ private int cusor; public SIterator(){ this.cusor=0; } @Override public boolean hasNext() { return cusor&lt;N; } @Override public Object next() { return eles[cusor++]; } } } 测试 public class SequenceListTest { public static void main(String[] args) { //创建顺序表对象 SequenceList&lt;String&gt; sl = new SequenceList&lt;&gt;(10); //测试插入 sl.insert(&quot;姚明&quot;); sl.insert(&quot;科比&quot;); sl.insert(&quot;麦迪&quot;); sl.insert(1,&quot;詹姆斯&quot;); for (String s : sl) { System.out.println(s); } System.out.println(&quot;------------------------------------------&quot;); //测试获取 String getResult = sl.get(1); System.out.println(&quot;获取索引1处的结果为：&quot;+getResult); //测试删除 String removeResult = sl.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); //测试清空 sl.clear(); System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length()); } } 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显。 java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查、扩容、遍历等功能。 链表 链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。 public class Node&lt;T&gt; { //存储元素 public T item; //指向下一个结点 public Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public static void main(String[] args) throws Exception { //构建结点 Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(11, null); Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(13, null); Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(12, null); Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(8, null); Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(9, null); //生成链表 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; } 单向链表 单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。 实现基本API、遍历、链表的反转。 public class LinkList&lt;T&gt; implements Iterable&lt;T&gt;{ //记录头结点 private Node head; //记录链表的长度 private int N; //结点类 private class Node { //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public LinkList() { //初始化头结点、 this.head = new Node(null,null); //初始化元素个数 this.N=0; } //清空链表 public void clear() { head.next=null; this.N=0; } //获取链表的长度 public int length() { return N; } //判断链表是否为空 public boolean isEmpty() { return N==0; } //获取指定位置i出的元素 public T get(int i) { //通过循环,从头结点开始往后找，依次找i次，就可以找到对应的元素 Node n = head.next; for(int index=0;index&lt;i;index++){ n=n.next; } return n.item; } //向链表中添加元素t public void insert(T t) { //找到当前最后一个结点 Node n = head; while(n.next!=null){ n=n.next; } //创建新结点，保存元素t Node newNode = new Node(t, null); //让当前最后一个结点指向新结点 n.next=newNode; //元素的个数+1 N++; } //向指定位置i出，添加元素t public void insert(int i, T t) { //找到i位置前一个结点 Node pre = head; for(int index=0;index&lt;=i-1;index++){ pre=pre.next; } //找到i位置的结点 Node curr = pre.next; //创建新结点，并且新结点需要指向原来i位置的结点 Node newNode = new Node(t, curr); //原来i位置的前一个节点指向新结点即可 pre.next=newNode; //元素的个数+1 N++; } //删除指定位置i处的元素，并返回被删除的元素 public T remove(int i) { //找到i位置的前一个节点 Node pre = head; for(int index=0;index&lt;=i-1;i++){ pre=pre.next; } //要找到i位置的结点 Node curr = pre.next; //找到i位置的下一个结点 Node nextNode = curr.next; //前一个结点指向下一个结点 pre.next=nextNode; //元素个数-1 N--; return curr.item; } //查找元素t在链表中第一次出现的位置 public int indexOf(T t) { //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，就找到了 Node n = head; for(int i=0;n.next!=null;i++){ n=n.next; if (n.item.equals(t)){ return i; } } return -1; } @Override public Iterator&lt;T&gt; iterator() { return new LIterator(); } private class LIterator implements Iterator{ private Node n; public LIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n = n.next; return n.item; } } //用来反转整个链表 public void reverse(){ //判断当前链表是否为空链表，如果是空链表，则结束运行，如果不是，则调用重载的reverse方法完成反转 if (isEmpty()){ return; } reverse(head.next); } //反转指定的结点curr，并把反转后的结点返回 public Node reverse(Node curr){ if (curr.next==null){ head.next=curr; return curr; } //递归的反转当前结点curr的下一个结点；返回值就是链表反转后，当前结点的上一个结点 Node pre = reverse(curr.next); //让返回的结点的下一个结点变为当前结点curr； pre.next=curr; //把当前结点的下一个结点变为null curr.next=null; return curr; } } 测试 public class LinkListTest { public static void main(String[] args) { //创建顺序表对象 LinkList&lt;String&gt; sl = new LinkList&lt;&gt;(); //测试插入 sl.insert(&quot;姚明&quot;); sl.insert(&quot;科比&quot;); sl.insert(&quot;麦迪&quot;); sl.insert(1,&quot;詹姆斯&quot;); for (String s : sl) { System.out.println(s); } System.out.println(&quot;------------------------------------------&quot;); //测试获取 String getResult = sl.get(1); System.out.println(&quot;获取索引1处的结果为：&quot;+getResult); //测试删除 String removeResult = sl.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); //测试清空 sl.clear(); System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length()); } } 双向链表 双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。 实现基本API、遍历。 public class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt; { //首结点 private Node head; //最后一个结点 private Node last; //链表的长度 private int N; //结点类 private class Node{ public Node(T item, Node pre, Node next) { this.item = item; this.pre = pre; this.next = next; } //存储数据 public T item; //指向上一个结点 public Node pre; //指向下一个结点 public Node next; } public TowWayLinkList() { //初始化头结点和尾结点 this.head = new Node(null,null,null); this.last=null; //初始化元素个数 this.N=0; } //清空链表 public void clear(){ this.head.next=null; this.head.pre=null; this.head.item=null; this.last=null; this.N=0; } //获取链表长度 public int length(){ return N; } //判断链表是否为空 public boolean isEmpty(){ return N==0; } //获取第一个元素 public T getFirst(){ if (isEmpty()){ return null; } return head.next.item; } //获取最后一个元素 public T getLast(){ if (isEmpty()){ return null; } return last.item; } //插入元素t public void insert(T t){ if (isEmpty()){ //如果链表为空： //创建新的结点 Node newNode = new Node(t,head, null); //让新结点称为尾结点 last=newNode; //让头结点指向尾结点 head.next=last; }else { //如果链表不为空 Node oldLast = last; //创建新的结点 Node newNode = new Node(t, oldLast, null); //让当前的尾结点指向新结点 oldLast.next=newNode; //让新结点称为尾结点 last = newNode; } //元素个数+1 N++; } //向指定位置i处插入元素t public void insert(int i,T t){ //找到i位置的前一个结点 Node pre = head; for(int index=0;index&lt;i;index++){ pre=pre.next; } //找到i位置的结点 Node curr = pre.next; //创建新结点 Node newNode = new Node(t, pre, curr); //让i位置的前一个结点的下一个结点变为新结点 pre.next=newNode; //让i位置的前一个结点变为新结点 curr.pre=newNode; //元素个数+1 N++; } //获取指定位置i处的元素 public T get(int i){ Node n = head.next; for(int index=0;index&lt;i;index++){ n=n.next; } return n.item; } //找到元素t在链表中第一次出现的位置 public int indexOf(T t){ Node n = head; for(int i=0;n.next!=null;i++){ n=n.next; if (n.next.equals(t)){ return i; } } return -1; } //删除位置i处的元素，并返回该元素 public T remove(int i){ //找到i位置的前一个结点 Node pre = head; for(int index=0;index&lt;i;index++){ pre=pre.next; } //找到i位置的结点 Node curr = pre.next; //找到i位置的下一个结点 Node nextNode= curr.next; //让i位置的前一个结点的下一个结点变为i位置的下一个结点 pre.next=nextNode; //让i位置的下一个结点的上一个结点变为i位置的前一个结点 nextNode.pre=pre; //元素的个数-1 N--; return curr.item; } @Override public Iterator&lt;T&gt; iterator() { return new TIterator(); } private class TIterator implements Iterator{ private Node n; public TIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n=n.next; return n.item; } } } 测试 public class TowWayLinkListTest { public static void main(String[] args) { //创建双向链表对象 TowWayLinkList&lt;String&gt; sl = new TowWayLinkList&lt;&gt;(); //测试插入 sl.insert(&quot;姚明&quot;); sl.insert(&quot;科比&quot;); sl.insert(&quot;麦迪&quot;); sl.insert(1,&quot;詹姆斯&quot;); for (String s : sl) { System.out.println(s); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(&quot;第一个元素是：&quot;+sl.getFirst()); System.out.println(&quot;最后一个元素是：&quot;+sl.getLast()); System.out.println(&quot;------------------------------------------&quot;); //测试获取 String getResult = sl.get(1); System.out.println(&quot;获取索引1处的结果为：&quot;+getResult); //测试删除 String removeResult = sl.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); //测试清空 sl.clear(); System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length()); } } java中LinkedList集合也是使用双向链表实现，结点类有三个域，并提供了增删改查等相关方法。 链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,同时它并没有涉及的元素的交换。 相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。 快慢指针 快慢指针获取中间值。slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。 public class FastSlowTest { public static void main(String[] args) throws Exception { //创建结点 Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null); Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null); Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null); Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null); Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null); Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null); Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null); //完成结点之间的指向 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven; //查找中间值 String mid = getMid(first); System.out.println(&quot;中间值为：&quot;+mid); } /** * @param first 链表的首结点 * @return 链表的中间结点的值 */ public static String getMid(Node&lt;String&gt; first) { //定义两个指针 Node&lt;String&gt; fast = first; Node&lt;String&gt; slow = first; //使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值 while(fast!=null &amp;&amp;fast.next!=null){ //变化fast的值和slow的值 fast = fast.next.next; slow=slow.next; } return slow.item; } //结点类 private static class Node&lt;T&gt; { //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } } 快慢指针检查是否有环。两个指针有速度差，那么迟早两个指针会相遇，只要相遇那么就说明有环。 public class CircleListCheckTest { public static void main(String[] args) throws Exception { //创建结点 Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null); Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null); Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null); Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null); Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null); Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null); Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null); //完成结点之间的指向 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven; // //产生环 // seven.next = third; //判断链表是否有环 boolean circle = isCircle(first); System.out.println(&quot;first链表中是否有环：&quot;+circle); } /** * 判断链表中是否有环 * @param first 链表首结点 * @return ture为有环，false为无环 */ public static boolean isCircle(Node&lt;String&gt; first) { //定义快慢指针 Node&lt;String&gt; fast = first; Node&lt;String&gt; slow = first; //遍历链表，如果快慢指针指向了同一个结点，那么证明有环 while(fast!=null &amp;&amp; fast.next!=null){ //变换fast和slow fast = fast.next.next; slow = slow.next; if (fast.equals(slow)){ return true; } } return false; } //结点类 private static class Node&lt;T&gt; { //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } } 快慢指针查找有环链表入口。当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。 public class CircleListInTest { public static void main(String[] args) throws Exception { Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null); Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null); Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null); Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null); Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null); Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null); Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null); //完成结点之间的指向 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven; //产生环 seven.next = third; //查找环的入口结点 Node&lt;String&gt; entrance = getEntrance(first); System.out.println(&quot;first链表中环的入口结点元素为：&quot;+entrance.item); } /** * 查找有环链表中环的入口结点 * @param first 链表首结点 * @return 环的入口结点 */ public static Node getEntrance(Node&lt;String&gt; first) { //定义快慢指针 Node&lt;String&gt; fast = first; Node&lt;String&gt; slow = first; Node&lt;String&gt; temp = null; //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口 while(fast!=null &amp;&amp; fast.next!=null){ //变换快慢指针 fast = fast.next.next; slow = slow.next; //判断快慢指针是否相遇 if (fast.equals(slow)){ temp = first; continue; } //让临时结点变换 if (temp!=null){ temp = temp.next; //判断临时指针是否和慢指针相遇 if (temp.equals(slow)){ break; } } } return temp; } //结点类 private static class Node&lt;T&gt; { //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } } 循环链表 在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。 约瑟夫问题 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；使用计数器count，记录当前报数的值；遍历链表，每循环一次，count++；判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0。 public class JosephTest { public static void main(String[] args) { //解决约瑟夫问题 //1.构建循环链表，包含41个结点，分别存储1~41之间的值 //用来就首结点 Node&lt;Integer&gt; first = null; //用来记录前一个结点 Node&lt;Integer&gt; pre = null; for(int i = 1;i&lt;=41;i++){ //如果是第一个结点 if (i==1){ first = new Node&lt;&gt;(i,null); pre = first; continue; } //如果不是第一个结点 Node&lt;Integer&gt; newNode = new Node&lt;&gt;(i, null); pre.next=newNode; pre=newNode; //如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first,变为循环链表了 if (i==41){ pre.next=first; } } //2.需要count计数器，模拟报数 int count=0; //3.遍历循环链表 //记录每次遍历拿到的结点，默认从首结点开始 Node&lt;Integer&gt; n = first; //记录当前结点的上一个结点 Node&lt;Integer&gt; before = null; while(n!=n.next){ //模拟报数 count++; //判断当前报数是不是为3 if (count==3){ //如果是3，则把当前结点删除调用，打印当前结点，重置count=0，让当前结点n后移 before.next=n.next; System.out.print(n.item+&quot;,&quot;); count=0; n=n.next; }else{ //如果不是3，让before变为当前结点，让当前结点后移； before=n; n=n.next; } } //打印最后一个元素 System.out.println(n.item); } //结点类 private static class Node&lt;T&gt; { //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } } 栈 栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。 我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。 代码实现 压栈、弹栈、遍历。 public class Stack&lt;T&gt; implements Iterable&lt;T&gt;{ //记录首结点 private Node head; //栈中元素的个数 private int N; private class Node{ public T item; public Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public Stack() { this.head = new Node(null,null); this.N=0; } //判断当前栈中元素个数是否为0 public boolean isEmpty(){ return N==0; } //获取栈中元素的个数 public int size(){ return N; } //把t元素压入栈 public void push(T t){ //找到首结点指向的第一个结点 Node oldFirst = head.next; //创建新结点 Node newNode = new Node(t, null); //让首结点指向新结点 head.next = newNode; //让新结点指向原来的第一个结点 newNode.next=oldFirst; //元素个数+1； N++; } //弹出栈顶元素 public T pop(){ //找到首结点指向的第一个结点 Node oldFirst = head.next; if (oldFirst==null){ return null; } //让首结点指向原来第一个结点的下一个结点 head.next=oldFirst.next; //元素个数-1； N--; return oldFirst.item; } @Override public Iterator&lt;T&gt; iterator() { return new SIterator(); } private class SIterator implements Iterator{ private Node n; public SIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n = n.next; return n.item; } } }- 测试 public class StackTest { public static void main(String[] args) { //创建栈对象 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); //测试压栈 stack.push(&quot;a&quot;); stack.push(&quot;b&quot;); stack.push(&quot;c&quot;); stack.push(&quot;d&quot;); for (String item : stack) { System.out.println(item); } System.out.println(&quot;------------------------------&quot;); //测试弹栈 String result = stack.pop(); System.out.println(&quot;弹出的元素是：&quot;+result); System.out.println(&quot;剩余的元素个数：&quot;+stack.size()); } } 括号匹配问题 给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。 创建一个栈用来存储左括号；从左往右遍历字符串，拿到每一个字符；判断该字符是不是左括号，如果是，放入栈中存储；判断该字符是不是右括号，如果不是，继续下一次循环；如果该字符是右括号，则从栈中弹出一个元素t；判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号；循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配。 public class BracketsMatchTest { public static void main(String[] args) { String str = &quot;上海(长安)())&quot;; boolean match = isMatch(str); System.out.println(str+&quot;中的括号是否匹配：&quot;+match); } /** * 判断str中的括号是否匹配 * @param str 括号组成的字符串 * @return 如果匹配，返回true，如果不匹配，返回false */ public static boolean isMatch(String str){ //1.创建栈对象，用来存储左括号 Stack&lt;String&gt; chars = new Stack&lt;&gt;(); //2.从左往右遍历字符串 for (int i = 0; i &lt; str.length(); i++) { String currChar = str.charAt(i)+ &quot;&quot;; //3.判断当前字符是否为左括号，如果是，则把字符放入到栈中 if (currChar.equals(&quot;(&quot;)){ chars.push(currChar); }else if(currChar.equals(&quot;)&quot;)){ //4.继续判断当前字符是否是有括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null,如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号 String pop = chars.pop(); if (pop==null){ return false; } } } //5.判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配 if (chars.size()==0){ return true; }else{ return false; } } } 逆波兰表达式求值 创建一个栈对象oprands存储操作数；从左往右遍历逆波兰表达式，得到每一个字符串；判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中；如果是运算符，则从oprands栈中弹出两个操作数o1,o2；使用该运算符计算o1和o2，得到结果result；把该结果压入oprands栈中 ；遍历结束后，拿出栈中最终的结果返回。 public class ReversePolishNotationTest { public static void main(String[] args) { //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9 String[] notation = {&quot;3&quot;, &quot;17&quot;, &quot;15&quot;, &quot;-&quot;, &quot;*&quot;, &quot;18&quot;, &quot;6&quot;, &quot;/&quot;, &quot;+&quot;}; int result = caculate(notation); System.out.println(&quot;逆波兰表达式的结果为：&quot; + result); } /** * @param notaion 逆波兰表达式的数组表示方式 * @return 逆波兰表达式的计算结果 */ public static int caculate(String[] notaion) { //1.定义一个栈，用来存储操作数 Stack&lt;Integer&gt; oprands = new Stack&lt;&gt;(); //2.从左往右遍历逆波兰表达式，得到每一个元素 for (int i = 0; i &lt; notaion.length; i++) { String curr = notaion[i]; //3.判断当前元素是运算符还是操作数 Integer o1; Integer o2; Integer result; switch (curr) { case &quot;+&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 + o1; oprands.push(result); break; case &quot;-&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 - o1; oprands.push(result); break; case &quot;*&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 * o1; oprands.push(result); break; case &quot;/&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 / o1; oprands.push(result); break; default: //5.操作数，把该操作数放入到栈中； oprands.push(Integer.parseInt(curr)); break; } } //6.得到栈中最后一个元素，就是逆波兰表达式的结果 int result = oprands.pop(); return result; } } 队列 队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。 实现 插入、删除、遍历。 public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{ //记录首结点 private Node head; //记录最后一个结点 private Node last; //记录队列中元素的个数 private int N; private class Node{ public T item; public Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public Queue() { this.head = new Node(null,null); this.last=null; this.N=0; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素的个数 public int size(){ return N; } //向队列中插入元素t public void enqueue(T t){ if (last==null){ //当前尾结点last为null last= new Node(t,null); head.next=last; } else { //当前尾结点last不为null Node oldLast = last; last = new Node(t, null); oldLast.next=last; } //元素个数+1 N++; } //从队列中拿出一个元素 public T dequeue(){ if (isEmpty()){ return null; } Node oldFirst = head.next; head.next = oldFirst.next; N--; //因为出队列其实是在删除元素，因此如果队列中的元素被删除完了，需要重置last=null; if (isEmpty()){ last=null; } return oldFirst.item; } @Override public Iterator&lt;T&gt; iterator() { return new QIterator(); } private class QIterator implements Iterator{ private Node n; public QIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n = n.next; return n.item; } } } 测试 public class QueueTest { public static void main(String[] args) { //创建队列对象 Queue&lt;String&gt; q = new Queue&lt;&gt;(); //测试队列的enqueue方法 q.enqueue(&quot;a&quot;); q.enqueue(&quot;b&quot;); q.enqueue(&quot;c&quot;); q.enqueue(&quot;d&quot;); for (String str : q) { System.out.println(str); } System.out.println(&quot;-------------------------------&quot;); //测试队列的dequeue方法 String result = q.dequeue(); System.out.println(&quot;出队列的元素是：&quot;+result); System.out.println(&quot;剩余的元素个数：&quot;+q.size()); } } 符号表 符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。符号表中，键具有唯一性。 实现 public class SymbolTable&lt;Key,Value&gt; { //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node{ //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } public SymbolTable() { this.head = new Node(null,null,null); this.N=0; } //获取符号表中键值对的个数 public int size(){ return N; } //往符号表中插入键值对 public void put(Key key,Value value){ //符号表中已经存在了键为key的键值对，那么只需要找到该结点，替换值为value即可 Node n = head; while(n.next!=null){ //变换n n = n.next; //判断n结点存储的键是否为key，如果是，则替换n结点的值 if (n.key.equals(key)){ n.value = value; return; } } //如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部 head.next=新结点即可 Node newNode = new Node(key, value, null); Node oldFirst = head.next; newNode.next = oldFirst; head.next = newNode; //元素个数+1； N++; } //删除符号表中键为key的键值对 public void delete(Key key){ //找到键为key的结点，把该结点从链表中删除 Node n = head; while(n.next!=null){ //判断n结点的下一个结点的键是否为key，如果是，就删除该结点 if (n.next.key.equals(key)){ n.next = n.next.next; N--; return; } //变换n n = n.next; } } //从符号表中获取key对应的值 public Value get(Key key){ //找到键为key的结点 Node n = head; while(n.next!=null){ //变换n n = n.next; if (n.key.equals(key)){ return n.value; } } return null; } } 测试 public class SymbolTableTest { public static void main(String[] args) { //创建符号表对象 SymbolTable&lt;Integer, String&gt; symbolTable = new SymbolTable&lt;&gt;(); //测试put方法（插入,替换） symbolTable.put(1,&quot;乔峰&quot;); symbolTable.put(2,&quot;虚竹&quot;); symbolTable.put(3,&quot;段誉&quot;); System.out.println(&quot;插入完毕后，元素的个数为:&quot;+symbolTable.size()); symbolTable.put(2, &quot;慕容复&quot;); System.out.println(&quot;替换完毕后的元素的个数为:&quot;+symbolTable.size()); //测试get方法 System.out.println(&quot;替换完毕后，键2对应的值为:&quot;+symbolTable.get(2)); //测试删除方法 symbolTable.delete(2); System.out.println(&quot;删除完毕后，元素的个数:&quot;+symbolTable.size()); } } 有序符号表 要根据键的大小进行排序，插入数据时要考虑顺序。 public class OrderSymbolTable&lt;Key extends Comparable&lt;Key&gt;,Value&gt; { //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node{ //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } public OrderSymbolTable() { this.head = new Node(null,null,null); this.N=0; } //获取符号表中键值对的个数 public int size(){ return N; } //往符号表中插入键值对 public void put(Key key,Value value){ //定义两个Node变量，分别记录当前结点和当前结点的上一个结点 Node curr = head.next; Node pre = head; while(curr!=null &amp;&amp; key.compareTo(curr.key)&gt;0){ //变换当前结点和前一个结点即可 pre = curr; curr = curr.next; } //如果当前结点curr的键和要插入的key一样，则替换 if (curr!=null &amp;&amp; key.compareTo(curr.key)==0){ curr.value = value; return; } //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前 Node newNode = new Node(key, value, curr); pre.next = newNode; //元素的个数+1； N++; } //删除符号表中键为key的键值对 public void delete(Key key){ //找到键为key的结点，把该结点从链表中删除 Node n = head; while(n.next!=null){ //判断n结点的下一个结点的键是否为key，如果是，就删除该结点 if (n.next.key.equals(key)){ n.next = n.next.next; N--; return; } //变换n n = n.next; } } //从符号表中获取key对应的值 public Value get(Key key){ //找到键为key的结点 Node n = head; while(n.next!=null){ //变换n n = n.next; if (n.key.equals(key)){ return n.value; } } return null; } } 测试 public class OrderSymbolTableTest { public static void main(String[] args) { //创建有序符号表对象 OrderSymbolTable&lt;Integer, String&gt; table = new OrderSymbolTable&lt;&gt;(); table.put(1,&quot;张三&quot;); table.put(2,&quot;李四&quot;); table.put(4,&quot;赵六&quot;); table.put(7,&quot;田七&quot;); table.put(3,&quot;王五&quot;); } } 二叉树定义 树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。树具有以下特点：每个结点有零个或多个子结点；没有父结点的结点为根结点；每一个非根结点只有一个父结点；每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树。 结点的度：一个结点含有的子树的个数称为该结点的度。 叶结点：度为0的结点称为叶结点，也可以叫做终端结点。 分支结点：度不为0的结点称为分支结点，也可以叫做非终端结点。 结点的层次：从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。 结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。 树的度：树中所有结点的度的最大值。 树的高度(深度)：树中结点的最大层次。 森林：m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树。 孩子结点：一个结点的直接后继结点称为该结点的孩子结点。 双亲结点(父结点)：一个结点的直接前驱称为该结点的双亲结点。 兄弟结点：同一双亲结点的孩子结点间互称兄弟结点。 二叉树就是度不超过2的树(每个结点最多有两个子结点)。 一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。 完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 二叉查找树基于链表的实现 插入方法put实现思想：如果当前树中没有任何一个结点，则直接把新结点当做根结点使用。如果当前树不为空，则从根结点开始：如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。 查询方法get实现思想：从根节点开始：如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；如果要查询的key等于当前结点的key，则树中返回当前结点的value。 删除方法delete实现思想：找到被删除结点；找到被删除结点右子树中的最小结点minNode；删除右子树中的最小结点；让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树；让被删除结点的父节点指向最小结点minNode。 查找最小键、查找最大键。 把树由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式： 前序遍历：先访问根结点，然后再访问左子树，最后访问右子树。中序遍历：先访问左子树，中间访问根节点，最后访问右子树。后序遍历：先访问左子树，再访问右子树，最后访问根节点。 前序遍历步骤：把当前结点的key放入到队列中;找到当前结点的左子树，如果不为空，递归遍历左子树；找到当前结点的右子树，如果不为空，递归遍历右子树。 中序遍历实现步骤：找到当前结点的左子树，如果不为空，递归遍历左子树；把当前结点的key放入到队列中;找到当前结点的右子树，如果不为空，递归遍历右子树。 后序遍历实现步骤：找到当前结点的左子树，如果不为空，递归遍历左子树；找到当前结点的右子树，如果不为空，递归遍历右子树；把当前结点的key放入到队列中。 层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值。实现步骤：创建队列，存储每一层的结点；使用循环从队列中弹出一个结点：获取当前结点的key；如果当前结点的左子结点不为空，则把左子结点放入到队列中；如果当前结点的右子结点不为空，则把右子结点放入到队列中。 最大深度：如果根结点为空，则最大深度为0；计算左子树的最大深度；计算右子树的最大深度；当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1。 public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { //记录根结点 private Node root; //记录树中元素的个数 private int N; private class Node { //存储键 public Key key; //存储值 private Value value; //记录左子结点 public Node left; //记录右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this.key = key; this.value = value; this.left = left; this.right = right; } } //获取树中元素的个数 public int size() { return N; } //向树中添加元素key-value public void put(Key key, Value value) { root = put(root, key, value); } //向指定的树x中添加key-value,并返回添加元素后新的树 private Node put(Node x, Key key, Value value) { //如果x子树为空， if (x==null){ N++; return new Node(key,value, null,null); } //如果x子树不为空 //比较x结点的键和key的大小： int cmp = key.compareTo(x.key); if (cmp&gt;0){ //如果key大于x结点的键，则继续找x结点的右子树 x.right = put(x.right,key,value); }else if(cmp&lt;0){ //如果key小于x结点的键，则继续找x结点的左子树 x.left = put(x.left,key,value); }else{ //如果key等于x结点的键，则替换x结点的值为value即可 x.value = value; } return x; } //查询树中指定key对应的value public Value get(Key key) { return get(root,key); } //从指定的树x中，查找key对应的值 public Value get(Node x, Key key) { //x树为null if (x==null){ return null; } //x树不为null //比较key和x结点的键的大小 int cmp = key.compareTo(x.key); if (cmp&gt;0){ //如果key大于x结点的键，则继续找x结点的右子树 return get(x.right,key); }else if(cmp&lt;0){ //如果key小于x结点的键，则继续找x结点的左子树 return get(x.left,key); }else{ //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可 return x.value; } } //删除树中key对应的value public void delete(Key key) { delete(root, key); } //删除指定树x中的key对应的value，并返回删除后的新树 public Node delete(Node x, Key key) { //x树为null if (x==null){ return null; } //x树不为null int cmp = key.compareTo(x.key); if (cmp&gt;0){ //如果key大于x结点的键，则继续找x结点的右子树 x.right = delete(x.right,key); }else if(cmp&lt;0){ //如果key小于x结点的键，则继续找x结点的左子树 x.left = delete(x.left,key); }else{ //如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x； //让元素个数-1 N--; //得找到右子树中最小的结点 if (x.right==null){ return x.left; } if (x.left==null){ return x.right; } Node minNode = x.right; while(minNode.left!=null){ minNode = minNode.left; } //删除右子树中最小的结点 Node n = x.right; while(n.left!=null){ if (n.left.left==null){ n.left=null; }else{ //变换n结点即可 n = n.left; } } //让x结点的左子树成为minNode的左子树 minNode.left = x.left; //让x结点的右子树成为minNode的右子树 minNode.right = x.right; //让x结点的父结点指向minNode x = minNode; } return x; } //查找整个树中最小的键 public Key min(){ return min(root).key; } //在指定树x中找出最小键所在的结点 private Node min(Node x){ //需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点 if (x.left!=null){ return min(x.left); }else{ return x; } } //在整个树中找到最大的键 public Key max(){ return max(root).key; } //在指定的树x中，找到最大的键所在的结点 public Node max(Node x){ //判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点 if (x.right!=null){ return max(x.right); }else{ return x; } } //获取整个树中所有的键 public Queue&lt;Key&gt; preErgodic(){ Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); preErgodic(root, keys); return keys; } //获取指定树x的所有键，并放到keys队列中 private void preErgodic(Node x,Queue&lt;Key&gt; keys){ if (x==null){ return; } //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } } //使用中序遍历获取树中所有的键 public Queue&lt;Key&gt; midErgodic(){ Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); midErgodic(root,keys); return keys; } //使用中序遍历，获取指定树x中所有的键，并存放到key中 private void midErgodic(Node x,Queue&lt;Key&gt; keys){ if (x==null){ return; } //先递归，把左子树中的键放到keys中 if (x.left!=null){ midErgodic(x.left,keys); } //把当前结点x的键放到keys中 keys.enqueue(x.key); //在递归，把右子树中的键放到keys中 if(x.right!=null){ midErgodic(x.right,keys); } } //使用后序遍历，把整个树中所有的键返回 public Queue&lt;Key&gt; afterErgodic(){ Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); afterErgodic(root,keys); return keys; } //使用后序遍历，把指定树x中所有的键放入到keys中 private void afterErgodic(Node x,Queue&lt;Key&gt; keys){ if (x==null){ return ; } //通过递归把左子树中所有的键放入到keys中 if (x.left!=null){ afterErgodic(x.left,keys); } //通过递归把右子树中所有的键放入到keys中 if (x.right!=null){ afterErgodic(x.right,keys); } //把x结点的键放入到keys中 keys.enqueue(x.key); } //使用层序遍历，获取整个树中所有的键 public Queue&lt;Key&gt; layerErgodic(){ //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes = new Queue&lt;&gt;(); //默认，往队列中放入根结点 nodes.enqueue(root); while(!nodes.isEmpty()){ //从队列中弹出一个结点，把key放入到keys中 Node n = nodes.dequeue(); keys.enqueue(n.key); //判断当前结点还有没有左子结点，如果有，则放入到nodes中 if (n.left!=null){ nodes.enqueue(n.left); } //判断当前结点还有没有右子结点，如果有，则放入到nodes中 if (n.right!=null){ nodes.enqueue(n.right); } } return keys; } //获取整个树的最大深度 public int maxDepth(){ return maxDepth(root); } //获取指定树x的最大深度 private int maxDepth(Node x){ if (x==null){ return 0; } //x的最大深度 int max=0; //左子树的最大深度 int maxL=0; //右子树的最大深度 int maxR=0; //计算x结点左子树的最大深度 if (x.left!=null){ maxL = maxDepth(x.left); } //计算x结点右子树的最大深度 if (x.right!=null){ maxR = maxDepth(x.right); } //比较左子树最大深度和右子树最大深度，取较大值+1即可 max = maxL&gt;maxR?maxL+1:maxR+1; return max; } } 代码测试 public class BinaryTreeTest { public static void main(String[] args) { //创建二叉查找树对象 BinaryTree&lt;Integer, String&gt; tree = new BinaryTree&lt;&gt;(); //测试插入 tree.put(1,&quot;张三&quot;); tree.put(2,&quot;李四&quot;); tree.put(3,&quot;王五&quot;); System.out.println(&quot;插入完毕后元素的个数：&quot;+tree.size()); //测试获取 System.out.println(&quot;键2对应的元素是：&quot;+tree.get(2)); //测试删除 tree.delete(3); System.out.println(&quot;删除后的元素个数：&quot;+tree.size()); System.out.println(&quot;删除后键3对应的元素:&quot;+tree.get(3)); } } 遍历测试 public class BinaryTreeErgodicTest { /*//测试前序遍历 public static void main(String[] args) { //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.preErgodic(); for (String key : keys) { String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); } }*/ //测试中序遍历 /* public static void main(String[] args) { //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.midErgodic(); for (String key : keys) { String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); } }*/ //测试后序遍历 /*public static void main(String[] args) { //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.afterErgodic(); for (String key : keys) { String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); } }*/ //测试层序遍历 public static void main(String[] args) { //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.layerErgodic(); for (String key : keys) { String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); } } } 最大深度测试 public class BinaryTreeMaxDepthTest { public static void main(String[] args) { //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); int maxDepth = tree.maxDepth(); System.out.println(maxDepth); } } 折纸问题 纸条对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up。 根结点为下折痕；每一个结点的左子结点为下折痕；每一个结点的右子结点为上折痕。 public class PagerFoldingTest { public static void main(String[] args) { //模拟这只过程，产生树 Node&lt;String&gt; tree = createTree(2); //遍历树，打印每个结点 printTree(tree); } //通过模拟对折N次纸，产生树 public static Node&lt;String&gt; createTree(int N){ //定义根结点 Node&lt;String&gt; root=null; for (int i = 0; i &lt; N; i++) { //1.当前是第一次对折 if (i==0){ root = new Node&lt;&gt;(&quot;down&quot;,null,null); continue; } //2.当前不是第一次对折 //定义一个辅助队列，通过层序遍历的思想，找到叶子结点，叶子结点添加子节点 Queue&lt;Node&gt; queue = new Queue&lt;&gt;(); queue.enqueue(root); //循环遍历队列 while(!queue.isEmpty()){ //从队列中弹出一个结点 Node&lt;String&gt; tmp = queue.dequeue(); //如果有左子结点，则把左子结点放入到队列中 if (tmp.left!=null){ queue.enqueue(tmp.left); } //如果有右子结点，则把右子结点放入到队列中 if (tmp.right!=null){ queue.enqueue(tmp.right); } //如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可 if (tmp.left==null &amp;&amp; tmp.right==null){ tmp.left = new Node&lt;String&gt;(&quot;down&quot;, null,null); tmp.right = new Node&lt;String&gt;(&quot;up&quot;,null,null); } } } return root; } //打印树中每个结点到控制台 public static void printTree(Node&lt;String&gt; root){ //需要使用中序遍历完成 if (root==null){ return; } //打印左子树的每个结点 if (root.left!=null){ printTree(root.left); } //打印当前结点 System.out.print(root.item+&quot; &quot;); //打印右子树的每个结点 if (root.right!=null){ printTree(root.right); } } //结点类 private static class Node&lt;T&gt;{ public T item;//存储元素 public Node left; public Node right; public Node(T item, Node left, Node right) { this.item = item; this.left = left; this.right = right; } } } 堆 堆通常可以被看做是一棵完全二叉树的数组对象。 完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。 二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。 如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。 每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟之前的二叉查找树是有区别的。 API实现 如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。 当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。 public class Heap&lt;T extends Comparable&lt;T&gt;&gt; { //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public Heap(int capacity) { this.items= (T[]) new Comparable[capacity+1]; this.N=0; } //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i,int j){ return items[i].compareTo(items[j])&lt;0; } //交换堆中i索引和j索引处的值 private void exch(int i,int j){ T temp = items[i]; items[i] = items[j]; items[j] = temp; } //往堆中插入一个元素 public void insert(T t){ items[++N]=t; swim(N); } //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k){ //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置 while(k&gt;1){ //比较当前结点和其父结点 if (less(k/2,k)){ exch(k/2,k); } k = k/2; } } //删除堆中最大的元素,并返回这个最大元素 public T delMax(){ T max = items[1]; //交换索引1处的元素和最大索引处的元素，让完全二叉树中最右侧的元素变为临时根结点 exch(1,N); //最大索引处的元素删除掉 items[N]=null; //元素个数-1 N--; //通过下沉调整堆，让堆重新有序 sink(1); return max; } //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k){ //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置 while(2*k&lt;=N){ //获取当前结点的子结点中的较大结点 int max;//记录较大结点所在的索引 if (2*k+1&lt;=N){ if (less(2*k,2*k+1)){ max=2*k+1; }else{ max=2*k; } }else { max = 2*k; } //比较当前结点和较大结点的值 if (!less(k,max)){ break; } //交换k索引处的值和max索引处的值 exch(k,max); //变换k的值 k = max; } } public static void main(String[] args) { Heap&lt;String&gt; heap = new Heap&lt;String&gt;(20); heap.insert(&quot;A&quot;); heap.insert(&quot;B&quot;); heap.insert(&quot;C&quot;); heap.insert(&quot;D&quot;); heap.insert(&quot;E&quot;); heap.insert(&quot;F&quot;); heap.insert(&quot;G&quot;); String del; while((del=heap.delMax())!=null){ System.out.print(del+&quot;,&quot;); } } } 测试 public class HeapTest { public static void main(String[] args) { //创建堆对象 Heap&lt;String&gt; heap = new Heap&lt;&gt;(10); //往堆中存入字符串数据 heap.insert(&quot;A&quot;); heap.insert(&quot;B&quot;); heap.insert(&quot;C&quot;); heap.insert(&quot;D&quot;); heap.insert(&quot;E&quot;); heap.insert(&quot;F&quot;); heap.insert(&quot;G&quot;); //通过循环从堆中删除数据 String result = null; while((result = heap.delMax())!=null){ System.out.print(result+&quot; &quot;); } } } 利用堆进行排序 构造堆；得到堆顶元素，这个值就是最大值；交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；重复上述步骤，直到堆中剩一个元素为止。 堆构造过程：创建一个新数组，把原数组0~length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后对扫描到的每一个元素做下沉调整即可。 堆排序过程：对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。将堆顶元素和堆中最后一个元素交换位置；通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)；重复上面步骤，直到堆中剩最后一个元素。 实现： public class HeapSort { //判断heap堆中索引i处的元素是否小于索引j处的元素 private static boolean less(Comparable[] heap, int i, int j) { return heap[i].compareTo(heap[j])&lt;0; } //交换heap堆中i索引和j索引处的值 private static void exch(Comparable[] heap, int i, int j) { Comparable tmp = heap[i]; heap[i] = heap[j]; heap[j] = tmp; } //根据原数组source，构造出堆heap private static void createHeap(Comparable[] source, Comparable[] heap) { //把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆 System.arraycopy(source,0,heap,1,source.length); //对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描) for (int i = (heap.length)/2;i&gt;0;i--){ sink(heap,i,heap.length-1); } } //对source数组中的数据从小到大排序 public static void sort(Comparable[] source) { //构建堆 Comparable[] heap = new Comparable[source.length+1]; createHeap(source,heap); //定义一个变量，记录未排序的元素中最大的索引 int N = heap.length-1; //通过循环，交换1索引处的元素和排序的元素中最大的索引处的元素 while(N!=1){ //交换元素 exch(heap,1,N); //排序交换后最大元素所在的索引，让它不要参与堆的下沉调整 N--; //需要对索引1处的元素进行对的下沉调整 sink(heap,1, N); } //把heap中的数据复制到原数组source中 System.arraycopy(heap,1,source,0,source.length); } //在heap堆中，对target处的元素做下沉，范围是0~range private static void sink(Comparable[] heap, int target, int range){ while(2*target&lt;=range){ //1.找出当前结点的较大的子结点 int max; if (2*target+1&lt;=range){ if (less(heap,2*target,2*target+1)){ max = 2*target+1; }else{ max = 2*target; } }else{ max = 2*target; } //2.比较当前结点的值和较大子结点的值 if (!less(heap,target,max)){ break; } exch(heap,target,max); target = max; } } } 测试 public class HeapSortTest { public static void main(String[] args) { //待排序数组 String[] arr = {&quot;S&quot;,&quot;O&quot;,&quot;R&quot;,&quot;T&quot;,&quot;E&quot;,&quot;X&quot;,&quot;A&quot;,&quot;M&quot;,&quot;P&quot;,&quot;L&quot;,&quot;E&quot;}; //通过HeapSort对数组中的元素进行排序 HeapSort.sort(arr); //打印排序后数组中的元素 System.out.println(Arrays.toString(arr)); } } 优先队列最大优先队列 可以获取并删除队列中最大的值。基于堆区实现最大优先队列。 public class MaxPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; { //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public MaxPriorityQueue(int capacity) { this.items = (T[]) new Comparable[capacity+1]; this.N= 0; } //获取队列中元素的个数 public int size() { return N; } //判断队列是否为空 public boolean isEmpty() { return N==0; } //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i, int j) { return items[i].compareTo(items[j])&lt;0; } //交换堆中i索引和j索引处的值 private void exch(int i, int j) { T tmp = items[i]; items[i] = items[j]; items[j] = tmp; } //往堆中插入一个元素 public void insert(T t) { items[++N] = t; swim(N); } //删除堆中最大的元素,并返回这个最大元素 public T delMax() { T max = items[1]; exch(1,N); N--; sink(1); return max; } //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) { while(k&gt;1){ if (less(k/2,k)){ exch(k/2,k); } k = k/2; } } //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) { while(2*k&lt;=N){ int max; if (2*k+1&lt;=N){ if (less(2*k,2*k+1)){ max=2*k+1; }else{ max = 2*k; } }else { max = 2*k; } if (!less(k,max)){ break; } exch(k,max); k = max; } } } 测试 public class MaxPriorityQueueTest { public static void main(String[] args) { //创建优先队列 MaxPriorityQueue&lt;String&gt; queue = new MaxPriorityQueue&lt;&gt;(10); //往队列中存储元素 queue.insert(&quot;A&quot;); queue.insert(&quot;B&quot;); queue.insert(&quot;C&quot;); queue.insert(&quot;D&quot;); queue.insert(&quot;E&quot;); queue.insert(&quot;F&quot;); queue.insert(&quot;G&quot;); //通过循环从队列中获取最大的元素 while(!queue.isEmpty()){ String max = queue.delMax(); System.out.print(max+&quot; &quot;); } } } 最小优先队列 可以获取并删除队列中最小的值。基于堆来完成最小优先队列：最小的元素放在数组的索引1处；每个结点的数据总是小于等于它的两个子结点的数据。 public class MinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; { //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public MinPriorityQueue(int capacity) { this.items = (T[]) new Comparable[capacity+1]; this.N=0; } //获取队列中元素的个数 public int size() { return N; } //判断队列是否为空 public boolean isEmpty() { return N==0; } //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i, int j) { return items[i].compareTo(items[j])&lt;0; } //交换堆中i索引和j索引处的值 private void exch(int i, int j) { T tmp = items[i]; items[i] = items[j]; items[j] = tmp; } //往堆中插入一个元素 public void insert(T t) { items[++N] = t; swim(N); } //删除堆中最小的元素,并返回这个最小元素 public T delMin() { T min = items[1]; exch(1,N); N--; sink(1); return min; } //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) { //通过循环比较当前结点和其父结点的大小 while(k&gt;1){ if (less(k,k/2)){ exch(k,k/2); } k = k/2; } } //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) { //通过循环比较当前结点和其子结点中的较小值 while(2*k&lt;=N){ //1.找到子结点中的较小值 int min; if (2*k+1&lt;=N){ if (less(2*k, 2*k+1)){ min = 2*k; }else{ min = 2*k+1; } }else{ min = 2*k; } //2.判断当前结点和较小值的大小 if (less(k,min)){ break; } exch(k,min); k = min; } } } 测试 public class MinPriorityQueueTest { public static void main(String[] args) { //创建最小优先队列对象 MinPriorityQueue&lt;String&gt; queue = new MinPriorityQueue&lt;String&gt;(10); //往队列中存数据 queue.insert(&quot;G&quot;); queue.insert(&quot;F&quot;); queue.insert(&quot;E&quot;); queue.insert(&quot;D&quot;); queue.insert(&quot;C&quot;); queue.insert(&quot;B&quot;); queue.insert(&quot;A&quot;); //通过循环获取最小优先队列中的元素 while(!queue.isEmpty()){ String min = queue.delMin(); System.out.print(min+&quot; &quot;); } } } 索引优先队列 存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。 用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。 数组int[]pq,来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。 数组int[] qp,用来存储pq的逆序。例如：在pq数组中：pq[1]=6;那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1。 代码实现 public class IndexMinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; { //存储堆中的元素 private T[] items; //保存每个元素在items数组中的索引，pq数组需要堆有序 private int[] pq; //保存qp的逆序，pq的值作为索引，pq的索引作为值 private int[] qp; //记录堆中元素的个数 private int N; public IndexMinPriorityQueue(int capacity) { this.items = (T[]) new Comparable[capacity+1]; this.pq = new int[capacity+1]; this.qp= new int[capacity+1]; this.N = 0; //默认情况下，队列中没有存储任何数据，让qp中的元素都为-1； for (int i = 0; i &lt; qp.length; i++) { qp[i]=-1; } } //获取队列中元素的个数 public int size() { return N; } //判断队列是否为空 public boolean isEmpty() { return N==0; } //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i, int j) { return items[pq[i]].compareTo(items[pq[j]])&lt;0; } //交换堆中i索引和j索引处的值 private void exch(int i, int j) { //交换pq中的数据 int tmp = pq[i]; pq[i] = pq[j]; pq[j] = tmp; //更新qp中的数据 qp[pq[i]]=i; qp[pq[j]] =j; } //判断k对应的元素是否存在 public boolean contains(int k) { return qp[k] !=-1; } //最小元素关联的索引 public int minIndex() { return pq[1]; } //往队列中插入一个元素,并关联索引i public void insert(int i, T t) { //判断i是否已经被关联，如果已经被关联，则不让插入 if (contains(i)){ return; } //元素个数+1 N++; //把数据存储到items对应的i位置处 items[i] = t; //把i存储到pq中 pq[N] = i; //通过qp来记录pq中的i qp[i]=N; //通过堆上浮完成堆的调整 swim(N); } //删除队列中最小的元素,并返回该元素关联的索引 public int delMin() { //获取最小元素关联的索引 int minIndex = pq[1]; //交换pq中索引1处和最大索引处的元素 exch(1,N); //删除qp中对应的内容 qp[pq[N]] = -1; //删除pq最大索引处的内容 pq[N]=-1; //删除items中对应的内容 items[minIndex] = null; //元素个数-1 N--; //下沉调整 sink(1); return minIndex; } //删除索引i关联的元素 public void delete(int i) { //找到i在pq中的索引 int k = qp[i]; //交换pq中索引k处的值和索引N处的值 exch(k,N); //删除qp中的内容 qp[pq[N]] = -1; //删除pq中的内容 pq[N]=-1; //删除items中的内容 items[k]=null; //元素的数量-1 N--; //堆的调整 sink(k); swim(k); } //把与索引i关联的元素修改为为t public void changeItem(int i, T t) { //修改items数组中i位置的元素为t items[i] = t; //找到i在pq中出现的位置 int k = qp[i]; //堆调整 sink(k); swim(k); } //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) { while(k&gt;1){ if (less(k,k/2)){ exch(k,k/2); } k = k/2; } } //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) { while(2*k&lt;=N){ //找到子结点中的较小值 int min; if (2*k+1&lt;=N){ if (less(2*k,2*k+1)){ min = 2*k; }else{ min = 2*k+1; } }else{ min = 2*k; } //比较当前结点和较小值 if (less(k,min)){ break; } exch(k,min); k = min; } } } 测试代码 public class IndexMinPriorityQueueTest { public static void main(String[] args) { //创建索引最小优先队列对象 IndexMinPriorityQueue&lt;String&gt; queue = new IndexMinPriorityQueue&lt;&gt;(10); //往队列中添加元素 queue.insert(0,&quot;A&quot;); queue.insert(1,&quot;C&quot;); queue.insert(2,&quot;F&quot;); //测试修改 queue.changeItem(2,&quot;B&quot;); //测试删除 while(!queue.isEmpty()){ int index = queue.delMin(); System.out.print(index+&quot; &quot;); } } } 平衡树2-3查找树 2-结点：含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点：含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 查找：要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。 向2-结点中插入新键：查找后未找到的节点是一个2-结点，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。 一棵完全平衡的2-3树具有以下性质：任意空链接到根结点的路径长度都是相等的。4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。 直接实现2-3树比较复杂，但是2-3查找树作为一种比较重要的概念和思路对于红黑树、B树和B+树非常重要。 红黑树 红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。 我们将树中的链接分为两种类型：红链接：将两个2-结点连接起来构成一个3-结点。黑链接：则是2-3树中的普通链接。 确切的说，我们将3-结点表示为由一条左斜的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。 红黑树是含有红黑链接并满足下列条件的二叉查找树：红链接均为左链接；没有任何一个结点同时和两条红链接相连；该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。 左旋：当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。前提：当前结点为h，它的右子结点为x。左旋过程：让x的左子结点变为h的右子结点：h.right=x.left;让h成为x的左子结点：x.left=h;让h的color属性变为x的color属性值：x.color=h.color;让h的color属性变为RED：h.color=true。 右旋：当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋。前提：当前结点为h，它的左子结点为x。右旋过程：让x的右子结点成为h的左子结点：h.left = x.right;让h成为x的右子结点：x.right=h;让x的color变为h的color属性值：x.color = h.color;让h的color为RED。 颜色反转：当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。 由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。 代码实现 public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { //根节点 private Node root; //记录树中元素的个数 private int N; //红色链接 private static final boolean RED = true; //黑色链接 private static final boolean BLACK = false; //结点类 private class Node { //存储键 public Key key; //存储值 private Value value; //记录左子结点 public Node left; //记录右子结点 public Node right; //由其父结点指向它的链接的颜色 public boolean color; public Node(Key key, Value value, Node left, Node right, boolean color) { this.key = key; this.value = value; this.left = left; this.right = right; this.color = color; } } //获取树中元素的个数 public int size() { return N; } /** * 判断当前节点的父指向链接是否为红色 * * @param x * @return */ private boolean isRed(Node x) { if (x==null){ return false; } return x.color==RED; } /** * 左旋转 * * @param h * @return */ private Node rotateLeft(Node h) { //找到h结点的右子结点x Node x = h.right; //找到x结点的左子结点，让x结点的左子结点称为h结点的右子结点 h.right = x.left; //让h结点称为x结点的左子结点 x.left = h; //让x结点的color属性变为h结点的color属性 x.color = h.color; //让h结点的color属性变为RED h.color = RED; return x; } /** * 右旋 * * @param h * @return */ private Node rotateRight(Node h) { //找到h结点的左子结点 x Node x = h.left; //让x结点的右子结点成为h结点的左子结点 h.left = x.right; //让h结点成为x结点的右子结点 x.right = h; //让x结点的color属性变为h结点的color属性 x.color = h.color; //让h结点的color属性为RED h.color = RED; return x; } /** * 颜色反转,相当于完成拆分4-节点 * * @param h */ private void flipColors(Node h) { //当前结点变为红色 h.color = RED; //左子结点和右子结点变为黑色 h.left.color=BLACK; h.right.color = BLACK; } /** * 在整个树上完成插入操作 * * @param key * @param val */ public void put(Key key, Value val) { root = put(root,key,val); //根结点的颜色总是黑色 root.color = BLACK; } /** * 在指定树中，完成插入操作,并返回添加元素后新的树 * * @param h * @param key * @param val */ private Node put(Node h, Key key, Value val) { //判断h是否为空，如果为空则直接返回一个红色的结点就可以了 if (h == null){ //数量+1 N++; return new Node(key,val,null,null,BLACK); } //比较h结点的键和key的大小 int cmp = key.compareTo(h.key); if (cmp&lt;0){ //继续往左 h.left = put(h.left,key,val); }else if (cmp&gt;0){ //继续往右 h.right = put(h.right,key,val); }else{ //发生值的替换 h.value = val; } //进行左旋:当当前结点h的左子结点为黑色，右子结点为红色，需要左旋 if (isRed(h.right) &amp;&amp; !isRed(h.left)){ h = rotateLeft(h); } //进行右旋：当当前结点h的左子结点和左子结点的左子结点都为红色，需要右旋 if (isRed(h.left) &amp;&amp; isRed(h.left.left)){ rotateRight(h); } //颜色反转：当前结点的左子结点和右子结点都为红色时，需要颜色反转 if (isRed(h.left) &amp;&amp; isRed(h.right)){ flipColors(h); } return h; } //根据key，从树中找出对应的值 public Value get(Key key) { return get(root,key); } //从指定的树x中，查找key对应的值 public Value get(Node x, Key key) { if (x == null){ return null; } //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp&lt;0){ return get(x.left,key); }else if (cmp&gt;0){ return get(x.right,key); }else{ return x.value; } } } 测试 public class RedBlackTreeTest { public static void main(String[] args) { //创建红黑树 RedBlackTree&lt;String, String&gt; tree = new RedBlackTree&lt;&gt;(); //往树中插入元素 tree.put(&quot;1&quot;,&quot;张三&quot;); tree.put(&quot;2&quot;,&quot;李四&quot;); tree.put(&quot;3&quot;,&quot;王五&quot;); //从树中获取元素 String r1 = tree.get(&quot;1&quot;); System.out.println(r1); String r2 = tree.get(&quot;2&quot;); System.out.println(r2); String r3 = tree.get(&quot;3&quot;); System.out.println(r3); } } B树和B+树B树 B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：每个结点最多有M-1个key，并且以升序排列；每个结点最多能有M个子结点；根结点至少有两个子结点。 在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。 在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。 B+树 B+树是对B树的一种变形树，它与B树的差异在于：非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。 B+ 树的优点在于：由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。 B树的优点在于：由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。 在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题，在很多数据库中，都是用到了B+树来提高查询的效率；在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这个索引就是B+树这种数据结构实现的。 并查集 并查集也是一种树型结构，跟二叉树、红黑树、B树等都不一样，这种树的要求比较简单：每个元素都唯一的对应一个结点；每一组数据中的多个元素都在同一颗树中；一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；元素在树中并没有子父级关系的硬性要求。 实现 初始情况下，并查集中的数据默认分为N个组；初始化数组eleAndGroup；把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i。 如果p和q已经在同一个分组中，则无需合并；如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可；分组数量-1。 public class UF { //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //初始化并查集 public UF(int N){ //初始化分组的数量,默认情况下，有N个分组 this.count = N; //初始化eleAndGroup数组 this.eleAndGroup = new int[N]; //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引 for (int i = 0; i &lt; eleAndGroup.length; i++) { eleAndGroup[i] = i; } } //获取当前并查集中的数据有多少个分组 public int count(){ return count; } //元素p所在分组的标识符 public int find(int p){ return eleAndGroup[p]; } //判断并查集中元素p和元素q是否在同一分组中 public boolean connected(int p,int q){ return find(p) == find(q); } //把p元素所在分组和q元素所在分组合并 public void union(int p,int q){ //判断元素q和p是否已经在同一分组中，如果已经在同一分组中，则结束方法就可以了 if (connected(p,q)){ return; } //找到p所在分组的标识符 int pGroup = find(p); //找到q所在分组的标识符 int qGroup = find(q); //合并组：让p所在组的所有元素的组标识符变为q所在分组的标识符 for (int i = 0; i &lt; eleAndGroup.length; i++) { if (eleAndGroup[i]==pGroup){ eleAndGroup[i] = qGroup; } } //分组个数-1 this.count--; } } 测试 public class UFTest { public static void main(String[] args) { //创建并查集对象 UF uf = new UF(5); System.out.println(&quot;默认情况下，并查集中有：&quot;+uf.count()+&quot;个分组&quot;); //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少 Scanner sc = new Scanner(System.in); while(true){ System.out.println(&quot;请输入第一个要合并的元素：&quot;); int p = sc.nextInt(); System.out.println(&quot;请输入第二个要合并的元素：&quot;); int q = sc.nextInt(); //判断这两个元素是否已经在同一组了 if (uf.connected(p,q)){ System.out.println(p+&quot;元素和&quot;+q+&quot;元素已经在同一个组中了&quot;); continue; } uf.union(p,q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); } } } UF_Tree算法优化 我们仍然让eleAndGroup数组的索引作为某个结点的元素；eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点。 public class UF_Tree { //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //初始化并查集 public UF_Tree(int N){ //初始化分组的数量,默认情况下，有N个分组 this.count = N; //初始化eleAndGroup数组 this.eleAndGroup = new int[N]; //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引 for (int i = 0; i &lt; eleAndGroup.length; i++) { eleAndGroup[i] = i; } } //获取当前并查集中的数据有多少个分组 public int count(){ return count; } //判断并查集中元素p和元素q是否在同一分组中 public boolean connected(int p,int q){ return find(p) == find(q); } //元素p所在分组的标识符 public int find(int p){ while(true){ if (p == eleAndGroup[p]){ return p; } p = eleAndGroup[p]; } } //把p元素所在分组和q元素所在分组合并 public void union(int p,int q){ //找到p元素和q元素所在组对应的树的根结点 int pRoot = find(p); int qRoot = find(q); //如果p和q已经在同一分组，则不需要合并了 if (pRoot==qRoot){ return; } //让p所在的树的根结点的父结点为q所在树的根结点即可 eleAndGroup[pRoot] = qRoot; //组的数量-1 this.count--; } } 测试 public class UFTeeTest { public static void main(String[] args) { //创建并查集对象 UF_Tree uf = new UF_Tree(5); System.out.println(&quot;默认情况下，并查集中有：&quot;+uf.count()+&quot;个分组&quot;); //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少 Scanner sc = new Scanner(System.in); while(true){ System.out.println(&quot;请输入第一个要合并的元素：&quot;); int p = sc.nextInt(); System.out.println(&quot;请输入第二个要合并的元素：&quot;); int q = sc.nextInt(); //判断这两个元素是否已经在同一组了 if (uf.connected(p,q)){ System.out.println(p+&quot;元素和&quot;+q+&quot;元素已经在同一个组中了&quot;); continue; } uf.union(p,q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); } } } 路径压缩优化 在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。 public class UF_Tree_Weighted { //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //用来存储每一个根结点对应的树中保存的结点的个数 private int[] sz; //初始化并查集 public UF_Tree_Weighted(int N){ //初始化分组的数量,默认情况下，有N个分组 this.count = N; //初始化eleAndGroup数组 this.eleAndGroup = new int[N]; //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引 for (int i = 0; i &lt; eleAndGroup.length; i++) { eleAndGroup[i] = i; } this.sz = new int[N]; //默认情况下，sz中每个索引处的值都是1 for (int i = 0; i &lt; sz.length; i++) { sz[i] = 1; } } //获取当前并查集中的数据有多少个分组 public int count(){ return count; } //判断并查集中元素p和元素q是否在同一分组中 public boolean connected(int p,int q){ return find(p) == find(q); } //元素p所在分组的标识符 public int find(int p){ while(true){ if (p == eleAndGroup[p]){ return p; } p = eleAndGroup[p]; } } //把p元素所在分组和q元素所在分组合并 public void union(int p,int q){ //找到p元素和q元素所在组对应的树的根结点 int pRoot = find(p); int qRoot = find(q); //如果p和q已经在同一分组，则不需要合并了 if (pRoot==qRoot){ return; } //判断proot对应的树大还是qroot对应的树大，最终需要把较小的树合并到较大的树中 if (sz[pRoot]&lt;sz[qRoot]){ eleAndGroup[pRoot] = qRoot; sz[qRoot]+=sz[pRoot]; }else{ eleAndGroup[qRoot] = pRoot; sz[pRoot]+= sz[qRoot]; } //组的数量-1 this.count--; } } 测试 public class UFTeeWeightedTest { public static void main(String[] args) { //创建并查集对象 UF_Tree_Weighted uf = new UF_Tree_Weighted(5); System.out.println(&quot;默认情况下，并查集中有：&quot;+uf.count()+&quot;个分组&quot;); //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少 Scanner sc = new Scanner(System.in); while(true){ System.out.println(&quot;请输入第一个要合并的元素：&quot;); int p = sc.nextInt(); System.out.println(&quot;请输入第二个要合并的元素：&quot;); int q = sc.nextInt(); //判断这两个元素是否已经在同一组了 if (uf.connected(p,q)){ System.out.println(p+&quot;元素和&quot;+q+&quot;元素已经在同一个组中了&quot;); continue; } uf.union(p,q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); } } } 案例 public class Traffic_Project_Test { public static void main(String[] args) throws Exception{ //构建一个缓冲读取流BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(Traffic_Project_Test.class.getClassLoader().getResourceAsStream(&quot;traffic_project.txt&quot;))); //读取第一行数据20 int totalNumber = Integer.parseInt(br.readLine()); //构建一个并查集对象 UF_Tree_Weighted uf = new UF_Tree_Weighted(totalNumber); //读取第二行数据7 int roadNumber = Integer.parseInt(br.readLine()); //循环读取7条道路 for (int i=1;i&lt;=roadNumber;i++){ String line = br.readLine();//0 1 String[] str = line.split(&quot; &quot;); int p = Integer.parseInt(str[0]); int q = Integer.parseInt(str[1]); //调用并查集对象的union方法让两个城市相通 uf.union(p,q); } //获取当前并查集中分组的数量-1就可以得到还需要修建的道路的数目 int roads = uf.count()-1; System.out.println(&quot;还需要修建&quot;+roads+&quot;条道路，才能实现畅通工程&quot;); } } 图概念 图是由一组顶点和一组能够将两个顶点相连的边组成的。按照连接两个顶点的边的不同，可以把图分为以下两种：无向图：边仅仅连接两个顶点，没有其他含义；有向图：边不仅连接两个顶点，并且具有方向。 相邻顶点：当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。 度：某个顶点的度就是依附于该顶点的边的个数。 子图：是一幅图的所有边的子集(包含这些边依附的顶点)组成的图。 路径：是由边顺序连接的一系列的顶点组成。 环：是一条至少含有一条边且终点和起点相同的路径。 连通图：如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图。 连通子图：一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图。 图的存储结构 只需要表示清楚以下两部分内容即可：图中所有的顶点；所有连接顶点的边。 常见的图的存储结构有两种：邻接矩阵和邻接表 邻接矩阵：使用一个 V*V 的二维数组int[V][V] adj,把索引的值看做是顶点；如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。邻接矩阵这种存储方式的空间复杂度是V^2的。 邻接表：使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点。 代码实现 public class Graph { //顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Graph(int V){ //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) { adj[i] = new Queue&lt;Integer&gt;(); } } //获取顶点数目 public int V(){ return V; } //获取边的数目 public int E(){ return E; } //向图中添加一条边 v-w public void addEdge(int v, int w) { //在无向图中，边是没有方向的，所以该边既可以说是从v到w的边，又可以说是从w到v的边，因此，需要让w出现在v的邻接表中，并且还要让v出现在w的邻接表中 adj[v].enqueue(w); adj[w].enqueue(v); //边的数量+1 E++; } //获取和顶点v相邻的所有顶点 public Queue&lt;Integer&gt; adj(int v){ return adj[v]; } } 图的搜索 深度优先搜索：在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。 public class DepthFirstSearch { //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录有多少个顶点与s顶点相通 private int count; //构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相邻顶点 public DepthFirstSearch(Graph G,int s){ //初始化marked数组 this.marked = new boolean[G.V()]; //初始化跟顶点s相通的顶点的数量 this.count=0; dfs(G,s); } //使用深度优先搜索找出G图中v顶点的所有相通顶点 private void dfs(Graph G, int v){ //把v顶点标识为已搜索 marked[v] = true; for (Integer w : G.adj(v)) { //判断当前w顶点有没有被搜索过，如果没有被搜索过，则递归调用dfs方法进行深度搜索 if (!marked[w]){ dfs(G,w); } } //相通顶点数量+1 count++; } //判断w顶点与s顶点是否相通 public boolean marked(int w){ return marked[w]; } //获取与顶点s相通的所有顶点的总数 public int count(){ return count; } } 测试深度优先搜索 public class DepthFirstSearchTest { public static void main(String[] args) { //准备Graph对象 Graph G = new Graph(13); G.addEdge(0,5); G.addEdge(0,1); G.addEdge(0,2); G.addEdge(0,6); G.addEdge(5,3); G.addEdge(5,4); G.addEdge(3,4); G.addEdge(4,6); G.addEdge(7,8); G.addEdge(9,11); G.addEdge(9,10); G.addEdge(9,12); G.addEdge(11,12); //准备深度优先搜索对象 DepthFirstSearch search = new DepthFirstSearch(G, 0); //测试与某个顶点相通的顶点数量 int count = search.count(); System.out.println(&quot;与起点0相通的顶点的数量为:&quot;+count); //测试某个顶点与起点是否相同 boolean marked1 = search.marked(5); System.out.println(&quot;顶点5和顶点0是否相通：&quot;+marked1); boolean marked2 = search.marked(7); System.out.println(&quot;顶点7和顶点0是否相通：&quot;+marked2); } } 广度优先搜索:在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。 实现代码 public class BreadthFirstSearch { //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录有多少个顶点与s顶点相通 private int count; //用来存储待搜索邻接表的点 private Queue&lt;Integer&gt; waitSearch; //构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 public BreadthFirstSearch(Graph G, int s) { this.marked = new boolean[G.V()]; this.count=0; this.waitSearch = new Queue&lt;Integer&gt;(); bfs(G,s); } //使用广度优先搜索找出G图中v顶点的所有相邻顶点 private void bfs(Graph G, int v) { //把当前顶点v标识为已搜索 marked[v] = true; //让顶点v进入队列，待搜索 waitSearch.enqueue(v); //通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索 while(!waitSearch.isEmpty()){ //弹出一个待搜索的顶点 Integer wait = waitSearch.dequeue(); //遍历wait顶点的邻接表 for (Integer w : G.adj(wait)) { if (!marked[w]){ bfs(G,w); } } } //让相通的顶点+1； count++; } //判断w顶点与s顶点是否相通 public boolean marked(int w) { return marked[w]; } //获取与顶点s相通的所有顶点的总数 public int count() { return count; } } 测试 public class BreadthFirstSearchTest { public static void main(String[] args) { //准备Graph对象 Graph G = new Graph(13); G.addEdge(0,5); G.addEdge(0,1); G.addEdge(0,2); G.addEdge(0,6); G.addEdge(5,3); G.addEdge(5,4); G.addEdge(3,4); G.addEdge(4,6); G.addEdge(7,8); G.addEdge(9,11); G.addEdge(9,10); G.addEdge(9,12); G.addEdge(11,12); //准备广度优先搜索对象 BreadthFirstSearch search = new BreadthFirstSearch(G, 0); //测试与某个顶点相通的顶点数量 int count = search.count(); System.out.println(&quot;与起点0相通的顶点的数量为:&quot;+count); //测试某个顶点与起点是否相同 boolean marked1 = search.marked(5); System.out.println(&quot;顶点5和顶点0是否相通：&quot;+marked1); boolean marked2 = search.marked(7); System.out.println(&quot;顶点7和顶点0是否相通：&quot;+marked2); } } 案例 public class Traffic_Project_Test2 { public static void main(String[] args) throws Exception{ //构建一个缓冲读取流BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(Traffic_Project_Test2.class.getClassLoader().getResourceAsStream(&quot;traffic_project.txt&quot;))); //读取第一行数据20 int totalNumber = Integer.parseInt(br.readLine()); //构建一个Graph对象 Graph G = new Graph(totalNumber); //读取第二行数据7 int roadNumber = Integer.parseInt(br.readLine()); //循环读取有限次(7)，读取已经修建好的道路 for (int i = 1;i&lt;=roadNumber;i++){ String road = br.readLine();//&quot;0 1&quot; String[] str = road.split(&quot; &quot;); int v = Integer.parseInt(str[0]); int w = Integer.parseInt(str[1]); //调用图的addEdge方法，把边添加到图中，表示已经修建好的道路 G.addEdge(v,w); } //构建一个深度优先搜索对象，起点设置为顶点9 DepthFirstSearch search = new DepthFirstSearch(G, 9); //调用marked方法，判断8顶点和10顶点是否与起点9相通 System.out.println(&quot;顶点8和顶点9是否相通：&quot;+search.marked(8)); System.out.println(&quot;顶点10和顶点9是否相通：&quot;+search.marked(10)); } } 路径查找 public class DepthFirstPaths { //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //起点 private int s; //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 private int[] edgeTo; //构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径 public DepthFirstPaths(Graph G, int s){ //初始化marked数组 this.marked = new boolean[G.V()]; //初始化起点 this.s = s; //初始化edgeTo数组 this.edgeTo = new int[G.V()]; dfs(G,s); } //使用深度优先搜索找出G图中v顶点的所有相邻顶点 private void dfs(Graph G, int v){ //把v表示为已搜索 marked[v] = true; //遍历顶点v的邻接表，拿到每一个相邻的顶点，继续递归搜索 for (Integer w : G.adj(v)) { //如果顶点w没有被搜索，则继续递归搜索 if (!marked[w]){ edgeTo[w] = v;//到达顶点w的路径上的最后一个顶点是v dfs(G,w); } } } //判断w顶点与s顶点是否存在路径 public boolean hasPathTo(int v){ return marked[v]; } //找出从起点s到顶点v的路径(就是该路径经过的顶点) public Stack&lt;Integer&gt; pathTo(int v){ if (!hasPathTo(v)){ return null; } //创建栈对象，保存路径中的所有顶点 Stack&lt;Integer&gt; path = new Stack&lt;&gt;(); //通过循环，从顶点v开始，一直往前找，到找到起点为止 for (int x = v; x!=s;x = edgeTo[x]){ path.push(x); } //把起点s放到栈中 path.push(s); return path; } } 测试 public class DepthFirstPathsTest { public static void main(String[] args) throws Exception{ //构建缓冲读取流BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(DepthFirstPathsTest.class.getClassLoader().getResourceAsStream(&quot;road_find.txt&quot;))); //读取第一行数据6 int total = Integer.parseInt(br.readLine()); //根据第一行数据构建一副图Graph Graph G = new Graph(total); //读取第二行数据8 int edgeNumbers = Integer.parseInt(br.readLine()); //继续通过循环读取每一条边关联的两个顶点，调用addEdge方法，添加边 for (int i = 1;i&lt;=edgeNumbers;i++){ String edge = br.readLine();//0 1 String[] str = edge.split(&quot; &quot;); int v = Integer.parseInt(str[0]); int w = Integer.parseInt(str[1]); G.addEdge(v,w); } //构建路径查找对象，并设置起点为0 DepthFirstPaths paths = new DepthFirstPaths(G, 0); //调用 pathTo(4)，找到从起点0到终点4的路径，返回Stack Stack&lt;Integer&gt; path = paths.pathTo(4); StringBuilder sb = new StringBuilder(); //遍历栈对象 for (Integer v : path) { sb.append(v+&quot;-&quot;); } sb.deleteCharAt(sb.length()-1); System.out.println(sb); } } 有向图定义 有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。 出度：由某个顶点指出的边的个数称为该顶点的出度。 入度：指向某个顶点的边的个数称为该顶点的入度。 有向路径：由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。 有向环：一条至少含有一条边，且起点和终点相同的有向路径。 一副有向图中两个顶点v和w可能存在以下四种关系：没有边相连；存在从v到w的边v—&gt;w;存在从w到v的边w—&gt;v;既存在w到v的边，也存在v到w的边，即双向连接。 有向图实现 public class Digraph { //顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Digraph(int V){ //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) { adj[i] = new Queue&lt;Integer&gt;(); } } //获取顶点数目 public int V(){ return V; } //获取边的数目 public int E(){ return E; } //向有向图中添加一条边 v-&gt;w public void addEdge(int v, int w) { //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终，顶点v的邻接表中存储的相邻顶点的含义是： v-&gt;其他顶点 adj[v].enqueue(w); E++; } //获取由v指出的边所连接的所有顶点 public Queue&lt;Integer&gt; adj(int v){ return adj[v]; } //该图的反向图 private Digraph reverse(){ //创建有向图对象 Digraph r = new Digraph(V); for (int v = 0;v&lt;V;v++){ //获取由该顶点v指出的所有边 for (Integer w : adj[v]) {//原图中表示的是由顶点v-&gt;w的边 r.addEdge(w,v);//w-&gt;v } } return r; } } 拓扑排序-检测有向图中的环 拓扑排序：给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明确的表示出每个顶点的优先级。 如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。 onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环。 代码实现 public class DirectedCycle { //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录图中是否有环 private boolean hasCycle; //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上 private boolean[] onStack; //创建一个检测环对象，检测图G中是否有环 public DirectedCycle(Digraph G){ //初始化marked数组 this.marked = new boolean[G.V()]; //初始化hasCycle this.hasCycle = false; //初始化onStack数组 this.onStack = new boolean[G.V()]; //找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索 for (int v =0; v&lt;G.V();v++){ //判断如果当前顶点还没有搜索过，则调用dfs进行搜索 if (!marked[v]){ dfs(G,v); } } } //基于深度优先搜索，检测图G中是否有环 private void dfs(Digraph G, int v){ //把顶点v表示为已搜索 marked[v] = true; //把当前顶点进栈 onStack[v] = true; //进行深度搜索 for (Integer w : G.adj(v)) { //判断如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索 if (!marked[w]){ dfs(G,w); } //判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了 if (onStack[w]){ hasCycle = true; return; } } //把当前顶点出栈 onStack[v] = false; } //判断当前有向图G中是否有环 public boolean hasCycle(){ return hasCycle; } } 拓扑排序-基于深度优先的顶点排序 栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该顶点放入到reversePost中，这样就可以实现顶点排序。 代码实现： public class DepthFirstOrder { //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //使用栈，存储顶点序列 private Stack&lt;Integer&gt; reversePost; //创建一个检测环对象，检测图G中是否有环 public DepthFirstOrder(Digraph G){ //初始化marked数组 this.marked = new boolean[G.V()]; //初始化reversePost栈 this.reversePost = new Stack&lt;Integer&gt;(); //遍历图中的每一个顶点，让每个顶点作为入口，完成一次深度优先搜索 for (int v = 0;v&lt;G.V();v++){ if (!marked[v]){ dfs(G,v); } } } //基于深度优先搜索，把顶点排序 private void dfs(Digraph G, int v){ //标记当前v已经被搜索 marked[v] = true; //通过循环深度搜索顶点v for (Integer w : G.adj(v)) { //如果当前顶点w没有搜索，则递归调用dfs进行搜索 if (!marked[w]){ dfs(G,w); } } //让顶点v进栈 reversePost.push(v); } //获取顶点线性序列 public Stack&lt;Integer&gt; reversePost(){ return reversePost; } } 拓扑排序实现 public class TopoLogical { //顶点的拓扑排序 private Stack&lt;Integer&gt; order; //构造拓扑排序对象 public TopoLogical(Digraph G) { //创建一个检测有向环的对象 DirectedCycle cycle = new DirectedCycle(G); //判断G图中有没有环，如果没有环，则进行顶点排序：创建一个顶点排序对象 if (!cycle.hasCycle()){ DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G); order = depthFirstOrder.reversePost(); } } //判断图G是否有环 private boolean isCycle(){ return order==null; } //获取拓扑排序的所有顶点 public Stack&lt;Integer&gt; order(){ return order; } } 测试 public class TopoLogicalTest { public static void main(String[] args) { //准备有向图 Digraph digraph = new Digraph(6); digraph.addEdge(0,2); digraph.addEdge(0,3); digraph.addEdge(2,4); digraph.addEdge(3,4); digraph.addEdge(4,5); digraph.addEdge(1,3); //通过TopoLogical对象堆有向图中的顶点进行排序 TopoLogical topoLogical = new TopoLogical(digraph); //获取顶点的线性序列进行打印 Stack&lt;Integer&gt; order = topoLogical.order(); StringBuilder sb = new StringBuilder(); for (Integer w : order) { sb.append(w+&quot;-&gt;&quot;); } String str = sb.toString(); int index = str.lastIndexOf(&quot;-&gt;&quot;); str = str.substring(0,index); System.out.println(str); } } 加权无向图 加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用对象来描述一条边。 边的实现： public class Edge implements Comparable&lt;Edge&gt; { private final int v;//顶点一 private final int w;//顶点二 private final double weight;//当前边的权重 //通过顶点v和w，以及权重weight值构造一个边对象 public Edge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } //获取边的权重值 public double weight(){ return weight; } //获取边上的一个点 public int either(){ return v; } //获取边上除了顶点vertex外的另外一个顶点 public int other(int vertex){ if (vertex==v){ return w; }else{ return v; } } @Override public int compareTo(Edge that) { //使用一个遍历记录比较的结果 int cmp; if (this.weight()&gt;that.weight()){ //如果当前边的权重值大，则让cmp=1； cmp = 1; }else if (this.weight()&lt;that.weight()){ //如果当前边的权重值小，则让cmp=-1； cmp=-1; }else{ //如果当前边的权重值和that边的权重值一样大，则让cmp=0 cmp = 0; } return cmp; } } 加权无向图的实现 public class EdgeWeightedGraph { //顶点总数 private final int V; //边的总数 private int E; //邻接表 private Queue&lt;Edge&gt;[] adj; //创建一个含有V个顶点的空加权无向图 public EdgeWeightedGraph(int V) { //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) { adj[i] = new Queue&lt;Edge&gt;(); } } //获取图中顶点的数量 public int V() { return V; } //获取图中边的数量 public int E() { return E; } //向加权无向图中添加一条边e public void addEdge(Edge e) { //需要让边e同时出现在e这个边的两个顶点的邻接表中 int v = e.either(); int w = e.other(v); adj[v].enqueue(e); adj[w].enqueue(e); //边的数量+1 E++; } //获取和顶点v关联的所有边 public Queue&lt;Edge&gt; adj(int v) { return adj[v]; } //获取加权无向图的所有边 public Queue&lt;Edge&gt; edges() { //创建一个队列对象，存储所有的边 Queue&lt;Edge&gt; allEdges = new Queue&lt;&gt;(); //遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边 //因为这是无向图，所以同一条边同时出现在了它关联的两个顶点的邻接表中，需要让一条边只记录一次； for(int v =0;v&lt;V;v++){ //遍历v顶点的邻接表，找到每一条和v关联的边 for (Edge e : adj(v)) { if (e.other(v)&lt;v){ allEdges.enqueue(e); } } } return allEdges; } } 最小生成树 图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边的权重之和)最小的生成树。 树的性质：用一条边接树中的任意两个顶点都会产生一个新的环；从树中删除任意一条边，将会得到两棵独立的树。 切分：将图的所有顶点按照某些规则分为两个非空且没有交集的集合。 横切边：连接两个属于不同集合的顶点的边称之为横切边。 切分定理：在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。注意:一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。 贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。 最小生成树Prim算法 Prim算法的切分规则：把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。实现： public class PrimMST { //索引代表顶点，值表示当前顶点和最小生成树之间的最短边 private Edge[] edgeTo; //索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 private double[] distTo; //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false private boolean[] marked; //存放树中顶点与非树中顶点之间的有效横切边 private IndexMinPriorityQueue&lt;Double&gt; pq; //根据一副加权无向图，创建最小生成树计算对象 public PrimMST(EdgeWeightedGraph G) { //初始化edgeTo this.edgeTo = new Edge[G.V()]; //初始化distTo this.distTo = new double[G.V()]; for (int i = 0; i &lt; distTo.length; i++) { distTo[i] = Double.POSITIVE_INFINITY; } //初始化marked this.marked = new boolean[G.V()]; //初始化pq pq = new IndexMinPriorityQueue&lt;Double&gt;(G.V()); //默认让顶点0进入到树中，但是树中只有一个顶点0，因此，0顶点默认没有和其他的顶点相连，所以让distTo对应位置处的值存储0.0 distTo[0] = 0.0; pq.insert(0,0.0); //遍历索引最小优先队列，拿到最小和N切边对应的顶点，把该顶点加入到最小生成树中 while (!pq.isEmpty()){ visit(G,pq.delMin()); } } //将顶点v添加到最小生成树中，并且更新数据 private void visit(EdgeWeightedGraph G, int v) { //把顶点v添加到最小生成树中 marked[v] = true; //更新数据 for (Edge e : G.adj(v)) { //获取e边的另外一个顶点(当前顶点是v) int w = e.other(v); //判断另外一个顶点是不是已经在树中，如果在树中，则不做任何处理，如果不再树中，更新数据 if (marked[w]){ continue; } //判断边e的权重是否小于从w顶点到树中已经存在的最小边的权重； if (e.weight()&lt;distTo[w]){ //更新数据 edgeTo[w] = e; distTo[w] = e.weight(); if (pq.contains(w)){ pq.changeItem(w,e.weight()); }else{ pq.insert(w,e.weight()); } } } } //获取最小生成树的所有边 public Queue&lt;Edge&gt; edges() { //创建队列对象 Queue&lt;Edge&gt; allEdges = new Queue&lt;&gt;(); //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中 for (int i = 0; i &lt; edgeTo.length; i++) { if (edgeTo[i]!=null){ allEdges.enqueue(edgeTo[i]); } } return allEdges; } } 测试 public class PrimMSTTest { public static void main(String[] args) throws Exception{ //准备一副加权无向图 BufferedReader br = new BufferedReader(new InputStreamReader(PrimMSTTest.class.getClassLoader().getResourceAsStream(&quot;min_create_tree_test.txt&quot;))); int total = Integer.parseInt(br.readLine()); EdgeWeightedGraph G = new EdgeWeightedGraph(total); int edgeNumbers = Integer.parseInt(br.readLine()); for (int e = 1;e&lt;=edgeNumbers;e++){ String line = br.readLine();//4 5 0.35 String[] strs = line.split(&quot; &quot;); int v = Integer.parseInt(strs[0]); int w = Integer.parseInt(strs[1]); double weight = Double.parseDouble(strs[2]); //构建加权无向边 Edge edge = new Edge(v, w, weight); G.addEdge(edge); } //创建一个PrimMST对象，计算加权无向图中的最小生成树 PrimMST primMST = new PrimMST(G); //获取最小生成树中的所有边 Queue&lt;Edge&gt; edges = primMST.edges(); //遍历打印所有的边 for (Edge e : edges) { int v = e.either(); int w = e.other(v); double weight = e.weight(); System.out.println(v+&quot;-&quot;+w+&quot; :: &quot;+weight); } } } 最小生成树kruskal算法 kruskal算法是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。 kruskal算法和prim算法的区别：Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。 取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。 kruskal算法实现: public class KruskalMST { //保存最小生成树的所有边 private Queue&lt;Edge&gt; mst; //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 private UF_Tree_Weighted uf; //存储图中所有的边，使用最小优先队列，对边按照权重进行排序 private MinPriorityQueue&lt;Edge&gt; pq; //根据一副加权无向图，创建最小生成树计算对象 public KruskalMST(EdgeWeightedGraph G) { //初始化mst this.mst = new Queue&lt;Edge&gt;(); //初始化uf this.uf = new UF_Tree_Weighted(G.V()); //初始化pq this.pq = new MinPriorityQueue&lt;&gt;(G.E()+1); //把图中所有的边存储到pq中 for (Edge e : G.edges()) { pq.insert(e); } //遍历pq队列，拿到最小权重的边，进行处理 while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1){ //找到权重最小的边 Edge e = pq.delMin(); //找到该边的两个顶点 int v = e.either(); int w = e.other(v); //判断这两个顶点是否已经在同一颗树中，如果在同一颗树中，则不对该边做处理，如果不在一棵树中，则让这两个顶点属于的两棵树合并成一棵树 if (uf.connected(v,w)){ continue; } uf.union(v,w); //让边e进入到mst队列中 mst.enqueue(e); } } //获取最小生成树的所有边 public Queue&lt;Edge&gt; edges() { return mst; } } 测试 public class KruskalMSTTest { public static void main(String[] args) throws Exception{ //准备一副加权无向图 BufferedReader br = new BufferedReader(new InputStreamReader(KruskalMSTTest.class.getClassLoader().getResourceAsStream(&quot;min_create_tree_test.txt&quot;))); int total = Integer.parseInt(br.readLine()); EdgeWeightedGraph G = new EdgeWeightedGraph(total); int edgeNumbers = Integer.parseInt(br.readLine()); for (int e = 1;e&lt;=edgeNumbers;e++){ String line = br.readLine();//4 5 0.35 String[] strs = line.split(&quot; &quot;); int v = Integer.parseInt(strs[0]); int w = Integer.parseInt(strs[1]); double weight = Double.parseDouble(strs[2]); //构建加权无向边 Edge edge = new Edge(v, w, weight); G.addEdge(edge); } //创建一个KruskalMST对象，计算加权无向图中的最小生成树 KruskalMST primMST = new KruskalMST(G); //获取最小生成树中的所有边 Queue&lt;Edge&gt; edges = primMST.edges(); //遍历打印所有的边 for (Edge e : edges) { int v = e.either(); int w = e.other(v); double weight = e.weight(); System.out.println(v+&quot;-&quot;+w+&quot; :: &quot;+weight); } } } 加权有向图 有向图边的表示： public class DirectedEdge { private final int v;//起点 private final int w;//终点 private final double weight;//当前边的权重 //通过顶点v和w，以及权重weight值构造一个边对象 public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } //获取边的权重值 public double weight(){ return weight; } //获取有向边的起点 public int from(){ return v; } //获取有向边的终点 public int to(){ return w; } } 有向图的实现： public class EdgeWeightedDigraph { //顶点总数 private final int V; //边的总数 private int E; //邻接表 private Queue&lt;DirectedEdge&gt;[] adj; //创建一个含有V个顶点的空加权有向图 public EdgeWeightedDigraph(int V) { //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) { adj[i] = new Queue&lt;DirectedEdge&gt;(); } } //获取图中顶点的数量 public int V() { return V; } //获取图中边的数量 public int E() { return E; } //向加权有向图中添加一条边e public void addEdge(DirectedEdge e) { //边e是有方向的，所以只需要让e出现在起点的邻接表中即可 int v = e.from(); adj[v].enqueue(e); E++; } //获取由顶点v指出的所有的边 public Queue&lt;DirectedEdge&gt; adj(int v) { return adj[v]; } //获取加权有向图的所有边 public Queue&lt;DirectedEdge&gt; edges() { //遍历图中的每一个顶点，得到该顶点的邻接表，遍历得到每一条边，添加到队列中返回即可 Queue&lt;DirectedEdge&gt; allEdges = new Queue&lt;&gt;(); for (int v = 0;v&lt;V;v++){ for (DirectedEdge edge : adj[v]) { allEdges.enqueue(edge); } } return allEdges; } } 最短路径 最短路径定义及性质定义：在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。 最短路径树：给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。 边的松弛：放松边v-&gt;w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w。 顶点的松弛：顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。 Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边是有效横切边pq队列中的权重最小的边。 public class DijkstraSP { //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边 private DirectedEdge[] edgeTo; //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 private double[] distTo; //存放树中顶点与非树中顶点之间的有效横切边 private IndexMinPriorityQueue&lt;Double&gt; pq; //根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象 public DijkstraSP(EdgeWeightedDigraph G, int s){ //初始化edgeTo this.edgeTo = new DirectedEdge[G.V()]; //初始化distTo this.distTo = new double[G.V()]; for (int i = 0; i &lt; distTo.length; i++) { distTo[i] = Double.POSITIVE_INFINITY; } //初始化pq this.pq = new IndexMinPriorityQueue&lt;&gt;(G.V()); //找到图G中以顶点s为起点的最短路径树 //默认让顶点s进入到最短路径树中 distTo[s] = 0.0; pq.insert(s,0.0); //遍历pq while(!pq.isEmpty()){ relax(G,pq.delMin()); } } //松弛图G中的顶点v private void relax(EdgeWeightedDigraph G, int v){ for (DirectedEdge edge : G.adj(v)) { //获取到该边的终点w int w = edge.to(); //通过松弛技术，判断从起点s到顶点w的最短路径是否需要先从顶点s到顶点v，然后再由顶点v到顶点w if (distTo(v)+edge.weight()&lt;distTo(w)){ distTo[w] = distTo[v]+edge.weight(); edgeTo[w] = edge; //判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在，则直接添加 if (pq.contains(w)){ pq.changeItem(w,distTo(w)); }else{ pq.insert(w,distTo(w)); } } } } //获取从顶点s到顶点v的最短路径的总权重 public double distTo(int v){ return distTo[v]; } //判断从顶点s到顶点v是否可达 public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY; } //查询从起点s到顶点v的最短路径中所有的边 public Queue&lt;DirectedEdge&gt; pathTo(int v){ //判断从顶点s到顶点v是否可达，如果不可达，直接返回null if (!hasPathTo(v)){ return null; } //创建队列对象 Queue&lt;DirectedEdge&gt; allEdges = new Queue&lt;&gt;(); while (true){ DirectedEdge e = edgeTo[v]; if (e==null){ break; } allEdges.enqueue(e); v = e.from(); } return allEdges; } } 测试 public class DijkstraSPTest { public static void main(String[] args) throws Exception{ //创建一副加权有向图 BufferedReader br = new BufferedReader(new InputStreamReader(DijkstraSPTest.class.getClassLoader().getResourceAsStream(&quot;min_route_test.txt&quot;))); int total = Integer.parseInt(br.readLine()); EdgeWeightedDigraph G = new EdgeWeightedDigraph(total); int edgeNumbers = Integer.parseInt(br.readLine()); for(int i=1;i&lt;=edgeNumbers;i++){ String line = br.readLine();//4 5 0.35 String[] strs = line.split(&quot; &quot;); int v = Integer.parseInt(strs[0]); int w = Integer.parseInt(strs[1]); double weight = Double.parseDouble(strs[2]); DirectedEdge e = new DirectedEdge(v, w, weight); G.addEdge(e); } //创建DijkstraSP对象，查找最短路径树 DijkstraSP dijkstraSP = new DijkstraSP(G, 0); //查找最短路径,0-&gt;6的最短路径 Queue&lt;DirectedEdge&gt; edges = dijkstraSP.pathTo(6); //遍历打印 for (DirectedEdge edge : edges) { System.out.println(edge.from()+&quot;-&gt;&quot;+edge.to()+&quot; ：： &quot;+edge.weight()); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"Git","slug":"38.git","date":"2020-07-04T12:13:24.467Z","updated":"2020-07-11T15:11:12.355Z","comments":false,"path":"2020/07/04/38.git/","link":"","permalink":"http://yoursite.com/2020/07/04/38.git/","excerpt":"","text":"创建和回退 下载地址 https://git-scm.com/download git分为工作区、暂存区、版本库。 使用如下命令可以查看版本记录： git log //简短log git log --pretty=oneline git log --pretty=oneline --graph 查看我们的操作记录，查看版本号： git reflog 使用如下命令查看当前工作树的状态： git status 创建仓库执行命令： git init 使用如下两条命令可以创建一个版本： git add 文件名.格式 git commit –m &apos;版本提交说明1&apos; 撤销工作区修改可以使用(没使用add)： git checkout -- 文件名.格式 把暂存区的修改撤销掉，重新放回工作区(使用了add，没使用commit): git reset HEAD 文件名.格式 现在若想回到某一个版本，可以使用如下命令(使用了commit)： git reset --hard HEAD^ //或者回退1个/100个版本 git reset --hard HEAD~1 git reset --hard HEAD~100 假如我们现在又想回到回退前的版本，可以使用如下命令： git reset --hard 版本号 对比工作区和某个版本文件的不同： git diff HEAD -- 文件名.格式 对比两个版本间文件的不同： git diff HEAD HEAD^ -- 文件名.格式 删错了，可以直接使用(还在工作区，没使用add): git checkout –- 文件名.格式 确实要从版本库中删除文件: git rm 文件名.格式 git commit –m &apos;版本提交说明&apos; 分支管理 截止到目前只有一条时间线，在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交0的，所以，HEAD指向的就是当前分支。 查看当前有几个分支并且看到在哪个分支下工作： git branch 创建一个分支dev,并切换到其上进行工作: git checkout -b dev //只创建分支 git branch dev 切换回master分支： git checkout master 当前在master分支，把dev分支的工作成果合并到master分支上： git merge dev //情况一：Fast-forward,这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快 //情况二：冲突了，先处理冲突文件，在add、commit提交冲突文件。 //情况三：快速合并不能成功而且合并时没有冲突，这个时候会合并之后并做一次新的提交，ctrl+x 强制禁用fast-forward模式: git merge --no-ff -m &apos;版本提交说明&apos; dev 合并完成后，就可以放心地删除dev分支: git branch -d dev 想把当前分支“储藏”起来，切换到别的分支： git stash //切换回来后 //git stash list git stash pop //恢复工作现场 github 克隆项目 git clone ...ssh... 推送分支，就是把该分支上的所有本地提交推送到远程库: git push origin 分支名称 将本地分支跟踪服务器分支: git branch --set-upstream-to=origin/远程分支名称 本地分支名称 推送分支，就是把该分支上的所有本地提交推送到远程库: git push git push origin 分支名称 从远程分支上拉取代码： git pull orgin 分支名称","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android性能分析与优化","slug":"35.Android性能分析与优化","date":"2020-06-26T09:55:12.815Z","updated":"2020-06-27T13:23:46.520Z","comments":false,"path":"2020/06/26/35.Android性能分析与优化/","link":"","permalink":"http://yoursite.com/2020/06/26/35.Android性能分析与优化/","excerpt":"","text":"1、启动优化1.1、启动类型 冷启动流程：用户点击 -&gt; IPC -&gt; Process.start创建进程 -&gt; ActivityThread(单独进程的入口) -&gt; bindApplication(创建Application) -&gt; LifeCycle(Activity) -&gt; ViewRootImpl界面绘制 冷启动之前会进行的操作：启动App，加载空白Window，创建进程。随后会创建Application，启动主线程，创建Activity，加载布局，布置屏幕，首帧绘制。主要对Application和Activity生命周期进行优化。 热启动：后台切换到前台。 温启动：只会重走Activity的生命周期。 1.2、启动时间 1、adb方式： adb shell am start -W 包名/包名.首屏Activity ThisTime:最后一个Activity启动耗时 TotalTime：所有Activity启动耗时 WaitTime：AMS启动Activity的总耗时 2、手动打点方式：启动时埋点，可以线上使用 开始时间Application @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); //开始计时 } 结束计时 //Activity中 @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); //结束计时 } //或者Adapter @Override public void onBindViewHolder(@NonNull final ViewHolder holder, int position) { if (position == 0 &amp;&amp; !mHasRecorded) { mHasRecorded = true; holder.layout.getViewTreeObserver() .addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { //结束计时 return true; } }); } } 1.3、工具 traceview:图形展示执行时间、调用栈；包含所有线程。缺点：运行变慢。 android.os.Debug.startMethodTracing();//也可以调用startMethodTracing(String traceName) 设置trace文件的文件名 android.os.Debug.stopMethodTracing();//放在结束调试的地方 生成文件在：Android/data/包名/files systrace：结合Android内核的数据，生成Html报告。轻量级，开销小。直接反应cpu利用率。 //b:大小，t:时间，o：生成文件名字 python systrace.py -b 32768 -t 5 -a 包名 -o html文件 sched gfx view wm am app //项目代码 TraceCompat.beginSection(mTask.getClass().getSimpleName()); TraceCompat.endSection(); cputime代码消耗cpu的时间（重要指标）；walltime：代码执行时间。 1.4、统计方法消耗时间 AOP：针对同一类问题统一处理。 AspectJ https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx classpath &apos;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&apos; apply plugin: &apos;android-aspectjx&apos; implementation &apos;org.aspectj:aspectjrt:1.8.+&apos; 例如PerformanceAop类 1.4、Theme小技巧 Theme切换：感觉上更快。 drawable下创建.xml &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;!-- The background color, preferably the same as your normal theme --&gt; &lt;item android:drawable=&quot;@android:color/white&quot;/&gt; &lt;!-- Your product logo - 144dp color version of your app icon --&gt; &lt;item&gt; &lt;bitmap android:src=&quot;@mipmap/splash&quot; android:gravity=&quot;fill&quot;/&gt; &lt;/item&gt; &lt;/layer-list&gt; styles中设置 &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/lanucher&lt;/item&gt; 首屏Activity引用 android:theme=&quot;@style/Theme.Splash&quot; Activity中 setTheme(R.style.AppTheme); //super.onCreate之前切换真正的style super.onCreate(savedInstanceState); 1.5、异步解决方案-启动器 异步优化：子线程分担主线程任务。 Application中的sdk初始化如果不需要再主线程中执行，那么就异步执行。CountDownLatch。 线程池创建线程数，根据手机cup private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); 启动器：充分利用cpu多核，自动梳理任务顺序 代码Task化，启动逻辑抽象为Task。根据任务依赖关系排序生成一个有向无环图。多线程按照排序后的优先级依次执行。 工具类：TaskDispatcher，例子：主线程Task：InitWeexTask；子线程Task：InitAMapTask；等待Task：InitJPushTask。 延迟初始化：在MainActivity的onFeedShow方法中调用DelayInitDispatcher利用addIdleHandler","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"HTTP和加密和HTTPS","slug":"34.HTTP和加密和HTTPS","date":"2020-06-13T04:40:23.631Z","updated":"2020-06-25T15:38:06.311Z","comments":false,"path":"2020/06/13/34.HTTP和加密和HTTPS/","link":"","permalink":"http://yoursite.com/2020/06/13/34.HTTP和加密和HTTPS/","excerpt":"","text":"HTTP1.1、HTTP的概念 HTTP是一种⽹网络传输协议，位于TCP/IP协议族的最顶层——应用层。Hypertext Transfer Protocol超文本传输协议，和 HTML (Hypertext Markup Language 超文本标记语言一起诞生，用于在网络上请求和传输HTML内容。 OSI的7层协议：从下到上分别是:7-应用层、6-表示层、5-会话层、4-传输层、3-网络层、2-数据链路层、1-物理层。 TCP三次握手（作用是建立连接）和四次挥手（作用是断开连接）——保证数据传输可靠性。 1.2、URL URL三部分组成：协议类型、服务器地址(和端口号)、路径(Path) 协议类型://服务器地址[:端口号]路径 1.3、报文 通信是以报文的形式。 请求报文 请求行: method、path、Http version Headers：Host、Content-Type、Content-Length Body 响应报文 状态行: Http version、status code、status message Headers：Content-Type、cache-control、vary、etag、content-encoding Body 请求头和响应头详细参考网站 http://tools.jb51.net/table/http_header 1.4、请求方法 GET：对服务器数据不进行修改、不发送Body。幂等（反复调用多次会得到相同的结果）。 @GET(&quot;/users/{id}&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender); POST：用于增加或修改资源、不幂等。 @FormUrlEncoded @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) String gender); PUT:仅用于修改资源、发送给服务器的内容写在Body里面、幂等。 @FormUrlEncoded @PUT(&quot;/users/{id}&quot;) Call&lt;User&gt; updateGender(@Path(&quot;id&quot;) String id, @Field(&quot;gender&quot;) String gender); DELETE：用于删除资源、不发送Body、幂等。 @DELETE(&quot;/users/{id}&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender); HEAD：和GET使用方法完全相同，唯一区别在于，返回的响应中没有Body。 1.5、HTTP状态码 1xx: Infomational (信息状态码) ，临时性消息，如：100 （继续发送）、101（正在切换协议） 2xx: Succeed(成功)，请求正常处理完毕,如 200 3xx: Redirection(重定向)，需要进行附加操作，一般是没有响应数据返回的，如 304（Not,modified）307 4xx: Client Error (客户端的错误)，服务器无法处理请求，如 404 5xx: Server Error (服务端的错误)，服务器处理请求出错，如 500 1.5、Content-Type 指定Body的类型。主要有四类： text/html：请求Web页面是返回响应的类型，Body中返回html文本。 x-www-form-urlencoded：Web页面纯文本表单的提交方式。 @FormUrlEncoded @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) String gender); multitype/form-data：Web页面含有二进制文件时的提交方式。 Content-Type: multipart/form-data; boundary=---- @Multipart @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;avatar&quot;) RequestBody avatar); RequestBody namePart = RequestBody.create(MediaType.parse(&quot;text/plain&quot;),nameStr); RequestBody avatarPart = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;),avatarFile); api.addUser(namePart, avatarPart); application/json,image/jpeg,application/zip…单项内容（文本或非文本都可以），用于Web Api的响应或者POST/PUT的请求。 @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Body(&quot;user&quot;) User user); @POST(&quot;users/{id}/avatar&quot;) Call&lt;User&gt; updateAvatar(@Path(&quot;id&quot;) String id, @Body RequestBody avatar); RequestBody avatarBody = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;),avatarFile); api.updateAvatar(id, avatarBody) 1.6、Header HTTP消息的元数据 (meta data) User-Agent:用户代理，即是谁实际发送请求、接受响应的，例如收机浏览器、某款收机App。 Host：服务器主机地址 Content-Length：长度 Location：重定向的目标 URL Cookie/Set-Cookie：发送Cookie/设置Cookie Authorization：授权信息 Accept: 客户端能接受的数据类型。如 text/html Accept-Charset: 客户端接受的字符集。如 utf-8 Accept-Encoding: 客户端接受的压缩编码类型。如 gzip Content-Encoding：压缩类型。如 gzip 1.7、Range Accept-Range: bytes 响应报文中出现，表示服务器支持按字节来取范围数据 Range: bytes=&lt;start&gt;-&lt;end&gt; 请求报文中出现，表示要取哪段数据 Content-Range:&lt;start&gt;-&lt;end&gt;/total 响应报⽂中出现，表示发送的是哪段数据 作用：断点续传、多线程下载。 1.8、Cache Cache 和 Buffer 的区别 Cache-Control: no-cache、no-store、max-age Last-Modified If-Modified-Since Etag If-None-Match Cache-Control: private / public 2、加密2.1、对称加密 DES（56位密钥，密钥太短而逐渐被弃用）、AES（128位、192位、256位密钥，现在最流行）。 2.2、非对称加密 使用公钥对数据进行加密得到密文；使用私钥对数据进行解密得到原数据。 缺点：双方公钥都暴漏，可能会伪造数据。 如果用私钥对数据加密，使用公钥是可以解密得到原数据的。但是一般不要互换，签名和验证就是这样，传输数据包括原数据+签名数据。 签名一般先对原数据hash，再进行签名。 用非对称加密+签名来传输数据 -&gt; 密文 + 签名数据。 解决上面的缺点。 经典算法：RSA（可用于加密和签名）、DSA（仅用于签名，但速度更快）。 2.3、Base64 将二进制数据转换成由64个字符组成的字符串的编码算法。64个字符：a-z、A-Z、0-9、+、/。 作用：让原数据具有字符串所具有的特性，如可以放在URL中传输、可以保存到文本文件。 Base64的缺点：因为自身的原理（6位变8位），因此每次Base64编码之后，数据都会增大约1/3，所以会影响存储和传输性能。 Base64并不是加密。 Base58：比特币使用的编码方式，去掉了Base64中的数字0，字母大写O，字母大写I，和字母小写l，以及 “+” 和 “/“ 符号，用于比特币地址的表示。 URL encoding:在URL的字符串中，对一些不用于特殊用途的保留字符，使⽤百分号%为前缀进行单独编码，以避免出现解析错误。 2.4、序列化 把数据对象（一般是内存中的，例如 JVM 中的对象）转换成字节序列的过程。对象在程序内存里的存放形式是散乱的（存放在不同的内存区域、并且由引用进行连接），通过序列化可以把内存中的对象转换成一个字节序列，从而使用byte[]等形式进行本地存储或网络传输，在需要的时候重新组装（反序列化）来使用。 目的：让内存中的对象可以被储存和传输。 序列化是编码吗？不是。编码是把数据由一种数据格式转换成另一种数据格式；而序列化是把数据由内存中的对象（而不是某种具体的格式）转换成字节序列。 2.5、Hash 定义：把任意数据转换成指定大小范围（通常很小，例如256字节以内）的数据。 作用：相当于从数据中提出摘要信息，因此最主要用途是数字指纹。 经典算法：MD5、SHA1、SHA256 等。 Hash的实际用途：唯一性验证。 例如 Java 中的 hashCode() 方法。怎么重写hashCode方法？ 把 equals() 方法中的每个用于判断相等的变量都放进 hashCode() 中，一起生成一个尽量不会碰撞的整数即可。 为什么每次重写 equals() 方法都需要？因为要把新的判断条件放进hashCode()。 Hash的实际用途：数据完整性验证 从网络上下载文件后，通过比对文件的Hash值（例如 MD5、SHA1），可以确认下载的文件是否有损坏。 Hash 的实际用途：快速查找 HashMap Hash 的实际用途：隐私保护 当重要数据必须暴露的时候，可以选择暴露它的Hash值（例如 MD5），以保障原数据的安全。 例如网站登录时，可以只保存用户密码的 Hash 值，在每次登录验证时只需要将输入的密码的Hash值和数据库中保存的 Hash 值作比对就好，网站无需知道用户的密码。这样，当网站数据失窃时，用户不会因为密码被盗导致其他网站的安全也受到威胁。 Hash是单向过程，往往是不可逆的，无法进行逆向恢复操作，因此Hash不属于编码。 Hash是单向过程，无法进行逆向回复操作，因此Hash不属于加密。（MD5不是加密！） 3、HTTPS3.1、TCP/IP协议 具体分层： Application Layer应用层：HTTP、FTP、DNS。 Transport Layer传输层：TCP、UDP。 Internet Layer网络层：IP。 Link Layer数据链路层：以太网、Wi-Fi。 三次握手：客户端：「我要向你发送消息」；服务器：「好的。我要向你发送消息」；客户端：「好的」。 四次挥手：客户端：「我不再给你发送消息」；服务端：「好的」；服务端：「我不再给你发送消息」；客户端：「好的」。 为什么四次挥手而不是三次：因为在客户端停止向服务器发送消息时，也许服务器还有消息需要向客户端发送，因此在它对客户端的「Fin」（即「我不再给你发送消息」，这个词不必记住）消息进行回应时，不需要立即附加上「我也不再向你发送消息」。在稍后服务器的消息发送完毕之后，才需要向客户端发送通知。 长连接：因为移动网络并不在Internet中，而是在运营商的内网，并不具有真正的公网 IP，因此当某个 TCP连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。 长连接的实现方式：心跳。即在一定间隔时间内，使用 TCP 连接发送超短无意义消息来让网关不能将自己定义为「空闲连接」，从而防止网关将自己的连接关闭。 3.2、HTTPS 定义：HTTP在SSL（或 TLS）上工作。 简单说就是加密通信的HTTP。 工作原理：在客户端和服务器之间协商出一套对称密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。因为对称加密性能更好。 为什么不直接用非对称加密？非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响网络通信的性能。 HTTPS 连接建⽴的过程 客户端请求建立连接Client Hello 服务端Server Hello 服务器发送证书（非对称加密的公钥、签名等）- 信任建立 客户端发给服务器Pre-master Secret（非对称加密随机数） 客户端通知：将使用加密通信 客户端发送：Finished 服务器通知：将使用加密通信 服务器发送：Finished 客户端加密密钥（客户端发送消息）、服务端加密密钥（服务端发送消息）、客户端MAC Secret（验证身份）、服务端MAC Secret（验证身份）。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"C基础","slug":"39.C基础","date":"2020-03-21T06:18:40.244Z","updated":"2020-08-30T13:19:56.026Z","comments":false,"path":"2020/03/21/39.C基础/","link":"","permalink":"http://yoursite.com/2020/03/21/39.C基础/","excerpt":"","text":"LinuxLinux主要目录速查表 /：根目录，一般根目录下只存放目录，在 linux 下有且只有一个根目录，所有的东西都是从这里开始。当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录 /bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等 /boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 ~ 表示当前用户的家目录 ~edu 表示用户 edu 的家目录 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载 /opt：给主机额外安装软件所摆放的目录 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等 /root：系统管理员root的家目录 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 /usr：应用程序存放目录 /usr/bin：存放应用程序 /usr/share：存放共享数据 /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包 /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /var：放置系统执行过程中经常变化的文件 /var/log：随时更改的日志文件 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动后，其 PID 存放在该目录下 Ubuntu 没有盘符这个概念，只有一个根目录/，所有文件都在它下面。 文件 在Linux中文件没有扩展名，可以通过颜色区分，也可以通过命令来区分file 文件名。在Linux中文件分为：普通文件、目录文件、设备文件、管道文件、链接文件。 文件权限 读权限（r）、写权限（w）、可执行权限（x）。通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。 d rwx rwx rwx 第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后9个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。每一个用户都有它自身的读、写和执行权限。 常用Linux命令 ctrl + shift + = //放大终端窗口的字体显示 ctrl + - //缩小终端窗口的字体显示 ls //查看当前文件夹下的内容 pwd //查看当前所在文件夹 cd //切换文件夹 touch [文件名] //如果文件不存在，新建文件 mkdir [目录名] //创建目录，参数-p可递归创建目录 rm [文件名] //删除指定的文件名 rm -r [文件夹名] //删除指定的文件 clear //清屏 Linux文件或者目录名称最长可以有256个字符，.代表当前目录，..代表上一级目录，以.开头的文件为隐藏文件，需要用-a参数才能显示。 ls -a //查看所有文件包含隐藏文件 ls -l //以列表形式查看文件，不包含隐藏文件 ls -lh //以列表形式查看文件，不包含隐藏文件 ，按照1024倍数显示{KB MB GB} ls -all //以列表形式查看文件，包含隐藏文件 快捷方式【ll】 通配符： 【*】 匹配任意多个字符【0-256】 a* 一个以上字符 256以下 【?】 匹配任意一个字符 a？ 两个字符 【[a-z]】 区间法 匹配a到z的所有字符 只能确定一个字符 【[abcde]】 穷举法 权值法 匹配abcde的所有字符 只能确定一个字符 重定向命令 //Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。 ls &gt; test.txt //test.txt 如果不存在，则创建，存在则覆盖其内容。 &gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 切换工作目录： cd ~ 切换到当前用户的主目录 cd .. 切换到上级目录 cd - 切换到上一次目录 查看或者合并文件内容： cat 文件名 cat a.txt b.txt &gt; c.txt 建立链接文件：ln //如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在。 //硬链接和拷贝（复制）区别:无论修改了哪一个链接之后的文件,两个文件都会改变,保持一致,但是拷贝不会。 ln 源文件 链接文件 //软链接文件不占磁盘空间 但是删除源文件会影响软链接文件 ln -s 源文件 链接文件 搜索文件里的文本内容： //行首,搜寻以a开头的行 grep -n &apos;^a&apos; 1.txt //行尾,搜寻以 ke 结束的行 grep -n &apos;ke$&apos; 1.txt //匹配 [] 里中一系列字符中的一个:搜寻匹配单词signal、signaL、Signal、SignaL的行 grep -n &apos;[Ss]igna[Ll]&apos; 1.txt //匹配一个非换行符的字符:匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae grep -n &apos;e.e&apos; 1.txt 计算文件行数或字数： wc 文件名 -l 统计行数 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -c 统计字节数 -m 统计字符数。这个标志不能与 -c 标志一起使用。 查找文件： find ./ -name test.sh //查找当前目录下所有名为test.sh的文件 find ./ -name &apos;*.sh&apos; //查找当前目录下所有后缀为.sh的文件 find ./ -name &quot;[A-Z]*&quot; //查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M //查找在/tmp 目录下等于2M的文件 find /tmp -size +2M //查找在/tmp 目录下大于2M的文件 find /tmp -size -2M //查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M //查找当前目录下大于4k，小于5M的文件 find ./ -perm 0777 //查找当前目录下权限为 777 的文件或目录 拷贝文件：cp cp vim_configure/ code/ -ivr //把文件夹 vim_configure 拷贝到 code 目录里： 移动文件：mv 获取文件类型： file 文件名 归档管理：tar //tar [参数] 打包文件名 文件 tar -cvf text.tar 1.text 2.text 3.text //解归档 tar -xvf test.tar //一步归档压缩:把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz tar zcvf test.tar.gz 1.c 2.c 3.c 4.c //一步解归档压缩 tar zxvf 文件名.tar.gz 文件压缩解压：gzip //tar与gzip命令结合使用实现文件打包、压缩。tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。 gzip text.tar //解压缩：生成了一个文件 归档文件名.tar gzip -d 归档文件名.tar.gz 文件压缩解压：bzip2 //bzip2压缩： tar -cjvf 文件名.tar.bz2 文件1 文件2 //bzip2解压缩： tar -xjvf 文件名.tar.bz2 -C 路径 文件压缩解压：zip、unzip //压缩 zip 文件名 文件1 文件2 生成一个文件为：文件名.zip //unzip解压缩： unzip 文件名.zip -C 路径 查看命令位置：which 用户、权限管理 查看当前用户：whoami 查看登录用户：who -m 切换用户 su //切换到root用户 su root //切换到root用户 su 普通用户 //切换到普通用户 su - 普通用户 //切换到普通用户，同时切换普通用户所在的目录 添加、删除组账号： groupadd 新建组账号 groupdel 组账号 修改用户所在组： usermod -g 用户组 用户名 添加组： groupadd 组名 // 添加组 需要用户权限 groupdel 组名 //删除组 需要用户权限和清空组成员 usermod -g 组名 用户名1 用户名2】//修改用户所在组：需要用户权限 修改文件权限：chmod 修改文件权限有两种使用格式：字母法与数字法。 //字母法： chmod u/g/o/a +/-/= rwx 文件 [ u/g/o/a ] 含义 u user 表示该文件的所有者 g group 表示与该文件的所有者属于同一组( group )者，即用户组 o other 表示其他以外的人 a all 表示这三者皆是 [ +-= ] 含义 + 增加权限 - 撤销权限 = 设定权限 rwx 含义 r read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。 w write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。 x excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。 //数字法：“rwx” 这些权限也可以用数字来代替 r 读取权限，数字代号为 &quot;4&quot; w 写入权限，数字代号为 &quot;2&quot; x 执行权限，数字代号为 &quot;1&quot; - 不具任何权限，数字代号为 &quot;0&quot; chmod u=rwx,g=rx,o=r filename //就等同于：chmod u=7,g=5,o=4 filename chmod 751 file //文件所有者：读、写、执行权限、同组用户：读、执行的权限、其它用户：执行的权限 修改文件所有者：chown 修改文件所属组：chgrp 系统管理 查看当前日历：cal 显示或设置时间：date 查看进程信息：ps 动态显示进程：top 终止进程：kill 后台程序：&amp;、jobs、fg 关机重启：reboot、shutdown、init VI VI编辑器有两个模式：文本编辑模式 命令行处理模式： 1、vi 文件名 2、vim 操作编辑器： 【i】在光标当前位置插入 【a】在光标右侧位置插入 【o】在光标下一行位置开启新的一行插入 【O】在光标上一行位置开启新的一行插入 【I】在光标当前行行首插入 【A】在光标当前行行尾插入 退出编辑器： 【ZZ】保存退出 【:wq】保存退出 【:x】保存退出 【:w 文件名】保存到指定文件中 【:q】 保存退出 针对未修改的文件 注意：未保存文件会提示 无法退出 【:q!】 强制退出 退出 不保存 【:! 命令】暂时离开vi 执行其他命令 编辑器操作： 【[n]x】删除光标位置后面n个字符 【[n]X】删除光标位置前面n个字符 【D】删除光标所在位置后面到行尾的所有字符 【[n]dd】删除光标所在行及下面n行 剪切 【p】在光标下一行粘贴 【[n]yy】复制光标所在行及下面n行 【dG】删除光标所在行到文件结尾 【J】合并光标所在行和下一行 中间用空格连接 【.】执行上一次命令行操作 【u】撤销 编辑器定位： 【ctrl+b】回滚 行号减小 【ctrl+f】前滚 行号增加 【gg】定位在文件第一行行首 【G】定位在文件最后一行行首 【:$】定位在文件最后一行行首 【[n]G | [n]gg】定位在m行 注意：在查找一些特殊含义的字符时，需要加上转义字符 【/内容】查找 【n】查找下一个 【N】查找上一个 【?】查找上一次的所搜内容 【/^word】 查找以word开头的内容 【/word$】 查找以word结尾的内容 【/.】查找任意一个字符 【/*】查找任意多个字符 编辑器替换： 【r】替换光标所在位置的字符 【:r 文件名】在光标当前行的下一行插入一个文件 每次添加只能添加一个文件 【:s/a/b/g】将光标所在行的a替换为b 【:g/a/s//b/g】将文件中所有a替换为b 【:n1,n2s/a/b/g】将行区间n1到n2的行中所有的a替换为b 编辑器设置： 【:set ic】搜索时不区分大小写 【:set noic】搜索时区分大小写 :set nu //显示行号 :set nonu //不显示行号 SSH 使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。 Xshell：是一个Windows平台下的SSH、TELNET和RLOGIN终端软件。它使得用户能轻松和安全地在Windows平台上访问Unix/Linux 主机。 Xftp：是一个应用于 Windows 平台的 FTP 和 SFTP 文件传输程序。Xftp能安全地在Unix/Linux 和 Windows 平台之间传输文件。 C语言概述 #include &lt;stdio.h&gt; int main(int argc, const char * argv[]) { printf(&quot;Hello, World!\\n&quot;); return 0; } return return代表函数执行完毕，返回return代表函数的终止 如果main定义的时候前面是int，那么return后面就需要写一个整数；如果main定义的时候前面是void，那么return后面什么也不需要写 在main函数中return 0代表程序执行成功，return -1代表程序执行失败 int main()和void main()在C语言中是一样的，但C++只接受int main这种定义方式 include #include的意思是头文件包含，#include &lt;stdio.h&gt;代表包含stdio.h这个头文件 使用C语言库函数需要提前包含库函数对应的头文件，如这里使用了printf()函数，需要包含stdio.h头文件 #include&lt; &gt; 与 #include &quot;&quot;的区别： &lt; &gt; 表示系统直接按系统指定的目录检索 &quot;&quot; 表示系统先在 &quot;&quot; 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索 C代码编译成可执行程序经过4步.c： 预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法（.i） 编译：检查语法，将预处理后文件编译生成汇编文件(.s) 汇编：将汇编文件生成目标文件(二进制文件)(.o) 链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去() 32个关键字 数据类型关键字（12个） char、short、int、long、float、double、unsigned、signed、struct、union、enum、void 控制语句关键字（12个） if、else、switch、case、default、for、do、while、break、continue、goto、return 存储类关键字（5个） auto、extern、register、static、constant 其他关键字（3个） sizeof、typedef、volatile 变量 声明变量不需要建立存储空间，如：extern int a;。定义变量需要建立存储空间，如：int b;。 #include &lt;stdio.h&gt; int main(int argc, const char* argv[]) { { //extern 关键字只做声明，不能做任何定义 //声明一个变量a，a在这里没有建立存储空间 extern int a; //a = 10; //err, 没有空间，就不可以赋值 int b = 10; //定义一个变量b，b的类型为int，b赋值为10 return 0; } } define、const #include &lt;stdio.h&gt; #define MAX 10 //声明了一个常量，名字叫MAX，值是10，常量的值一旦初始化不可改 int main() { int a; //定义了一个变量，其类型为int，名字叫a const int b = 10; //定义一个const常量，名为叫b，值为10 //b = 11; //err,常量的值不能改变 //MAX = 100; //err,常量的值不能改变 a = MAX;//将abc的值设置为MAX的值 a = 123; printf(&quot;%d\\n&quot;, a); //打印变量a的值 return 0; } 通过 #define 定义的常量,是根据值来匹配数据类型的。const修饰的常量是不安全，可以通过指针来修改。 进制 #include &lt;stdio.h&gt; int main() { int a = 123; //十进制方式赋值 int b = 0123; //八进制方式赋值， 以数字0开头 int c = 0xABC; //十六进制方式赋值 //如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x printf(&quot;十进制：%d\\n&quot;, a); printf(&quot;八进制：%o\\n&quot;, b); //%o,为字母o,不是数字 printf(&quot;十六进制：%x\\n&quot;, c); return 0; } sizeof sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节。sizeof的返回值为size_t。size_t类型在32位操作系统下是unsigned int，是一个无符号的整数。 #include &lt;stdio.h&gt; int main() { int a; int b = sizeof(a);//sizeof得到指定值占用内存的大小，单位：字节 printf(&quot;b = %d\\n&quot;, b); size_t c = sizeof(a); printf(&quot;c = %u\\n&quot;, c);//用无符号数的方式输出c的值 return 0; } int 打印格式 %hd 输出short类型 %d 输出int类型 %l 输出long类型 %ll 输出long long类型 %hu 输出unsigned short类型 %u 输出unsigned int类型 %lu 输出unsigned long类型 %llu 输出unsigned long long类型 代码 #include &lt;stdio.h&gt; int main() { short a = 10; int b = 10; long c = 10l; //或者10L long long d = 10ll; //或者10LL printf(&quot;sizeof(a) = %u\\n&quot;, sizeof(a)); printf(&quot;sizeof(b) = %u\\n&quot;, sizeof(b)); printf(&quot;sizeof(c) = %u\\n&quot;, sizeof(c)); printf(&quot;sizeof(c) = %u\\n&quot;, sizeof(d)); printf(&quot;short a = %hd\\n&quot;, a); printf(&quot;int b = %d\\n&quot;, b); printf(&quot;long c = %ld\\n&quot;, c); printf(&quot;long long d = %lld\\n&quot;, d); unsigned short a2 = 20u; unsigned int b2 = 20u; unsigned long c2 = 20ul; unsigned long long d2 = 20ull; printf(&quot;unsigned short a = %hu\\n&quot;, a2); printf(&quot;unsigned int b = %u\\n&quot;, b2); printf(&quot;unsigned long c = %lu\\n&quot;, c2); printf(&quot;unsigned long long d = %llu\\n&quot;, d2); return 0; } 有符号数是最高位为符号位，0代表正数，1代表负数。 #include &lt;stdio.h&gt; int main() { signed int a = -1089474374; //定义有符号整型变量a printf(&quot;%X\\n&quot;, a); //结果为 BF0FF0BA //B F 0 F F 0 B A //1011 1111 0000 1111 1111 0000 1011 1010 return 0; } 无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。无符号数，可以增大数的表达最大值。 #include &lt;stdio.h&gt; int main() { unsigned int a = 3236958022; //定义无符号整型变量a printf(&quot;%X\\n&quot;, a); //结果为 C0F00F46 return 0; } char 字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。 #include &lt;stdio.h&gt; int main() { char ch = &apos;a&apos;; printf(&quot;sizeof(ch) = %u\\n&quot;, sizeof(ch)); printf(&quot;ch[%%c] = %c\\n&quot;, ch); //打印字符 printf(&quot;ch[%%d] = %d\\n&quot;, ch); //打印‘a’ ASCII的值 char A = &apos;A&apos;; char a = &apos;a&apos;; printf(&quot;a = %d\\n&quot;, a); //97 printf(&quot;A = %d\\n&quot;, A); //65 printf(&quot;A = %c\\n&quot;, &apos;a&apos; - 32); //小写a转大写A printf(&quot;a = %c\\n&quot;, &apos;A&apos; + 32); //大写A转小写a ch = &apos; &apos;; printf(&quot;空字符：%d\\n&quot;, ch); //空字符ASCII的值为32 printf(&quot;A = %c\\n&quot;, &apos;a&apos; - &apos; &apos;); //小写a转大写A printf(&quot;a = %c\\n&quot;, &apos;A&apos; + &apos; &apos;); //大写A转小写a return 0; } float、double #include &lt;stdio.h&gt; int main() { //传统方式赋值 float a = 3.14f; //或3.14F double b = 3.14; printf(&quot;a = %f\\n&quot;, a); printf(&quot;b = %lf\\n&quot;, b); //科学法赋值,e3相当于1000，e-3相当于0.001 a = 3.2e3f; //3.2*1000 = 32000，e可以写E printf(&quot;a1 = %f\\n&quot;, a); a = 100e-3f; //100*0.001 = 0.1 printf(&quot;a2 = %f\\n&quot;, a); a = 3.1415926f; printf(&quot;a3 = %f\\n&quot;, a); //结果为3.141593 return 0; } 类型限定符 //extern:声明一个变量，extern声明的变量没有建立存储空间 extern int a; //const:定义一个常量，常量的值不能修改。 const int a = 10; //volatile 防止编译器优化代码 //register 定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。 字符串常量 字符串是内存中一段连续的char空间，以&#39;\\0&#39;(数字0)结尾。 每个字符串的结尾，编译器会自动的添加一个结束标志位&#39;\\0&#39;，即 &quot;a&quot; 包含两个字符&#39;a&#39;和&#39;\\0&#39;。 运算符 C语言的比较运算中，“真”用数字“1”来表示，“假”用数字“0”来表示。 -&gt; 对象指针-&gt;成员名 //成员选择（指针） &amp; &amp;变量名 //取地址运算符 三目运算符 #include &lt;stdio.h&gt; int main() { int a = 10; int b = 20; int c; c = (a &gt; b ? a : b); printf(&quot;c = %d\\n&quot;, c); return 0; } 冒泡排序 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; int main() { int arr[10] = { 7,4,2,3,5,8,9,6,1,10 }; int len = sizeof(arr) / sizeof(arr[0]) - 1; //冒泡排序 从小到大 for (int i = 0; i &lt;= len; i++) { for (int j = 0; j &lt; len - i; j++) { if (arr[j] &lt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i &lt; 10; i++) { printf(&quot;%d\\n&quot;, arr[i]); } system(&quot;pause&quot;); return EXIT_SUCCESS; } goto语句 无条件跳转，尽量少用。 #include &lt;stdio.h&gt; int main() { goto End; //无条件跳转到End的标识 printf(&quot;aaaaaaaaa\\n&quot;); End: printf(&quot;bbbbbbbb\\n&quot;); return 0; } 数组 数组就是在内存中连续的相同类型的变量空间。同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的。 #include &lt;stdio.h&gt; int main() { int a[10];//定义了一个数组，名字叫a，有10个成员，每个成员都是int类型 //a[0]…… a[9]，没有a[10] //没有a这个变量，a是数组的名字，但不是变量名，它是常量 int i = 0; for (i = 0; i &lt; 10; i++) { a[i] = i; //给数组赋值 } //遍历数组，并输出每个成员的值 for (i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\\n&quot;); return 0; } 一维数组的初始化 在定义数组的同时进行赋值，称为初始化。全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。 int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//定义一个数组，同时初始化所有成员变量 int a[10] = { 1, 2, 3 };//初始化前三个成员，后面所有元素都设置为0 int a[10] = { 0 };//所有的成员都设置为0 //[]中不定义元素个数，定义时必须初始化 int a[] = { 1, 2, 3, 4, 5 };//定义了一个数组，有5个成员 数组名 数组名是一个地址的常量，代表数组中首元素的地址。 #include &lt;stdio.h&gt; int main() { int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//定义一个数组，同时初始化所有成员变量 printf(&quot;a = %p\\n&quot;, a); printf(&quot;&amp;a[0] = %p\\n&quot;, &amp;a[0]);//相等的 int n = sizeof(a); //数组占用内存的大小，10个int类型，10 * 4 = 40 int n0 = sizeof(a[0]);//数组第0个元素占用内存大小，第0个元素为int，4 //遍历数组 int i = 0; for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\\n&quot;); return 0; } 数组元素个数： int （size_t） unsigned int 个数 = sizeof(数组名)/sizeof(数组元素 | 数组数据类型) 数组地址 int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//定义一个数组，同时初始化所有成员变量 printf(&quot;a = %p\\n&quot;, a); printf(&quot;&amp;a[0] = %p\\n&quot;, &amp;a[0]); 一维数组的最值 #include &lt;stdio.h&gt; int main() { int a[] = { 1, -2, 3,-4, 5, -6, 7, -8, -9, 10 };//定义一个数组，同时初始化所有成员变量 int i = 0; int max = a[0]; for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) { if (a[i] &gt; max) { max = a[i]; } } printf(&quot;数组中最大值为：%d\\n&quot;, max); return 0; } 一维数组的逆置 #include &lt;stdio.h&gt; int main() { int a[] = { 1, -2, 3,-4, 5, -6, 7, -8, -9, 10 };//定义一个数组，同时初始化所有成员变量 int i = 0; int j = sizeof(a) / sizeof(a[0]) - 1; int tmp; while (i &lt; j) { tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; } for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) { printf(&quot;%d &quot;, a[i]);//10 -9 -8 7 -6 5 -4 3 -2 1 } printf(&quot;\\n&quot;); return 0; } 冒泡法排序 #include &lt;stdio.h&gt; int main() { int a[] = { 1, -2, 3,-4, 5, -6, 7, -8, -9, 10 };//定义一个数组，同时初始化所有成员变量 int i = 0; int j = 0; int n = sizeof(a) / sizeof(a[0]); int tmp; for (i = 0; i &lt; n - 1; i++) { for (j = 0; j &lt; n - i - 1; j++)//内循环的目的是比较相邻的元素，把大的放到后面 { if (a[j] &gt; a[j + 1]) { tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; } } } for (i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\\n&quot;); return 0; } 二维数组 //常量表达式1表示第一维下标的长度，常量表达式2表示第二维下标的长度。 类型说明符 数组名[常量表达式1][常量表达式2] 在内存中并不存在二维数组，二维数组实际的硬件存储器是连续编址的，也就是说内存中只有一维数组，即放完一行之后顺次放入第二行，和一维数组存放方式是一样的。 实现 #include &lt;stdio.h&gt; int main() { //定义了一个二维数组，名字叫a //由3个一维数组组成，这个一维数组是int [4] //这3个一维数组的数组名分别为a[0],a[1],a[2] int a[3][4]; //给数组每个元素赋值 int i = 0; int j = 0; int num = 0; for (i = 0; i &lt; 3; i++) { for (j = 0; j &lt; 4; j++) { a[i][j] = num++; } } //遍历数组，并输出每个成员的值 for (i = 0; i &lt; 3; i++) { for (j = 0; j &lt; 4; j++) { printf(&quot;%d, &quot;, a[i][j]); } printf(&quot;\\n&quot;); } return 0; } 二维数组的初始化 //分段赋值 int a[3][4] = {{ 1, 2, 3, 4 },{ 5, 6, 7, 8, },{ 9, 10, 11, 12 }}; //连续赋值 int a[3][4] = { 1, 2, 3, 4 , 5, 6, 7, 8, 9, 10, 11, 12}; //可以只给部分元素赋初值，未初始化则为0 int a[3][4] = { 1, 2, 3, 4}; //所有的成员都设置为0 int a[3][4] = {0}; //[]中不定义元素个数，定义时必须初始化 int a[][4] = { 1, 2, 3, 4, 5, 6, 7, 8}; 数组名 数组名是一个地址的常量，代表数组中首元素的地址。 #include &lt;stdio.h&gt; int main() { //定义了一个二维数组，名字叫a。二维数组是本质上还是一维数组，此一维数组有3个元素。每个元素又是一个一维数组int[4] int a[3][4] = { 1, 2, 3, 4 , 5, 6, 7, 8, 9, 10, 11, 12 }; //数组名为数组首元素地址，二维数组的第0个元素为一维数组。第0个一维数组的数组名为a[0] printf(&quot;a = %p\\n&quot;, a); printf(&quot;a[0] = %p\\n&quot;, a[0]);//二者相等 //测二维数组所占内存空间，有3个一维数组，每个一维数组的空间为4*4。sizeof(a) = 3 * 4 * 4 = 48 printf(&quot;sizeof(a) = %d\\n&quot;, sizeof(a)); //测第0个元素所占内存空间，a[0]为第0个一维数组int[4]的数组名，4*4=16 printf(&quot;sizeof(a[0]) = %d\\n&quot;, sizeof(a[0])); //测第0行0列元素所占内存空间，第0行0列元素为一个int类型，4字节 printf(&quot;sizeof(a[0][0]) = %d\\n&quot;, sizeof(a[0][0])); //求二维数组行数，3 printf(&quot;i = %d\\n&quot;, sizeof(a) / sizeof(a[0])); // 求二维数组列数，4 printf(&quot;j = %d\\n&quot;, sizeof(a[0]) / sizeof(a[0][0])); //求二维数组行*列总数，12 printf(&quot;n = %d\\n&quot;, sizeof(a) / sizeof(a[0][0])); return 0; } 字符数组与字符串 C语言中没有字符串这种数据类型，可以通过char的数组来替代；字符串一定是一个char的数组，但char的数组未必是字符串；数字0(和字符‘\\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。 #include &lt;stdio.h&gt; int main() { char c1[] = { &apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos; }; //普通字符数组 printf(&quot;c1 = %s\\n&quot;, c1); //乱码，因为没有’\\0’结束符 //以‘\\0’(‘\\0’就是数字0)结尾的字符数组是字符串 char c2[] = { &apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;\\0&apos; }; printf(&quot;c2 = %s\\n&quot;, c2); //字符串处理以‘\\0’(数字0)作为结束符，后面的&apos;h&apos;, &apos;l&apos;, &apos;l&apos;, &apos;e&apos;, &apos;o&apos;不会输出 char c3[] = { &apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;\\0&apos;, &apos;h&apos;, &apos;l&apos;, &apos;l&apos;, &apos;e&apos;, &apos;o&apos;, &apos;\\0&apos; }; printf(&quot;c3 = %s\\n&quot;, c3); return 0; } 字符串初始化 #include &lt;stdio.h&gt; // C语言没有字符串类型，通过字符数组模拟 // C语言字符串，以字符‘\\0’, 数字0 int main() { //不指定长度, 没有0结束符，有多少个元素就有多长 char buf[] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; }; printf(&quot;buf = %s\\n&quot;, buf); //乱码 //指定长度，后面没有赋值的元素，自动补0 char buf2[100] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; }; printf(&quot;buf2 = %s\\n&quot;, buf2);//buf2 = abc //所有元素赋值为0 char buf3[100] = { 0 }; //char buf4[2] = { &apos;1&apos;, &apos;2&apos;, &apos;3&apos; };//数组越界 char buf5[50] = { &apos;1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;0&apos;, &apos;7&apos; }; printf(&quot;buf5 = %s\\n&quot;, buf5);//buf5 = 1ab07 char buf6[50] = { &apos;1&apos;, &apos;a&apos;, &apos;b&apos;, 0, &apos;7&apos; }; printf(&quot;buf6 = %s\\n&quot;, buf6);// 1ab char buf7[50] = { &apos;1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;\\0&apos;, &apos;7&apos; }; printf(&quot;buf7 = %s\\n&quot;, buf7);// 1ab //使用字符串初始化，编译器自动在后面补0，常用 char buf8[] = &quot;agjdslgjlsdjg&quot;; //&apos;\\0&apos;后面最好不要连着数字，有可能几个数字连起来刚好是一个转义字符 //&apos;\\ddd&apos;八进制字义字符，&apos;\\xdd&apos;十六进制转移字符 // \\012相当于\\n char str[] = &quot;\\012abc&quot;; printf(&quot;str == %s\\n&quot;, str); return 0; } 字符串追加拼接 #include &lt;stdio.h&gt; int main() { char str1[] = &quot;abcdef&quot;; char str2[] = &quot;123456&quot;; char dst[100]; int i = 0; while (str1[i] != 0) { dst[i] = str1[i]; i++; } int j = 0; while (str2[j] != 0) { dst[i + j] = str2[j]; j++; } dst[i + j] = 0; //字符串结束符 printf(&quot;dst = %s\\n&quot;, dst); return 0; } 随机数 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int main() { time_t tm = time(NULL);//得到系统时间 srand((unsigned int)tm);//随机种子只需要设置一次即可 int r = rand(); printf(&quot;r = %d\\n&quot;, r); return 0; } strlen() #include &lt;string.h&gt;计算指定指定字符串的长度，不包含字符串结束符‘\\0’。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str[] = &quot;abcdefg&quot;; int n = strlen(str); printf(&quot;n = %d\\n&quot;, n); return 0; } strcpy_s include &lt;string.h&gt; char *strcpy_s(char *dest, const char *src); 功能：把src所指向的字符串复制到dest所指向的空间中，’\\0’也会拷贝过去。返回值：成功：返回dest字符串的首地址；失败：NULL。 注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char dest[20] = &quot;123456789&quot;; char src[] = &quot;hello world&quot;; strcpy_s(dest, src); printf(&quot;%s\\n&quot;, dest); return 0; } strncpy_s #include &lt;string.h&gt; char *strncpy_s(char *dest, const char *src, size_t n);把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含’\\0’。返回值：成功：返回dest字符串的首地址;失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char dest[20]; char src[] = &quot;hello world&quot;; strncpy_s(dest, src, 5); printf(&quot;%s\\n&quot;, dest); dest[5] = &apos;\\0&apos;; printf(&quot;%s\\n&quot;, dest); return 0; } strcat_s #include &lt;string.h&gt; char *strcat_s(char *dest, const char *src);将src字符串连接到dest的尾部，‘\\0’也会追加过去。返回值：成功：返回dest字符串的首地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str[20] = &quot;123&quot;; char src[] = &quot;hello world&quot;; strcat_s(str, src); printf(&quot;%s\\n&quot;, str); return 0; } strncat_s #include &lt;string.h&gt; char *strncat(char *dest, const char *src, size_t n);将src字符串前n个字符连接到dest的尾部，‘\\0’也会追加过去。返回值：成功：返回dest字符串的首地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str[20] = &quot;123&quot;; char src[] = &quot;hello world&quot;; strncat_s(str, src,5); printf(&quot;%s\\n&quot;, str); return 0; } strcmp和strncmp 比较 s1 和 s2 的大小，比较的是字符ASCII码大小。返回值：相等：0; 大于：&gt;0; 小于：&lt;0。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello mike&quot;; if (strcmp(str1, str2) == 0) { printf(&quot;str1==str2\\n&quot;); } else if (strcmp(str1, str2) &gt; 0) { printf(&quot;str1&gt;str2\\n&quot;); } else { printf(&quot;str1&lt;str2\\n&quot;); } return 0; } #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello mike&quot;; if (strncmp(str1, str2, 5) == 0) { printf(&quot;str1==str2\\n&quot;); } else if (strncmp(str1, str2, 5) &gt; 0) { printf(&quot;str1&gt;str2\\n&quot;); } else { printf(&quot;str1&lt;str2\\n&quot;); } return 0; } sprintf_s #include &lt;stdio.h&gt; int main() { char dst[100] = { 0 }; int a = 10; char src[] = &quot;hello world&quot;; printf(&quot;a = %d, src = %s&quot;, a, src); printf(&quot;\\n&quot;); int len = sprintf_s(dst, &quot;a = %d, src = %s&quot;, a, src); printf(&quot;dst = \\&quot; %s\\&quot;\\n&quot;, dst);// dst = &quot; a = 10, src = hello world&quot; printf(&quot;len = %d\\n&quot;, len);//25 return 0; } strchr #include &lt;string.h&gt; char *strchr(const char *s, int c);在字符串s中查找字母c出现的位置。返回值：成功：返回第一次出现的c地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char src[] = &quot;ddda123abcd&quot;; char* p = strchr(src, &apos;a&apos;); printf(&quot;p = %s\\n&quot;, p); return 0; } strstr #include &lt;string.h&gt; char *strstr(const char *haystack, const char *needle);在字符串haystack中查找字符串needle出现的位置。返回值：成功：返回第一次出现的needle地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char src[] = &quot;ddddabcd123abcd333abcd&quot;; char* p = strstr(src, &quot;abcd&quot;); printf(&quot;p = %s\\n&quot;, p);//p = abcd123abcd333abcd return 0; } strstr #include &lt;stdlib.h&gt; int atoi(const char *nptr);atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(‘\\0’)才结束转换，并将结果返回返回值。返回值：成功转换后整数 类似的函数有：atof()：把一个小数形式的字符串转化为一个浮点数。atol()：将一个字符串转化为long类型。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { char str1[] = &quot;-10&quot;; int num1 = atoi(str1); printf(&quot;num1 = %d\\n&quot;, num1);//num1 = -10 char str2[] = &quot;0.123&quot;; double num2 = atof(str2); printf(&quot;num2 = %lf\\n&quot;, num2);//num2 = 0.123000 return 0; } 函数函数的定义 函数定义的一般形式： 返回类型 函数名(形式参数列表) { 数据定义部分; 执行语句部分; } 如果没有形参，圆括号内容为空，或写一个void关键字。 函数的形参和实参 形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参也不能使用。单向传递，只由实参传给形参，而不能由形参传回来给实参。在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放。实参单元与形参单元是不同的单元。调用结束后，形参单元被释放，函数调用结束返回主调函数后则不能再使用该形参变量。实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调函数中实参的值。 实参可以是常量、变量或表达式。 函数的声明 函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数作声明。 所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行。注意：一个函数只能被定义一次，但可以声明多次。 #include &lt;stdio.h&gt; int max(int x, int y); // 函数的声明，分号不能省略 // int max(int, int); // 另一种方式 int main() { int a = 10, b = 25, num_max = 0; num_max = max(a, b); // 函数的调用 printf(&quot;num_max = %d\\n&quot;, num_max); return 0; } // 函数的定义 int max(int x, int y) { return x &gt; y ? x : y; } exit 在main函数中调用exit和return结果是一样的，但在子函数中调用return只是代表子函数终止了，在子函数中调用exit，那么程序终止。 分文件编程 max.h文件 extern int max(int a, int b); max.c文件 int max(int x, int y) { return x &gt; y ? x : y; } main.c文件 #include &lt;stdio.h&gt; #include &quot;max.h&quot; int main() { int a = 10, b = 25, num_max = 0; num_max = max(a, b); // 函数的调用 printf(&quot;num_max = %d\\n&quot;, num_max); return 0; } 防止头文件重复包含 方法一： #ifndef __SOMEFILE_H__ #define __SOMEFILE_H__ // 声明语句 #endif 方法二： #pragma once // 声明语句 指针int i 定义整形变量 int *p 定义一个指向int的指针变量 int a[10] 定义一个有10个元素的数组，每个元素类型为int int *p[10] 定义一个有10个元素的数组，每个元素类型为int* int func() 定义一个函数，返回值为int型 int *func() 定义一个函数，返回值为int *型 int **p 定义一个指向int的指针的指针，二级指针 内存地址和指针 将内存抽象成一个很大的一维字符数组。编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）。这个内存编号我们称之为内存地址。 内存中的每一个数据都会分配相应的地址：char:占一个字节分配一个地址；int: 占四个字节分配四个地址。 内存区的每一个字节都有一个编号，这就是“地址”。 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号) 指针的实质就是内存“地址”。指针就是地址，地址就是指针。指针是内存单元的编号，指针变量是存放地址的变量。 指针也是一种数据类型，指针变量也是一种变量。指针变量指向谁，就把谁的地址赋值给指针变量。“*”操作符操作的是指针变量指向的内存空间。 #include &lt;stdio.h&gt; int main() { int a = 0; char b = 100; printf(&quot;%p, %p\\n&quot;, &amp;a, &amp;b); //打印a, b的地址 //int *代表是一种数据类型，int*指针类型，p才是变量名 //定义了一个指针类型的变量，可以指向一个int类型变量的地址 int* p; p = &amp;a;//将a的地址赋值给变量p，p也是一个变量，值是一个内存地址编号 printf(&quot;%d\\n&quot;, *p);//p指向了a的地址，*p就是a的值 char* p1 = &amp;b; printf(&quot;%c\\n&quot;, *p1);//*p1指向了b的地址，*p1就是b的值 return 0; } 通过指针间接修改变量的值 #include &lt;stdio.h&gt; int main() { int a = 0; int b = 11; int* p = &amp;a; *p = 100; printf(&quot;a = %d, *p = %d\\n&quot;, a, *p);//a = 100, *p = 100 p = &amp;b; *p = 22; printf(&quot;b = %d, *p = %d\\n&quot;, b, *p);//b = 22, *p = 22 return 0; } 指针大小 使用sizeof()测量指针的大小，得到的总是：4或8。sizeof()测的是指针变量指向存储地址的大小。 在32位平台，所有的指针（地址）都是32位(4字节)。在64位平台，所有的指针（地址）都是64位(8字节)。 野指针和空指针 指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。 int a = 100; int* p; p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义 p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义 *p = 1000; //操作野指针指向未知区域，内存出问题，err 但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。NULL是一个值为0的宏常量： int *p = NULL; 万能指针 void *指针可以指向任意变量的内存空间： void* p = NULL; int a = 10; p = (void*)&amp;a; //指向变量时，最好转换为void * //使用指针变量指向的内存时，转换为int * *((int*)p) = 11; printf(&quot;a = %d\\n&quot;, a);//11 const修饰的指针变量 指针常量和常量的指针 #include &lt;stdio.h&gt; int main() { int a = 100; int b = 200; //指向常量的指针 //修饰*，指针指向内存区域不能修改，指针指向可以变 const int* p1 = &amp;a; //等价于int const *p1 = &amp;a; //*p1 = 111; //err p1 = &amp;b; //ok //指针常量 //修饰p2，指针指向不能变，指针指向的内存可以修改 int* const p2 = &amp;a; //p2 = &amp;b; //err *p2 = 222; //ok return 0; } 指针和数组 数组名字是数组的首元素地址，但它是一个常量： int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; printf(&quot;a = %p\\n&quot;, a);//a = 0000002A5F6FFB48 printf(&quot;&amp;a[0] = %p\\n&quot;, &amp;a[0]);//&amp;a[0] = 0000002A5F6FFB48 //a = 10; //err, 数组名只是常量，不能修改 指针操作数组元素 #include &lt;stdio.h&gt; int main() { int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int i = 0; int n = sizeof(a) / sizeof(a[0]); for (i = 0; i &lt; n; i++) { //printf(&quot;%d, &quot;, a[i]); printf(&quot;%d, &quot;, *(a + i));//1, 2, 3, 4, 5, 6, 7, 8, 9, } printf(&quot;\\n&quot;); int* p = a; //定义一个指针变量保存a的地址 for (i = 0; i &lt; n; i++) { p[i] = 2 * i; } for (i = 0; i &lt; n; i++) { printf(&quot;%d, &quot;, *(p + i));//0, 2, 4, 6, 8, 10, 12, 14, 16, } printf(&quot;\\n&quot;); return 0; } 指针加法运算:指针计算不是简单的整数相加，如果是一个int *，+1的结果是增加一个int的大小;如果是一个char *，+1的结果是增加一个char大小。 int a; int* p = &amp;a; printf(&quot;%d\\n&quot;, p);//896988804 p += 2;//移动了2个int printf(&quot;%d\\n&quot;, p);//896988812 char b = 0; char* p1 = &amp;b; printf(&quot;%d\\n&quot;, p1);//896988812 p1 += 2;//移动了2个char printf(&quot;%d\\n&quot;, p1);//896988812 return 0; 通过改变指针指向操作数组元素： #include &lt;stdio.h&gt; int main() { int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int i = 0; int n = sizeof(a) / sizeof(a[0]); int *p = a; for (i = 0; i &lt; n; i++) { printf(&quot;%d, &quot;, *p); p++; } printf(&quot;\\n&quot;);//1, 2, 3, 4, 5, 6, 7, 8, 9, return 0; } 指针减法运算 int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int* p2 = &amp;a[2]; //第2个元素地址 int* p1 = &amp;a[1]; //第1个元素地址 printf(&quot;p1 = %p, p2 = %p\\n&quot;, p1, p2); int n1 = p2 - p1; //n1 = 1 int n2 = (int)p2 - (int)p1; //n2 = 4 printf(&quot;n1 = %d, n2 = %d\\n&quot;, n1, n2); 指针数组，它是数组，数组的每个元素都是指针类型。 //指针数组 int* p[3]; int a = 1; int b = 2; int c = 3; int i = 0; p[0] = &amp;a; p[1] = &amp;b; p[2] = &amp;c; for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++) { printf(&quot;%d, &quot;, *(p[i]));//1, 2, 3, } printf(&quot;\\n&quot;); 多级指针 C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。二级指针就是指向一个一级指针变量地址的指针。 int a = 10; int* p = &amp;a; //一级指针 *p = 100; //*p就是a int** q = &amp;p; //*q就是p //**q就是a int*** t = &amp;q; //*t就是q //**t就是p //***t就是a 指针和函数函数形参改变实参的值 #include &lt;stdio.h&gt; void swap1(int x, int y) { int tmp; tmp = x; x = y; y = tmp; printf(&quot;x = %d, y = %d\\n&quot;, x, y);//x = 5, y = 3 } void swap2(int* x, int* y) { int tmp; tmp = *x; *x = *y; *y = tmp; } int main() { int a = 3; int b = 5; swap1(a, b); //值传递 printf(&quot;a = %d, b = %d\\n&quot;, a, b);//a = 3, b = 5 a = 3; b = 5; swap2(&amp;a, &amp;b); //地址传递 printf(&quot;a2 = %d, b2 = %d\\n&quot;, a, b);//a2 = 5, b2 = 3 return 0; } 数组名做函数参数 数组名做函数参数，函数的形参会退化为指针。 //void printArrary(int a[10], int n) //void printArrary(int a[], int n) void printArrary(int* a, int n) { int i = 0; for (i = 0; i &lt; n; i++) { printf(&quot;%d, &quot;, a[i]);//1, 2, 3, 4, 5, 6, 7, 8, 9, } printf(&quot;\\n&quot;); } int main() { int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int n = sizeof(a) / sizeof(a[0]); //数组名做函数参数 printArrary(a, n); return 0; } 指针做为函数的返回值 #include &lt;stdio.h&gt; int a = 10; int* getA() { return &amp;a; } int main() { *(getA()) = 111; printf(&quot;a = %d\\n&quot;, a);//a = 111 return 0; } 指针和字符串 char str[] = &quot;hello world&quot;; char* p = str; *p = &apos;m&apos;; p++; *p = &apos;i&apos;; printf(&quot;%s\\n&quot;, str);//millo world p = &quot;mike jiang&quot;; printf(&quot;%s\\n&quot;, p);//mike jiang char* q = &quot;test&quot;; printf(&quot;%s\\n&quot;, q);//test 字符指针做函数参数 #include &lt;stdio.h&gt; void mystrcat(char* dest, const char* src) { int len1 = 0; int len2 = 0; while (dest[len1]) { len1++; } while (src[len2]) { len2++; } int i; for (i = 0; i &lt; len2; i++) { dest[len1 + i] = src[i]; } } int main() { char dst[100] = &quot;hello mike&quot;; char src[] = &quot;123456&quot;; mystrcat(dst, src); printf(&quot;dst = %s\\n&quot;, dst);//dst = hello mike123456 return 0; } const修饰的指针，变量从左往右看，跳过类型，看修饰哪个字符，如果是*， 说明指针指向的内存不能改变，如果是指针变量，说明指针的指向不能改变，指针的值不能修改。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) { //const修饰一个变量为只读 const int a = 10; //a = 100; //err //指针变量， 指针指向的内存， 2个不同概念 char buf[] = &quot;aklgjdlsgjlkds&quot;; //从左往右看，跳过类型，看修饰哪个字符 //如果是*， 说明指针指向的内存不能改变 //如果是指针变量，说明指针的指向不能改变，指针的值不能修改 const char* p = buf; // 等价于上面 char const *p1 = buf; //p[1] = &apos;2&apos;; //err p = &quot;agdlsjaglkdsajgl&quot;; //ok char* const p2 = buf; p2[1] = &apos;3&apos;; //p2 = &quot;salkjgldsjaglk&quot;; //err //p3为只读，指向不能变，指向的内存也不能变 const char* const p3 = buf; return 0; } 查找”abcd”个数-while #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) { char* p = &quot;11abcd111122abcd333abcd3322abcd3333322qqq&quot;; int n = 0; while ((p = strstr(p, &quot;abcd&quot;)) != NULL) { //能进来，肯定有匹配的子串 //重新设置起点位置 p = p + strlen(&quot;abcd&quot;); n++; if (*p == 0) //如果到结束符 { break; } } printf(&quot;n = %d\\n&quot;, n); return 0; } 查找”abcd”个数-do-while #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) { char* p = &quot;11abcd111122abcd333abcd3322abcd3333322qqq&quot;; int n = 0; do { p = strstr(p, &quot;abcd&quot;); if (p != NULL) { n++; //累计个数 //重新设置查找的起点 p = p + strlen(&quot;abcd&quot;); } else //如果没有匹配的字符串，跳出循环 { break; } } while (*p != 0); //如果没有到结尾 printf(&quot;n = %d\\n&quot;, n); return 0; } 求非空字符串元素的个数： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; int fun(char* p, int* n) { if (p == NULL || n == NULL) { return -1; } int begin = 0; int end = strlen(p) - 1; //从左边开始 //如果当前字符为空，而且没有结束 while (p[begin] == &apos; &apos; &amp;&amp; p[begin] != 0) { begin++; //位置从右移动一位 } //从右往左移动 while (p[end] == &apos; &apos; &amp;&amp; end &gt; 0) { end--; //往左移动 } if (end == 0) { return -2; } //非空元素个数 *n = end - begin + 1; return 0; } int main(void) { char* p = &quot; abcddsgadsgefg &quot;; int ret = 0; int n = 0; ret = fun(p, &amp;n); if (ret != 0) { return ret; } printf(&quot;非空字符串元素个数：%d\\n&quot;, n);//非空字符串元素个数：14 return 0; } 字符串反转模型(逆置): #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int inverse(char* p) { if (p == NULL) { return -1; } char* str = p; int begin = 0; int end = strlen(str) - 1; char tmp; while (begin &lt; end) { //交换元素 tmp = str[begin]; str[begin] = str[end]; str[end] = tmp; begin++; //往右移动位置 end--; //往左移动位置 } return 0; } int main(void) { //char *str = &quot;abcdefg&quot;; //文件常量区，内容不允许修改 char str[] = &quot;abcdef&quot;; int ret = inverse(str); if (ret != 0) { return ret; } printf(&quot;str ========== %s\\n&quot;, str);//str ========== fedcba return 0; } 内存管理 类型 作用域 生命周期 存储位置 auto变量 一对{}内 当前函数 栈区 static局部变量 一对{}内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对{}内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 C代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。 只有c语言将数组放在栈区。 malloc() #include &lt;stdlib.h&gt; void *malloc(size_t size); 功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。参数：size：需要分配内存大小(单位：字节)。返回值：成功：分配空间的起始地址，失败：NULL。 free #include &lt;stdlib.h&gt; void free(void *ptr); 功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。参数：ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。返回值：无。 结构体 定义结构体变量的方式：先声明结构体类型再定义变量名；在声明类型的同时定义变量；直接定义结构体类型变量（无类型名）。 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { &quot;mike&quot;, 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { &quot;lily&quot;, 22 }; struct { char name[50]; int age; }s3 = { &quot;yuri&quot;, 25 }; 结构体成员的使用 #include&lt;stdio.h&gt; #include&lt;string.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, &quot;abc&quot;); s1.age = 18; printf(&quot;s1.name = %s, s1.age = %d\\n&quot;, s1.name, s1.age); //如果是指针变量，通过-&gt;操作结构体成员 strcpy((&amp;s1)-&gt;name, &quot;test&quot;); (&amp;s1)-&gt;age = 22; printf(&quot;(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\\n&quot;, (&amp;s1)-&gt;name, (&amp;s1)-&gt;age); return 0; } 结构体数组 #include &lt;stdio.h&gt; //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, &quot;Li ping&quot;, &apos;M&apos;, 45 }, { 102, &quot;Zhang ping&quot;, &apos;M&apos;, 62.5 }, { 103, &quot;He fang&quot;, &apos;F&apos;, 92.5 }, { 104, &quot;Cheng ling&quot;, &apos;F&apos;, 87 }, { 105, &quot;Wang ming&quot;, &apos;M&apos;, 58 } }; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i &lt; 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score &lt; 60) { c += 1; //统计不及格人的分数 } } printf(&quot;s=%f\\n&quot;, s);//打印总分数 s=345.000000 ave = s / 5; //计算平均分数 printf(&quot;average=%f\\ncount=%d\\n\\n&quot;, ave, c); //打印平均分与不及格人数 average=69.000000 count=2 for (i = 0; i &lt; 5; i++) { printf(&quot; name=%s, score=%f\\n&quot;, boy[i].name, boy[i].score); // printf(&quot; name=%s, score=%f\\n&quot;, (boy+i)-&gt;name, (boy+i)-&gt;score); } return 0; } 结构体套结构体 #include &lt;stdio.h&gt; struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, &quot;lily&quot;, &apos;F&apos;, 2, &quot;yuri&quot;, &apos;M&apos; }; int i = 0; for (i = 0; i &lt; 2; i++) { printf(&quot;id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n&quot;, s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 结构体赋值 #include&lt;stdio.h&gt; #include&lt;string.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, &quot;abc&quot;); s1.age = 18; printf(&quot;s1.name = %s, s1.age = %d\\n&quot;, s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(&amp;s2, &amp;s1, sizeof(s1)); printf(&quot;s2.name = %s, s2.age = %d\\n&quot;, s2.name, s2.age); return 0; } 指向普通结构体变量的指针 #include&lt;stdio.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { &quot;lily&quot;, 18 }; //如果是指针变量，通过-&gt;操作结构体成员 struct stu* p = &amp;s1; printf(&quot;p-&gt;name = %s, p-&gt;age=%d\\n&quot;, p-&gt;name, p-&gt;age);//p-&gt;name = lily, p-&gt;age=18 printf(&quot;(*p).name = %s, (*p).age=%d\\n&quot;, (*p).name, (*p).age);//(*p).name = lily, (*p).age=18 return 0; } 堆区结构体变量 #include&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu* p = NULL; p = (struct stu*)malloc(sizeof(struct stu)); //如果是指针变量，通过-&gt;操作结构体成员 strcpy(p-&gt;name, &quot;test&quot;); p-&gt;age = 22; printf(&quot;p-&gt;name = %s, p-&gt;age=%d\\n&quot;, p-&gt;name, p-&gt;age); printf(&quot;(*p).name = %s, (*p).age=%d\\n&quot;, (*p).name, (*p).age); free(p); p = NULL; return 0; } 结构体套一级指针 #include&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; //结构体类型的定义 struct stu { char* name; //一级指针 int age; }; int main() { struct stu* p = NULL; p = (struct stu*)malloc(sizeof(struct stu)); p-&gt;name = malloc(strlen(&quot;test&quot;) + 1); strcpy(p-&gt;name, &quot;test&quot;); p-&gt;age = 22; printf(&quot;p-&gt;name = %s, p-&gt;age=%d\\n&quot;, p-&gt;name, p-&gt;age); printf(&quot;(*p).name = %s, (*p).age=%d\\n&quot;, (*p).name, (*p).age); if (p-&gt;name != NULL) { free(p-&gt;name); p-&gt;name = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 结构体普通变量做函数参数 #include&lt;stdio.h&gt; #include &lt;string.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, &quot;mike&quot;); tmp.age = 18; printf(&quot;tmp.name = %s, tmp.age = %d\\n&quot;, tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(&quot;s.name = %s, s.age = %d\\n&quot;, s.name, s.age); return 0; } 结构体指针变量做函数参数 #include&lt;stdio.h&gt; #include &lt;string.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体指针变量 void set_stu_pro(struct stu *tmp) { strcpy(tmp-&gt;name, &quot;mike&quot;); tmp-&gt;age = 18; } int main() { struct stu s = { 0 }; set_stu_pro(&amp;s); //地址传递 printf(&quot;s.name = %s, s.age = %d\\n&quot;, s.name, s.age); return 0; } 结构体数组名做函数参数 #include&lt;stdio.h&gt; //结构体类型的定义 struct stu { char name[50]; int age; }; //void set_stu_pro(struct stu tmp[100], int n) //void set_stu_pro(struct stu tmp[], int n) void set_stu_pro(struct stu *tmp, int n) { int i = 0; for (i = 0; i &lt; n; i++) { sprintf(tmp-&gt;name, &quot;name%d%d%d&quot;, i, i, i); tmp-&gt;age = 20 + i; tmp++; } } int main() { struct stu s[3] = { 0 }; int i = 0; int n = sizeof(s) / sizeof(s[0]); set_stu_pro(s, n); //数组名传递 for (i = 0; i &lt; n; i++) { printf(&quot;%s, %d\\n&quot;, s[i].name, s[i].age); } return 0; } const修饰结构体指针形参变量 //结构体类型的定义 struct stu { char name[50]; int age; }; void fun1(struct stu* const p) { //p = NULL; //err p-&gt;age = 10; //ok } //void fun2(struct stu const* p) void fun2(const struct stu* p) { p = NULL; //ok //p-&gt;age = 10; //err } void fun3(const struct stu* const p) { //p = NULL; //err //p-&gt;age = 10; //err } 共用体(联合体) 联合union是一个能在同一个存储空间存储不同类型数据的类型；联合体所占的内存长度等于其最长成员的长度，也有叫做共用体； 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用； 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖； 共用体变量的地址和它的各成员的地址都是同一地址。 #include &lt;stdio.h&gt; //共用体也叫联合体 union Test { unsigned char a; unsigned int b; unsigned short c; }; int main() { //定义共用体变量 union Test tmp; //1、所有成员的首地址是一样的 printf(&quot;%p, %p, %p\\n&quot;, &amp;(tmp.a), &amp;(tmp.b), &amp;(tmp.c));//0000003825CFF6B4, 0000003825CFF6B4, 0000003825CFF6B4 //2、共用体大小为最大成员类型的大小 printf(&quot;%lu\\n&quot;, sizeof(union Test));//4 //3、一个成员赋值，会影响另外的成员 //左边是高位，右边是低位 //低位放低地址，高位放高地址 tmp.b = 0x44332211; printf(&quot;%x\\n&quot;, tmp.a); //11 printf(&quot;%x\\n&quot;, tmp.c); //2211 tmp.a = 0x00; printf(&quot;short: %x\\n&quot;, tmp.c); //2200 printf(&quot;int: %x\\n&quot;, tmp.b); //44332200 return 0; } 枚举 枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 enum 枚举名 { 枚举值表 }; 在枚举值表中应列出所有可用值，也称为枚举元素。枚举值是常量，不能在程序中用赋值语句再对它赋值。枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …。 #include &lt;stdio.h&gt; enum weekday { sun = 2, mon, tue, wed, thu, fri, sat }; enum bool { flase, true }; int main() { enum weekday a, b, c; a = sun; b = mon; c = tue; printf(&quot;%d,%d,%d\\n&quot;, a, b, c);//2,3,4 enum bool flag; flag = true; if (flag == 1) { printf(&quot;flag为真\\n&quot;);//flag为真 } return 0; } typedef 为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值。#define发生在预处理，typedef发生在编译阶段。 #include &lt;stdio.h&gt; typedef int INT; typedef char BYTE; typedef BYTE T_BYTE; typedef unsigned char UBYTE; typedef struct type { UBYTE a; INT b; T_BYTE c; }TYPE, * PTYPE; int main() { TYPE t; t.a = 254; t.b = 10; t.c = &apos;c&apos;; PTYPE p = &amp;t; printf(&quot;%u, %d, %c\\n&quot;, p-&gt;a, p-&gt;b, p-&gt;c);//254, 10, c return 0; }","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"JNI入门","slug":"33.JNI入门","date":"2020-03-07T03:21:44.564Z","updated":"2020-03-15T08:50:45.982Z","comments":false,"path":"2020/03/07/33.JNI入门/","link":"","permalink":"http://yoursite.com/2020/03/07/33.JNI入门/","excerpt":"","text":"介绍JNI含义:java native interface JNI好处: 1、JNI可以扩展java虚拟机的能力，让java代码可以调用驱动 2、C/C++的效率要高，通过jni把耗时操作方法C/C++可以提高java运行效率 3、java代码编译成的.class文件安全性较差, 可以通过jni把重要的业务逻辑放到c/c++去实现,c/c++反编译比较困难,安全性较高. C基本语法1、C的基本数据类型java基本数据类型:boolean(1个字节),byte(1),char(2),short(2),int(4),long(8),float(4),double(8) C的基本数据类型:char(1个字节), int(4), float(4), double(8), long(4), short(2), signed, unsigned, void signed:有符号数,可以表示负数;unsigned:无符号数,不可以表示负数。signed和unsigned只能用来修饰整形变量char、short、int、long。 C没有boolean和byte，C用0和非0表示false和true。 2、占位符和字符串占位符： %d - int %ld – long int %lld - long long %hd – short %c - char %f - float %lf – double %u – 无符号数 %x – 十六进制输出 int 或者long int 或者short int %o - 八进制输出 %s – 字符串 占位符不要乱用,要选择正确的对应类型,否则可能会损失精度。 C没有String类型,C的字符串实际就是字符数组。C字符串两种定义方式： //注意&apos;\\0&apos;字符串结束符, []只能再变量名之后 char str[] = {&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;r&apos;,&apos;t&apos;,&apos;\\0&apos;}; //这种定义方式不用写结束符,可以表示汉字 char str[] = &quot;你好&quot;; C字符串不检查下标越界,使用时要注意。 C的控制台输入 scanf(&quot;占位符&quot;, &amp;地址);//&amp; 取地址符 3、内存地址的概念声明一个变量,就会立即为这个变量申请内存,一定会有一个对应的内存地址；没有地址的内存是无法使用的；内存的每一个字节都有一个对应的地址；内存地址用一个16进制数来表示；32位操作系统最大可以支持4G内存。 4、指针int i = 123; //一般计算机中用16进制数来表示一个内存地址 printf(&quot;%#x\\n&quot;,&amp;i); //int* int类型的指针变量 pointer指针 指针变量只能用来保存内存地址 //用取地址符&amp;i 把变量i的地址取出来 用指针变量pointer 保存了起来 //此时我们可以说 指针pointer指向了 i的地址 int* pointer = &amp;i; printf(&quot;pointer的值 = %#x\\n&quot;,pointer); printf(&quot;*pointer的值%d\\n&quot;,*pointer); *pointer = 456; printf(&quot;i的值是%d\\n&quot;,i); system(&quot;pause&quot;); 未赋值的指针称为野指针。 5、指针交换两个数的值所有传递其实本质都是值传递，引用传递本质是把地址传递过去，引用传递其实也是传递一个值，但是这个值是一个内存地址。 void swap(int* p, int* p2){ int temp = *p; *p = *p2; *p2 = temp; } 6、数组和指针的关系数组占用的内存空间是连续的 数组变量保存的地址，是第0个元素地址，也就是首地址。&amp;array和&amp;array[0]值一样。 *(p + 1):指针位移一个单位，一个单位是多少个字节，取决于指针的类型。 7、指针的长度不管变量的类型是什么，它的内存地址的长度一定是相同的；类型不同只决定变量占用的内存空间不同；32位环境下，内存地址长度都是4个字节，64位环境下，内存地址长度都是8个字节。 8、多级指针二级指针变量只能保存一级指针变量的地址，有几个*就是几级指针 int i = 123; //int类型一级指针 int* p = &amp;i; //int 类型 二级指针 二级指针只能保存一级指针的地址 int** p2 = &amp;p; //int 类型 三级指针 三级指针只能保存二级指针的地址 int*** p3 = &amp;p2; //通过p3 取出 i的值 printf(&quot;***p3 = %d\\n&quot;, ***p3); 9、堆、栈、静态内存、动态内存栈内存:系统自动分配，系统自动销毁，连续的内存区域，向低地址扩展，大小固定，栈上分配的内存称为静态内存。 静态内存分配：子函数执行完，子函数中的所有局部变量都会被销毁，内存释放，但内存地址不可能被销毁，只是地址上的值没了。 堆内存：程序员手动分配（java：new，c：malloc），空间不连续，大小取决于系统的虚拟内存，C程序员手动回收free，java自动回收，堆上分配的内存称为动态内存。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; main(){ printf(&quot;请输入班级的人数:&quot;); int count; scanf(&quot;%d&quot;,&amp;count); //申请一块堆内存 int* pointer = malloc(sizeof(int)*count); int i; for(i = 0;i&lt;count;i++){ printf(&quot;请输入第%d个学生的学号:&quot;,i+1); scanf(&quot;%d&quot;, pointer+i); } for(i = 0;i&lt;count;i++){ printf(&quot;第%d个学生的学号是:%d\\n&quot;,i+1,*(pointer+i)); } printf(&quot;请输入插班生的人数:&quot;); //声明一个变量increment用来保存 插班生的人数 int increment; //接受用户的输入 scanf(&quot;%d&quot;,&amp;increment); //重新申请一块足够大的内存 //如果 malloc申请到的内存后面还有足够的空间 realloc会在malloc申请的内存空间后继续申请足够大的内存空间 //如果 malloc申请到的内存后面没有足够的空间 realloc会找到一块足够大的堆内存 并且把 malloc申请到的内存中的值复制过来 pointer = realloc(pointer,sizeof(int)*(count+increment)); for(i = count;i&lt;count+increment;i++){ printf(&quot;请输入第%d个学生的学号:&quot;,i+1); scanf(&quot;%d&quot;, pointer+i); } for(i = count;i&lt;count+increment;i++){ printf(&quot;第%d个学生的学号是:%d\\n&quot;,i+1,*(pointer+i)); } system(&quot;pause&quot;); } 10、结构体结构体的大小大于等于结构体中每一变量的占字节数的和;结构体的大小是最大的那个变量所占字节数的整数倍。 c结构体类似java的class。struct来声明c的结构体。C结构体中不能定义函数，可以定义函数指针 。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void study(){ printf(&quot;good good study!\\n&quot;); } typedef struct Student{ int age; //8 int score; // 4 char sex; //1 void(*studypointer)(); } stud; main(){ stud stu = {18,100,&apos;f&apos;}; stu.studypointer = &amp;study; stu.studypointer(); struct Student* stuPointer = &amp;stu; printf(&quot;*stuPointer.age = %d\\n&quot;,(*stuPointer).age); (*stuPointer).sex =&apos;m&apos;; printf(&quot;stu.sex = %c\\n&quot;,stu.sex); printf(&quot;stuPointer-&gt;age = %d&quot;,stuPointer-&gt;age); //printf(&quot;stu.age = %hd\\n&quot;,stu.age); //printf(&quot;stu.score = %d\\n&quot;,stu.score); //printf(&quot;stu.sex = %c\\n&quot;,stu.sex); // printf(&quot;结构体student占%d个字节\\n&quot;,sizeof(stu)); system(&quot;pause&quot;); } 11、联合体union长度等于联合体中定义的变量当中最长的那个,联合体只能保存一个变量的值,联合体共用同一块内存 c++c++开发jni代码时 env不再是结构体Jninativeinterface的二级指针。_JNIEnv是C++的结构体，C++的结构体可以定义函数。env是JNIEnv的一级指针,也就是结构体_JNIEnv的一级指针。env-&gt;来调用结构体里的函数。 am命令am命令:在adb shell里可以通过am命令进行一些操作如启动activity Service 启动浏览器等等。 #include &lt;jni.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;android/log.h&gt; #define LOG_TAG &quot;System.out&quot; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) int ppid; JNIEXPORT void JNICALL Java_com__cfork_demo_MainActivity_cfork (JNIEnv * env, jobject obj){ int pid = fork(); //fork成功的分叉出一个子进程 会返回当前进程的id 但是只能在主进程中fork成功 //在子进程中运行fork 会返回0 但是不能再分叉出新的进程 //fork的返回值可能三种 &gt;0 == 0 &lt;0 FILE* file; if(pid&gt;0){ LOGD(&quot;pid = %d&quot;,pid); }else if(pid == 0){ //拿到父进程的进程编号 LOGD(&quot;pid == 0&quot;); while(1){ ppid = getppid(); //如果父进程的进程编号为1 说明父进程被杀死了 if(ppid == 1){ LOGD(&quot;ppid =%d&quot;,ppid); file = fopen(&quot;/data/data/com.cfork.demo&quot;,&quot;r&quot;); if(file == NULL){ //打开网页 调用am命令 execlp(&quot;am&quot;, &quot;am&quot;, &quot;start&quot;, &quot;--user&quot;,&quot;0&quot;,&quot;-a&quot;, &quot;android.intent.action.VIEW&quot;, &quot;-d&quot;, &quot;http://www.baidu.com&quot;, (char *) NULL); }else{ execlp(&quot;am&quot;, &quot;am&quot;, &quot;start&quot;, &quot;--user&quot;,&quot;0&quot;, &quot;-n&quot; , &quot;com.cfork.demo/com.cfork.demo.MainActivity&quot;,(char *) NULL); } break; } LOGD(&quot;sub process is running&quot;); sleep(2); } }else{ LOGD(&quot;pid&lt;0 &quot;); } } JNIc本地函数命名规则:Java_包名_类名_本地方法名。 参数jobject thiz：调用本地函数的java对象，在这个例子中，就是MainActivity的实例。 参数JNIEnv* env：是结构体JNINativeInterface的二级指针。JNIEnv是结构体JNINativeInterface的一级指针，操作一级指针用(*env)-&gt;。JNINativeInterface结构体中定义了大量的函数指针，这些函数指针在jni开发中很常用。 C代码 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;jni.h&gt; jstring Java_com_vcredit_cdemo_MainActivity_stringFromJNI(JNIEnv* env,jobject thiz){ char* cstr = &quot;hello from c!&quot;; return (*env)-&gt;NewStringUTF(env,cstr); } C++代码 #include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_com_vcredit_cdemo_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); } java传参数给cJava给C传递int，String和int[]，并且返回: #include &lt;jni.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //传递数字，并返回数字 JNIEXPORT jint JNICALL Java_com_vcredit_cdemo_MainActivity_intFromJNI(JNIEnv *env, jobject thiz, jint a, jint b) { return a + b; } char *_JString2CStr(JNIEnv *env, jstring jstr) { char *rtn = NULL; jclass clsstring = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); jstring strencode = (*env)-&gt;NewStringUTF(env, &quot;GB2312&quot;); jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) (*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte(&quot;GB2312&quot;); jsize alen = (*env)-&gt;GetArrayLength(env, barr); jbyte *ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char *) malloc(alen + 1); //&quot;\\0&quot; memcpy(rtn, ba, alen); rtn[alen] = 0; } (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); return rtn; } //传递字符串，并返回字符串 JNIEXPORT jstring JNICALL Java_com_vcredit_cdemo_MainActivity_stringChange(JNIEnv *env, jobject thiz, jstring string) { char *cstr = _JString2CStr(env, string); int length = strlen(cstr); int i; for (i = 0; i &lt; length; i++) { *(cstr + i) += 1; } return (*env)-&gt;NewStringUTF(env, cstr); } //传递int数组，并返回数组 JNIEXPORT jintArray JNICALL Java_com_vcredit_cdemo_MainActivity_arrIncrease(JNIEnv *env, jobject thiz, jintArray jArray) { jsize length = (*env)-&gt;GetArrayLength(env, jArray); jint *arrayPointer = (*env)-&gt;GetIntArrayElements(env, jArray, NULL); int i; for (i = 0; i &lt; length; i++) { *(arrayPointer + i) += 10; } (*env)-&gt;SetIntArrayRegion(env, jArray, 0, length, arrayPointer); return jArray; } 在C中打印log#include &lt;android/log.h&gt; #define LOG_TAG &quot;System.out&quot; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__) //使用 LOGD(&quot;length = %d&quot;,length); c调用JavaC调用Java空参方法 JNIEXPORT void JNICALL Java_com_vcredit_cdemo_MainActivity_callbackvoidmethod(JNIEnv* env, jobject thiz) { jclass claz = (*env)-&gt;FindClass(env, &quot;com/vcredit/cdemo/MainActivity&quot;); jmethodID methodID = (*env)-&gt;GetMethodID(env, claz, &quot;helloFromJava&quot;, &quot;()V&quot;); (*env)-&gt;CallVoidMethod(env, thiz, methodID); } public void helloFromJava() { Log.d(&quot;-----rrrrr&quot;, &quot;hello from java&quot;); } 注意FindClass路径用/。 C调用Java有Int参数方法并返回 JNIEXPORT void JNICALL Java_com_vcredit_cdemo_MainActivity_callbackintmethod(JNIEnv *env, jobject thiz) { jclass claz = (*env)-&gt;FindClass(env, &quot;com/vcredit/cdemo/MainActivity&quot;); jmethodID methodID = (*env)-&gt;GetMethodID(env, claz, &quot;add&quot;, &quot;(II)I&quot;); int result = (*env)-&gt;CallIntMethod(env, thiz, methodID, 6, 6); LOGD(&quot;result = %d&quot;, result); } public int add(int x, int y) { return x + y; } C调用Java有String参数方法 JNIEXPORT void JNICALL Java_com_vcredit_cdemo_MainActivity_callbackStringmethod(JNIEnv *env, jobject thiz) { jclass claz = (*env)-&gt;FindClass(env, &quot;com/vcredit/cdemo/MainActivity&quot;); jmethodID methodID = (*env)-&gt;GetMethodID(env, claz, &quot;printString&quot;, &quot;(Ljava/lang/String;)V&quot;); jstring result = (*env)-&gt;NewStringUTF(env, &quot;hello from c&quot;); (*env)-&gt;CallVoidMethod(env, thiz, methodID, result); } public void printString(String s) { Log.d(&quot;-----rrrrr&quot;, s); }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"http://yoursite.com/tags/JNI/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android自定义控件入门与实战-读书笔记","slug":"32.Android自定义控件入门与实战","date":"2020-01-04T11:48:26.998Z","updated":"2020-03-27T12:43:23.348Z","comments":false,"path":"2020/01/04/32.Android自定义控件入门与实战/","link":"","permalink":"http://yoursite.com/2020/01/04/32.Android自定义控件入门与实战/","excerpt":"","text":"第1章、绘图基础1.1、基本图形绘制1.1.1、概述在 Android中，Paint类就是画笔，而Canvas类就是纸，在这里叫作画布。 1.1.2、画笔的基本设置Paint paint.setAntiAlias(true); //打开抗锯齿功能 paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Paint.Style.FILL); //设置填充样式 paint.setStrokeWidth(50); //设置画笔宽度 ARGB A 代表透明度（Alpha） R 代表红色值（Red） G 代表绿色值（Green） B 代表蓝色值（Blue） 设置填充样式，对于文字和几何图形都有效: Paint.Style.FILL//仅填充内部。 Paint.Style.FILL_AND_STROKE//填充内部和描边。 Paint.Style.STROKE//仅描边。 FILL_AND_STROKE比FILL多了一个描边的宽度。 1.1.3、Canvas使用基础demo地址 com.vcredit.doview.chapter1.DrawShapeView 1、画布背景设置canvas.drawColor(int color) canvas.drawARGB(int a, int r, int g, int b) canvas.drawRGB(int r, int g, int b) //透明度Alpha的值取255 2、画直线void drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 直线的粗细是与setStrokeWidth有直接关系的。所以，paint.setStrokeWidth在Style起作用时，用于设置描边宽度；在Style不起作用时，用于设置画笔宽度。 3、多条直线void drawLines(float[] pts, Paint paint) void drawLines(float[] pts, int offset, int count, Paint paint) pts：点的集合。两个元素形成一个点，每两个点形成一条直线。 offset：pts集合中跳过的元素个数。 count：pts集合中参与绘制的元素个数。 float[] pts = {10,10,100,100,200,200,400,400}; canvas.drawLines(pts,2,4,paint); 表示点(100,100)和(200,200)这两个点的连线。 4、点void drawPoint(float x, float y, Paint paint) 点的大小只与setStrokeWidth(width)有关，而与setStyle无关。 5、多个点void drawPoints(float[] pts, Paint paint) void drawPoints(float[] pts, int offset, int count, Paint paint) 这几个参数的含义与多条直线中的参数含义相同。 6、矩形工具类RectF和RectRectF与Rect中的方法、成员变量完全一样，都是根据4个点构造出一个矩形结构，唯一不同的是：RectF是用来保存float类型数值的矩形结构的；而Rect是用来保存int类型数值的矩形结构的。 //RectF 的构造函数有如下4个，但最常用的还是第二个，即根据 4 个点构造出一个矩形。 RectF() RectF(float left, float top, float right, float bottom) RectF(RectF r) RectF(Rect r) //Rect的构造函数有如下3个。 Rect() Rect(int left, int top, int right, int bottom) Rect(Rect r) 一般而言，要构造一个矩形结构，可以通过以下两种方法来实现。 //方法一：直接构造 Rect rect = new Rect(10,10,100,100); //方法二：间接构造 Rect rect = new Rect(); rect.set(10,10,100,100); 7、矩形矩形的绘制方法 void drawRect(float left, float top, float right, float bottom, Paint paint) void drawRect(RectF rect, Paint paint) void drawRect(Rect r, Paint paint) 8、圆角矩形void drawRoundRect(RectF rect, float rx, float ry, Paint paint) rect：要绘制的矩形；rx：生成圆角的椭圆的X轴半径；ry：生成圆角的椭圆的Y轴半径。 drawRoundRect()函数不能针对每个角设置对应的椭圆，而只能统一设置4个角对应的椭圆。 9、圆形void drawCircle(float cx, float cy, float radius, Paint paint) 参数是圆心和半径 10、椭圆void drawOval(RectF oval, Paint paint) 椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，以矩形的宽为椭圆的Y轴。 11、弧void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter,Paint paint) 弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧也是根据矩形来生成的。 oval：生成椭圆的矩形。startAngle：弧开始的角度，以 X 轴正方向为 0°。sweepAngle：弧持续的角度,顺时针方向为正值。 useCenter：是否有弧的两边。为true时，表示带有两边；为false时，只有一条弧。 1.1.4、Rect与RectF1、是否包含点、矩形//判断是否包含某个点，如果在，则返回true；如果不在，则返回false。 boolean contains(int x, int y) //rect.contains(mX, mY) //判断是否包含某个矩形 Boolean contains(int left, int top, int right, int bottom) boolean contains(Rect r) postInvalidate()和 nvalidate()函数都是用来重绘控件的，区别是invalidate()函数一定要在主线程中执行，否则就会报错；而postInvalidate()可以在任何线程中执行。因为在 postInvalidate()函数中就是利用handler给主线程发送刷新界面的消息来实现的，所以它可以在任何线程中执行而不会出错。postInvalidate()界面刷新速度可能没有直接调用invalidate()函数那么快。 2、判断两个矩形是否相交//这是Rect类的一个静态方法，如果相交则返回true，否则返回false。 static boolean intersects(Rect a, Rect b) //还可以使用 Rect 类中自带的方法来判断当前 Rect 对象与其他矩形是否相交。 boolean intersects(int left, int top, int right, int bottom) //判断相交并返回结果 //不仅会返回是否相交的结果，而且会把相交部分的矩形赋给当前Rect对象。如果两个矩形不相交，则当前Rect对象的值不变。 boolean intersect(int left, int top, int right, int bottom) boolean intersect(Rect r) 3、合并合并两个矩形的意思就是将两个矩形合并成一个矩形，即无论这两个矩形是否相交，取两个矩形最小左上角点作为结果矩形的左上角点，取两个矩形最大右下角点作为结果矩形的右下角点。如果要合并的两个矩形有一方为空，则将有值的一方作为最终结果。 public void union(int left, int top, int right, int bottom) public void union(Rect r) 合并矩形与某个点：先判断当前矩形与目标合并点的关系，如果不相交，则根据目标点(x,y)的位置，将目标点设置为当前矩形的左上角点或者右下角点。如果当前矩形是一个空矩形，则最后的结果矩形为([0,0],[x,y])，即结果矩形的左上角点为[0,0]，右下角点为[x,y]。 public void union(int x, int y) 1.1.5、Color 当需要重绘时就会调用onDraw()函数，所以在 onDraw()函数中创建的变量会一直被重复创建，这样会引起频繁的程序GC（回收内存），进而引起程序卡顿。所以一定要记住，在onDraw()函数中不能创建变量！一般在自定义控件的构造函数中创建变量，即在初始化时一次性创建。 1.2、路径1.2.1、概述Path类就代表路径。在Canvas中绘制路径的方法 void drawPath(Path path, Paint paint) 1.2.2、直线路径//(x1,y1)是直线的起始点 void moveTo(float x1, float y1) //(x2,y2)是直线的终点，又是下一次绘制直线路径的起始点； lineTo()函数可以一直使用。 void lineTo(float x2, float y2) //首尾点连接起来，形成闭环 void close() 1.2.3、弧线路径//弧线是从椭圆上截取的一部分 void arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) //oval：生成椭圆的矩形。 //startAngle：弧开始的角度，以 X 轴正方向为 0°。sweepAngle：弧持续的角度。 //forceMoveTo 的含义是是否强制将弧的起始点作为绘制起始位置。 1.2.4、addXXX系列函数addXXX系列函数可以让我们直接往Path中添加一些曲线，而不必考虑连贯性。 添加矩形路径void addRect(float left, float top, float right, float bottom,Path.Direction dir) void addRect(RectF rect, Path.Direction dir) Path.Direction 参数有两个值。Path.Direction.CCW：是指创建逆时针方向的矩形路径。Path.Direction.CW：指创建顺时针方向的矩形路径。 添加圆角矩形路径void addRoundRect(RectF rect, float[] radii, Path.Direction dir) void addRoundRect(RectF rect, float rx, float ry, Path.Direction dir) float[] radii：必须传入8个数值，分4组，第一组对应第一个角（左上角）的用来生成圆角的椭圆的横轴半径和纵轴半径。在第二个构造函数中，只能构建统一的圆角大小，rx：生成圆角的椭圆的横轴半径，ry：生成圆角的椭圆的纵轴半径。 添加圆形路径void addCircle(float x, float y, float radius, Path.Direction dir) x和y：圆心坐标；radius：圆半径。 添加椭圆路径void addOval(RectF oval, Path.Direction dir) 添加弧形路径void addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) void addArc(RectF oval, float startAngle, float sweepAngle) oval：生成椭圆的矩形;startAngle：弧开始的角度;sweepAngel：弧持续的角度。 1.2.5、填充模式Path的填充模式是指填充Path的哪部分。 //Path.FillType 表示 Path 的填充模式，它有 4 个枚举值。 FillType.WINDING：默认值，当两个图形相交时，取相交部分显示。 FillType.EVEN_ODD：取 path 所在并不相交的区域。 FillType.INVERSE_WINDING：取 path 的外部区域。 FillType.INVERSE_EVEN_ODD：取 path 的外部和相交区域。 在利用画笔填充图形时，填充的肯定是图形内部，而 path.setFillType()函数就是用来界定哪里算Path内部的算法，进而让Paint填充这部分图像。 1.2.6、重置路径系统提供了两个重置路径的方法: void reset() void rewind() 共同点是都会清空内部所保存的所有路径。 区别:rewind()函数不会清除内存，但会清除FillType；而reset()函数则会清除内存，但不会清除FillType。 1.2.7、蜘蛛网状图示例1.3、文字1.3.1、Paint设置Paint与文字相关的设置: //普通设置 paint.setStrokeWidth(5); //设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能 paint.setStyle(Paint.Style.FILL); //绘图样式，对于文字和几何图形都有效 paint.setTextAlign(Align.CENTER); //设置文字对齐方式，取值为Align.CENTER、Align.LEFT 或 Align.RIGHT paint.setTextSize(12); //设置文字大小 //样式设置 paint.setFakeBoldText(true); //设置是否为粗体文字 paint.setUnderlineText(true); //设置下画线 paint.setTextSkewX((float) -0.25); //字体水平倾斜度，默认为0，普通斜体字设为-0.25，负数代表向右倾斜 paint.setStrikeThruText(true); //设置带有删除线效果 //其他设置 paint.setTextScaleX(2); //水平方向拉伸，高度不变，表示拉伸倍数，默认为1表示不拉伸 1.3.2、Canvas绘制文本//setTextAlign的显示与x、y的设置有关系 canvas.drawText(String text,Float x,Float y,Paint paint); 1、普通绘制//参数(x,y)就是起始点坐标 void drawText(String text, float x, float y, Paint paint) //start：表示起始绘制字符所在字符串中的索引。 //end：表示结束绘制字符所在字符串中的索引。x,y：起始点坐标。 void drawText(CharSequence text, int start, int end, float x, float y, Paint paint) void drawText(String text, int start, int end, float x, float y, Paint paint) //绘制char类型的数组所组成的字符串。其他参数的含义如下。index：指定起始绘制字符的位置。 //count：指定从起始绘制字符开始绘制几个字符。x,y：起始点坐标。 void drawText(char[] text, int index, int count, float x, float y, Paint paint) 举例 canvas.drawText(&quot;床前明月光&quot;,2,4, 10,100, paint);//明月 2、逐个指定文字位置指定每个要绘制的文字的具体位置 void drawPosText(String text, float[] pos, Paint paint) void drawPosText(char[] text, int index, int count, float[] pos, Paint paint) index：第一个要绘制的文字的索引。count：要绘制的文字的个数。pos：要绘制的每个文字的具体位置，两个点确定一个文字的位置。 3、沿路径绘制void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint) void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset,float vOffset, Paint paint) hOffset：与路径起始点的水平偏移量。vOffset：与路径中心的垂直偏移量。 1.3.3、设置字体样式在Paint中有一个函数是专门用来设置字体样式的。使用这个函数的前提是必须构造Typeface类的一个参数。 Typeface setTypeface(Typeface typeface) 设置字体样式 Typeface defaultFromStyle(int style) //参数int style的取值如下。 Typeface.NORMAL：正常字体。 Typeface.BOLD：粗体。 Typeface.ITALIC：斜体。 Typeface.BOLD_ITALIC：粗斜体。 举例，设置粗斜体样式: Typeface typeface = Typeface.defaultFromStyle(Typeface.BOLD_ITALIC); paint.setTypeface(typeface); 1.4、RegionRegion译为“区域”，区域是一块任意形状的封闭图形。 1.4.1、构造Region直接构造public Region(Region region) //复制一个 Region 的范围 public Region(Rect r) //创建一个矩形区域 public Region(int left, int top, int right, int bottom) //创建一个矩形区域 间接构造间接构造主要是通过空构造函数与set系列函数相结合来实现的。 //Region的空构造函数： public Region() //set 系列函数： public void setEmpty() //置空 public boolean set(Region region)//利用新的区域替换原来的区域 public boolean set(Rect r) public boolean set(int left, int top, int right, int bottom) public boolean setPath(Path path, Region clip)//根据路径的区域与某区域的交集构造出新的区域 无论调用set系列函数的Region是不是有区域值，当调用set系列函数后，原来的区域值就会被替换成set系列函数里的区域值。 利用setPath可以设置不规则区域 1.4.2、枚举区域——RegionIterator类//构造函数：根据区域构建对应的矩形集。 RegionIterator(Region region) //获取下一个矩形，将结果保存在参数 Rect r 中。 boolean next(Rect r) Canvas中没有直接绘制Region的函数，想要绘制一个区域，就只能通过RegionIterator类构造矩形集来逼近显示区域。 private void drawRegion(Canvas canvas,Region rgn,Paint paint){ RegionIterator iter = new RegionIterator(rgn); Rect r = new Rect(); while (iter.next(r)) { canvas.drawRect(r, paint); } } 1.4.3、区域相交Region不是用来绘图的，Region最重要的功能在区域的相交操作中。 union()函数boolean union(Rect r) 该函数用于与指定矩形取并集，即将Rect所指定的矩形加入当前区域中。举例： Region region = new Region(10,10,200,100); region.union(new Rect(10,10,50,300)); 区域操作方法一： 相交操作，并将结果赋给当前的Region对象。如果计算成功，则返回true；否则返回false。 boolean op(Rect r, Op op) boolean op(int left, int top, int right, int bottom, Op op) boolean op(Region region, Op op) Op参数值有如下6个： public enum Op { DIFFERENCE(0), //最终区域为region1区域，但是不包括与region2相交的区域 INTERSECT(1), // 最终区域为region1与region2 相交的区域 UNION(2), //最终区域为region1与region2组合在一起的区域 XOR(3), //最终区域为region1和region2区域，但是不包括相交的区域 REVERSE_DIFFERENCE(4),//最终区域为region2区域，但是不包括与region1相交的区域 REPLACE(5); //最终区域为region2的区域 } 方法二：传入两个 Region 对象进行区域操作 boolean op(Rect rect, Region region, Op op) boolean op(Region region1, Region region2, Region.Op op) 1.4.4、其他函数几个判断 //该函数用于判断该区域是否为空 public boolean isEmpty(); //该函数用于判断该区域是否是一个矩阵。 public boolean isRect(); //该函数用于判断该区域是否是多个矩阵的组合。 public boolean isComplex(); getBound系列函数 //这两个函数用于返回能够包裹当前路径的最小矩形。 public Rect getBounds() public boolean getBounds(Rect r) //这两个函数用于返回当前矩形所对应的 Path 对象。 public Path getBoundaryPath() public boolean getBoundaryPath(Path path) 是否包含 //该函数用于判断该区域是否包含某个点。 public boolean contains(int x, int y) //这两个函数用于判断该区域是否包含某个矩形。 public boolean quickContains(Rect r) public boolean quickContains(int left, int top, int right,int bottom) 是否相交 //这两个函数用于判断该区域是否没有和指定矩形相交。 public boolean quickReject(Rect r) public boolean quickReject(int left, int top, int right, int bottom); //该函数用于判断该区域是否没有和指定区域相交。 public boolean quickReject(Region rgn); 平移变换 //该函数用于将Region对象向X轴平移dx距离，向Y轴平移dy距离，并将结果赋给当前的Region对象。X轴向右是正方向，Y轴向下是正方向。 public void translate(int dx, int dy) //与上一个函数不同的是，该函数将结果赋给dst对象，而当前Region对象的值保持不变。 public void translate(int dx, int dy, Region dst) 1.5、Canvas（画布）除了在Canvas上绘图以外，还可以对画布进行变换及裁剪等操作。 1.5.1、Canvas变换平移（Translate）右是X轴正方向，向下是Y轴正方向。 void translate(float dx, float dy) 举例 canvas.translate(100, 100); Rect rect = new Rect(0,0,400,220); canvas.drawRect(rect, paint); 屏幕显示与Canvas的关系每次调用drawXXX系列函数来绘图时，都会产生一个全新的Canvas透明图层。调用平移、旋转等函数对Canvas进行了操作，不会对之前已经draw的产生影响。 旋转（Rotate）//旋转的中心点是原点(0,0) void rotate(float degrees) //指定旋转的中心点坐标(px,py) void rotate(float degrees, float px, float py) 缩放（Scale）//sx是小数表示缩小，sx是整数表示放大 public void scale(float sx, float sy) //px,py表示缩放中心位置 public void scale(float sx, float sy, float px, float py) 扭曲（Skew）//sx为X轴方向倾斜角度的正切值，比如在X轴方向上倾斜60°，tan60=1.732 void skew(float sx, float sy) 举例 canvas.skew(1.732f,0);//X 轴倾斜 60°， Y 轴不变 裁剪画布（clip系列函数）一旦Canvas被裁剪，就不能恢复。在使用clip系列函数时，需要禁用硬件加速功能，setLayerType(LAYER_TYPE_SOFTWARE,null)。 clip 系列函数如下： boolean clipPath(Path path) boolean clipPath(Path path, Region.Op op) boolean clipRect(Rect rect, Region.Op op) boolean clipRect(RectF rect, Region.Op op) boolean clipRect(int left, int top, int right, int bottom) boolean clipRect(float left, float top, float right, float bottom) boolean clipRect(RectF rect) boolean clipRect(float left, float top, float right, float bottom, Region.Op op) boolean clipRect(Rect rect) boolean clipRegion(Region region) boolean clipRegion(Region region, Region.Op op) 1.5.2、画布的保存与恢复save()和restore()函数每次调用save()函数，都会先保存当前画布的状态，然后将其放入特定的栈中。每次调用restore()函数，都会把栈中顶层的画布状态取出来，并按照这个状态恢复当前的画布，然后在这个画布上作画。 restoreToCount(int saveCount)函数在利用save()函数保存画布时，会有一个int类型的返回值。该返回值是当前所保存的画布所在栈的索引。restoreToCount()函数就是一直出栈，直到指定索引的画布出栈为止，即将指定索引的画布作为当前画布。 public void restoreToCount(int saveCount); 1.5.3、圆形头像示例1.5.4、裁剪动画示例1.6、控件的使用方法1.6.1、控件概述1.6.2、通过XML引入控件通过XML引入控件，所调用的构造函数： public MyView(Context context, AttributeSet attrs) { super(context, attrs); } 1.6.3、动态添加控件LinearLayout rootView = (LinearLayout)findViewById(R.id.root); CustomView customView = new CustomView(this); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams (LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); rootView.addView(customView,layoutParams); LayoutParams的作用就是设置控件的宽和高，对应的是XML中的layout_width和layout_height属性。 LayoutParams有三个构造函数: //指定具体的宽和高:LayoutParams.MATCH_PARENT或者具体值 public LayoutParams(int width, int height) //从AttributeSet中提取出宽高等属性值 public LayoutParams(Context c, AttributeSet attrs) //复制一份LayoutParams public LayoutParams(LayoutParams source) LinearLayout、FrameLayout、RelativeLayout都有各自的LayoutParams。 addRuleRelativeLayout.LayoutParams的addRule()函数：第一个参数是指RelativeLayout的布局属性，第二个参数是指相对于哪个控件ID来布局。 RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root); CustomView customView = new CustomView(this); RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT); layoutParams.addRule(RelativeLayout.RIGHT_OF,R.id.text); rootView.addView(customView, layoutParams); 设置marginLinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 20, 30, 40); imageView.setLayoutParams(lp); 设置layout_weight（方法一）构造函数 public LayoutParams(int width, int height, float weight) 示例： TextView tv_like = new TextView(this); LinearLayout.LayoutParams LP_LIKE_MW = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f); tv_like.setText(&quot;赞(8)&quot;); tv_like.setTextSize(16); layout_sub_Lin.addView(tv_like, LP_LIKE_MW); 设置layout_weight（方法二）LinearLayout rootView = (LinearLayout) findViewById(R.id.root); CustomView customView = new CustomView(this); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); layoutParams.weight = 1.0f; rootView.addView(customView, layoutParams); 设置layout_gravityLinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.FILL_PARENT); params.gravity = Gravity.TOP; params.gravity的取值有Gravity.TOP、Gravity.BOTTOM、Gravity.LEFT、Gravity.RIGHT、Gravity.CENTER_VERTICAL、Gravity.CENTER_HORIZONTAL等这些属性值可|（或）运算符合并。 设置android:gravity分别给Button和rootView设置 Button button = new Button(this); button.setGravity(Gravity.TOP); button.setText(&quot;btn&quot;); rootView.addView(button, layoutParams); rootView.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL); addViewpublic void addView(View child, int index) 在指定位置添加一个View控件，index的取值有-1、0和正数。当取值为-1时，表示在末尾添加一个View控件，此时的效果就与addView(View child)相同；当取值为0时，表示在容器顶端添加一个View控件；当取值为正数时，表示在对应的索引位置插入一个View控件。 第2章、视图动画两种类型的动画：View Animation（视图动画）和Property Animation（属性动画）。其中，View Animation包括Tween Animation（补间动画）和Frame Animation（逐帧动画）;Property Animation包括ValueAnimator和ObjectAnimator。 2.1、视图动画标签2.1.1、概述alpha(渐变透)、scale(缩放)、translate(位置移动)、rotate(旋转)set(动画集)。 配置XML动画文件//首先加载动画 Animation animation = AnimationUtils.loadAnimation(Activity.this,R.a aim.scaleanim); //然后利用View的startAnimation()函数开始动画 tv.startAnimation(animation); 2.1.2、scale标签&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;700&quot; android:fillBefore=&quot;true&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.2&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:toXScale=&quot;0.4&quot; android:toYScale=&quot;0.6&quot; /&gt; android:fromXScale：动画起始时，控件在X轴方向上相对自身的缩放比例，浮点值，比如1.0 代表自身无变化，0.5代表缩小1倍，2.0代表放大1倍。 android:toXScale：动画结束时，控件在X轴方向上相对自身的缩放比例，浮点值。 android:fromYScale和android:toYScale类似。 android:pivotX：缩放起始点X轴坐标，可以是数值、百分数、百分数p三种样式，如50、50%、50%p。如果是数值，则表示在当前视图本身View的左上角，即原点处加上50px，作为缩放起始点X轴坐标；如果是50%，则表示在当前控件的左上角加上自己宽度的50%作为缩放起始点X轴坐标；如果是50%p，则表示在当前控件的左上角加上父控件宽度的50%作为缩放起始点X轴坐标。 android:pivotY：与android:pivotX一样用法。 Animation继承属性android:duration：用于设置完成一次动画的持续时间，以毫秒为单位。 android:fillAfter：如果设置为true，则控件动画结束时，将保持动画结束时的状态。 android:fillBefore：如果设置为true，则控件动画结束时，将还原到初始化状态。 android:fillEnabled：与android:fillBefore效果相同。 android:repeatCount：用于指定动画的重复次数，当取值为infinite时，表示无限循环。 android:repeatMode：用于设定重复的类型，有reverse和restart两个值。其中，reverse表示倒序回放：restart表示重放，并且必须与repeatCount一起使用才能看到效果。 android:interpolator：用于设定插值器，其实就是指定的动画效果，比如弹跳效果等。 2.1.3、alpha标签透明度动画效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:fillBefore=&quot;true&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot;&gt; &lt;/alpha&gt; android:fromAlpha:开始时的透明度,android:toAlpha:结束时的透明度。0.0表示全透明，1.0表示完全不透明。 2.1.4、rotate标签旋转动画效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:fillAfter=&quot;true&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;100%&quot; android:pivotY=&quot;100%&quot; android:toDegrees=&quot;-650&quot;&gt; &lt;/rotate&gt; android:fromDegrees：动画开始旋转时的角度位置；android:toDegrees：动画结束时旋转到的角度位置。正值代表顺时针方向的度数，负值代表逆时针方向的度数。 android:pivotX：旋转中心点X轴坐标；android:pivotY：旋转中心点Y轴坐标。没有指定android:pivotX与android:pivotY属性，旋转中心点是默认的控件坐标原点，即控件左上角位置。 2.1.5、translate标签位置移动动画效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;-80&quot; android:toYDelta=&quot;-80&quot;&gt; &lt;/translate&gt; android:fromXDelta：起始点X轴坐标，android:fromYDelta：起始点Y轴坐标，android:toXDelta：终点X轴坐标，android:toYDelta：终点Y轴坐标。可以是数值、百分数、百分数p三种样式。 2.1.6、set标签定义动画集。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt; &lt;scale android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.4&quot; android:toYScale=&quot;1.4&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot; /&gt; &lt;/set&gt; 在set标签中设直repeateCount属性是无效的，必须对每个动画单独设直才有作用。 2.2、视图动画的代码实现2.2.1、概述setDuration(long) setFillAfter(boolean) setFillBefore(boolean) setFillEnabled(boolean) setRepeatCount(int) setRepeatMode(int) setlnterpolator(lnterpolator) setRepeatMode(int）取值为Animation.RESTART或者Animation.REVERSE;setRepeatCount(int）用于设置循环次数，当设置为Animation.INFINITE时，表示无限循环。 2.2.2、ScaleAnimationScaleAnimation(float fromX , float toX, float fromY , float toY) ScaleAnimation(float fromX , float toX , float fromY , float toY , float pivotX, float pivotY) ScaleAnimation(float fromX , float toX , float fromY , float toY, intpivotXType,float pivotXVal ue , int pivotYType , float pivotYValue) pivotXType的取值有三个：Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF和Animation.RELATIVE_TO_PARENT。对应的是android:pivotX中的三种取值样式:数值、百分数、百分数p。 ScaleAnimation scaleAnim = new ScaleAnimation(O.Of , 1.4f, O.Of, 1.4f, Animation.RELATIVE_TO_SELF , 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnim.setDuration(700); tv.startAnimation(scaleAnim); 2.2.3、AlphaAnimationAlphaAnimation(Context context , AttributeSet attrs) AlphaAnimation(float fromAlpha , float toAlpha) 示例 AlphaAnimation alphaAnim = new AlphaAnimation(1.Of, 0.1f); alphaAnim.setDuration(3000); alphaAnim.setFillBefore(true); tv.startAnimation(alphaAnim); 2.2.4、RotateAnimationRotateAnimation(Context context , AttributeSet attrs) RotateAnimation(float fromDegrees , float toDegrees) RotateAnimation(float fromDegrees , float toDegrees , float pivotX,float pivotY) RotateAnimation (float fromDegrees , float toDegrees , int pivotXType , float pivotXValue , int pivotYType , float pivotYValue) 示例 RotateAnimation rotateAnim = new RotateAnimation(0 , -650, Animation.RELATIVE_TO_SELF, O.5f , Animation.RELATIVE_TO_SELF , 0.5f); rotateAnim.setDuration(3000); rotateAnim.setFillAfter(true); tv.startAnimation(rotateAnim); 2.2.5、TranslateAnimationTranslateAnimation(Context context , AttributeSet attrs) TranslateAnimation(float fromXDelta ,float toXDelta, float fromYDelta, float toYDelta) TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue , int fromYType , float fromYValue , int toYType , float toYValue) 示例 TranslateAnimation translateAnim = new TranslateAnimation(Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80); translateAnim.setDuration(2000); translateAnim.setFillBefore(true); tv.startAnimation(translateAnim); 2.2.6、AnimationSet构造函数 AnimationSet(Context context, AttributeSet attrs) AnimationSet(boolean shareinterpolator) shareinterpolator当取值为true，在AnimationSet类中定义一个插值器（Interpolator）其下面的所有动画共用该插值器；当取值为false，则表示其下面的动画定义各自的插值器。 增加动画的函数为： public void addAnimation(Animation a) 示例 Animation alpha_Anim = new AlphaAnimation(1.0f, 0.1f); Animation scale_Anim = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); Animation rotate_Anim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); AnimationSet setAnim = new AnimationSet(true); setAnim.addAnimation(alpha_Anim); setAnim.addAnimation(scale_Anim); setAnim.addAnimation(rotate_Anim); setAnim.setDuration(3000); setAnim.setFillAfter(true); tv.startAnimation(setAnim); 2.2.7、Animation//取消动画 void cancel() //将控件重置到动画开始前状态 void reset() //设置动画监昕 void setAnimationListener(Animation.AnimationListener listener) 监听： scaleAnim.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationEnd(Animation animation) { } @Override public void onAnimationRepeat(Animation animation) { } }); 2.3、插值器初探Interpolator只是一个接口，通过实现这个接口就可以自定义动画的变化速率。 使用： //xml中 android:interpolator=”@android:anim/accelerate_interpolator” //代码 alphaAnim.setinterpolator(new LinearInterpolator()); 2.3.1、AccelerateDeceleratelnterpolator加速减速插值器，表示在开始与结束的地方速率改变比较慢，在中间的时候加速。效果是先加速后减速。 2.3.2、Acceleratelnterpolator动画开始的地方速率改变比较慢，然后开始加速。动画一直是加速的。 2.3.3、Deceleratelntelnterpolator动画开始的一瞬间加速到最大值，然后逐渐变慢。 2.3.4、Linearlnterpolator动画的速率始终保持恒定。 2.3.5、Bouncelnterpolator弹跳插值器，模拟了控件自由落地后回弹的效果。 2.3.6、Anticipatelnterpolator动画开始后，会先往动画反方向移动一段距离，再应用动画。 Anticipatelnterpolator还有一个构造函数： public Anticipateinterpolator(float tension) 参数tension对应的XML属性为android:tension，表示张力值，默认值为2，值越大，初始的偏移量越大，而且速度越快。 2.3.7、Overshootlnterpolator结束偏移插值器，表示在动画结束时，沿动画方向继续运动一段距离后再结束动画。 Overshootlnterpolator也有另一个构造函数： public Overshootinterpolator(float tension） 参数tension对应的XML属性为android:tension，表示张力值，默认值为2，值越大，结束时的偏移量越大，而且速度越快。 2.3.8、AnticipateOvershootlnterpolatorAnticipateOvershootlnterpolator是Anticipatelnterpolator与Overshootlnterpolator的合体，即在动画开始时向前偏移一段距离，在动画结束时向后偏移一段距离。 AnticipateOvershootlnterpolator也有其他的构造函数 public AnticipateOvershootlnterpolator(float tension) public AnticipateOvershootlnterpolator(float tension, float extraTension) tension默认值为2，extraTension默认值为1.5。 2.3.9、Cyclelnterpolator循环插值器，表示动画循环播放特定的次数，速率沿正弦曲线改变。 Cyclelnterpolator的构造函数如下： public Cycleinterpolator(float cycles) 参数cycles表示循环次数。 2.4、动画示例2.4.1、镜头由远及近效果2.4.2、加载框效果2.4.3、扫描动画效果用Animation.setStartOffset(int time）来延迟各个动画的开始时间。 2.5、逐帧动画Frame Animation 2.5.1、XML实现1、概述XML文件放置在／res下的drawable目录中： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing1&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing2&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing3&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing4&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing5&quot; android:duration=&quot;60&quot; /&gt; &lt;/animation-list&gt; android:oneshot如果定义为true，那么此动画只会执行1次;如果定义为false，则一直循环。 然后给ImageView设置动画资源。可以通过android:src实现，也可以通过android:background实现。 android:background=&quot;@drawable/playing_ani&quot; //或者 android:src=&quot;@drawable/playing_ani&quot; 最后代码中开始动画 AnimationDrawable anim = (AnimationDrawable) image.getDrawable(); anim.start(); 当我们通过android:src＝””设置动画资源时，对应的取出方式是image.getDrawable()如果我们通过android:background=””设置动画资源，那么对应的取出方式就是image.getBackground()。 2、音乐播放示例3、AnimationDrawable类AnimationDrawable有下面几个常用函数 void start()//开始播放逐帧动画 void stop()//停止播放逐帧动画 int getDuration(int index）//得到指定index的帧的持续时间 Drawable getFrame(int index）//得到指定index的帧所对应的Drawable对象 int getNumberOfFrames()//得到当前AnimationDrawable的所有帧数量 boolean isRunning() //判断当前AnimationDrawable是否正在播放 void setOneShot(boolean oneShot）//设置AnimationDrawable是否执行一次，true表示执行一次，false表示循环播放 boolean isOneShot() //判断当前AnimationDrawable是否执行一次，true表示执行一次，返回false表示循环播放。 void addFrame(Drawable frame,int duration）//为AnimationDrawable添加1帧，并设置持续时间。 2.5.2、代码实现&lt;ImageView android:id=&quot;@+id/frame_iv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 代码 AnimationDrawable anim = new AnimationDrawable(); for (int i = 1; i &lt;= 14; i++) { int id = getResources().getIdentifier(&quot;list_icon_gif_playing&quot; + i,&quot;drawable&quot;, getPackageName()); Drawable drawable = getResources().getDrawable(id); anim.addFrame(drawable, 60); } anim.setOneShot(false); image.setBackgroundDrawable(anim); anim.start(); getldentifier()函数的完整声明如下： int getldentifier(String name, String defType, String defPackage) //获得string getResources().getldentifier(”name”,”string”, packdgeName); //获得array中的数组： getResources().getidentifier(”name”,”array”, packdgeName); 第3章、属性动画3.1、ValueAnimator的基本使用3.1.1、概述View Animation中的动画类命名都是XXXXAnimation，而Property Animation中的动画类命名都是XXXXAnimator。 视图动画仅能对指定的控件做动画，而属性动画是通过改变控件的某一属性值来做动画的。 3.1.2、ValueAnimator的简单使用ValueAnimator不会对控件执行任何操作，我们可以给它设定从哪个值运动到哪个值，通过监听这些值的渐变过程来自己操作控件。 //创建实例 ValueAnimator animator = ValueAnimator.ofInt(0, 400); animator.setDuration(1000); //添加监昕事件 animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { int curValue = (Integer)animation.getAnimatedValue() ; Log.d(&quot;qijian&quot;,&quot;curValue:&quot; + curValue); } }); //开启动画 animator.start(); 改变控件位置 view.layout(); 3.1.3、常用函数public static ValueAnimator ofint (int... values) public static ValueAnimator ofFloat(float... values) //设置动画时长，单位是毫秒 ValueAnimator setDuration(long duration) //获取 ValueAnimator 在运动时当前运动点的值 Object getAnimatedValue() //开始动画 void start() //设置循环次数，设置为ValueAnimator.INFINITE表示无限循环 void setRepeatCount(int value) //设置循环模式有ValueAnimator.RESTART和ValueAnimator.REVERSE void setRepeatMode(int value) //取消动画 void cancel() 重复次数为INFINITE的动画，当Activity结束的时候，必须调用cancel()函数取消动画，否则动画将无限循环，从而导致View无法释放，进一步导致整个Activity无法释放，最终引起内存泄漏。 //监听动画过程中值的实时变化,添加方法为:public void addUpdateListener(AnimatorUpdateListener listener) public static interface AnimatorUpdateListener { void onAnimationUpdate(ValueAnimator animation); } //听动画变化时的4个状态,添加方法为:public void addListener(AnimatorListener listener) public static interface AnimatorListener { void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); } 移除监听 void removeUpdateListener(AnimatorUpdateListener listener); void removeAllUpdateListeners(); void removeListener(AnimatorListener listener); void removeAllListeners(); 其他不常用函数 //延时多久开始，单位是毫秒 public void setStartDelay(long startDelay) //完全克隆一个ValueAnimator实例，包括它所有的设置以及所有对监听器代码的处理 public void Animatorclone() 3.1.4、弹跳加载申效果示例通过setTop(int top）函数将控件移动到当前位置。这里需要说明的是，getTop和setTop函数所得到的和设置的坐标都是相对父控件的坐标位置。 3.2、自定义插值器与Evaluator对于Animator而言，不仅可以设置插值器，还可以设置Evaluator。 3.2.1、自定义插值器系统插值器实现的接口： public interface TimeInterpolator { float getInterpolation(float input); } 参数input:取值范围是0～1，表示当前动画的进度，只与时间有关，取0时表示动画刚开始，取1时表示动画结束。 返回值：表示当前实际想要显示的进度。取值可以超过1，也可以小于0。超过1表示己经超过目标值，小于0表示小于开始位置。 自定义插值器，只需实现Timelnterpolator接口就可以了。 3.2.2、Evaluator流程：oflnt(0,400）定义动画数值区间 -&gt; 插值器(返面当前数值进度，如0.2) -&gt; Evaluator(根据数值进度计算当前值) -&gt; 监听器退回(在AnimatorUpdatelistener中返回)。 Evaluator用于将从插值器返回的数值进度转换成对应的数值。 public class IntEvaluator Implements TypeEvaluator&lt;Integer&gt; { public Integer evaluate(float fraction , Integer startValue , Integer endValue) { int startint = startValue; return (int) (startint + fraction * (endValue - startint)); } } fraction参数就是插值器中的返回值，表示当前动画的数值进度，以小数表示。startValue和endValue分别对应oflnt(int start,int end）函数中start和end的数值。返回值就是在AnimatorUpdateListener监听器中通过animation.getAnimatedValue()函数得到的数值。 使用 animator.setEvaluator(new IntEvaluator()); 所以既可以通过重写插值器改变数值进度来改变数值位置，也可以通过改变Evaluator中数值进度所对应的具体数值来改变数值位置。 ArgbEvaluator除 IntEvaluator 和 FloatEvaluator 外，还有一个名为 ArgbEvaluator，它是用来实现颜色值过渡转换的。 ValueAnimator animator = ValueAnimator.ofInt(0xffffff00,0xff0000ff); animator.setEvaluator(new ArgbEvaluator()); animator.setDuration(3000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { public void onAnimationUpdate(ValueAnimator animation) { int curValue = (Integer) animation.getAnimatedValue(); tv.setBackgroundColor(curValue); } }); animator.start(); 3.3、ValueAnimator进阶ofObjectpublic static ValueAnimator ofObject(TypeEvaluator evaluator, Object ...values) TextView中的字母从A变化到Z实例3.3.2、示例：抛物动画3.4、ObjectAnimator3.4.1、概述ObjectAnimator是派生自ValueAnimator的，所以ValueAnimator中所能使用的函数在ObjectAnimator中都可以正常使用。 public static ObjectAnimator ofFloat(Object target,String propertyName,float ...values) 在View中，有关动画共有下面几组set函数。 // 1. 透明 度： alpha public void setAlpha(float alpha) // 2. 旋转度数 ： rotation 、 rotationX 、 rotationY public void setRotation(float rotation) public void setRotationX(float rotationX) public void setRotationY(float rotationY) // 3. 平移 ： translationX 、 translationY public void setTranslationX(float translationX) public void setTranslationY(float translationY) // 4. 缩放 ： scaleX 、 scaleY public void setScaleX(float scaleX) public void setScaleY(float scaleY) 3.4.2、ObjectAnimator动画原理ofFloat(tv, &quot;scaleY&quot;,0,3,1）(定义动画对象及区间） —&gt; 插值器(返面当前数值进度，如0.2) -&gt; Evaluator(根据数值进度计算当前值) -&gt; 调用set函数(根据属性拼装set函数并反射调用，并将当前值作为参数传入)。 ObjectAnimator 只负责把动画过程中的数值传到对应属性的set函数中就结束了。 3.4.3、自定义ObjectAnimator属性抛物动画例子 3.4.4、何时需要实现对应属性的get函数当动画只有一个过渡值时，系统才会调用对应属性的get函数来得到动画的初始值。当不存在get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。 3.4.5、常用函数//设置动画时长，单位是毫秒 ValueAnimator setDuration(long duration) //获取 ValueAnimator 在运动时，当前运动点的值 Object getAnimatedValue () ; //开始动画 void start () //设置循环次数，设置为 INFINITE 表示无限循环 void setRepeatCount(int value) //设置循环模式，value 取值有 RESTART 和 REVERSE void setRepeatMode （Int value) //取消动画 void cancel() //监听动画变化时的实时值 //添加方法为 public void addUpdateListener(AnimatorUpdateListener listener public static interface AnimatorUpdateListener { void onAnimatorUpdate(ValueAnimator animation); ) //监听器二 ： 监听动画变化时的 4 种状态 //添加方法为 public void addListener(AnimatorListener listener) public static interface AnimatorListener { void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); } //设置插值器 public void setInterpolator(Timeinterpolator value) //设置 Evaluator public void setEvaluator(TypeEvaluator value) 3.5、组合动画AnimatorSet3.5.1、playSequentially与playTogetherplaySequentially：动画依次播放，playTogether：所有动画一起开始。 playTogether和playSequentially函数在开始动画时，只是把每个控件的动画激活，至于每个控件自身的动画是否延时、是否无限循环，只与控件自身的动画设定有关，与playTogether和 playSequentially函数无关，它们只负责到时间后激活动画。 playSequentially函数只有在上一个控件做完动画以后，才会激活下一个控件的动画。如果上一个控件的动画是无限循环的，那么下一个控件就别再指望能做动画了。 3.5.2、AnimatorSet.Builde//表示要播放哪个动画 public Builder play (Animator anim) //和前面的动画一起执行 public Builder with(Animator anim) //先执行这个动画，再执行前面的动画 public Builder before (Animator aηim) //在执行前面的动画后才执行该动画 public Builder after(Animator anim) //延迟 n 毫秒之后执行动画 public Builder after(long delay) 3.5.3、AnimatorSet监昕器public void addListener(AnimatorListener listener); 3.5.4、常用函数//设置单次动画时长 public AnimatorSet setDuration(long duration); //设置插值器 public void setinterpolator(Timeinterpolator interpolator) //设置 ObjectAnimator 动画目标控件 public void setTarget(Object target) 在AnimatorSet中设置以后，会覆盖单个ObjectAnimator中的设置。 //设置延时开始动画时长 public void setStartDelay(long startDelay) 不会覆盖单个动画的延时，而且仅针对性地延长AnimatorSet的激活时间。 3.5.5、示例：路径动画代码 https://github.com/AdamRight/TeaTool/blob/master/app/src/main/java/com/tea/teatool/pathMenu/PathMenuActivity.java 3.6、Animator动画的XML实现在 XML 中与 Animator 对应的有三个标签: &lt;animator/＞:对应ValueAnimator &lt;objectAnimator/＞ 对应ObjectAnimator &lt;set/＞对应 AnimatorSet ValueAnimator valueAnimator = (ValueAnimator)Animatorinflater.loadAnimator(MyActivity.this , R.animator.animator); valueAnimator.start(); ObjectAnimator animator = (ObjectAnimator) Animatorinflater.loadAnimator(MyActivity.this , R.animator.object_animator); animator.setTarget(mTvl); animator.start(); 第4章属性动画进阶4.1、PropertyValuesHolder与Keyframe通过ofPropertyValu巳sHolder函数来创建实例。 4.1.1、PropertyValuesHolderofFloat PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;Rotation&quot;, 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f); PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0.1f, 1f, 0.1f, 1f); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, alphaHolder); animator.setDuration(3000); animator.start(); ofObject public static PropertyValuesHolder ofObject (String propertyName ,TypeEvaluator evaluator, Object . .. values ) 4.1.2、Keyframe关键帧：解决控制动画速率的问题。 public static Keyframe ofFloat(float fraction , float value) fraction：表示当前的显示进度，即在插值器中getlnterpolation函数的返回值。 value：表示动画当前所在的数值位置。 设置插值器： public void setinterpolator(Timeinterpolator interpolator) 使用ofObject函数来制作动画的时候，必须设置Evaluator，因为系统根本无法知道动画的中间值Object真正是什么类型的。 4.1.3 PropertyValuesHolde其他函数4.1.4、电话晌铃效果示例借助Keyframe，不需要使用AnimatorSet，也能实现多个动画同时播放。 4.2、ViewPropertyAnimator4.2.1、概述4.2.2、常用函数tv.animate().scaleX(2).scaleY(2).setListener(new Animator.AnimatorListener() { public void onAnimationStart(Animator animation ) {} public void onAnimationEnd (Animator animation ) {} public void onAnimationCancel(Animator animation) {} public void onAnimationRepeat(Animator animation) {} }); 4.3、为ViewGroup内的组件添加动画4.3.1、animatelayoutChanges属性android:animateLayoutChanges＝”true/false”，所有派生自ViewGroup类的控件都具有此属性。动画不能自定义。 4.3.2、LayoutTransition第一步，创建实例。 LayoutTransition transitioner = new LayoutTransition(); 第二步创建动画并进行设置。 ObjectAnimator animOut = ObjectAnimator.ofFloat(null,”rotation”, Of,90f, Of); transitioner.setAnimator(LayoutTransition.DISAPPEARING , animOut); 第三步将LayoutTransition设置到ViewGroup中。 linearLayout.setLayoutTransition(transitioner); 其中,transitionType表示当前应用动画的对象范围，取值如下: APPEARING：元素在容器中出现时所定义的动画。 DISAPPEARING：元素在容器中消失时所定义的动画。 CHANGE_APPEARING:由于容器中要显现一个新的元素，其他需要变化的元素所应用的动画。 CHANGE_DISAPPEARING：当容器中某个元素消失时，其他需要变化的元素所应用的动画。 4.3.3、其他函数4.4、开源动画库NineOldAndroids第5章动画进阶5.1、利用PathMeasure实现路径动画5.1.1、初始化方式一： PathMeasure pathMeasure = new PathMeasure() ; setPath (Path path , boolean forceClosed); 方式二： PathMeasure(Path path , boolean forceClosed); boolean forceClosed表示Path最终是否需要闭合，如果为true，则不管关联的Path是否是闭合的，都会被闭合。对绑定的Path不会产生任何影响，PathMeasure的计算就会包含最后一段闭合的路径，与原来的Path不同。 5.1.2、简单函数使用//获取计算的路径长度 PathMeasure.getLength() //判断测量Path时是否计算闭合 public boolean isClosed() //函数得到的曲线的顺序与Path中添加的顺序相同。getLength等函数针对的都是当前的曲线，而不是整个Path。 PathMeasure.nextContour() 5.1.3、getSegment函数//截取整个Path中的某个片段，将截取后的 Path 保存到参数 dst 中。 boolean getSegrneηt(float startD ,float stopD, Path dst, boolean startWithMoveTo) startD、stopD：开始截取位置距离 Path 起始点的长度；结束截取位置距离 Path 起始点的长度。 Path dst：截取的Path将会被添加到dst中。注意是添加，而不是替换。 boolean startWithMoveTo：起始点是否使用 moveTo。 5.1.4、getPosTan函数//用于得到路径上某一长度的位置以及该位置的正切值 boolean getPosTan(float distance , float[] pos , float[] tan) float distance：距离Path起始点的长度。float[] pos：该点的坐标值。pos[O]表示x坐标，pos[1］表示y坐标。float[] tan：该点的正切值。 箭头加载动画示例 5.1.5、getMatrix函数//用于得到路径上某一长度的位置以及该位置的正切值的矩阵 boolean getMatrix(float distance , Matrix matrix , int flags) 5.1.6、支付宝支付成功动画示例5.2、SVG动画5.2.1、概述SVG 的全称是Scalable Vector Graphics（可缩放矢量图形〉。矢量图相对应的是位图，Bitmap就是位图。 对于5.0以下的机型，可以通过引入 com.android.support:appcompat-v7:23.4.0及以上版本进行支持。 5.2.2、vector标签与图像显示vector标签指定的是画布大小，path标签则指定的是路径内容。 Android工程中使用SVG图像。 5.2.3、动态Vector5.2.4、输入搜索动画示例第6章Paint基本使用6.1、硬件加速GPU的英文全称为Graphic Processing Unit，中文翻译为“图形处理器”。GPU是专门为处理图形任务而产生的芯片。在GPU加速时，实际上是使用OpenGL的相关函数来完成绘制的。 Android提供了不同的禁用方法，分Application、Activity、Window、View4个层级。 在AndroidManifest.xml文件中为application标签添加如下属性，即可为整个应用程序开启/关闭硬件加速。 &lt;application android:hardwareAccelerated=”true”...&gt; 在activity标签下开启或关闭硬件加速: &lt;activity android:hardwareAccelerated=”false” /&gt; 在Window层级上使用如下代码开启硬件加速(在Window层级上不支持关闭硬件加速: getWiηdow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 在View层级上使用如下代码关闭硬件加速（在View层级上不支持开启硬件加速） setLayerType(View.LAYER_TYPE_SOFTWARE,null}; 或者使用android:layerType＝&quot;software&quot;来关闭硬件加速。 6.2、文字6.2.1、概述基线就是四线格中的第三条线。 public void drawText (String text , float x , float y , Paint paint) y代表的是基线的位置,而不是左上角。x代表所要绘制的文字所在矩形的相对位置。 Align的取值为 Paint.Align.LEFT、Paint.Align.CENTER、Paint.Align.RIGHT Paint :: setTextAlign(Align align); 6.2.2、绘图四线搭与FontMetricsascent：系统推荐的，在绘制单个字符时，字符应当的最高高度所在线。 descent：系统推荐的，在绘制单个字符肘，宇符应当的最低高度所在线。 top：可绘制的最高高度所在线。 bottom：可绘制的最低高度所在线。 ascent变量的值是负数。descent变量的值必然是正数。 ascent线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.ascent descent线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.descent top线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.top bottom线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.bottom 获取 FontMetrics 对象 Paint paint = new Paint(); Paint.FontMetrics fm = paint.getFontMetrics();//Float类型 Paint.FontMetricsint fmint = paint.getFontMetricsint();//Int类型 6.2.3、常用函数字符串所占区域的高度、宽度和最小矩形。 高度：bottom线所在位置的y坐标减去top线所在位置的y坐标 Paint.FontMetricsint fm = paint.getFontMetricsint(); int top = baseLineY + fm.top; int bottom = baseLineY + fm.bottom; //所占区域的高度 int height = bottom - top; 宽度: int width = paint.measureText(String text); 最小矩形 //以（0, 0）点所在位置为基线,text要测量最小矩形的字符串,start 要测量起始字符在字符串中的索引, //end 所要测量的字符的长度,bounds接收测量结果 public void getTextBounds(String text, int start, int end, Rect bounds); 矩形实际位置的坐标如下 Rect minRect = new Rect(); paint.getTextBounds(text , 0 , text. length(), minRect); //最小矩形，实际top线的位置 int minTop =bounds.top + baselineY; //最小矩形，实际 bottom 线的位置 int minBottom = bounds.bottom + baselineY; 6.2.4、定点写字示例当给定中间线位置以后，baseline线的位置为： baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom 6.3、Paint常用函数6.3.1、基本设置函数reset() setColor(int color) setARGB(int a, int r, int g, int b) setAlpha(int a) //Paint.Style.FILL、Paint.Style.FILL_AND_STROE、Paint.Style.STROKE setStyle(Paint.Style style) setStrokeWidth(float width) setAntiAlias(boolean aa) setStrokeMiter(float miter) //ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect。 setPathEffect(PathEffect effect) //Paint.Cap.ROUND 、Paint.Cap.SQUARE、Paint.Cap.BUTT setStrokeCap(Paint.Cap cap) //Paiηt.Join.MITER、Paiηt.Join.ROUND、Paiηt.Join.BEVEL setStrokeJoin (Paiηt.Join join) setDither(boolean dither) 6.3.2、字体相关函数setTextSize(float textSize) setFakeBoldText(boolean fakeBoldText) setUnderlineText(boolean underlineText) setTextAlign（Paint.Align align) setTextScaleX(float scaleX) setTextSkewX(float skewX) setTypeface(Typeface typeface) setSubpixelText(boolean subpixelText) 第7章绘图进阶7.1、贝济埃曲线7.1.1、概述一阶贝济埃曲线，可以理解为在由起始点和终点形成的这条直线上匀速移动的点。 二阶贝济埃曲线的移动轨迹是建立在两条一阶贝济埃曲线的中间点的基础上的。 所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。 7.1.2、贝济埃曲线之quadTo//二阶贝济埃曲线 public void quadTo(float xl , float yl, fl oat x2 , float y2) public void rQuadTo(float dxl, float dyl , float dx2, float dy2) //三阶贝济埃曲线 public void cubicTo (float xl , float yl , float x2 , float y2 , float x3 , float y3) public void rCubicTo(float xl , float yl, float x2 , float y2 , float x3 , float y3 ) 起始点是通过Path.moveTo(x,y）函数来指定的，而如果我们连续调用quadTo（）函数， 那么前一个quadTo（）函数的终点就是下一个quadTo（）函数的起始。 传统捕捉手势轨迹示例 7.1.3、贝济埃曲线之rQuadToquadTo()函数定义一个绝对坐标： path.moveTo(300,400) path.quadTo(500,300,500,500) 与利用rQuadTo()函数定义相对坐标是等价的： path.moveTo(300,400) path.rQuadTo(200,-100,200,100) 7.1.4、波浪效果示例7.2、setShadowLayer与阴影效果7.2.1、setShadowlayer()构造函数public void setShadowLayer(float radius, float dx , float dy , int color) float radius：模糊半径，radius越大越模糊、越小越清晰。如果radius设置为0则阴影消失不见。float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移。float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移。int color：绘制阴影的画笔颜色，阴影的颜色（对图片阴影无效）。 setShadowLayer()函数使用的是高斯模糊算法。高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的RGB值并且平均，这个平均值就是模糊处理过的像素。如果对图片中的所有像素都这么处理，那么处理完成的图片就会变得模糊。其中，所取周围像素的半径就是模糊半径。所以，模糊半径越大，所得平均像素与原始像素相差就越大，也就越模糊。 7.2.2、清除阴影setShadowLayer函数的radius参数值设为0， 或者用专门的清除阴影的函数： public void clearShadowLayer() 7.2.3、给文字添加阴影示例7.3、BlurMaskFilter发光效果与图片阴影public MaskFilter setMaskFilter(MaskFilter maskfilter) public BlurMaskFilter{float radius ,Blur style) 7.3.2、给图片添加纯色阴影public Bitmap extractAlpha(); extractAlpha会新建一幅仅具有Alpha值的空白图像，而且这幅图像的颜色是在使用canvas.drawBitmap函数绘制时由传入的画笔颜色指定的。 7.4、Shader与BitmapShader7.4.1、Shader概述通过给Shader指定对应的图像、渐变色等来填充图形的。 public Shader setShader (Shader shader) 7.4.2、BitmapShader的基本用法public BitmapShader(Bitmap bitmap, TileMode tileX , TileMode tileY) bitmap用来指定图案，tileX用来指定当X轴超出单张图片大小时所使用的重复策略，tileY用来指定当Y轴超出单张图片大小时所使用的重复策略。 TileMode的取值： TileMode.CLAMP：用边缘色彩来填充多余空间。 TileMode.REPEAT：重复原图像来填充多余空间。 TileMode.MIRROR：重复使用镜像模式的 图像来填充多余空间。 先填充Y轴，然后填充X轴。 7.4.3、望远镜效果示例7.4.4、生成不规则头像示例7.5、Shader之LinearGradient7.5.1、概述public LinearGradient(float xO , float yO , float xl , float yl , int colorO , int colorl , TileMode tile) public LinearGradient (float xO , fl 。atyO, floatxl ,floatyl,intcolors[], float positions[] , TileMode tile) 7.5.2、闪光文字效果示例7.6、Shader之RadialGradient7.6.1、双色渐变RadialGradient(float centerX , float centerY , float radius , int centerColor ,int edgeColor, Shader.TileMode tileMode) 7.6.2、多色渐变RadialGradient(float centerX , float centerY , float radius, int[] colors , float[] stops, Shader.TileMode tileMode) 第8章混合模式8.1、混合模式之AvoidXfermode8.1.1、混合模式概述Xfermode的子类有AvoidXfermode、PixelXorXfermode和PorterDuffXfermode。 在使用Xfermode时，为了保险起见，需要做两件事： 禁用硬件加速： setLayerType(View.LAYER_TYPE_SOFTWARE, null); 使用离屏绘制: 需要把绘制的核心代码放在canvas.save和canvas.restore函数之间 //新建图层 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(),null ,Canvas.ALL_SAVE_FLAG); //核心绘制代码 //.... //还原图层 canvas.restoreToCount(layerid); 8.1.2、AvoidXfermodepublic AvoidXfermode (int opColor, int tolerance ,Mode mode) 8.1.3、AvoidXfermode绘制原理8.1.4、AvoidXfermode之Mode.AVOID8.2、混合模式之PorterDuffXfermode8.2.1、PorterDuffXfermode概述public PorterDuffXfermode(PorterDuff .Mode mode) 在Xfermode设置前画出的图像叫作目标图像，即给谁应用Xfermode；在Xfermode设置后画出 的图像叫作源图像，即拿什么应用Xfermode。 8.2.2、颜色叠加相关模式8.3、PorterDuffXfermode之源图像模式刮刮卡效果示例 8.4、目标图像模式与真他模式区域波纹示例","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"http://yoursite.com/tags/自定义控件/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"ConstraintLayout布局详解","slug":"31.ConstraintLayout布局","date":"2019-12-23T13:44:16.294Z","updated":"2020-02-20T08:13:17.463Z","comments":false,"path":"2019/12/23/31.ConstraintLayout布局/","link":"","permalink":"http://yoursite.com/2019/12/23/31.ConstraintLayout布局/","excerpt":"","text":"相对位置下面是ConstraintLayout确定位置的属性： layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf # 底部对齐 layout_constraintBaseline_toBaselineOf ＃ 与left\\right相似 layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf 这些属性的值即可以是parent，也可以是某个view的id。 居中显示 app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; 尺寸约束ConstraintLayout 中不支持 MATCH_PARENT 这个值，如果需要实现跟MATCH_PARENT同样的效果，可以使用0dp来代替，其表示MATCH_CONSTRAINT,即适应约束。其跟MATCH_PARENT还是有区别的。 android:layout_width=&quot;0dp&quot; 宽高比在ConstraintLayout中，还可以将宽定义成高的一个比例或者高定义成宽的比率。首先，需要将宽或者高设置为0dp（即MATCH_CONSTRAINT），即要适应约束条件。然后通过layout_constraintDimensionRatio属性设置一个比率即可。这个比率可以是一个浮点数，表示宽度和高度之间的比率；也可以是“宽度：高度”形式的比率。 &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:text=&quot;-------------------宽高比2：1-------------------&quot; app:layout_constraintDimensionRatio=&quot;2:1&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; 如果宽和高都设置为0dp（MATCH_CONSTRAINT），那么layout_constraintDimensionRatio的值需要先加一个&quot;W,&quot;或者&quot;H,&quot;来表示约束宽度或高度。如下： &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintDimensionRatio=&quot;H,16:9&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; 这里例子是说，首先宽度将满足父布局的约束，然后将按照16：9的比例设置高度。 百分比宽高ConstraintLayout还能使用百分比来设置view的宽高。要使用百分比，宽或高同样要设置为0dp（MATCH_CONSTRAINT）。然后设置以下属性即可： app:layout_constraintWidth_default=&quot;percent&quot; //设置宽为百分比 app:layout_constraintWidth_percent=&quot;0.3&quot; //0到1之间的值 或 app:layout_constraintHeight_default=&quot;percent&quot; //设置高为百分比 app:layout_constraintHeight_percent=&quot;0.3&quot; //0到1之间的值 例子 &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;宽50%&quot; app:layout_constraintWidth_default=&quot;percent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintWidth_percent=&quot;0.5&quot;/&gt; layout_constraintWidth_default 设置为 percent 即采用百分比的方式布局，然后设置 layout_constraintWidth_percent 的属性值，来改变水平方向的百分比。 位置偏向如果想让view的位置偏向某一侧，可以使用以下的两个属性来设置： layout_constraintHorizontal_bias //水平偏向 layout_constraintVertical_bias //竖直偏向 其值同样也是0到1之间。比如，以下例子为横向偏向左侧30%，默认的居中效果就是50％： &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;左边偏向30%&quot; app:layout_constraintHorizontal_bias=&quot;0.3&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; 权重通过设置以下两个属性： app:layout_constraintHorizontal_weight //水平权重 app:layout_constraintVertical_weight //竖直权重 举个栗子 &lt;Button android:id=&quot;@+id/btn_1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;权重为1&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@id/btn_2&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;权重为2&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; app:layout_constraintLeft_toRightOf=&quot;@id/btn_1&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; 链 设置链样式的属性是： app:layout_constraintHorizontal_chainStyle=&quot;spread|spread_inside|packed&quot; 官网上一共有5种样式的链：spread、spread_inside、packed和Weighter Chain、Packed Chain with bias、 Guideline辅助线Guideline可以用来辅助布局，通过Guideline能创建出一条条的水平线或者垂直线，该线不会显示到界面上，但是能够利用这些线条来添加约束去完成界面的布局。 Guideline主要的属性有： android:orientation=&quot;horizontal|vertical&quot; app:layout_constraintGuide_begin=&quot;30dp&quot; app:layout_constraintGuide_end=&quot;30dp&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; android:orientation=”horizontal|vertical”表示是水平或垂直引导线。 app:layout_constraintGuide_begin=”30dp”，如果是水平引导线，则距离布局顶部30dp，如果是垂直引导线，则距离布局左边30dp。 app:layout_constraintGuide_end=”30dp”，如果是水平引导线，则距离布局底部30dp，如果是垂直引导线，则距离布局右边30dp。 app:layout_constraintGuide_percent=”0.5”，如果是水平引导线，则距离布局顶部为整个布局高度的50%，如果是垂直引导线，则距离布局左边文这个布局宽度的50%。 &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline_h&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.5&quot;/&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline_v&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot;/&gt; &lt;Button app:layout_constraintLeft_toLeftOf=&quot;@id/guideline_v&quot; app:layout_constraintTop_toTopOf=&quot;@id/guideline_h&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;辅助线定位&quot;/&gt; 参考 https://blog.csdn.net/wangjiang_qianmo/article/details/78254326","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://yoursite.com/tags/ConstraintLayout/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"adb命令","slug":"30.adb命令","date":"2019-11-29T14:22:57.855Z","updated":"2020-01-04T11:50:43.355Z","comments":false,"path":"2019/11/29/30.adb命令/","link":"","permalink":"http://yoursite.com/2019/11/29/30.adb命令/","excerpt":"","text":"monkey测试 adb shell monkey -p 包名 -v 次数 启动adb、关闭adb adb start-server adb kill-server 获取手机的系统版本 adb shell getprop ro.build.version.release 清除apk的数据和缓存 adb shell pm clear 包名 安装和卸载apk adb install 文件路径 adb uninstall 包名 电脑和手机文件互传 adb push C:\\Users\\win\\Desktop\\xx.png /sdcard adb pull /sdcard/xx.png C:\\Users\\win\\Desktop 查看保存app错误日志 adb logcat *:E | grep &quot;包名&quot; &gt; 电脑路径 //mac adb logcat *:E | find &quot;包名&quot; &gt; 电脑路径 //win 获取当前app包名和当前页面名(⼿机打开对应app) adb shell dumpsys window windows | grep mFocusedApp //mac adb shell dumpsys window windows | findstr mFocusedApp //win log获取app的包名和activity名称 adb logcat | grep START //mac adb logcat | findstr START //win 然后点击app 关闭app后,获取app启动时间 关闭app adb shell am start -W 包名/启动名 adb shell am start -W com.xxx.xxx/.LaunchActivity //TotalTime： app⾃身启动时间,WaitTime： 系统启动应⽤时间 Appium 官⽹： www.appium.io, Appium是由nodejs的express框架写的Http Server,Appium使⽤WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"adb","slug":"adb","permalink":"http://yoursite.com/tags/adb/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Gradle构建详解","slug":"29.Gradle构建详解","date":"2019-07-13T08:08:14.650Z","updated":"2020-07-26T04:29:28.275Z","comments":false,"path":"2019/07/13/29.Gradle构建详解/","link":"","permalink":"http://yoursite.com/2019/07/13/29.Gradle构建详解/","excerpt":"","text":"1、介绍和环境搭建DSL(domain specific language)：领域特定语言，解决特定问题，包括Groovy，xml等等。 Groovy是一种基于JVM的敏捷开发语言，可以使用java所用的库。 Groovy官网 http://groovy-lang.org/ 下载最新稳定版本(the latest stable version of Groovy)-2.5.8版本。 检查环境变量配置 groovy -version 在Android studio中Tools - Groovy Console直接编写Groovy语言。 println &quot;hello groovy&quot; 2、语法2.1、基础语法groovy变量的类型都是对象类型，没有基本类型，因为基本类型都会装箱成对象类型。 变量的定义包括强类型定义和弱类型def定义。 def x = 10 println x.class //class java.lang.Integer 字符串除了String还有GString，GString的常用三种定义方式 def s1 = &apos;a single \\&apos;a\\&apos; String&apos; println s1 //a single &apos;a&apos; String def s2 = &apos;&apos;&apos;\\ line one line two line three &apos;&apos;&apos; println s2 //line one //line two //line three def s3 = &quot;a common String&quot; def say = &quot;this is ${s3}&quot; //花括号可扩展任意的表达式 println say //this is a common String println say.class //class org.codehaus.groovy.runtime.GStringImpl 新增常用操作符 def str = &quot;groovy&quot; //println str.center(9,&apos;a&apos;) //agroovyaa //println str.padLeft(9,&apos;a&apos;) //aaagroovy //println str.padRight(9,&apos;a&apos;) //groovyaaa def str2 = &apos;Hello&apos; println str &gt; str2 //true println str[0] //g println str[0..1] //gr def str3 = &apos;gro&apos; println str.minus(str3) //ovy println str - str3 //ovy //println str.reverse() //yvoorg println str.capitalize() //Groovy println str.isNumber() //false 逻辑控制: switch def x = 1.23 def result switch (x){ case &quot;str&quot;: result = &apos;str&apos; break case [4,6,7,&apos;inlist&apos;]: //list result = &apos;list&apos; break case 12..30: //范围 result = &apos;range&apos; break case Integer: result = &apos;Integer&apos; break case BigDecimal: result = &apos;BigDecimal&apos; break default:result = &apos;default&apos; } println result //BigDecimal for范围 def sum = 0 for (i in 0..9){ sum += i } println sum //45 list循环 def sum = 0 for (i in [1,2,3,4,5,6,7,8,9]){ sum += i } println sum //45 map循环 def sum = 0 for (i in [&apos;wang&apos;:1,&apos;zhang&apos;:2,&apos;li&apos;:3]){ sum += i.value } println sum //6 2.2、闭包类似于方法 def clouser = { println &quot;Hello groovy&quot;} clouser.call() //调用方式一，Hello groovy clouser() //调用方式二，Hello groovy 有参数的闭包-&gt;前的是参数,也可以有多个参数 def clouser = {String name -&gt; println &quot;${name} Hello groovy&quot;} clouser.call(&quot;this is&quot;) //调用方式一，this is Hello groovy clouser(&quot;this is&quot;) //调用方式二，this is Hello groovy 隐式的it参数,不需要定义参数 def clouser = {println &quot;Hello ${it}&quot;} clouser(&quot;groovy&quot;) //Hello groovy 返回值 def clouser = {String name -&gt; return &quot;Hello ${name}&quot;} println clouser(&quot;groovy&quot;) //Hello groovy 基本类型和闭包结合使用 int x = cal(5) println x //num的阶乘 int fab(int number) { int result = 1 1.upto(number, { num -&gt; result *= num }) return result } int fab2(int number) { int result = 1 number.downto(1) { num -&gt; result *= num } return result } //累加 int cal(int number) { int result = 0 number.times { num -&gt; result += num } return result } 字符串和闭包结合使用 String str = &apos;2 and 3 is 5&apos; //each遍历 str.each { // String temp -&gt; println temp.multiply(2) String temp -&gt; println temp } //find查找符合条件的第一个,findAll查找所有符合条件的放到集合 println str.find{ String s -&gt; s.isNumber() } def list = str.findAll{ String s -&gt; s.isNumber() } println list.toListString() //[2, 3, 5] def result = str.any { String s -&gt; s.isNumber() //有一项是数字就返回true } println result //true println str.every { //false String s -&gt; s.isNumber() //每一项都是数字就返回true } def list2 = str.collect{ it.toUpperCase() } println list2.toListString() //[2, , A, N, D, , 3, , I, S, , 5] 闭包进阶 变量：this、owner、delegate def scriptClouser = { println &quot;this:&quot; + this //代表闭包定义处的类 println &quot;owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;delegate:&quot; + delegate //代表任意对象，默认与owner一致 } scriptClouser.call() class Person{//内部类 def classClouser = { println &quot;classClouser this:&quot; + this //代表闭包定义处的类 println &quot;classClouser owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;classClouser delegate:&quot; + delegate //代表任意对象，默认与owner一致 } def say(){ def classClouser = { println &quot;method classClouser this:&quot; + this //代表闭包定义处的类 println &quot;method classClouser owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;method classClouser delegate:&quot; + delegate //代表任意对象，默认与owner一致 } classClouser.call() } } Person person = new Person() person.classClouser.call() person.say() def nextClouser = { def innerClouser = { println &quot;innerClouser this:&quot; + this //代表闭包定义处的类 println &quot;innerClouser owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;innerClouser delegate:&quot; + delegate //代表任意对象，默认与owner一致 } innerClouser.delegate = person //修改delegate innerClouser.call() } nextClouser.call() 闭包委托策略 class Student { String name def pretty = { &quot;My name is ${name}&quot; } String toSting(){ pretty.call() } } class Teacher { String name } def stu = new Student(name: &apos;Sarash&apos;) def tea = new Teacher(name: &apos;Qndroid&apos;) stu.pretty.delegate = tea stu.pretty.resolveStrategy = Closure.DELEGATE_FIRST//delegate优先 println stu.toSting() //My name is Qndroid 2.3、列表list数组和列表定义方式 def array = [1, 2, 3, 4, 5, 6] as int[] int[] array2 = [1, 2, 3, 4, 5, 6] def list = [1, 2, 3, 4, 5, 6] 主要介绍特有的 //排序 def sortList = [1, -4, 5, -6, 2, 3] //Collections.sort(sortList) //println sortList //[-6, -4, 1, 2, 3, 5] sortList.sort() println sortList //[-6, -4, 1, 2, 3, 5] //自定义排序 //Comparator mc = { a, b -&gt; // a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 //} //Collections.sort(sortList, mc) //println sortList //[1, 2, 3, -4, 5, -6] sortList.sort { a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } println sortList //[1, 2, 3, -4, 5, -6] //字符串排序 def sortStringList = [&apos;123&apos;, &apos;a&apos;, &apos;groovy&apos;] sortStringList.sort { it -&gt; return it.size() } println sortStringList //[a, 123, groovy] //查找 def findList = [-3, 8, -8, 12, 4, 7] int result = findList.find { return it % 2 == 0 } println result //8 def result2 = findList.findAll { return it % 2 == 0 } println result2.toListString() //[8, -8, 12, 4] def result3 = findList.any { return it % 2 != 0 } println result3 //true def result4 = findList.every { return it % 2 != 0 } println result4 //false println findList.min() //-8 println findList.max() //12 def num = findList.count { return it % 2 == 0 } //符合条件的个数 println num //4 2.4、映射map定义和基本操作 def colors = [red: &apos;ff0000&apos;, green: &apos;00ff00&apos;, blue: &apos;0000ff&apos;] println colors.getClass() //class java.util.LinkedHashMap //索引 println colors[&apos;red&apos;] //ff0000 println colors.red //ff0000 //添加 colors.yellow = &apos;ffff00&apos; println colors.toMapString() //[red:ff0000, green:00ff00, blue:0000ff, yellow:ffff00] 其他操作 def students = [ 1: [number: &apos;0001&apos;, name: &apos;zhang&apos;, score: 55, sex: &apos;male&apos;], 2: [number: &apos;0002&apos;, name: &apos;li&apos;, score: 62, sex: &apos;female&apos;], 3: [number: &apos;0003&apos;, name: &apos;wang&apos;, score: 63, sex: &apos;female&apos;], 4: [number: &apos;0004&apos;, name: &apos;zhao&apos;, score: 66, sex: &apos;male&apos;] ] //遍历 students.each { def student -&gt; println student.key + &quot;:&quot; + student.value } //带索引 students.eachWithIndex { def student, int index -&gt; println index + &apos;::&apos; + student.key + &quot;:&quot; + student.value } //直接遍历 students.each { key, value -&gt; println key + &quot;:&quot; + value } students.eachWithIndex { key, value, index -&gt; println index + &apos;:::&apos; + key + &quot;:&quot; + value } //查找 def entry = students.find { def student -&gt; return student.value.score &gt;= 60 } println entry //2={number=0002, name=li, score=62, sex=female} def entry2 = students.findAll { def student -&gt; return student.value.score &gt;= 60 } println entry2 //计数 def count = students.count { def student -&gt; return student.value.score &gt;= 60 &amp;&amp; student.value.sex == &apos;male&apos; } println count //1 //查找并筛选 def names = students.findAll { def student -&gt; return student.value.score &gt;= 60 }.collect { return it.value.name } println names //[li, wang, zhao] //分组 def group = students.groupBy { def student -&gt; return student.value.score &gt;= 60 ? &apos;及格&apos; : &apos;不及格&apos; } println group.toMapString() //排序 def sort = students.sort{ def stu1 ,def stu2-&gt; Number num1 = stu1.value.score Number num2 = stu2.value.score return num1 == num2 ? 0 : num1 &lt; num2 ? -1 : 1 } println sort.toMapString() 2.5、范围range定义和使用 def range = 1..10 println range[0] //1 println range.contains(10) //true println range.from //1 println range.to //10 //遍历 range.each { println it } //switch中使用 def result = getGrade(75) println result def getGrade(Number number){ def result switch (number){ case 0..&lt;60: result = &apos;不及格&apos; break case 60..&lt;70: result = &apos;及格&apos; break case 70..&lt;80: result = &apos;良好&apos; break case 80..100: result = &apos;优秀&apos; break } return result } 2.6、面向对象类、方法、接口 //groovy中默认都是public类型 class Person implements Action{ String name Integer age def increasseAge(Integer years) { this.age += years } @Override void eat() {} @Override void drink() {} @Override void play() {} } def person = new Person(name: &quot;zhang&quot;, age: 26) println &quot;name:${person.name},age:${person.age}&quot;//name:zhang,age:26 person.increasseAge(10) println &quot;name:${person.name},age:${person.age}&quot;//name:zhang,age:36 interface Action{ void eat() void drink() void play() } trait DefaultAction{ abstract void eat() void play(){ println &apos;i can play&apos; } } 元编程 class Person { String name Integer age def increasseAge(Integer years) { this.age += years } //一个方法找不到时候，用它代替 def invokeMethod(String name, Object args) { return &quot;invokeMethod: ${name},${args}&quot; } //优先级高于invokeMethod def methodMissing(String name, Object args) { return &quot;methodMissing: ${name},${args}&quot; } } def person = new Person(name: &apos;zhang&apos;, age: 26) println person.cry() //为类动态添加属性 Person.metaClass.sex = &apos;male&apos; def person1 = new Person(name: &apos;zhang&apos;, age: 26) println person1.sex //male //为类动态添加方法 Person.metaClass.sexUpperCase = { -&gt; sex.toUpperCase() } def personn2 = new Person(name: &apos;zhang&apos;, age: 26) println personn2.sexUpperCase() //MALE //添加静态方法 Person.metaClass.static.createPerson = { String name, int age -&gt; new Person(name: name, age: age) } def personn3 = Person.createPerson(&apos;li&apos;, 18) println personn3.name + personn3.age //li18 一次注入，应用程序其他方法都可以使用 ExpandoMetaClass.enableGlobally() 3、高级用法3.1、json文件处理转换成json import groovy.json.JsonOutput import groovy.json.JsonSlurper class Person { String name Integer age } //转换成Json def list = [new Person(name: &apos;zhang&apos;, age: 26), new Person(name: &apos;li&apos;, age: 22)] def json = JsonOutput.toJson(list) println JsonOutput.prettyPrint(json) //转成实体对象 def jsonSlpuer = new JsonSlurper() jsonSlpuer.parseText() get请求 import groovy.json.JsonSlurper def response = getNetworkData(&quot;http://httpbin.org/get?id=123&quot;) println response.args.id def getNetworkData(String url){ def connection = new URL(url).openConnection() connection.setRequestMethod(&apos;GET&apos;) connection.connect() def response = connection.content.text def jsonSlurper = new JsonSlurper() return jsonSlurper.parseText(response) } 3.2、xml读取和生成解析xml格式数据，创建xml格式数据，都不再详解 3.3、文件操作读取文件 def file = new File(&quot;目标文件&quot;) //方式一 file.eachLine { line -&gt; println line } //方式二 def text = file.getText() println text //方式三 def result = file.readLines() println result //方式四,读取部分内容 def reader = file.withReader { reader -&gt; char[] buffer = new char[100] reader.read(buffer) return buffer } println reader 拷贝文件 def copy(String sourcePath, String destationPath) { try { def desFile = new File(destationPath) if (!desFile.exists()) { desFile.createNewFile() } new File(sourcePath).withReader { reader -&gt; def lines = reader.readLines() desFile.withWriter { writer -&gt; lines.each { line -&gt; writer.append(line + &quot;\\r\\n&quot;) } } } return true } catch (Exception e) { } } 对象的读写 def saveObject(Object object, String path) { try { def desFile = new File(path) if (!desFile.exists()) { desFile.createNewFile() } desFile.withObjectOutputStream { out -&gt; out.writeObject(object) } return true } catch (Exception e) { } return false } def readObject(String path) { def obj = null try { def file = new File(path) if (file == null || !file.exists()) return null file.withObjectInputStream { input -&gt; obj = input.readObject() } } catch (Exception e) { } return obj } 4、Gradle介绍Gradle用于构建应用程序，使用Groovy核心语法。 在Terminal中执行 gradlew clean //win gradlew build //win ./gradlew clean //mac ./gradlew build //mac gradle的生命周期 initialization初始化阶段：根据settings.gradle解析整个工程中所有的Project，构建所有的Project对应的project对象。 Configuration配置阶段：解析所有的projects对象中的task，构建好所有的task的拓扑图 Excution执行阶段：执行具体的task及其依赖task 生命周期监听 //配置阶段开始前的监听回调 this.beforeEvaluate { println &apos;------配置阶段开始------&apos; } //配置阶段完成以后的监听回调 this.afterEvaluate { println &apos;------配置阶段完成------&apos; } //gradle执行完毕后的回调监听 this.gradle.buildFinished { println &apos;------gradle执行完毕------&apos; } //等同beforeEvaluate this.gradle.beforeProject {} //等同afterEvaluate this.gradle.afterProject {} 5、Project查看Project的个数 gradlew projects ./gradlew projects //mac 5.1、Project相关API在最外层的根的build.gradle中 this.getProjects() def getProjects(){ //只输全部projects this.getAllprojects().eachWithIndex { Project project, int index -&gt; if (index ==0){ println &quot;this is Root project:${project.name}&quot; } else { println &quot;this is project:${project.name}&quot; } } //只输出子projects this.getSubprojects().eachWithIndex { Project project, int index -&gt; println &quot;this is project:${project.name}&quot; } //只输出根projects println &quot;this is Root project:&quot; + this.getRootProject().name } 在module的build.gradle中 //只输出父projects println &quot;this is parent project:&quot; + this.getParent().name 根project中可以配置module的配置 //根project配置module为app的配置 project(&apos;app&apos;) { Project project -&gt; println project.name //app apply plugin: &apos;com.android.application&apos; group &apos;com.tea&apos; version &apos;1.0.0-release&apos; dependencies {} android {} } 配置当前节点工程和subproject的所有project //配置当前节点工程和subproject的所有project allprojects { group &apos;com.tea&apos; version &apos;1.0.0-release&apos; } println project(&apos;app&apos;).group 不包括当前节点工程，只包括他的subproject //不包括当前节点工程，只包括他的subproject subprojects { Project project -&gt; if (project.plugins.hasPlugin(&apos;com.android.library&apos;)) { apply from: &apos;../publistTOMaven.gradle&apos; } } 5.2、属性相关API定义扩展属性 ext{} 所以提供扩展属性定义方式: 方式一： 可以在根build中定义 ext { compileSdkVersion = 28 cardview = &apos;com.android.support:cardview-v7:28.0.0&apos; } 然后在需要用的build中引用 compileSdkVersion this.rootProject.compileSdkVersion implementation this.cardview 方式二： 和根build同级定义common.gradle ext { android = [compileSdkVersion: 28, buildToolsVersion: &apos;26.0.0&apos;, applicationId : &apos;com.tea&apos;, minSdkVersion : 16, targetSdkVersion : 26, versionCode : 1, versionName : &apos;1.0.0&apos;, multiDexEnabled : true] signConfigs = [&apos;storeFile&apos; : &apos;tea.jks&apos;, &apos;storePassword&apos;: &apos;tea123456&apos;, &apos;keyAlias&apos; : &apos;android&apos;, &apos;keyPassword&apos; : &apos;tea123456&apos;] java = [&apos;javaVersion&apos;: JavaVersion.VERSION_1_8] dependence = [&apos;libCardview&apos; : &apos;com.android.support:cardview-v7:28.0.0&apos;, &apos;libAppcompat&apos;: &apos;com.android.support:appcompat-v7:28.0.0&apos;] } 在根build中引入 apply from: this.file(&apos;common.gradle&apos;) 在需要的build中使用 compileSdkVersion rootProject.ext.android.compileSdkVersion implementation rootProject.ext.dependence.libCardview 方式三： 在gradle.properties中定义key:value形式 mCompileSdkVersion = 28 build中使用，默认都是字符串，需要转换 compileSdkVersion mCompileSdkVersion.toInteger() 5.3、file相关API文件路径获取 println getRootDir().absolutePath println getBuildDir().absolutePath println getProjectDir().absolutePath 文件定位 apply from: this.file(&apos;common.gradle&apos;) println getContent(&apos;common.gradle&apos;) def getContent(String path){ try { //路径是相对于当前project查找 def file = file(path) return file.text }catch (GradleException e){ println &quot;not found&quot; } return null } 文件拷贝,在app的build中拷贝文件或者文件夹 copy { from file(&apos;build/outputs/apk/&apos;) into getRootProject().getBuildDir().path + &apos;/apk/&apos; exclude {}//补拷贝的文件 rename {}//重命名 } 文件树 fileTree(&apos;src/main/assets/&apos;){FileTree fileTree -&gt; fileTree.visit {FileTreeElement element -&gt; println element.file.name copy { from element.file into getRootProject().getBuildDir().path + &apos;/test/&apos; } } } 5.4、依赖相关API依赖 buildscript { //配置工程的仓库地址 repositories { } //配置工程的gradle插件依赖地址，app中的是项目的第三库依赖 dependencies { } } 依赖冲突常用解决办法 compile (&apos;rootProject.ext.dependence.libAutoScrollViewPager&apos;) { exclude module: &apos;support-v4&apos;//排除依赖 exclude group: &apos;com.android.support&apos; transitive false//禁止传递依赖 } provided只在编译起作用，占位编译。 5.5、外部命令API调用系统指令，执行./gradlew apkcopy task(name: &apos;apkcopy&apos;) { doLast { def srcPath = this.buildDir.path + &apos;/outputs/apk&apos; def destPath = &apos;./target/apk&apos; def command = &quot;mv -f ${srcPath} ${destPath}&quot; exec { try { executable &apos;bash&apos; args &apos;-c&apos;, command println &apos;this command exec success&apos; }catch(GradleException e){ println &apos;this command exec error&apos; } } } } 调用脚本 task stopTomcat(type:Exec) { //dir workingDir &apos;../tomcat/bin&apos; //windows commandLine &apos;cmd&apos;, &apos;/c&apos;, &apos;stop.bat&apos; //linux commandLine &apos;./stop.sh&apos; } 6、task两种定义方式task helloTask (group: &apos;com.tea&apos;,description: &apos;study&apos;){ println &apos;---------helloTask&apos; } this.tasks.create(name : &apos;helloTask2&apos;){ setGroup(&apos;com.tea&apos;) setDescription(&apos;study&apos;) println &apos;---------helloTask2&apos; } doFirst和doLasttask helloTask (group: &apos;com.tea&apos;,description: &apos;study&apos;){ println &apos;---------helloTask&apos; doFirst { println &apos;---------helloTask---doFirst&apos; } } helloTask.doFirst{ println &apos;---------helloTask---doFirst2&apos;//比闭包的先执行 } 统计Build时长def startTime,endTime this.afterEvaluate {Project project -&gt; def preBuildTask = project.tasks.getByName(&apos;preBuild&apos;) preBuildTask.doFirst { startTime = System.currentTimeMillis() println &quot;==============:&quot; + startTime } def buildTask = project.tasks.getByName(&apos;build&apos;) buildTask.doLast { endTime = System.currentTimeMillis() println &quot;==============:&quot; + endTime println &quot;==============:&quot; + (endTime - startTime) } } 依赖task taskX { doLast { println &quot;taskX&quot; } } task taskY { doLast { println &quot;taskY&quot; } } //动态依赖 task taskZ { dependsOn this.tasks.findAll { task -&gt; println task.name return task.name.startsWith(&apos;taskX&apos;) } doLast { println &quot;taskZ&quot; } } //静态依赖 task taskZ(dependsOn: [taskX, taskY]) { dependsOn this.tasks.findAll { task -&gt; return task.name.startsWith(&apos;lib&apos;) } doLast { println &quot;taskZ&quot; } } //或者 taskZ.dependsOn(taskX, taskY) 输入输出task writeTask{ //输入 inputs.property(&quot;key&quot;,&quot;value&quot;) def data = inputs.getProperties() //输出 outputs.file 文件 File file = outputs.getFiles().getSingleFile() } 执行顺序指定mustRunAfter 7、其他模块7.1、SourceSet修改资源路径 sourceSets { main{ jniLibs.srcDirs = [&apos;libs&apos;]//修改so库文件位置 } } 给res分模块分包 sourceSets { main{ res.srcDirs = [&apos;src/main/res&apos;, &apos;src/main/res-ad&apos;, &apos;src/main/res-tea&apos;] } } 7.2、自定义plugin main下的java替换成groovy，新建.groovy类： class GradleStudyPlugin implements Plugin&lt;Project&gt;{ @Override void apply (Project project){ project.extensions.create(&apos;comTea&apos;,xxx（groovy类）) } } 自定义task的类 class xxxxx extend DefaultTask{ @TaskAction void doAction(){ //执行于gradle执行阶段的代码 } } main/resources/META-INF.gradle/包名.properties: implementation-class=包名.类名 build.gradle为： apply plugin: &apos;groovy&apos; sourceSets { main{ groovy { srcDir &apos;src/main/groovy&apos; } resources { srcDir &apos;src/main/resources&apos; } } } 引用和传参 apply plugin: &apos;包名&apos; comTea{ //传参 } 7.3、修改apk名字app的build中 this.afterEvaluate { this.android.applicationVariants.all { variant -&gt; def output = variant.outputs.first() def apkName = &quot;app-${variant.baseName}&quot; + &quot;-${variant.versionName}.apk&quot; output.outputFile = new File(output.outputFile.parent,apkName) println &quot;------------------&quot; } } 8、Jenkinsjava -jar jenkins.war Android实战应用buildTypes和productFlavors 和main同级别，同包名，创建文件，区别使用debug还是release。可以用来实现类似gradle调用java类。 implementation implementation：不会传递依赖；compile / api：会传递依赖；api 是 compile 的替代品。当依赖被传递时，二级依赖的改动会导致0级项目重新编译；当依赖不传递时，二级依赖的改动不会导致 0 级项目重新编译。 plugin android{}的内容就是对apply plugin: &#39;com.android.application&#39;的配置。 参考上述7.2、自定义plugin。 新建Module-Java Library-buildSrc模块 创建目录\\buildSrc\\src\\main\\resources\\META-INF\\gradle-plugins，创建文件xxx.properties implementation-class=com.plugin.demo.PluginDemo 目录buildSrc\\src\\main\\groovy\\com\\plugin\\demo创建文件PluginDemo.groovy import com.android.build.gradle.BaseExtension import org.gradle.api.Plugin import org.gradle.api.Project public class PluginDemo implements Plugin&lt;Project&gt; { @Override public void apply(Project project) { def extension = project.extensions.create(&apos;yyyy&apos;, ExtensionDemo) project.afterEvaluate { println &quot;Hello ${extension.name}!&quot;//Hello zzzzz } //def transform = new TransformDemo() //def baseExtension = project.extensions.getByType(BaseExtension) //baseExtension.registerTransform(transform) } } 创建文件ExtensionDemo.groovy public class ExtensionDemo { def name = &quot;Author&quot;; } 在app的build中使用plugin apply plugin: &apos;xxx&apos; yyyy { name &apos;zzzzz&apos; } 关于 buildSrc 目录：这是 gradle 的一个特殊目录，这个目录的 build.gradle 会自动被执行，即使不配配置进settings.gradle。buildSrc 的执行早于任何一个 project，也早于 settings.gradle。它是一个独立的存在。 buildSrc 所配置出来的 Plugin 会被自动添加到编译过程中的每一个 project 的 classpath，因此它们才可以直接使用 apply plugin: &#39;xxx&#39;的方式来便捷应用这些 plugin。 settings.gradle 中如果配置了 ‘:buildSrc’ ，buildSrc 目录就会被当做是子 Project ，因此会被执行两遍。所以在 settings.gradle 里面应该删掉 :buildSrc 的配置。 Transform Transform是由 Android 提供的，在项目构建过程中把编译后的文件（jar文件和 class文件）添加自定义的中间处理过程的工具。下面代码只是把编译完的内容原封不动搬运到目标位置，没有实际用处。要修改字节码，需要引入其他工具，例如 javassist。 新建TransformDemo.groovy import com.android.build.api.transform.Format import com.android.build.api.transform.QualifiedContent import com.android.build.api.transform.Transform import com.android.build.api.transform.TransformException import com.android.build.api.transform.TransformInvocation import com.android.build.gradle.internal.pipeline.TransformManager import com.android.utils.FileUtils; public class TransformDemo extends Transform { @Override String getName() { return &quot;hencoderTransform&quot; } @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() { return TransformManager.CONTENT_CLASS } @Override Set&lt;? super QualifiedContent.Scope&gt; getScopes() { return TransformManager.SCOPE_FULL_PROJECT } @Override boolean isIncremental() { return false } @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException { def inputs = transformInvocation.inputs def outputProvider = transformInvocation.outputProvider inputs.each { it.jarInputs.each { File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.JAR) FileUtils.copyFile(it.file, dest) } it.directoryInputs.each { File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.DIRECTORY) FileUtils.copyDirectory(it.file, dest) } } } } buildSrc-build中改为： repositories { google() jcenter() } dependencies { implementation &apos;com.android.tools.build:gradle:3.2.1&apos; } PluginDemo.groovy中添加代码 def transform = new TransformDemo() def baseExtension = project.extensions.getByType(BaseExtension) baseExtension.registerTransform(transform) 修改app-build中的plugin放在android{}之后。 示例：https://github.com/liangzhitao/consuming-collector","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/tags/gradle/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"手写实现EventBus","slug":"28.手写实现EventBus","date":"2019-07-07T07:07:51.613Z","updated":"2019-07-08T13:45:25.976Z","comments":false,"path":"2019/07/07/28.手写实现EventBus/","link":"","permalink":"http://yoursite.com/2019/07/07/28.手写实现EventBus/","excerpt":"","text":"使用github地址： https://github.com/greenrobot/EventBus 引入 implementation &apos;org.greenrobot:eventbus:3.0.0&apos; 订阅和接收 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this); } @Override protected void onDestroy() { super.onDestroy(); EventBus.getDefault().unregister(this); } @Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true) public void onStringEvent(String event) { Log.d(&quot;接收者&quot;, &quot;event----:&quot; + event); } 发布事件 EventBus.getDefault().post(&quot;我来发布消息&quot;); 发布粘性事件 EventBus.getDefault().postSticky(&quot;我来发布消息&quot;); ThreadMode总共四个枚举项： MAIN //UI主线程 BACKGROUND //后台线程 POSTING //和发布者处在同一个线程 ASYNC //异步线程 终止事件往下传递： //优先级高的订阅者可以终止事件往下传递 EventBus.getDefault().cancelEventDelivery(event); 混淆 -keepattributes *Annotation* -keepclassmembers class * { @org.greenrobot.eventbus.Subscribe &lt;methods&gt;; } -keep enum org.greenrobot.eventbus.ThreadMode { *; } -keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent { &lt;init&gt;(java.lang.Throwable); } 源码分析第一步register第一步：EventBus.getDefault().register(this);其中getDefault()获取单例，看EventBus中register()方法： public void register(Object subscriber) { //首先获得class对象 Class&lt;?&gt; subscriberClass = subscriber.getClass(); //通过findSubscriberMethods来找到订阅者订阅了哪些事件，返回一个SubscriberMethod对象的List。 //SubscriberMethod里包含了：这个对象的方法method、响应订阅的线程ThreadMode、方法参数类型eventType、订阅的优先级 priority、是否接收粘性sticky的boolean值。 //其实就是解析这个类上的所有带@Subscriber注解的方法的属性。 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) { for (SubscriberMethod subscriberMethod : subscriberMethods) { // 订阅，第二步分析 subscribe(subscriber, subscriberMethod); } } } 看SubscriberMethodFinder类中findSubscriberMethods(Class&lt;?&gt; subscriberClass)方法： List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) { // 先从缓存里面读取，订阅者的Class List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) { return subscriberMethods; } // ignoreGeneratedIndex属性表示是否忽略注解器生成的MyEventBusIndex。 // 支持编译时注解的方式，需要引入eventbus的apt，ignoreGeneratedIndex的默认值为false，可以通过EventBusBuilder来设置它的值 if (ignoreGeneratedIndex) { // 利用反射来获取订阅类中所有订阅方法信息 subscriberMethods = findUsingReflection(subscriberClass); } else { // 从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息 subscriberMethods = findUsingInfo(subscriberClass); } if (subscriberMethods.isEmpty()) { throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); } else { METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; } } 会走到SubscriberMethodFinder类中findUsingInfo(Class&lt;?&gt; subscriberClass)方法： private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) { // FindState涉及到享元设计模式 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) { //默认是空，除非用了编译时注解 findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) { SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) { if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) { findState.subscriberMethods.add(subscriberMethod); } } } else { //走到这里，通过反射去找 findUsingReflectionInSingleClass(findState); } findState.moveToSuperclass(); } // 释放 findState 享元模式 return getMethodsAndRelease(findState); } 走到SubscriberMethodFinder类中findUsingReflectionInSingleClass(FindState findState)方法： //找方法的核心代码 private void findUsingReflectionInSingleClass(FindState findState) { Method[] methods; try { // 通过反射来获取订阅类的所有方法 methods = findState.clazz.getDeclaredMethods(); } catch (Throwable th) { methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; } //for循环所有方法 for (Method method : methods) { // 获取方法访问修饰符 int modifiers = method.getModifiers(); //找到所有声明为public的方法 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) { //获取参数的的Class Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //只允许包含一个参数 if (parameterTypes.length == 1) { //Subscribe注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) { //获取事件的Class ，也就是方法参数的Class Class&lt;?&gt; eventType = parameterTypes[0]; // 检测添加 if (findState.checkAdd(method, eventType)) { //获取ThreadMode ThreadMode threadMode = subscribeAnnotation.threadMode(); // 往集合里面添加 SubscriberMethod ，解析方法注解所有的属性 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); } } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); } } } 第一步总结：register()方法中调用findSubscriberMethods()，去解析注册者对象的所有方法，找出public方法，并且带有@Subscribe注解、并且参数只有一个，的方法，然后通过Annotation解析所有细节参数threadMode(线程)、priority(优先级)、sticky(是否粘性)、method(方法名)、eventType(方法参数类型)，把这些参数封装成一个SubscriberMethod对象，添加到集合返回。 第二步registerEventBus中register()方法调用了subscribe(subscriber, subscriberMethod);其中subscriber就是register(this)中的this，subscriberMethod就是第一步中的集合遍历的元素对象。 EventBus中subscribe(Object subscriber, SubscriberMethod subscriberMethod)方法: private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) { // 获取方法参数的class Class&lt;?&gt; eventType = subscriberMethod.eventType; // 创建一个 Subscription，subscribe方法的参数传给了Subscription Subscription newSubscription = new Subscription(subscriber, subscriberMethod); // 获取订阅了此事件类的所有订阅者信息列表,下面有分析subscriptionsByEventType CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) { // 线程安全的 ArrayList subscriptions = new CopyOnWriteArrayList&lt;&gt;(); // 添加 subscriptionsByEventType.put(eventType, subscriptions); } else { // 是否包含，如果包含再次添加抛异常 if (subscriptions.contains(newSubscription)) { throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); } } // 处理优先级priority int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) { if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) { subscriptions.add(i, newSubscription); break; } } // 通过 subscriber 获取 List&lt;Class&lt;?&gt;&gt;，下面有分析typesBySubscriber List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) { subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); } // 将此事件类加入 订阅者事件类列表中 subscribedEvents.add(eventType); // 处理粘性事件 if (subscriberMethod.sticky) { if (eventInheritance) { Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) { Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) { Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } else { Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } 查看subscriptionsByEventType，是EventBus的一个Map成员变量，可以根据EventType查找订阅事件 // key 是注解方法参数的class(eventType)，value 存放的是Subscription的线程安全的集合列表 //Subscription 包含两个属性，一个是subscriber 订阅者（this），一个是SubscriberMethod注解方法的所有属性参数值（SubscriberMethod） private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; 查看typesBySubscriber，是EventBus的一个Map成员变量，根据我们的订阅对象找到EventType。 // key 是所有的订阅者(this)，value 是所有订阅者里面方法的参数的class的集合 private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; 粘性事件stickyEvents:是ConcurrentHashMap集合,粘性事件的缓存。 第二步总结：register()方法中调用subscribe方法，解析所有SubscriberMethod的eventType，然后按照要求解析成Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType和Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber。 第三步post查看EventBus中post方法： public void post(Object event) { // currentPostingThreadState是一个 ThreadLocal，他的特点是获取当前线程一份独有的变量数据，不受其他线程影响。 PostingThreadState postingState = currentPostingThreadState.get(); // postingState 就是获取到的线程独有的变量数据 List&lt;Object&gt; eventQueue = postingState.eventQueue; // 把post的事件添加到事件队列 eventQueue.add(event); // 如果没有处在事件发布状态，那么开始发送事件并一直保持发布状态 if (!postingState.isPosting) { //是否是主线程 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); //isPosting = true postingState.isPosting = true; if (postingState.canceled) { throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); } try { while (!eventQueue.isEmpty()) { //走到这里，下面有分析 postSingleEvent(eventQueue.remove(0), postingState); } } finally { postingState.isPosting = false; postingState.isMainThread = false; } } } private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() { @Override protected PostingThreadState initialValue() { return new PostingThreadState(); } }; 查看EventBus中postSingleEvent方法： //参数event是post的对象 private void postSingleEvent(Object event, PostingThreadState postingState) throws Error { //得到事件的Class Class&lt;?&gt; eventClass = event.getClass(); //是否找到订阅者 boolean subscriptionFound = false; //如果支持事件继承，默认为支持 if (eventInheritance) { //查找 eventClass 的所有父类和接口 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) { Class&lt;?&gt; clazz = eventTypes.get(h); // 依次向 eventClass 的父类或接口的订阅方法发送事件 // 只要有一个事件发送成功，返回 true ，那么 subscriptionFound 就为 true，下面有分析 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); } } else { // 发送事件 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); } // 如果没有订阅者 if (!subscriptionFound) { if (logNoSubscriberMessages) { Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); } if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) { post(new NoSubscriberEvent(this, event)); } } } 查看EventBus中postSingleEventForEventType方法： //event是post的对象，eventClass是post的对象的class private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) { CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) { // subscriptionsByEventType是第二步中的map，得到Subscription集合List subscriptions = subscriptionsByEventType.get(eventClass); } if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) { // 遍历subscriptions for (Subscription subscription : subscriptions) { postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try { // 发送事件，下面分析 postToSubscription(subscription, event, postingState.isMainThread); // 是否被取消了 aborted = postingState.canceled; } finally { postingState.event = null; postingState.subscription = null; postingState.canceled = false; } // 如果被取消，则跳出循环 if (aborted) { break; } } return true; } return false; } 查看EventBus中postToSubscription方法： private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) { // 根据不同的线程模式执行对应 switch (subscription.subscriberMethod.threadMode) { // 和发送事件处于同一个线程 case POSTING: invokeSubscriber(subscription, event); break; // 主线程 case MAIN: if (isMainThread) { invokeSubscriber(subscription, event); } else { mainThreadPoster.enqueue(subscription, event); } break; // 子线程，如果发布事件的线程是主线程，那么调用线程池中的子线程来执行订阅方法；否则直接执行； case BACKGROUND: if (isMainThread) { backgroundPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; // 异步线程：无论发布事件执行在主线程还是子线程，都利用一个异步线程来执行订阅方法 case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); } } 第三步总结：post()方法中去遍历了subscriptionsByEventType，找到符合的方法,调用方法的method.invoke()执行。 第四步unregisterunregister就是移除。查看EventBus中unregister方法： public synchronized void unregister(Object subscriber) { // 获取订阅对象的所有订阅事件类列表,第二步中的map List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) { for (Class&lt;?&gt; eventType : subscribedTypes) { // 将订阅者的订阅信息移除，下面分析 unsubscribeByEventType(subscriber, eventType); } // 将订阅者从列表中移除 typesBySubscriber.remove(subscriber); } else { Log.w(TAG, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); } } 查看EventBus中unsubscribeByEventType方法： private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) { // 获取事件类的所有订阅信息列表，将订阅信息从订阅信息集合中移除，同时将订阅信息中的active属性置为FALSE,第二步中的map List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) { int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) { Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) { // 将订阅信息激活状态置为FALSE subscription.active = false; // 将订阅信息从集合中移除 subscriptions.remove(i); i--; size--; } } } } 手写实现https://github.com/AdamRight/TeaTool/blob/master/app/src/main/java/com/tea/teatool/teaeventbus","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RecyclerView","slug":"27.RecyclerView","date":"2019-07-01T14:22:32.257Z","updated":"2019-11-24T14:23:50.649Z","comments":false,"path":"2019/07/01/27.RecyclerView/","link":"","permalink":"http://yoursite.com/2019/07/01/27.RecyclerView/","excerpt":"","text":"1、基本使用和封装布局、点击、分割线、多类型条目使用。 1.1、基本使用点我跳转 1.2、基本封装点我跳转 1.3、多类型条目点我跳转 1.4、添加头部和底部点我跳转 2、分割线2.1、条目相关设置分割线类中的getItemOffsets方法中 //获取条目View在RecyclerView中的第几个位置：0、1、2、3... int currentPosition = ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewLayoutPosition(); //获取条目的总个数 int itemCount = parent.getAdapter().getItemCount(); //GridLayoutManager时候，获取列数 RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) { GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; int spanCount = gridLayoutManager.getSpanCount(); } 其他实例化View的3种方式View.inflate(mContext, mLayoutId, null); LayoutInflater.from(mContext).inflate(mLayoutId, parent); LayoutInflater.from(mContext).inflate(mLayoutId, parent, false);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"手写实现Butterknife","slug":"26.手写实现Butterknife","date":"2019-06-29T04:21:42.594Z","updated":"2019-06-30T09:00:08.561Z","comments":false,"path":"2019/06/29/26.手写实现Butterknife/","link":"","permalink":"http://yoursite.com/2019/06/29/26.手写实现Butterknife/","excerpt":"","text":"介绍Butterknife源码地址 https://github.com/JakeWharton/butterknife 引入 implementation &apos;com.jakewharton:butterknife:8.5.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.5.1&apos; 主要是解决掉findViewById、setOnclick 、资源的注入等。反射造成大量的临时文件，造成gc，影响性能。而Butterknife采用编译时注解，即用APT mirror生成代码。 ButterKnife的工作原理: 声明的注解的生命周期为CLASS。继承AbstractProcessor类，再调用AbstractProcessor的process方法。 编译的时候扫描注解，调用javapoet库，生成java代码。 调用ButterKnife.bind(this);方法的时候，将ID与对应的上下文绑定在一起。 思路发现编译后生成类名_ViewBinding，那么我们手动实现Butterknife，先写下伪代码： 新建类名_ViewBinding： public class ButterknifeActivity_ViewBinding { private ButterknifeActivity target; @UiThread public ButterknifeActivity_ViewBinding(ButterknifeActivity target) { this.target = target; target.textView = target.findViewById(R.id.tv); } @CallSuper public void unbind() { ButterknifeActivity target = this.target; if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;); this.target = null; target.textView = null; } } 在Activity中不需要再findViewById： public class ButterknifeActivity extends AppCompatActivity { public TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_butterknife); ButterknifeActivity_ViewBinding viewBinding = new ButterknifeActivity_ViewBinding(this); textView.setText(&quot;我是伪代码&quot;); } } 所以，我们的思路就是用APT实现伪代码，就实现了手写Butterknife。 实现前奏新建Module-Library Android Library:butterknife Java Library:butterknife-annotations(运行时的注解)和butterknife-compiler(编译，生成代码) 配置 app的build中引入 implementation project(&apos;:butterknife-annotations&apos;) implementation project(&apos;:butterknife&apos;) annotationProcessor project(&apos;:butterknife-compiler&apos;) butterknife-compiler中引入 implementation &apos;com.google.auto.service:auto-service:1.0-rc3&apos;//注解 implementation &apos;com.squareup:javapoet:1.8.0&apos;//生成代码文件 implementation project(&apos;:butterknife-annotations&apos;)//依赖butterknife-annotations 注解处理器是（Annotation Processor）是javac的一个工具，用来在编译时扫描和编译和处理注解（Annotation）。在编译时把标记了注解的类，变量等作为输入内容，经过注解处理器处理，生成想要生成的java代码。处理器都是继承于AbstractProcessor。 APT(Annotation Processing Tool)是一种处理注解的工具,它对源代码文件进行检测找出其中的Annotation，根据注解自动生成代码。 注解处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 @AutoService(Processor.class) public class ButterKnifeProcessor extends AbstractProcessor { @Override public synchronized void init(ProcessingEnvironment processingEnvironment) { //先进init } //用来指定支持的 SourceVersion @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } //用来指定支持的 AnnotationTypes @Override public Set&lt;String&gt; getSupportedAnnotationTypes() { Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) { types.add(annotation.getCanonicalName()); } return types; } //绑定哪些注解 private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() { Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindView.class); return annotations; } //编译时候执行,核心方法，有注解就都会进来这个方法，可以扫描，处理注解等，并且可以生成java代码。 @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) { return false; } } APT流程：编译开始 → 拿到元素(添加指定的注解元素) → 处理分解元素以及注解信息 → 通过JAVAPOET拼装生成Java文件 → 交给编译器。 AbstractProcessor中的init方法中的参数ProcessingEnvironment public interface ProcessingEnvironment { Map&lt;String, String&gt; getOptions(); Messager getMessager(); Filer getFiler(); Elements getElementUtils(); Types getTypeUtils(); SourceVersion getSourceVersion(); Locale getLocale(); } ProcessingEnvironment提供了一些工具类，Filer用于创建文件，Elements获取所有源文件元素，Types获取源代码类型信息。 反射唯一使用反射的地方： 不在class中写入 Class_ViewBinding viewBinding = new Class_ViewBinding(this); 而是通过 ButterKnife.bind(this)//中对Class_ViewBinding进行有参构造反射 实现生成的类在/build/generated/source/apt/base/包名/ClassName_ViewBinding类。 代码 https://github.com/AdamRight/TeaTool/tree/master/app/src/main/java/com/tea/teatool/teabutterknife https://github.com/AdamRight/TeaTool","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"handler源码分析及手写handler","slug":"24.handler源码分析及手写handler","date":"2019-06-11T13:20:32.691Z","updated":"2019-06-29T04:26:32.860Z","comments":false,"path":"2019/06/11/24.handler源码分析及手写handler/","link":"","permalink":"http://yoursite.com/2019/06/11/24.handler源码分析及手写handler/","excerpt":"","text":"小实例private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); System.out.println(msg.what); } }; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); setContentView(R.layout.activity_main); new Thread(new Runnable() { @Override public void run() { //进行耗时操作后 Message message = Message.obtain(); message.what = 1; mHandler.sendMessage(message); } }).start(); } 在子线程中，进行耗时操作，执行完操作后，发送消息，通知主线程更新UI。 子线程中创建handler如果在子线程中创建handler： new Thread(){ @Override public void run() { Handler handler = new Handler(); } }.start(); 代码运行报错： java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare() 可以修改为： new Thread(){ @Override public void run() { Looper.prepare(); Handler handler = new Handler(); Looper.loop(); } }.start(); 在主线程中不需要，究其原因，在ActivityThread的main()方法中： ... Looper.prepareMainLooper();//准备循环 ... Looper.loop();//循环 ... 其中prepareMainLooper()方法会调用prepare(false)方法。 源码流程分析分析源码的思路,就是小实例中,从子线程调用mHandler.sendMessage(message);到主线程更新数据执行handleMessage(Message msg)方法的流程。 第一步sendMessage到MessageQueue:Handler.sendMessage → Handler.sendMessageDelayed → Handler.sendMessageAtTime → MessageQueue.enqueueMessage。 Handler中sendMessageAtTime()方法 public boolean sendMessageAtTime(Message msg, long uptimeMillis) { //其中mQueue是消息队列，从Looper中获取的 MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } //调用enqueueMessage方法 return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { //注意此处的msg.target就是当前的Handler，Looper中的loop会使用。 msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } //调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); } 可以看到sendMessageAtTime()方法的作用很简单，就是调用MessageQueue的enqueueMessage()方法，往消息队列中添加一个消息。 知识扩展：在子线程中通过Handler的post()方式或send()方式发送消息，最终都是调用了sendMessageAtTime()方法。子线程中调用Activity中的runOnUiThread()中更新UI，其实也是发送消息通知主线程更新UI，最终也会调用sendMessageAtTime()方法。 MessageQueue中enqueueMessage()方法 boolean enqueueMessage(Message msg, long when) { // 每一个Message必须有一个target if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { //正在退出时，回收msg，加入到消息池 if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的（即第一个msg）,则进入该该分支. msg.next = p; mMessages = msg; needWake = mBlocked; } else { //将消息按时间顺序插入到MessageQueue。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } if (needWake) { nativeWake(mPtr); } } return true; } MessageQueue是按照Message触发时间(when)的先后顺序排列的，队头的消息是最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。MessageQueue消息队列采用链表存储Message,因为链表是增加删除快，数组是查询快 第一步总结：Handler.sendMessage是把Message加入了消息队列(MessageQueue)中，消息队列采用的是链表存储方式，按照when也就是时间排序。 第二步我们知道主线程中，已经创建了Looper，在Loop方法中消息循环调用了Handler.handleMessage。 初始化Looper无参情况下，默认调用prepare(true);表示的是这个Looper可以退出，而对于false的情况则表示当前Looper不可以退出。 Looper中 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 调用sThreadLocal.set，在ThreadLocal中 public void set(T value) { Thread t = Thread.currentThread(); //从线程中获取ThreadLocalMap ，一个线程中只有一个ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } 一个线程中只有一个ThreadLocalMap，一个线程中只能创建一个Looper，ThreadLocalMap中把ThreadLocal为key，Looper为value，存储起来。其中ThreadLocal是线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。 开启Looperpublic static void loop() { //获取线程中TLS存储的Looper对象 final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } //获取Looper对象中的消息队列 final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //进入loop的主循环方法，死循环 for (;;) { Message msg = queue.next(); //可能会阻塞,因为next()方法可能会无限循环 if (msg == null) { //消息为空，则退出循环 // No message indicates that the message queue is quitting. return; } try { //重点地方,获取msg的目标Handler，然后通过handler去执行Message这个时候就调用了handleMessage方法 msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } // 回收消息 msg.recycleUnchecked(); } } loop()进入循环模式，直到消息为空时退出循环:读取MessageQueue的下一条Message；把Message分发给相应的target。 当next()取出下一条消息时，队列中已经没有消息时，next()会无限循环，产生阻塞。等待MessageQueue中加入消息，然后重新唤醒。 Handler创建创建Handler public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { //必须先执行Looper.prepare()，才能获取Looper对象，否则为null. mLooper = Looper.myLooper(); //从当前线程的TLS中获取Looper对象 if (mLooper == null) { throw new RuntimeException(&quot;&quot;); } mQueue = mLooper.mQueue; //消息队列，来自Looper对象 mCallback = callback; //回调方法 mAsynchronous = async; //设置消息是否为异步处理方式 } 对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行了Looper.prepare()方法，那么便可以获取有效的Looper对象。 Handler分发消息在Looper.loop()方法中，获取到下一条消息后，执行msg.target.dispatchMessage(msg)，来分发消息到目标Handler对象。 public void dispatchMessage(Message msg) { if (msg.callback != null) { //当Message存在回调方法，回调msg.callback.run()方法； handleCallback(msg); } else { if (mCallback != null) { //当Handler存在Callback成员变量时，回调方法handleMessage()； if (mCallback.handleMessage(msg)) { return; } } //Handler自身的回调方法handleMessage() handleMessage(msg); } } private static void handleCallback(Message message) { message.callback.run(); } public void handleMessage(Message msg) { } 第三步获取消息：当发送了消息后，在MessageQueue维护了消息队列，然后在Looper中通过loop()方法，不断地获取消息。上面对loop()方法进行了介绍，其中最重要的是调用了queue.next()方法,通过该方法来提取下一条信息。下面我们来看一下next()方法的具体流程。 MessageQueue中 Message next() { final long ptr = mPtr; if (ptr == 0) { //当消息循环已经退出，则直接返回 return null; } int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1 int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { //当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，为空则退出循环。 do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { //当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // 获取一条消息，并返回 mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; //设置消息的使用状态，即flags |= FLAG_IN_USE msg.markInUse(); return msg; //成功地获取MessageQueue中的下一条即将要执行的消息 } } else { //没有消息 nextPollTimeoutMillis = -1; } //消息正在退出，返回null if (mQuitting) { dispose(); return null; } ............................... } } nativePollOnce是阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。可以看出next()方法根据消息的触发时间，获取下一条需要执行的消息,队列中消息为空时，则会进行阻塞操作。 总结消息机制主要包含部分： Message：需要传递的消息，可以传递数据； MessageQueue：消息队列，但是它的内部实现并不是用的队列，实际上是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)； Handler：主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)； Looper：不断循环执行(Looper.loop)，从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。 在主线程中,默认已经调用了Looper.preper()方法,调用该方法的目的是在Looper中创建MessageQueue成员变量并把Looper对象绑定到当前线程中。当调用Handler的sendMessage()方法的时候就将Message对象添加到了Looper创建的MessageQueue队列中，同时给Message指定了target对象，其实这个target对象就是Handler对象。主线程默认执行了Looper.looper()方法,该方法从Looper的成员变量MessageQueue中取出Message，然后调用Message的target对象的handleMessage()方法。这样就完成了整个消息机制。 每个线程中只能存在一个Looper，Looper是保存在ThreadLocal中的。主线程（UI线程）已经创建了一个Looper，所以在主线程中不需要再创建Looper，但是在其他线程中需要创建Looper。每个线程中可以有多个Handler，即一个Looper可以处理来自多个Handler的消息。 Looper中维护一个MessageQueue，来维护消息队列。MessageQueue有一组待处理的Message,消息队列中的Message可以来自不同的Handler。 思考在Activity中使用Handler的时候如何去除警告信息将Handler类声明为static，同时在Handler类中使用弱引用去引用Context对象。 static class MyHandler extends Handler { private SoftReference&lt;Context&gt; srf; public MyHandler(Context context) { srf = new SoftReference&lt;Context&gt;(context); } @Override public void handleMessage(Message msg) { Toast.makeText(srf.get(), msg.toString(), Toast.LENGTH_SHORT).show(); } } Android中为什么主线程不会因为Looper.loop()里的死循环卡死主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。 真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。 ActivityThread实际上并非线程，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，该人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。 主线程的死循环一直运行是不是特别消耗CPU资源呢？其实不然，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施： 在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。 比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法。 手写handler实现实现代码github","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自定义View","slug":"22.自定义View","date":"2019-05-15T12:55:41.469Z","updated":"2019-07-28T14:31:17.902Z","comments":false,"path":"2019/05/15/22.自定义View/","link":"","permalink":"http://yoursite.com/2019/05/15/22.自定义View/","excerpt":"","text":"构造函数一个参数(Context context)的构造函数会在代码里面new的时候调用， 两个参数(Context context, AttributeSet attrs)的构造函数在布局layout中使用(调用)， 三个参数(Context context, AttributeSet attrs, int defStyleAttr)的构造函数在布局layout中使用(调用)，但是会有style。 public MyView(Context context) { this(context, null); } public MyView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public MyView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } xml布局通过LayoutInflate，解析的时候，实例化View是通过反射，显示加载到我们Activity。 measure布局的宽高都是由这个方法指定，需要测量，获取宽高的模式。 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取宽高的模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); //获取宽高的值 int widthSize = MeasureSpec.getSize(widthMeasureSpec);// 获取后面30位 int heightSize = MeasureSpec.getSize(heightMeasureSpec); } MeasureSpec：32位的二进制数字，前两位代表mode(测量模式)，后面30位才是他们的实际宽高的数值（size）。 三种模式： MeasureSpec.UNSPECIFIED：二进制00，默认值，父控件没有给子view任何限制，子View可以设置为任意大小。 MeasureSpec.EXACTLY：二进制01，表示父控件已经确切的指定了子View的大小。比如100dp、match_parent、fill_parent。 MeasureSpec.AT_MOST：二进制10，表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。wrap_content。 一般情况，wrap_content，即MeasureSpec.AT_MOST才需要重新计算。onMeasure方法最终调用setMeasuredDimension确定宽高值。 layoutdraw用于绘制 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); //canvas可以画文本、画弧、画圆等等 } ViewGroup不会触发onDraw方法解决办法： 方式一：把onDraw方法替换为dispatchDraw；方式二：设置透明的背景setBackgroundColor(Color.TRANSPARENT);;方式三：设置setWillNotDraw(false); 主要三个方法onDraw绘制自己；dispatchDraw绘制孩子；绘制背景 // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); Pathvoid moveTo (float x1, float y1):直线的开始点；即将直线路径的绘制点定在（x1,y1）的位置； void lineTo (float x2, float y2)：直线的结束点，又是下一次绘制直线路径的开始点；lineTo（）可以一直用； void close ():如果连续画了几条直线，但没有形成闭环，调用Close()会将路径首尾点连接起来，形成闭环； Paint相关属性setAntiAlias(true);//抗锯齿功能 setColor(Color.RED);//设置画笔颜色 //Style.FILL:填充内部;Style.FILL_AND_STROKE填充内部和描边;Style.STROKE仅描边 setStyle(Style.FILL);//设置填充样式 setStrokeWidth(30);//设置画笔宽度 //参数：radius:阴影的倾斜度;dx:水平位移;dy:垂直位移 setShadowLayer(float radius, float dx, float dy, int color)//添加阴影 //设置线冒样式，Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeCap(Paint.Cap cap) setAlpha(int a) //设置画笔透明度 reset() //重置画笔 和文字相关//相对位置 paint.setTextAlign(Paint.Align.LEFT);//Paint.Align.LEFT、Paint.Align.CENTER、Paint.Align.RIGHT setTextSize(float textSize) //设置文字大小 setFakeBoldText(boolean fakeBoldText) //设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) //设置带有删除线效果 setUnderlineText(boolean underlineText) //设置下划线 setTextSkewX(float skewX) //设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 draw图形画点//参数：float X：点的X坐标； float Y：点的Y坐标 drawPoint (float x, float y, Paint paint) 多个点//参数：pts:点的合集｛x1,y1,x2,y2,x3,y3,……｝; offset:集合中跳过的数值个数， //注意不是点的个数,一个点是两个数值; count:参与绘制的数值的个数。 drawPoints (float[] pts, Paint paint) drawPoints (float[] pts, int offset, int count, Paint paint) 画直线//参数：startX:开始点X坐标; startY:开始点Y坐标; stopX:结束点X坐标; stopY:结束点Y坐标 drawLine (float startX, float startY, float stopX, float stopY, Paint paint) 多条直线//参数：pts是点的集合，每两个点形成一条直线，pts的组织方式为｛x1,y1,x2,y2,x3,y3,……｝ drawLines (float[] pts, Paint paint) drawLines (float[] pts, int offset, int count, Paint paint) 矩形工具类RectF和Rect//根据四个点构造出一个矩形； RectF(float left, float top, float right, float bottom) Rect(int left, int top, int right, int bottom) 画矩形drawRect (float left, float top, float right, float bottom, Paint paint) drawRect (RectF rect, Paint paint) drawRect (Rect r, Paint paint) 画圆角矩形//参数：rx:生成圆角的椭圆的X轴半径； ry:生成圆角的椭圆的Y轴半径 drawRoundRect (RectF rect, float rx, float ry, Paint paint) 画圆形//参数：cx：圆心点X轴坐标 ; cy：圆心点Y轴坐标; radius：圆的半径 drawCircle (float cx, float cy, float radius, Paint paint) 画椭圆//椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，矩形的宽为椭圆的Y轴，建立的椭圆图形 drawOval (RectF oval, Paint paint) 画弧弧当然也是根据矩形来生成的 //参数：oval:生成椭圆的矩形; startAngle：弧开始的角度，X轴正方向为0度,顺时针为正; //sweepAngle：弧持续的角度,顺时针; useCenter:是否有弧的两边，True，有两边，False，只有一条弧。 drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 画三角if (mPath == null) { // 画路径 mPath = new Path(); mPath.moveTo(getWidth() / 2, 0); mPath.lineTo(0, (float) ((getWidth()/2)*Math.sqrt(3))); mPath.lineTo(getWidth(), (float) ((getWidth()/2)*Math.sqrt(3))); mPath.close();// 把路径闭合 } canvas.drawPath(mPath, mPaint); 画图片canvas.drawBitmap(bitmap, x, y, paint); drawText画文字//text:要绘制的文字; x：绘制原点x坐标; y：基线y坐标; paint:用来做画的画笔 drawText(String text, float x, float y, Paint paint) 从上往下依次为：top、ascent、baseLine、descent、bottom。 Paint paint = new Paint(); Paint.FontMetrics fm = paint.getFontMetrics(); Paint.FontMetricsInt fmInt = paint.getFontMetricsInt(); FontMetricsInt和FontMetrics完全相同，只是得到的值的类型不一样而已，FontMetricsInt中的四个成员变量的值都是Int类型，而FontMetrics得到的四个成员变量的值则都是float类型的。 获取基线 Paint.FontMetricsInt fontMetrics = paint.getFontMetricsInt(); int dy = (fontMetrics.bottom - fontMetrics.top) / 2 - fontMetrics.bottom; int baseLine = getHeight() / 2 + dy; 获取文字宽度 int width = paint.measureText(String text); onTouch处理跟用户交互，手指触摸，事件分发事件拦截等等。 @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: // 手指按下 break; case MotionEvent.ACTION_MOVE: // 手指移动 break; case MotionEvent.ACTION_UP: // 手指抬起 break; } return super.onTouchEvent(event); } 可以通过event.getX()获取相对于当前控件的位置,event.getRawX()获取距离屏幕的x位置。 自定义属性在res/values下面新建attrs.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;!--name 自定义View的名字MyView--&gt; &lt;declare-styleable name=&quot;MyView&quot;&gt; &lt;!-- name属性名称 format格式: string 文字、color 颜色、dimension 宽高 字体大小、 integer 数字、reference 资源（drawable）--&gt; &lt;attr name=&quot;myText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;myTextColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;myTextSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;myMaxLength&quot; format=&quot;integer&quot;/&gt; &lt;attr name=&quot;myBackground&quot; format=&quot;reference|color&quot;/&gt; &lt;!-- 枚举 --&gt; &lt;attr name=&quot;myInputType&quot;&gt; &lt;enum name=&quot;number&quot; value=&quot;1&quot;/&gt; &lt;enum name=&quot;text&quot; value=&quot;2&quot;/&gt; &lt;enum name=&quot;password&quot; value=&quot;3&quot;/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 在布局中使用，声明命名空间，然后在自己的自定义View中使用 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &lt;com.view.MyView app:myText=&quot;jt&quot; app:myTextColor=&quot;@color/colorAccent&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 在自定义View中获取属性 //获取自定义属性 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); mText = array.getString(R.styleable.MyView_myText); mTextColor = array.getColor(R.styleable.MyView_myTextColor, mTextColor); mTextSize = array.getDimensionPixelSize(R.styleable.MyView_myTextSize, mTextSize); //回收 array.recycle(); 系统有的自定义属性，我们是不能重新定义。 其他方法onFinishInflatesetContentView布局解析完毕之后会执行这个方法。而View的绘制流程是在Activity的onResume()之后才调用的。 requestDisallowInterceptTouchEvent改变的其实就是mGroupFlags的值 //事件分发 //dispatchTouchEvent-&gt;onInterceptTouchEvent-&gt;onTouchEvent @Override public boolean dispatchTouchEvent(MotionEvent ev) { //请求所有父控件及祖宗控件不要拦截事件 getParent().requestDisallowInterceptTouchEvent(true); return super.dispatchTouchEvent(ev); } canChildScrollUpSwipeRefreshLayout中方法，判断是否滚动到了最顶部。 public boolean canChildScrollUp() { if (mChildScrollUpCallback != null) { return mChildScrollUpCallback.canChildScrollUp(this, mTarget); } if (android.os.Build.VERSION.SDK_INT &lt; 14) { if (mTarget instanceof AbsListView) { final AbsListView absListView = (AbsListView) mTarget; return absListView.getChildCount() &gt; 0 &amp;&amp; (absListView.getFirstVisiblePosition() &gt; 0 || absListView.getChildAt(0) .getTop() &lt; absListView.getPaddingTop()); } else { return ViewCompat.canScrollVertically(mTarget, -1) || mTarget.getScrollY() &gt; 0; } } else { return ViewCompat.canScrollVertically(mTarget, -1); } } GestureDetector快速滑动，手势处理。 在ScrollView中嵌入ListView在ScrollView添加一个ListView会导致listview控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。 ListView,ScrollView在测量子布局的时候会用UNSPECIFIED,需要重写listview中的onMeasure。 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 解决显示不全的问题 heightMeasureSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE&gt;&gt; 2,MeasureSpec.AT_MOST); //heightMeasureSpec：32位的值，30位 是 Integer.MAX_VALUE，2位是MeasureSpec.AT_MOST super.onMeasure(widthMeasureSpec, heightMeasureSpec); } invalidate源码分析invlidate()一路向上，不断调用invalidateChild(this, damage)，调到最外层ViewRootImpl。最外层调用draw()、dispatchDraw(),一路往下画,最终画到当前调用invaldate的View的onDraw()方法。invlidate() 牵连着整个layout布局中的View。 ViewRootImpl中的重要方法 performTraversals()、performMeasure()、performLayout()、performDraw() 为什么不能在子线程中更新UIViewRootImpl中checkThread()方法用来检测线程。 if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } mThread在构造函数中初始化的主线程mainThread View的绘制流程setContentView创建DecorView，把我们的布局加载到了DecorView。 Activity的启动流程 performLaunchActivity -&gt; Activity.onCreate()handleResumeActivity() -&gt; performResumeActivity() -&gt; Activity的onResume()方法 -&gt; wm.addView(decor, l); 才开始把我们的 DecorView 加载到 WindowManager, -&gt; View的绘制流程在这个时候才开始 measure() layout() draw() addView wm.addView(decor, l); -&gt; WindowManangerImpl.addView()-&gt; root.setView(view, wparams, panelParentView); -&gt; requestLayout() -&gt; scheduleTraversals()-&gt; doTraversal() -&gt; performTraversals() onmeasure:测量是从外往里递归 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; onMeasure(widthMeasureSpec, heightMeasureSpec); 测量开始 -&gt; measureVertical(int widthMeasureSpec, int heightMeasureSpec)-&gt; measureChildWithMargins childWidthMeasureSpec,childHeightMeasureSpec测量模式是通过getChildMeasureSpec计算。调用setMeasuredDimension()这个时候我们布局才真正指定宽度和高度，mMeasuredWidth和mMeasuredHeight才开始有值。 layout:摆放子布局for循环所有子View, 前提不是GONE，调用child.layout() performLayout ：View -&gt; layout() -&gt; onLayout() draw performDraw() : View -&gt; draw() -&gt; drawBackground();//画背景 onDraw(canvas);// 画自己 ViewGroup 默认情况下不会调用 dispatchDraw(canvas);// 画子View 不断的循环调用子View的 draw() 流程小结： 第一步performMeasure()：用于指定和测量layout中所有控件的宽高，对于ViewGroup,先去测量里面的子孩子，根据子孩子的宽高再来计算和指定自己的宽高，对于View,它的宽高是由自己和父布局决定的。 第二步performLayout(): 用于摆放子布局,for循环所有子View,用child.layout()摆放ChildView。 第三步performDraw(): 用于绘制自己还有子View,对于ViewGroup首先绘制自己的背景,for循环绘制子View调用子View的draw()方法, 对于View绘制自己的背景，绘制自己显示的内容（TextView）。 细节: View的绘制流程是在onResume() 之后才开始，如果要获取View的高度，前提肯定需要调用测量方法，测量完毕之后才能获取宽高。 addView、setVisibility、等，会调用requestLayout()重新走一遍View的绘制流程。 View的Touch事件分发自定义view @Override public boolean onTouchEvent(MotionEvent event) { Log.e(&quot;TAG&quot;,&quot;onTouchEvent -&gt; &quot;+event.getAction()); return super.onTouchEvent(event); } 添加listener view.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { Log.e(&quot;TAG&quot;, &quot;onTouch -&gt; &quot; + event.getAction()); return false; } }); view.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.e(&quot;TAG&quot;, &quot;onClick&quot;); } }); 现象： OnTouchListener返回false时： OnTouchListener.DOWN -&gt; onTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; onTouchEvent.MOVE -&gt; OnTouchListener.UP-&gt; onTouchEvent.UP-&gt; OnClickListener OnTouchListener返回true时： OnTouchListener.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchListener.UP OnTouchListener没有，onTouchEvent返回true时： onTouchEvent.DOWN -&gt; onTouchEvent.MOVE -&gt; onTouchEvent.UP 自定义view中添加dispatchTouchEvent时候，如果不写super，就什么都不走了： @Override public boolean dispatchTouchEvent(MotionEvent event) { //super.dispatchTouchEvent(event); return true; } dispatchTouchEvent事件分发ListenerInfo li = mListenerInfo; ListenerInfo: 存放了关于View的所有Listener信息，如：OnTouchListener、OnClickListener。 boolean result = false; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED //是否是enable &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {//如果onTouch是false，result=false；如果是true，result=true result = true; } if (!result &amp;&amp; onTouchEvent(event)) {//如果result=false就会执行onTouchEvent，如果result=true就不会执行onTouchEvent result = true; } return result; 在View的onTouchEvent中的case MotionEvent.ACTION_UP:里面调用了performClick()添加了点击事件li.mOnClickListener.onClick(this)。 onTouchEvent方法ViewGroup的事件分发自定义View和上面view一样，自定义ViewGroup： @Override public boolean dispatchTouchEvent(MotionEvent ev) { Log.e(&quot;TAG&quot;, &quot;ViewGroup dispatchTouchEvent -&gt; &quot; + ev.getAction()); return super.dispatchTouchEvent(ev); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { Log.e(&quot;TAG&quot;, &quot;ViewGroup onInterceptTouchEvent -&gt; &quot; + ev.getAction()); return super.onInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { Log.e(&quot;TAG&quot;, &quot;ViewGroup onTouchEvent -&gt; &quot; + event.getAction()); return super.onTouchEvent(event); } 自定义ViewGroup包裹自定义View，点击View时候： DOWN -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; MOVE -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; Up -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; View.onclick 去掉自定义View的onClick： ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View onTouchEvent -&gt; ViewGroup.onTouchEvent 自定义View的onTouchEvent()方法里面返回true时： DOWN -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; MOVE -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; Up -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent 自定义ViewGroup的onInterceptTouchEvent()返回true时： ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; ViewGroup.onTouchEvent dispatchTouchEventonInterceptTouchEventonInterceptTouchEvent()默认情况下返回false。 onTouchEvent如果子View没有一个地方返回true,只会进来一次只会响应DOWN事件,代表不需要消费该事件,如果你想响应MOVE,UP必须找个地方ture。 对于ViewGroup,如果想拦截子View的Touch事件,可以覆写onInterceptTouchEvent返回true,执行该ViewGroup的onTouchEvent方法;如果子View没有消费Touch事件,也会调用该ViewGroup的onTouchEvent方法。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"线程和线程池","slug":"21.线程和线程池","date":"2019-05-13T14:17:03.835Z","updated":"2020-07-19T12:52:06.351Z","comments":false,"path":"2019/05/13/21.线程和线程池/","link":"","permalink":"http://yoursite.com/2019/05/13/21.线程和线程池/","excerpt":"","text":"创建线程两种方法： 继承Thread类 实现Runnable接口 共同点：都要用start()开启线程 创建子线程方式1： Thread thread = new Thread() { @Override public void run() { //super.run(); System.out.println(&quot;Thread started!&quot;); } }; thread.start(); start调用了native方法。 或者 class MyThread1 extends Thread{ @Override public void run() { super.run(); System.out.println(&quot;MyThread1:&quot;+Thread.currentThread().getName()); } } new MyThread1().start();//创建并启动线程 创建子线程方式2： Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;Thread with Runnable started!&quot;); } }; Thread thread = new Thread(runnable); thread.start(); 或者 class MyThread2 implements Runnable{ @Override public void run() { System.out.println(&quot;MyThread2:&quot;+Thread.currentThread().getName()); } } new Thread(new MyThread2()).start();//创建并启动线程 //或者 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;MyThread3:&quot;+Thread.currentThread().getName()); } }).start(); ThreadFactory ThreadFactory factory = new ThreadFactory() { AtomicInteger count = new AtomicInteger(0); @Override public Thread newThread(Runnable r) { return new Thread(r, &quot;Thread-&quot; + count.incrementAndGet()); } }; Runnable runnable = new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot; started!&quot;); } }; Thread thread = factory.newThread(runnable); thread.start(); Thread thread1 = factory.newThread(runnable); thread1.start(); Executors Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;Thread with Runnable started!&quot;); } }; Executor executor = Executors.newCachedThreadPool(); executor.execute(runnable); executor.execute(runnable); executor.execute(runnable); 除了newCachedThreadPool还有newSingleThreadExecutor单线程池、newFixedThreadPool指定固定线程数的线程池。 ExecutorService executor = Executors.newFixedThreadPool(20); for (Bitmap bitmap : bitmaps) { executor.execute(bitmapProcessor(bitmap)); } executor.shutdown(); synchronized synchronized 的本质:保证方法内部或代码块内部资源（数据）的互斥访问。即同一时间、由同一个Monitor监视的代码，最多只能有一个线程在访问。 synchronized定义在方法上，Monitor默认指定的是这个类；方法中使用synchronized(this),Monitor指定的也是这个类；如果想更换Monitor，就要把this换成其他对象。即多个线程，访问同一个类的多个方法，就要处理Monitor是不是同一个。 如果线程1正在访问count方法，那么线程2无法访问到minus方法，因为两个方法是同一个Monitor： private synchronized void count(int newValue) { x = newValue; y = newValue; } private void minus(int delta) { synchronized (this) { x -= delta; y -= delta; } } 如果线程1正在访问count方法，线程2可以访问到minus方法，因为两个方法不是同一个Monitor，是两个Monitor： private final Object monitor1 = new Object(); private synchronized void count(int newValue) { x = newValue; y = newValue; } private void minus(int delta) { synchronized (monitor1) { x -= delta; y -= delta; } } 保证线程之间对监视资源的数据同步。即，任何线程在获取到 Monitor 后的第一时间，会先将共享内存中的数据复制到自己的缓存中；任何线程在释放 Monitor 的第一时间，会先将缓存中的数据复制到共享内存中。 volatile 保证加了 volatile 关键字的字段的操作具有原子性和同步性，其中原子性相当于实现了针对单一字段的线程间互斥访问。因此 volatile 可以看做是简化版的 synchronized。 volatile 只对基本类型 (byte、char、short、int、long、float、double、boolean) 的赋值操作和对象的引用赋值操作有效。 原子性是cup执行的最小单位。 atomic java.util.concurrent.atomic 包： 下面有 AtomicInteger AtomicBoolean 等类，作用和 volatile 基本一致，可以看做是通用版的 volatile。 AtomicInteger atomicInteger = new AtomicInteger(0); ... atomicInteger.getAndIncrement(); lock 同样是「加锁」机制。但使用方法更灵活，同时也更麻烦一些。 Lock lock = new ReentrantLock(); ... lock.lock(); try { x++; } finally { lock.unlock(); } 一般并不会只是使用Lock，而是会使用更复杂的锁ReentrantReadWriteLock： public class ReadWriteLockDemo { ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); Lock readLock = lock.readLock(); Lock writeLock = lock.writeLock(); private int x = 0; private void count() { writeLock.lock(); try { x++; } finally { writeLock.unlock(); } } private void print(int time) { readLock.lock(); try { for (int i = 0; i &lt; time; i++) { System.out.print(x + &quot; &quot;); } System.out.println(); } finally { readLock.unlock(); } } public void runTest() { new Thread() { @Override public void run() { for (int i = 0; i &lt; 1_000_000; i++) { count(); } System.out.println(&quot;final x from 1: &quot; + x); } }.start(); new Thread() { @Override public void run() { print(1); } }.start(); new Thread() { @Override public void run() { print(2); } }.start(); new Thread() { @Override public void run() { print(3); } }.start(); new Thread() { @Override public void run() { print(4); } }.start(); new Thread() { @Override public void run() { print(5); } }.start(); } } wait在未达到目标时 wait();用 while 循环检查;设置完成后 notifyAll();wait() 和 notify() / notifyAll() 都需要放在同步代码块里。 public class WaitDemo { private String sharedString; private synchronized void initString() { sharedString = &quot;kkk&quot;; notifyAll(); } private synchronized void printString() { while (sharedString == null) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;String: &quot; + sharedString); } public void runTest() { final Thread thread1 = new Thread() { @Override public void run() { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } printString(); } }; thread1.start(); Thread thread2 = new Thread() { @Override public void run() { Thread.yield(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } initString(); } }; thread2.start(); } } 其他Service：后台任务的活动空间。适用场景：音乐播放器等。IntentService：执行单个任务后自动关闭的 Service。 如果在界面组件里创建 Executor 或者 HandlerThread，记得要在关闭的时候（例如Activity.onDestroy() ）关闭 Executor 和 HandlerThread。 @Override protected void onDestroy() { super.onDestroy(); executor.shutdown(); } @Override protected void onDestroy() { super.onDestroy(); handlerThread.quit(); // 这个其实就是停⽌ Looper 的循环 } 线程池ThreadPoolExecutor构造方法参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：线程基本大小 maximumPoolSize：线程池最大所能容纳线程大小 keepAliveTime：线程活动保持时间 workQueue：阻塞队列 threadFactory创建线程的工厂 handler：饱和策略 手动创建线程池仿照AsyncTask源码，写个线程池。缓存队列Runnable，加入到线程队列中去执行。 public class ThreadPoolDemo { static ThreadPoolExecutor threadPoolExecutor; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;&gt;(128); static { threadPoolExecutor = new ThreadPoolExecutor( 4,// 核心线程数，就是线程池里面的核心线程数量 10, // 最大线程数，线程池中的最大线程数 60,// 线程存活的时间，没事干的时候的空闲存活时间，超过这个时间线程就会被销毁 TimeUnit.SECONDS,// 线程存活时间的单位 sPoolWorkQueue,// 线程队列 new ThreadFactory() {//线程创建工厂，如果线程池需要创建线程就会调用newThread 来创建 @Override public Thread newThread(@NonNull Runnable r) { // Thread thread = new Thread(r,&quot;自己线程的名字&quot;); // thread.setDaemon(false); // 不是守护线程 return new Thread(r); } }); } public static void main(String[] args) { for (int i = 0; i &lt; 20; i++) { Runnable runnable = new Runnable() { @Override public void run() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;下载图片显示完毕&quot;+Thread.currentThread().getName()); } }; // 加入线程队列，寻找合适的时机去执行 threadPoolExecutor.execute(runnable); } } } 输出结果： Runnable缓存队列大于WorkQueue线程队列就可能会报错。 workQueue的参数BlockingQueue: 先进先出的一个队列 FIFO（rxjava，AsyncTask） SynchronousQueue: 线程安全的队列，它里面是没有固定的缓存的（OKHttp所使用的） PriorityBlockingQueue: 无序的可以根据优先级进行排序，指定的对象要实现Comparable作比较 有限队列SynchronousQueue和ArrayBlockingQueue；无限队列LinkedBloackingQueue。 PriorityBlockingQueue示例 public class Request implements Runnable,Comparable&lt;Request&gt;{ @Override public void run() { System.out.println(&quot;run&quot;); } @Override public int compareTo(@NonNull Request o) { return 0; } } public class ThreadPoolTest { static ThreadPoolExecutor threadPoolExecutor; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new PriorityBlockingQueue&lt;Runnable&gt;(4); static { threadPoolExecutor = new ThreadPoolExecutor( 4,// 核心线程数，就是线程池里面的核心线程数量 10, // 最大线程数，线程池中的最大线程数 60,// 线程存活的时间，没事干的时候的空闲存活时间，超过这个时间线程就会被销毁 TimeUnit.SECONDS,// 线程存活时间的单位 sPoolWorkQueue,// 线程队列 new ThreadFactory() {// 线程创建工厂，如果线程池需要创建线程就会调用 newThread 来创建 @Override public Thread newThread(@NonNull Runnable r) { return new Thread(r); } }); } public static void main(String[] args) { for (int i = 0; i &lt; 20; i++) { Request request = new Request(); // 加入线程队列，寻找合适的时机去执行 threadPoolExecutor.execute(request); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/线程池/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"学习Node","slug":"17.学习node","date":"2019-04-26T12:25:02.383Z","updated":"2019-04-28T13:29:43.743Z","comments":false,"path":"2019/04/26/17.学习node/","link":"","permalink":"http://yoursite.com/2019/04/26/17.学习node/","excerpt":"","text":"起步官网： https://nodejs.org/en/ 检查安装版本 node --version Node.js既不是语言，也不是框架，它是一个平台。Node.js 中的 JavaScript没有 BOM、DOM，提供了一些服务器级别的 API：文件操作的能力、http 服务的能力。 helloworld.js var f = &apos;hello nodejs&apos; console.log(f) 然后执行 node .../helloworld.js require 是一个方法,它的作用就是用来加载模块的。在 Node 中，模块有三种：具名的核心模块，例如 fs、http；用户自己编写的文件模块；第三方模块。 读和写文件浏览器中的 JavaScript 是没有文件操作的能力的，但是 Node 中的JavaScript 具有文件操作的能力。fs 是 file-system 的简写，就是文件系统的意思，fs.readFile 就是用来读取文件的。 node执行下面的js文件： var fs = require(&apos;fs&apos;) // 第一个参数就是要读取的文件路径,第二个参数是一个回调函数 fs.readFile(&apos;./data/hello.txt&apos;, function (error, data) { if (error) { console.log(&apos;读取文件失败了&apos;) } else { console.log(data.toString()) } }) 写文件： var fs = require(&apos;fs&apos;) fs.writeFile(&apos;./data/你好.md&apos;, &apos;我是Node.js&apos;, function (error) { if (error) { console.log(&apos;写入失败&apos;) } else { console.log(&apos;写入成功了&apos;) } }) http服务简单的http服务 var http = require(&apos;http&apos;) //使用 http.createServer() 方法创建一个 Web 服务器 var server = http.createServer() //当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数 server.on(&apos;request&apos;, function () { console.log(&apos;收到客户端的请求了&apos;) }) //绑定端口号，启动服务器 server.listen(3000, function () { console.log(&apos;服务器启动成功了，可以通过 http://你的ip/ 来进行访问&apos;) }) 处理请求,request请求事件处理函数，需要接收两个参数：Request 请求对象,请求对象可以用来获取客户端的一些请求信息，例如请求路径;Response 响应对象,响应对象可以用来给客户端发送响应消息。 var http = require(&apos;http&apos;) var server = http.createServer() server.on(&apos;request&apos;, function (request, response) { console.log(&apos;收到客户端的请求了，请求路径是：&apos; + request.url) // response 对象有一个方法：write 可以用来给客户端发送响应数据,write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待 response.write(&apos;hello&apos;) response.write(&apos; nodejs&apos;) response.end() }) server.listen(3000, function () { console.log(&apos;服务器启动成功了，可以通过 http://你的ip:3000/ 来进行访问&apos;) }) 根据不同请求路径返回不同数据： var http = require(&apos;http&apos;) var server = http.createServer() server.on(&apos;request&apos;, function (req, res) { console.log(&apos;收到请求了，请求路径是：&apos; + req.url) console.log(&apos;请求我的客户端的地址是：&apos;, req.socket.remoteAddress, req.socket.remotePort) var url = req.url if (url === &apos;/&apos;) { res.end(&apos;index page&apos;) } else if (url === &apos;/login&apos;) { res.end(&apos;login page&apos;) } else if (url === &apos;/products&apos;) { var products = [{ name: &apos;苹果 X&apos;, price: 8888 }, { name: &apos;菠萝 X&apos;, price: 5000 }, { name: &apos;小辣椒 X&apos;, price: 1999 } ] res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) // 响应内容只能是二进制数据或者字符串、 数字、 对象、数组、布尔值 res.end(JSON.stringify(products)) } else { res.end(&apos;404 Not Found.&apos;) } }) server.listen(3000, function () { console.log(&apos;服务器启动成功，可以访问了。。。&apos;) }) 在服务端默认发送的数据，其实是 utf8 编码的内容，中文操作系统默认是 gbk。在 http 协议中，Content-Type 就是用来告知对方我给你发送的数据内容是什么类型 // text/plain 就是普通文本 res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) // 如果你发送的是 html 格式的字符串，则也要告诉浏览器我给你发送是 text/html 格式的内容 res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) // 图片就不需要指定编码了，因为我们常说的编码一般指的是：字符编码 res.setHeader(&apos;Content-Type&apos;, &apos;image/jpeg&apos;) 模板引擎读取文件目录 var fs = require(&apos;fs&apos;) fs.readdir(&apos;D:/Movie/www&apos;, function (err, files) { if (err) { return console.log(&apos;目录不存在&apos;) } console.log(files) }) art-template不仅可以在浏览器使用，也可以在 node 中使用。 https://github.com/aui/art-template https://aui.github.io/art-template/ 安装：该命令在哪执行就会把包下载到哪里,下载到 node_modules 目录中。 npm install art-template 注意：在浏览器中需要引用 lib/template-web.js 文件 浏览器中使用art-template: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;浏览器中使用art-template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/template&quot; id=&quot;tpl&quot;&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;大家好，我叫：{{ name }}&lt;/p&gt; &lt;p&gt;我今年 {{ age }} 岁了&lt;/p&gt; &lt;h1&gt;我来自 {{ province }}&lt;/h1&gt; &lt;p&gt;我喜欢：{{each hobbies}} {{ $value }} {{/each}}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;/script&gt; &lt;script&gt; var ret = template(&apos;tpl&apos;, { name: &apos;Jack&apos;, age: 18, province: &apos;北京市&apos;, hobbies: [ &apos;写代码&apos;, &apos;唱歌&apos;, &apos;打游戏&apos; ] }) console.log(ret) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在 Node 中使用 art-template 模板引擎。在需要使用的文件模块中加载 art-template，只需要使用 require 方法加载就可以了：require(&#39;art-template&#39;) node执行js var template = require(&apos;art-template&apos;) var fs = require(&apos;fs&apos;) fs.readFile(&apos;./tpl.html&apos;, function (err, data) { if (err) { return console.log(&apos;读取文件失败了&apos;) } var ret = template.render(data.toString(), { name: &apos;Jack&apos;, age: 18, province: &apos;北京市&apos;, hobbies: [ &apos;写代码&apos;, &apos;唱歌&apos;, &apos;打游戏&apos; ], title: &apos;个人信息&apos; }) console.log(ret) }) tpl.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;大家好，我叫：{{ name }}&lt;/p&gt; &lt;p&gt;我今年 {{ age }} 岁了&lt;/p&gt; &lt;h1&gt;我来自 {{ province }}&lt;/h1&gt; &lt;p&gt;我喜欢：{{each hobbies}} {{ $value }} {{/each}}&lt;/p&gt; &lt;script&gt; var foo = &apos;{{ title }}&apos; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 留言板小案例 npm官网 https://www.npmjs.com/ 常用命令行工具 //查看版本 npm --version //升级npm npm install --global npm //跳过向导，快速生成 npm init -y //只下载 npm install 包名 //下载并且保存依赖项(package.json文件中的dependencies选项) npm install --save //只删除，如果有依赖项依然保存 npm uninstall 包名 //依赖也删除 npm uninstall --save 包名 //帮助 npm help 解决翻墙： 首先安装淘宝cnpm（可以再任意目录执行，–global表示安装到全局） npm install --global cnpm 接下来用cnpm替换npm。 如果不想安装npm又想使用淘宝镜像： npm install jquery --registry=https://registry.npm.taobao.org 加入配置文件中： npm config set registry https://registry.npm.taobao.org //查看配置成功 npm config list","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"设计模式","slug":"16.设计模式","date":"2019-04-24T12:22:35.621Z","updated":"2020-07-18T05:16:46.021Z","comments":false,"path":"2019/04/24/16.设计模式/","link":"","permalink":"http://yoursite.com/2019/04/24/16.设计模式/","excerpt":"","text":"单例模式 单例模式：保证整个程序只有一个实例。 套路：1、构造函数私有，防止在外部new对象；2、内部必须提供一个静态的方法，让外部调用。 饿汉模式 public class SingletonEHan { private SingletonEHan() { } private static SingletonEHan singletonEHan = new SingletonEHan(); public static SingletonEHan getInstance() { return singletonEHan; } // SingletonEHan instance= SingletonEHan.getInstance(); } 优点：比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。 缺点：由于在类加载的时候就实例化了，也就是说可能我没有用到这个实例，但是它也会加载，会造成内存的浪费(但是这个浪费可以忽略)。 懒汉模式，四种方式 public class SingletonLanHan { private SingletonLanHan() { } /** * 单例模式的懒汉式[线程不安全，不可用] */ private static SingletonLanHan singletonLanHan; public static SingletonLanHan getInstance() { if (singletonLanHan == null) { //多线程并发，这里线程是不安全的,可能得到两个不同的实例 singletonLanHan = new SingletonLanHan(); } return singletonLanHan; } /** * 懒汉式线程安全的:加锁，[线程安全，效率低不推荐使用] * 缺点：效率太低，每个线程在想获得类的实例时候，执行getSingletonLanHanTwo()方法都要进行同步。 */ private static SingletonLanHan singletonLanHanTwo; public static synchronized SingletonLanHan getSingletonLanHanTwo() { if (singletonLanHanTwo == null) { singletonLanHanTwo = new SingletonLanHan(); } return singletonLanHanTwo; } /** * 单例模式懒汉式[线程不安全，不可用] * 虽然加了锁，new Singleton()跳出这个锁时，另一个已经进入if语句的线程同样会实例化另外一个Singleton对象。 * */ private static SingletonLanHan singletonLanHanThree = null; public static SingletonLanHan getSingletonLanHanThree() { if (singletonLanHanThree == null) { synchronized (SingletonLanHan.class) {// 线程不安全 singletonLanHanThree = new SingletonLanHan(); } } return singletonLanHanThree; } /** * 懒汉式双重校验 * 缺点:不推荐用，下面解释 */ private static SingletonLanHan singletonLanHanFour; public static SingletonLanHan getSingletonLanHanFour() { if (singletonLanHanFour == null) {//只执行一次锁，所以效率高一些 synchronized (SingletonLanHan.class) { if (singletonLanHanFour == null) { singletonLanHanFour = new SingletonLanHan(); } } } return singletonLanHanFour; } } 1、开辟一块内存空间，2、初始化对象，3、给变量赋值，指向内存地址。在java中2和3的顺序不一定，也可能先3再2。用volatile保证123的顺序执行，防止重排序。 volatile[同步锁DCL] public class SingletonLanHan { private SingletonLanHan() { } //volatile解决了gvm指令重排序优化 private static volatile SingletonLanHan singletonLanHanFour; public static SingletonLanHan getSingletonLanHanFour() { if (singletonLanHanFour == null) { synchronized (SingletonLanHan.class) { if (singletonLanHanFour == null) { singletonLanHanFour = new SingletonLanHan(); } } } return singletonLanHanFour; } } volatile关键字作用:防止重排序,线程可见性。 线程可见性:某一个线程改了公用对象(变量)，短时间内另一个线程可能是不可见的，因为每一个线程都有自己的缓存区(线程工作区)。 举例：可以看加不加volatile的区别： public class VolatileTest { public static void main(String[] args) { ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true){ if(td.isFlag()){ System.out.println(&quot;主线程flag:&quot; + td.isFlag()); break; } } } } class ThreadDemo implements Runnable { private volatile boolean flag = false; @Override public void run() { try { Thread.sleep(200); } catch (InterruptedException e) { } flag = true; System.out.println(&quot;其他线程flag=&quot; + isFlag()); } public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } } 静态内部类 /** * 内部类[推荐用] * 在饿汉式方式是只要Singleton类被装载就会实例化, * 内部类是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类 * 优点：避免了线程不安全，延迟加载，效率高。 */ public class SingletonIn { private SingletonIn() { } private static class SingletonInHodler { private static final SingletonIn singletonIn = new SingletonIn(); } public static SingletonIn getSingletonIn() { return SingletonInHodler.singletonIn; } } 枚举 /** * 枚举[推荐使用] * SingletonEnum.instance * 这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。 * 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 */ public enum SingletonEnum { instance; private SingletonEnum() { } public void whateverMethod() { } // SingletonEnum.instance.method(); } 容器管理 SystemServiceRegistry.getSystemService系统的服务就是用的这种 public class Singleton { private static Map&lt;String,Object&gt; mSingleMap = new HashMap&lt;&gt;(); static { mSingleMap.put(&quot;activity_manager&quot;,new Singleton()); } private Singleton() { } public static Object getService(String serviceName){ return mSingleMap.get(serviceName); } } 补充复习static static关键字的特点：随着类的加载而加载，随着类的消失而消失；优先于对象存在；被类的所有对象共享。 静态变量存储于方法区的静态区；成员变量存储于堆内存。 静态代码块：在类中方法外出现，并加上static修饰；用于给类进行初始化(全局初始化)，在类加载的时候就执行，并且只执行一次。main主方法所在的类中的静态代码块优先于主方法执行。 class Student { static { System.out.println(&quot;Student 静态代码块&quot;); } { System.out.println(&quot;Student 构造代码块&quot;); } public Student() { System.out.println(&quot;Student 构造方法&quot;); } } class Demo2_Student { static { System.out.println(&quot;Demo2_Student静态代码块&quot;); } public static void main(String[] args) { System.out.println(&quot;我是main方法&quot;); Student s1 = new Student(); Student s2 = new Student(); } } 输出结果： Demo2_Student静态代码块 我是main方法 Student 静态代码块 Student 构造代码块 Student 构造方法 Student 构造代码块 Student 构造方法 工厂模式简单工厂模式 简单工厂模式：提供专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。客户端只知道传入工厂类的参数，不需要关心具体的实现。它不属于GoF23种设计模式，但在软件开发中应用也较为频繁。 实例 Bitmap bitmap = BitmapFatory.deresources(res,id); 简单工厂场景 使用简单工厂模式设计一个可以创建圆形、方形和三角形的绘图工具。 //抽象类 public interface IPain { void draw(); } //具体产品类 class Triangle implements IPain { @Override public void draw() { System.out.println(&quot;画出三角形&quot;); } } class Square implements IPain { @Override public void draw() { System.out.println(&quot;画出正方形&quot;); } } class Circle implements IPain { @Override public void draw() { System.out.println(&quot;画出圆形&quot;); } } //工厂类 public class PainFactory { //静态工厂方法 public static IPain create(int type){ switch (type) { case 1: return new Triangle(); case 2: return new Square(); case 3: return new Circle(); default: return new Circle(); } } } //客户端 public class Client { public static void main(String[] args) { //通过静态工厂方法创建产品 IPain mPain = PainFactory.create(2); mPain.draw(); } } 在简单工厂模式包含如下几个角色： 工厂类，负责实现创建所有产品实例，在工厂类中提供了静态方法，可以被外界直接调用，返回抽象产品类Product。 Product抽象产品角色，它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，所有创建的具体产品对象都是其子类对象。 具体产品角色，都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象。 工厂方法模式 简单工厂Factory Method Pattern，模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类。 工厂方法模式中，不再提供一个统一的工厂类，而是针对不同的产品提供不同的工厂。提供一个抽象工厂接口来声明抽象工厂方法，其子类来具体实现工厂方法，创建具体的产品对象。即把对象的实现延迟到子类完成。 实例： //List:Factory抽象工厂，ArrayList:具体的工厂Factory //Iterator:抽象产品Product，ArrayListIterator:具体的产品 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.iterator(); 工厂方法场景 玩具工厂生产动物玩具，发出不同叫声。 //抽象产品-玩具 interface IToy { void makeNoise(String string); } //具体产品 class DogToy implements IToy { public void makeNoise(String string) { System.out.println(string + &quot;汪汪汪的叫。&quot; ); } } //具体产品 class CatToy implements IToy { public void makeNoise(String string) { System.out.println(string + &quot;喵喵喵的叫。&quot;); } } //抽象工厂 abstract class IToyFactory { abstract IToy createToy(); } //具体工厂 class DogFactory extends IToyFactory { public IToy createToy() { return new DogToy(); } } //具体工厂 class CatFactory extends IToyFactory { public IToy createToy() { return new CatToy(); } } //客户端 class Client { public static void main(String args[]) { IToyFactory factory = new CatFactory(); IToy toy = factory.createToy(); toy.makeNoise(&quot;我是cat。&quot;); //factory.createToy().makeNoise(&quot;我是cat。&quot;); } } 工厂方法模式的几个角色： Product抽象产品角色和具体产品角色，和简单工厂模式类似，不再累述。 Factory（抽象工厂）：是工厂方法模式的核心，在抽象工厂类中，声明了抽象工厂方法，用于返回一个产品。可以是接口，也可以是抽象类或者具体类。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 抽象工厂模式 抽象工厂模式Abstract Factory Pattern 待更新 建造者模式介绍 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。 简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件。 角色 在建造者模式中包含如下几个角色： Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 Director（指挥者）：负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。 客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 建造者模式与抽象工厂模式有点相似，但是建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品。 场景 实例：生产机器人，包含机器人服装，脸型，机器人功能 //产品,包含很多组件 class RobotProduct { private String type; //机器人功能 private String face; //脸型 private String costume; //服装 public void setType(String type) { this.type = type; } public void setFace(String face) { this.face = face; } public void setCostume(String costume) { this.costume = costume; } public String getType() { return (this.type); } public String getFace() { return (this.face); } public String getCostume() { return (this.costume); } } //抽象建造者 abstract class RobotBuilder { protected RobotProduct robot = new RobotProduct(); public abstract void buildType(); public abstract void buildFace(); public abstract void buildCostume(); //工厂方法，返回一个完整机器人 public RobotProduct createRobot() { return robot; } } //具体建造者 class ManBuilder extends RobotBuilder { public void buildType() { robot.setType(&quot;男仆&quot;); } public void buildFace() { robot.setFace(&quot;英俊&quot;); } public void buildCostume() { robot.setCostume(&quot;西服&quot;); } } //具体建造者 class WomanBuilder extends RobotBuilder { public void buildType() { robot.setType(&quot;女仆&quot;); } public void buildFace() { robot.setFace(&quot;漂亮&quot;); } public void buildCostume() { robot.setCostume(&quot;短裙&quot;); } } //指挥者类定义了construct()方法，该方法拥有一个抽象建造者类型的参数，在该方法内部实现了机器人的逐步构建 class RobotController { //逐步构建复杂产品对象 public RobotProduct construct(RobotBuilder ab) { RobotProduct robot; ab.buildType(); ab.buildFace(); ab.buildCostume(); robot = ab.createRobot(); return robot; } } class Client { public static void main(String args[]) { RobotBuilder ab = new WomanBuilder(); RobotController ac = new RobotController(); RobotProduct robot = ac.construct(ab); //通过指挥者创建完整的建造者对象 System.out.println(robot.getType() + &quot;的外观：&quot;); System.out.println(&quot;面容：&quot; + robot.getFace()); System.out.println(&quot;服装：&quot; + robot.getCostume()); } } 变形 建造者模式的变形，也是在源码和开源项目中长用的，比如：AlertDialog //产品,包含很多组件 class RobotProduct { private String type; //机器人功能 private String face; //脸型 private String costume; //服装 public void apply(RobotBuilder.RobotParmas parmas) { type = parmas.type; face = parmas.face; costume = parmas.costume; } @Override public String toString() { return type + &quot;的外观：&quot; + &quot;面容：&quot; + face + &quot;服装：&quot; + costume; } } //具体建造者 class RobotBuilder { private RobotBuilder.RobotParmas parmas; public RobotBuilder() { this.parmas = new RobotBuilder.RobotParmas(); } public RobotBuilder makeType(String type) { parmas.type = type; return this; } public RobotBuilder makeFace(String face) { parmas.face = face; return this; } public RobotBuilder makeCostume(String costume) { parmas.costume = costume; return this; } //真正构建 public RobotProduct build() { RobotProduct produc = new RobotProduct(); produc.apply(parmas); return produc; } class RobotParmas { public String type; //机器人功能 public String face; //脸型 public String costume; //服装 } } class Client { public static void main(String args[]) { RobotProduct product = new RobotBuilder().makeType(&quot;女仆&quot;).makeFace(&quot;俊俏&quot;).makeCostume(&quot;护士装&quot;).build(); System.out.println(product.toString()); } } 责任链模式介绍 职责链模式(Chain of Responsibility Pattern，职责链模式)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。职责链模式结构的核心在于引入了一个抽象处理者。 重点：上一个处理对象必须含有下一个处理对象的引用，形成一个单向链表。 角色 Handler（抽象处理者）：定义一个处理请求的抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。 ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。 场景 安卓实例，比如，事件分发机制。在View、ViewGroup、Activity中都有机会处理OnTouchEvent请求。 例子：主任、副董事长、董事长有不同的审批金额的权利，当超过自己额度审批范围，就像上级提交。 class Client { public static void main(String[] args) { ApproverHander little, middle, high; little = new Director(&quot;张三&quot;); middle = new VicePresident(&quot;李四&quot;); high = new President(&quot;王五&quot;); //创建职责链 little.setSuccessor(middle); middle.setSuccessor(high); //创建采购单 PurchaseRequest pr1 = new PurchaseRequest(45000); little.processRequest(pr1); PurchaseRequest pr2 = new PurchaseRequest(60000); little.processRequest(pr2); PurchaseRequest pr3 = new PurchaseRequest(160000); little.processRequest(pr3); } } //采购单：请求类 class PurchaseRequest { private double amount; //采购金额 public PurchaseRequest(double amount) { this.amount = amount; } public void setAmount(double amount) { this.amount = amount; } public double getAmount() { return this.amount; } } //审批者类：抽象处理者 abstract class ApproverHander { protected ApproverHander hander; //定义后继对象 protected String name; //审批者姓名 public ApproverHander(String name) { this.name = name; } //设置后继者 public void setSuccessor(ApproverHander hander) { this.hander = hander; } //抽象请求处理方法 public abstract void processRequest(PurchaseRequest request); } //主任类：具体处理者 class Director extends ApproverHander { public Director(String name) { super(name); } //具体请求处理方法 public void processRequest(PurchaseRequest request) { if (request.getAmount() &lt; 50000) { System.out.println(&quot;主任&quot; + this.name + &quot;审批金额：&quot; + request.getAmount()); //处理请求 } else { this.hander.processRequest(request); //转发请求 } } } //副董事长类：具体处理者 class VicePresident extends ApproverHander { public VicePresident(String name) { super(name); } //具体请求处理方法 public void processRequest(PurchaseRequest request) { if (request.getAmount() &lt; 100000) { System.out.println(&quot;副董事长&quot; + this.name + &quot;审批金额：&quot; + request.getAmount()); //处理请求 } else { this.hander.processRequest(request); //转发请求 } } } //董事长类：具体处理者 class President extends ApproverHander { public President(String name) { super(name); } //具体请求处理方法 public void processRequest(PurchaseRequest request) { System.out.println(&quot;董事长&quot; + this.name + &quot;审批金额：&quot; + request.getAmount()); //处理请求 } } 和观察者模式区别 受众数量不同。观察者广播链式可以 1:N 的方式广播，而责任链则要求是的 1:1 的传递，必然有一个且只有一个类完成请求的处理; 请求内容不同。观察者广播链中的信息可以在传播中改变，但是责任链中的请求是不可改变的; 处理逻辑不通。观察者广播链主要用于触发联动动作，而责任链则是对一个类型的请求按照既定的规 则进行处理。 装饰模式介绍 装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。 角色 Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 装饰设计模式一般情况都是把类对象作为构造参数传递。在不使用的继承的方式下，采用装饰设计模式可以扩展一个对象的功能，可以使一个对象变得越来越强大。 场景 例子：在铺了地板的毛坯房上进行装饰： public class Client { public static void main(String args[]) { Home home, homeTake; //使用抽象构件定义 home = new Floor(); //定义具体构件 homeTake = new TakeHomeDecorator(home); //定义装饰后的构件 homeTake.display(); } } //抽象界面构件类 abstract class Home { public abstract void display(); } //具体构件类 class Floor extends Home { public void display() { System.out.println(&quot;毛坯房铺了地板&quot;); } } //抽象装饰类 class HomeDecorator extends Home { private Home component; //维持对抽象构件类型对象的引用 public HomeDecorator(Home component){//注入抽象构件类型的对象 this.component = component; } public void display() { component.display(); } } //具体装饰类 class TakeHomeDecorator extends HomeDecorator { public TakeHomeDecorator(Home component) { super(component); } public void display() { super.display(); this.setFurniture(); } public void setFurniture() { System.out.println(&quot;搬进去很多家具&quot;); } } 安卓实例 ListView中的HeaderViewListAdapter，添加头部和底部。 ContextWrapper。 模板方法模式介绍 模板方法模式(Template Method Pattern)：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 其核心是抽象类和其中的模板方法的设计。父类一般都是流程和通用部分的封装，子类一般都是具体的功能和逻辑。 钩子：用来控制父类的流程,比如:插件化开发hook启动流程。 场景 模版和钩子,比如吃饭:点餐、吃东西、充卡、买单,充卡可以自由选择 public class Client { public static void main(String[] args) { PeopleEat h1 = new PeopleEat(); h1.setMoney(true); h1.havaEat(); } } abstract class EatModel { //钩子方法，默认会充钱 protected boolean isAdd(){ return true; } protected abstract void orderFood(); protected abstract void eatMeal(); protected abstract void addMoney(); protected abstract void payBill(); final public void havaEat() { this.orderFood(); this.eatMeal(); if(this.isAdd()){ this.addMoney(); } this.payBill(); } } class PeopleEat extends EatModel { private boolean addMoneyFlag = true; @Override protected void addMoney() { System.out.println(&quot;充值200元...&quot;); } @Override protected void payBill() { System.out.println(&quot;买单离开...&quot;); } @Override protected void orderFood() { System.out.println(&quot;点了烤肉...&quot;); } @Override protected void eatMeal() { System.out.println(&quot;开始烤肉啦...&quot;); } @Override protected boolean isAdd() { return this.addMoneyFlag; } public void setMoney(boolean isAdd){ this.addMoneyFlag = isAdd; } } 安卓实例 Activity的生命周期采用了模板方法模式：首先都是继承自Activity，而且所有要自己定义写的Activity的生命周期的流程都是一样的，每个Activity可以设置不同的界面，可以实现自己的具体交互逻辑。 AsyncTask 开发中BaseActivity 策略设计模式介绍 策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。 策略模式的主要目的是将算法的定义与使用分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。 角色 Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。 Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。 ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。 场景 景区门票，原始票价，学生票价，老人票价 public class Client { public static void main(String[] args){ ParkTicket pt = new ParkTicket(); double originalPrice = 100; pt.setPrice(originalPrice); System.out.println(&quot;原始价为：&quot; + originalPrice); Discount discount = new StudentDiscount(); pt.setDiscount(discount); //注入折扣对象 System.out.println(&quot;折后价为：&quot; + pt.getPrice()); } } //环境类:公园票价 class ParkTicket { private double price; private Discount discount; //维持一个对抽象折扣类的引用 public void setPrice(double price) { this.price = price; } //注入一个折扣类对象 public void setDiscount(Discount discount) { this.discount = discount; } public double getPrice() { //调用折扣类的折扣价计算方法 return discount.calculate(this.price); } } //抽象策略类：折扣类 interface Discount { public double calculate(double price); } //具体策略类：学生票折扣类 class StudentDiscount implements Discount { public double calculate(double price) { System.out.println(&quot;学生票：&quot;); return price * 0.8; } } //具体策略类：老人票折扣类 class OldManDiscount implements Discount { public double calculate(double price) { System.out.println(&quot;老人票：&quot;); return price - 10; } } 策略模式定义了一系列算法，并将每一个算法封装起来，而且是他们之间可以相互切换。 安卓实例 第三方的：Glide的缓存策略，ImageLoader的生成图片文件的命名策略，timber日志打印工具的策略，OKhttp部分 源码里面：属性动画setInterpolator差值器；RecyclerView:setLayoutManager可以是ListView样式或者是GirdView样式等等。 观察者模式场景 观察者是汽车，根据被观察者红路灯，作出反应。 public class Client { public static void main(String[] args){ //观察者 Observer bigCar = new BigCar(); Observer smallCar = new SmallCar(); //被观察者 TrafficLight trafficLight = new TrafficLight(); //关联 trafficLight.addObserver(bigCar); trafficLight.addObserver(smallCar); //目标有变化，看看观察者怎么办 trafficLight.havaRed(); trafficLight.havaGreen(); } } //被观察者 interface Observable { //增加一个观察者 void addObserver(Observer observer); //删除一个观察者 void deleteObserver(Observer observer); //通知观察者 void notifyObservers(String context); } //观察者 interface Observer { //一发现􏰀人有动静，自己也要行动起来 void update(String context); } //被观察者 class TrafficLight implements Observable { //存放所有的观察者 private ArrayList&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); //增加观察者 public void addObserver(Observer observer) { this.observerList.add(observer); } //删除观察者 public void deleteObserver(Observer observer) { this.observerList.remove(observer); } //通知所有的观察者 public void notifyObservers(String context) { for (Observer observer : observerList) { observer.update(context); } } public void havaRed() { System.out.println(&quot;红灯...&quot;); //通知所有的观察者 this.notifyObservers(&quot;红灯停车啦&quot;); } public void havaGreen() { System.out.println(&quot;绿灯...&quot;); this.notifyObservers(&quot;绿灯开车啦&quot;); } } //观察者 class BigCar implements Observer { public void update(String str) { System.out.println(str); this.makeCar(str); } private void makeCar(String reportContext) { System.out.println(&quot;我是大汽车---&gt;&quot; + reportContext); } } //观察者 class SmallCar implements Observer { public void update(String str) { System.out.println(str); this.makeCar(str); } private void makeCar(String reportContext) { System.out.println(&quot;我是小汽车---&gt;&quot; + reportContext); } } 推拉模式 推拉模式：上面是推模式，即被观察者变化的时候，推送给观察者。拉模式，即被观察者变化的时候，观察者主动查看下被观察者。可以分开使用，也可以结合使用。 原生API 继承原生API实现 import java.util.Observable; import java.util.Observer; public class Client { public static void main(String[] args){ //观察者 Observer bigCar = new BigCar(); Observer smallCar = new SmallCar(); //被观察者 TrafficLight trafficLight = new TrafficLight(); //关联 trafficLight.addObserver(bigCar); trafficLight.addObserver(smallCar); //目标有变化，看看观察者怎么办 trafficLight.havaRed(); trafficLight.havaGreen(); } } //被观察者 class TrafficLight extends Observable { public void havaRed() { System.out.println(&quot;红灯...&quot;); super.setChanged(); super.notifyObservers(&quot;红灯停车啦&quot;); } public void havaGreen() { System.out.println(&quot;绿灯...&quot;); super.setChanged(); super.notifyObservers(&quot;绿灯开车啦&quot;); } } //观察者 class BigCar implements Observer { private void makeCar(String reportContext) { System.out.println(&quot;我是大汽车---&gt;&quot; + reportContext); } @Override public void update(Observable o, Object arg) { System.out.println(arg.toString()); this.makeCar(arg.toString()); } } //观察者 class SmallCar implements Observer { private void makeCar(String reportContext) { System.out.println(&quot;我是小汽车---&gt;&quot; + reportContext); } @Override public void update(Observable o, Object arg) { System.out.println(arg.toString()); this.makeCar(arg.toString()); } } 安卓实例 ListView的Adapter的setDataChange方法。给Adapter注册一个mDataSetObserver。 mAdapter.registerDataSetObserver(mDataSetObserver); 代理模式静态代理 目标接口、代理对象、被代理的对象。 /** * 银行办理业务 - 目标接口（业务） */ public interface IBank { /*** 申请办卡*/ public void applyBank(); /*** 挂失*/ public void lostBank(); } /** * 银行办理业务 - 代理对象 - 银行的业务员 */ public class BankWorker implements IBank{ private IBank bank; /** * 持有被代理的对象 * @param bank */ public BankWorker(IBank bank){ this.bank = bank; } @Override public void applyBank() { System.out.println(&quot;开始受理&quot;); bank.applyBank(); System.out.println(&quot;操作完毕&quot;); } @Override public void lostBank() { System.out.println(&quot;开始受理&quot;); bank.lostBank(); System.out.println(&quot;操作完毕&quot;); } } /** * 银行办理业务 - 被代理的对象 - 我们 */ public class Man implements IBank { private String name; public Man(String name) { this.name = name; } /** * 自己的一些操作 */ @Override public void applyBank() { System.out.println(name + &quot; 申请办卡&quot;); } @Override public void lostBank() { System.out.println(name + &quot; 申请挂失&quot;); } } public class Client { public static void main(String[] args){ Man man = new Man(&quot;张三&quot;); BankWorker bankWorker = new BankWorker(man); bankWorker.applyBank(); } } 动态代理 形式 Proxy.newProxyInstance( IBank.class.getClassLoader(),//ClassLoader new Class&lt;?&gt;[]{IBank.class},//目标接口 null//InvocationHandler-关键 ); 代码 /** * 银行办理业务 - 动态代理 - InvocationHandler */ public class BankInvocationHandler implements InvocationHandler{ /** * 被代理的对象 */ private Object mObject; public BankInvocationHandler(Object object){ this.mObject = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 执行方法 ，目标接口调用的方法都会来到这里面 // System.out.println(&quot;methodName = &quot;+method.getName()); System.out.println(&quot;开始受理&quot;); // System.out.println(&quot;params = &quot;+args.toString()); // 调用被代理对象的方法,这里其实调用的就是 man 里面的 applyBank 方法 Object voidObject = method.invoke(mObject,args); System.out.println(&quot;操作完毕&quot;); return voidObject; } } public class Client { public static void main(String[] args) { Man man = new Man(&quot;张三&quot;); IBank bank = // 返回的是 IBank 的一个实例对象，这个对象是由 Java 给我们创建的 ,调用的是 jni (IBank) Proxy.newProxyInstance( IBank.class.getClassLoader(), // ClassLoader new Class&lt;?&gt;[]{IBank.class}, // 目标接口 new BankInvocationHandler(man) // InvocationHandler (这个类是关键) ); // 当调用这个方法的时候会来到 BankInvocationHandler 的 invoke 方法 bank.applyBank(); bank.lostBank(); bank.extraBank(); } } /** * 银行办理业务 - 目标接口（业务） */ public interface IBank { /** * 申请办卡 */ public void applyBank(); /** * 挂失 */ public void lostBank(); /** * 额外业务 */ public void extraBank(); } /** * 银行办理业务 - 被代理的对象 - 我们 */ public class Man implements IBank { private String name; public Man(String name){ this.name = name; } /** * 自己的一些操作 */ @Override public void applyBank() { System.out.println(name + &quot; 申请办卡&quot;); } @Override public void lostBank() { System.out.println(name + &quot; 申请挂失&quot;); } @Override public void extraBank() { System.out.println(name + &quot; 额外业务&quot;); } } 开发用到的地方 Android 插件化架构之绕过 AndroidManifest 检测（动态代理） Android 数据库实现数据的懒加载（静态代理） Android MVP 架构设计（静态代理和动态代理） Android Xutils 实现 View 事件注入（动态代理） Android Retrofit 的 create 创建接口对象 （动态代理） Android Framework 层的 AMS Android Framework 层的 Binder 驱动 Retrofit的create public &lt;T&gt; T create(final Class&lt;T&gt; service) { // 验证当前类是否是接口 Utils.validateServiceInterface(service); //有需要的话做方法缓存？ if (validateEagerly) { eagerlyValidateMethods(service); } // 动态代理设计模式 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable { //如果调用的方法是Object的 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } // //默认进不来这个if ，平台判断 android java8 ios if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } // 重点*具体执行细节 // method:就是我们调用的具体的方法(例如：login方法) 去解析方法属性和参数属性吧？ ServiceMethod serviceMethod = loadServiceMethod(method); // 解析完成之后，调用OKHttp框架执行请求 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // 这个最终是 ExecutorCallAdapterFactory 里面的 CallAdapter 所以最终返回的是 ExecutorCallbackCall return serviceMethod.callAdapter.adapt(okHttpCall); } }); } 自己实现create的思路 public &lt;T&gt; T create(Class&lt;T&gt; clazz){ // 动态代理 return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class&lt;?&gt;[]{clazz}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Log.e(&quot;TAG&quot;,method.getName()); // 如果要实现 Retrofit 一样的代码应该怎么办？ // 1. 解析方法的所有注解 比如 POST GET FormUrlEncoded 等等 // 2. 解析参数的所有注解 比如 FieldMap Part PartMap 等等 // 3. 封装成 Call 对象 // 4.返回的 Call 对象 return &quot;返回&quot;; } }); } 通过Retrofit.create(class)方法创建出Service interface的实例，从而使得Service中配置的方法变得可用，这是Retrofit代码结构的核心。 Retrofit.create(class)方法内部，使用Proxy.newProxyInstance()方法创建Service实例。create方法会为参数中的interface创建一个对象，这个对象实现了interface中的每一个方法，并且每个方法的实现都是类似的：调用对象实例内部的一个InvocationHandler成员变量的invoke()方法，并把自己的方法信息传递进去。实质上就是动态代理：interface中的方法全部由一个另外设定的InvocationHandler对象来进行代理操作。并且，这些方法的具体实现是在运行时生成interface实例时才确定的，而不是在编译时。 invoke()方法中创建interface实例，有三行关键代码： 1、ServiceMethod的创建： ServiceMethod&lt;Object, Object&gt; serviceMethod = （ServiceMethod&lt;Object, Object&gt;）loadServiceMethod(method); 这行代码负责读取interface中原方法的信息，包括返回值、方法注解、参数类型、参数注解，并将这些信息做初步分支。 2、OkHttpCall的创建 OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCall是retrofit2.Call的子类。这行代码负责将ServiceMethod封装进retrofit2.Call对象，这个对象可以在需要的时候，例如enqueue()方法被调用的时候，利用ServiceMethod中包含的信息来创建一个okhttp3.Call对象，并调用这个okhttp3.Call对象来进行网络请求的发起，然后对结果进行预处理，如类型转换。 3、adapt()方法 return serviceMethod.callAdapter.adapt(okHttpCall); 这个方法会使用ServiceMethod中的callAdapter对象来把okHttpCall对象进行转换,生成一个新的retrofit2.Call对象，在这个新的Call对象中，后台线程发起的请求，会在相应返回后，从主线程中调用回调方法，实现线程的自动切换。 另外这个方法不止可以生成新的retrofit2.Call对象，也可以生成别的类型对象，例如RaJava的Obervable，来让Retrofit可以和RaJava结合使用。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"反射、注解、泛型","slug":"15.反射、注解、泛型","date":"2019-04-17T12:37:27.932Z","updated":"2019-10-21T14:58:14.494Z","comments":false,"path":"2019/04/17/15.反射、注解、泛型/","link":"","permalink":"http://yoursite.com/2019/04/17/15.反射、注解、泛型/","excerpt":"","text":"反射.java文件，通过编译，生成.class文件，再通过类加载器，加载到jdk内存中并且生成字节码对象class。 所有的反射功能都是基于我们字节码（class），一个类的class在内存中只有一份，而且class其实也是一个对象Class。 获取class对象的三种方式方式一： 通过Object继承来的方法(getClass)获取对象对应的字节码文件对象 Person p = new Person();//创建Peron对象 Class clazz = p.getClass();//1 方式二：每一个类型都具备一个class静态属性，通过该属性即可获取该类的字节码文件对象。 Class clazz = Person.class; 方式三：必须类全名,使用最多。 Class clazz = Class.forName(&quot;cn.bean.Person&quot;);//必须类全名 通过构造函数，获取对象默认构造函数 public class Person { public Person() { System.out.println(&quot;无参构造---&quot;); } } try{ Class clazz = Person.class; Person person = (Person)clazz.newInstance(); } catch (Exception e) { e.printStackTrace(); } 有参公共构造函数 public class Person { private String name; public Person(String name) { this.name = name; System.out.println(&quot;有参构造---&quot; + name); } } try{ Class clazz = Person.class; Constructor constructor = clazz.getConstructor(String.class); Person person = (Person)constructor.newInstance(&quot;张三&quot;); } catch (Exception e) { e.printStackTrace(); } 无参私有构造 public class Person { private Person() { System.out.println(&quot;无参私有构造---&quot; ); } } try{ Class clazz = Person.class; Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); Person person = (Person)constructor.newInstance(); } catch (Exception e) { e.printStackTrace(); } 有参私有构造 public class Person { private String name; private Person(String name) { this.name = name; System.out.println(&quot;有参私有构造---&quot; + name); } } try{ Class clazz = Person.class; Constructor constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); Person person = (Person)constructor.newInstance(&quot;张三&quot;); } catch (Exception e) { e.printStackTrace(); } 获取属性public class Person { private String name = &quot;李四&quot;; public int age = 18; } try { Class clazz = Person.class; Person person = (Person) clazz.newInstance(); Field field = clazz.getField(&quot;age&quot;); int age = (int) field.get(person); Field fieldDeclared = clazz.getDeclaredField(&quot;name&quot;); fieldDeclared.setAccessible(true); String name = (String) fieldDeclared.get(person); System.out.println(name + &quot;----&quot; + age); } catch (Exception e) { e.printStackTrace(); } 方法调用获取，私有有参方法和公有无参方法 public class Person { private String name = &quot;李四&quot;; public String getName() { System.out.println(&quot;get:&quot; + name); return name; } private void setName(String name) { this.name = name; System.out.println(&quot;set:&quot; + name); } } try{ Class clazz = Person.class; Person person = (Person)clazz.newInstance(); Method methodDeclared = clazz.getDeclaredMethod(&quot;setName&quot;, String.class); methodDeclared.setAccessible(true); methodDeclared.invoke(person,&quot;张三&quot;); Method method = clazz.getMethod(&quot;getName&quot;); method.invoke(person); } catch (Exception e) { e.printStackTrace(); } 实例：调用静态属性Class clazz = Class.forName(&quot;android.app.ActivityThread&quot;); Field sCurrentActivityThreadField = clazz.getDeclaredField(&quot;sCurrentActivityThread&quot;); sCurrentActivityThreadField.setAccessible(true); //sCurrentActivityThread是静态的，可以传null Object sCurrentActivityThread = sCurrentActivityThreadField.get(null); 注解注解和反射没有什么必然联系。注解只是一个标识（标记），没有具体的功能逻辑代码。注解作用:给jvm看的，给机器看的。注解优点：开发效率高，成本低。注解缺点：耦合性大，并且不利于后期维护。 jdk5提供的注解@Override：告知编译器此方法是覆盖父类的 @Deprecated：标注过时 @SuppressWarnings：压制警告 编写一个注解关键字：@interface。属性：返回值 名称() 。 注意：如果属性的名字是value，并且注解的属性值有一个,那么在使用注解时可以省略value。 注解属性类型只能是以下几种:基本类型、String、枚举类型、注解类型、Class类型、以上类型的一维数组类型。 元注解：代表修饰注解的注解。作用：限制定义的注解的特性。 @Retention//代表注解什么时候起作用 SOURCE: 注解在源码级别可见，编程阶段 CLASS：注解在字节码文件级别可见，编译时（打包的时候） RUNTIME：注解在整个运行阶段都可见 @Target //代表注解修饰的范围：类上使用，方法上使用，字段上使用 FIELD:字段上可用此注解 METHOD:方法上可以用此注解 TYPE:类/接口上可以使用此注解 例如 @Target(ElementType.FIELD) @Target({ElementType.METHOD,ElementType.TYPE}) 注解例子 @Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Anno { int age() default 28; String[] value(); } @Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Anno2 { String value(); } @Anno2(&quot;张三&quot;) public class Test{ @Anno(value = { &quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;},age = 18) public void test(){ } } default作用是设置默认值,如果设置了default,注解时候可以不传。 butterknife 用了反射没有？ 一个地方用了Class.fromName().newInstance();（new 对象的时候）。 补充@Target注解的作用目标 @Target(ElementType.TYPE) //接口、类、枚举、注解 @Target(ElementType.FIELD) //字段、枚举的常量 @Target(ElementType.METHOD) //方法 @Target(ElementType.PARAMETER) //方法参数 @Target(ElementType.CONSTRUCTOR) //构造函数 @Target(ElementType.LOCAL_VARIABLE)//局部变量 @Target(ElementType.ANNOTATION_TYPE)//注解 @Target(ElementType.PACKAGE) ///包 反射加注解实现要想解析使用了注解的类，那么该注解的Retention必须设置成Runtime。关于注解解析的实质：从注解中解析出属性值。字节码对象存在于获得注解相关的方法。 运行时注解，仿xutil获取Id（编译时注解-ButterKnife注解）: @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface ViewById { int value(); } public class ViewUtils { public static void inject(Activity activity) { // 1.获取所有的属性 Field[] fields = activity.getClass().getDeclaredFields(); // 2.过滤关于 ViewById 属性 for (Field field : fields) { ViewById viewById = field.getAnnotation(ViewById.class); if(viewById != null){ // 3.findViewById View view = activity.findViewById(viewById.value()); // 4.反射注入 field.setAccessible(true); try { //activity 属性所在类，view 代表的是属性的值 field.set(activity,view); } catch (IllegalAccessException e) { e.printStackTrace(); } } } } } @ViewById(R.id.tv) private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ViewUtils.inject(this); tv.setText(&quot;ViewById&quot;); } 泛型泛型的好处：将运行时期的ClassCastException，转移到了编译时期变成了编译失败;避免了类型强转的麻烦。 缺点：泛型不能用于显性地引用运行时类型的操作之中，例如转型，instanceof和new操作。 多泛型 class MorePoint&lt;T,U,A,B,C&gt;{ } 任意一个大写字母都可以。他们的意义是完全相同的，但为了提高可读性，大家还是用有意义的字母比较好，一般来讲，在不同的情境下使用的字母意义如下： E — Element，常用在java Collection里，如：List&lt;E&gt;,Iterator&lt;E&gt;,Set&lt;E&gt; K,V — Key，Value，代表Map的键值对 N — Number，数字 T — Type，类型，如String，Integer等等 类泛型在任何地方出现的，代表的是统一类型。创建对象时，确定泛型的类型 class ArrayList&lt;T&gt; { public boolean add(T e) { return false; } public T get(int index) { return null; } } 方法泛型定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){泛型类型 变量名} 例如，API中的ArrayList集合中的方法： //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组 public &lt;T&gt; T[] toArray(T[] a){ } //使用格式：调用方法时，确定泛型的类型 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); String[] arr = new String[100]; String[] result = list.toArray(arr); 方法泛型最好与类的泛型一致,如果不一致,需要在方法上声明该泛型静态方法必须声明自己的泛型 泛型的接口//带有泛型的接口 public interface List &lt;E&gt;{ abstract boolean add(E e); } //一种实现类,先实现接口,不理会泛型 public class ArrayList&lt;E&gt; implements List&lt;E&gt;{ } //另一种实现类,实现接口的同时,也指定了数据类型 public class XXX implements List&lt;String&gt;{ } 泛型的通配匹配所有的数据类型:&lt;?&gt;。 泛型的上限和下限// 上限，限制的是父类,接收BaseActivity和它的子类 public void startActivity(Class&lt;? extends BaseActivity&gt; clazz) { Intent intent = new Intent(this,clazz); startActivity(intent); } //下限，限制的是子类,接收BaseActivity和它的父类 public void startActivity1(Class&lt;? super BaseActivity&gt; clazz) { Intent intent = new Intent(this,clazz); startActivity(intent); }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"win下Fiddler和mac下charles抓包","slug":"14.win下Fiddler和mac下charles抓包","date":"2019-04-12T11:59:42.748Z","updated":"2019-04-21T09:04:16.059Z","comments":false,"path":"2019/04/12/14.win下Fiddler和mac下charles抓包/","link":"","permalink":"http://yoursite.com/2019/04/12/14.win下Fiddler和mac下charles抓包/","excerpt":"","text":"前戏准备：win下的Fiddler，mac下的charles，安卓手机。 手机：打开手机WIFI高级设置，代理服务器类型改为”手动”，代理服务器地址填入PC的IP地址，填入代理服务器端口值，一般默认为8888。 ip：方式一：win通过ipconfig，mac通过ifconfig，快速查询电脑ip。 方式二：顶部菜单：Fiddler右上角;charles中Help → Local IP Address。 FiddlerFiddler官网 https://www.telerik.com/fiddler 端口号设置 过滤设置 查看请求和返回数据 模拟请求 注意4中为请求头，5中为请求体。 抓取https手机自带浏览器输入ip:端口号下载证书 修改请求或返回参数 步骤：1设置修改返回数据，2去掉勾勾，3修改返回数据，4打上勾勾，5输入go回车。 charlescharles官网，30天试用 https://www.charlesproxy.com/ 端口号设置 通过菜单栏：proxy → Proxy Settings，进行查看当前或者修改当前代理端口，并且保证Enable transparent HTTP proxying被勾选。 过滤设置 菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择Include栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。 查看请求和返回数据 Structure视图模式下，所有的请求是以域名进行分类显示的;Sequence视图模式下，会将所有的网络请求都按照访问的时间从上到下进行排序。 抓取https在Mac上安装CA证书:通过顶部菜单选择：Help → SSL Proxying → Install Charles Root Certificate，来安装CA证书。 安卓手机安装Charles证书:在Charles菜单栏里点击Help — SSL Proxying — Save Charles Root Certificate，生成后缀名是.cer的文件，然后传到手机安装。 最后:双击对应证书，打开简介全部信任。 如果还是不行:设置匹配规则，菜单栏 - proxy - ssl proxy settings，重启 模拟限流网络 Proxy → Throttle Setting，勾选Enable Throttling然后在1中选择我们需要网络环境。开启限速之后，2处的小乌龟图标也会高亮，点击小乌龟，就可以关闭限速模式。 重发请求,模拟请求 在网络请求上，右键选择Repeat，即可对这个链接重新发送一遍。右键选择Compose，就可以对这个请求进行编辑。 对网络请求的任意修改后,点击Execute即可将修改后的数据直接发送出去;点击Revert就恢复到最初的数据了。 修改请求响应数据Map适合将所有的A请求，重定向到，B地址请求(Map Remote)或者本地文件(Map Local)。 设置Map Remote或者Map Local可以在，顶部菜单中选择Tools或者请求链接上右键。请求链接上，点击右键save，可以保存请求或者响应的数据文件。 Rewrite功能适合对所有网络请求做一些简单的正则匹配后，对匹配的内容进行替换。 顶部菜单栏中，选择Tools → Rewrite。图中将所有响应体中“查询新闻列表成功”替换成了“我成功啦”。1处可以添加url。 Breakpoints类似于调试的断点。每次触发 Breakpoint 都会断住两次，一次是 request、一次是 response,可以分别对请求和响应的数据进行修改。点击2处execute继续执行。 请求链接上点击右键，然后选择Breakpoints:接下来的相同url会被断点。或者点击1处的六边形，有颜色就开始对接下来的请求依次断点，直至终止。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"http://yoursite.com/tags/Fiddler/"},{"name":"charles","slug":"charles","permalink":"http://yoursite.com/tags/charles/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Vue学习笔记","slug":"13.Vue学习笔记","date":"2019-04-03T13:47:38.218Z","updated":"2019-05-06T14:01:02.442Z","comments":false,"path":"2019/04/03/13.Vue学习笔记/","link":"","permalink":"http://yoursite.com/2019/04/03/13.Vue学习笔记/","excerpt":"","text":"介绍Vue.js是一套构建用户界面的框架，只关注视图层。可以减少不必要的DOM操作，提高渲染效率。 打包工具：WebPack和Gulp 框架：一套完整的技术解决方案，对项目侵入性较大；库（插件）：提供某一小功能，侵入性小。 MVVM是前端视图层的概念，主要关注于视图层分离，把前端的视图层分为三部分，Model、View、VM ViewModel。 引入 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; 实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue_det&quot;&gt; &lt;h1&gt;url : {{url}}&lt;/h1&gt; &lt;h1&gt;{{details()}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el: &apos;#vue_det&apos;, data: { url: &quot;http://www.baidu.com&quot; }, methods: { details: function() { return this.url + &quot; - 百度一下&quot;; } } }) document.write(vm.url) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 文本插值使用双大括号: {{}} Vue调试谷歌应用商店搜索Vue.js devtools 教程https://cn.vuejs.org/v2/guide/ https://github.com/pagekit/vue-resource http://cubic-bezier.com/#.17,.67,.83,.67 指令指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到 DOM 上。 v-cloak解决插值表达式闪烁问题，只替换占位符。 v-textv-text默认没有闪烁问题，替换内容时会把整个元素替换。 v-html用于输出html格式的，也会替换全部内容。 v-bind绑定属性的指令，用于监听DOM事件。v-bind:可以省略为:。变量加常量的效果可以实现。 v-on事件绑定机制。v-on:可以省略为@。 代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; [v-cloak]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-cloak&gt;hh{{msg}}dd&lt;/p&gt; &lt;p v-text=&quot;msg&quot;&gt;fff&lt;/p&gt; &lt;div v-html=&quot;msg2&quot;&gt;&lt;/div&gt; &lt;!--&lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle+&apos;补充信息&apos;&quot;/&gt;--&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; :title=&quot;mytitle+&apos;补充信息&apos;&quot; v-on:click=&quot;show&quot;/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { msg: &apos;欢迎学习Vue&apos;, msg2: &apos;&lt;h1&gt;哈哈哈哈&lt;/h1&gt;&apos;, mytitle:&apos;这是我的title&apos; }, methods:{ show:function(){ alert(&quot;我是弹窗&quot;) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例之跑马灯&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;浪起来&quot; @click=&quot;lang&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;稳住&quot; @click=&quot;stop&quot;/&gt; &lt;h4&gt;{{msg}}&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { msg: &apos;猥琐发育，别浪~~~~~&apos;, intervalId :null }, methods:{ lang:function() { if(this.intervalId != null){ return; } this.intervalId = setInterval(() =&gt;{ var start = this.msg.substring(0,1) var end = this.msg.substring(1) this.msg = end + start },400) }, stop(){ clearInterval(this.intervalId) this.intervalId = null } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-model双向数据绑定，唯一的一个。v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定。 v-model可以实现表单元素和Model中数据双向绑定。 注意:只能用到在input、select、text、checkbox、radio等表单元素中。根据表单上的值，自动更新绑定的元素的值。 v-model实现简单计算器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-model=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;/&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;/&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { n1:0, n2:0, result:0, opt:&quot;+&quot; }, methods:{ calc:function(){ /*switch (this.opt){ case &quot;+&quot;: this.result = parseInt(this.n1)+parseInt(this.n2) break; case &quot;-&quot;: this.result = parseInt(this.n1)-parseInt(this.n2) break; case &quot;*&quot;: this.result = parseInt(this.n1)*parseInt(this.n2) break; case &quot;/&quot;: this.result = parseInt(this.n1)/parseInt(this.n2) break; }*/ var codeStr =&quot;parseInt(this.n1)&quot;+ this.opt + &quot;parseInt(this.n2)&quot; this.result = eval(codeStr) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-forv-for 指令需要以site in sites形式的特殊语法， sites是源数据数组并且site是数组元素迭代的别名。 循环普通数组；循环对象数组；循环对象，包含key，value，和索引；迭代数字，从1开始。 &lt;div id=&quot;app&quot;&gt; &lt;!--循环普通数组--&gt; &lt;p v-for=&quot;item in list&quot;&gt;{{item}}&lt;/p&gt; &lt;p v-for=&quot;(item,i) in list&quot;&gt;索引值是{{i}}&lt;/p&gt; &lt;!--循环对象数组--&gt; &lt;p v-for=&quot;item in list2&quot;&gt;{{item.id}}和{{item.name}}&lt;/p&gt; &lt;p v-for=&quot;(item,i) in list2&quot;&gt;索引值是{{i}}&lt;/p&gt; &lt;!--循环对象--&gt; &lt;p v-for=&quot;val in user&quot;&gt;{{val}}&lt;/p&gt; &lt;p v-for=&quot;(val,key) in user&quot;&gt;{{val}}---{{key}}&lt;/p&gt; &lt;p v-for=&quot;(val,key,i) in user&quot;&gt;{{val}}---{{key}}----{{i}}&lt;/p&gt; &lt;!--迭代数字--&gt; &lt;p v-for=&quot;count in 10&quot;&gt;这是第{{count}}次&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { list:[1,2,3,4,5,6], list2:[ {id:1,name:&quot;a&quot;}, {id:2,name:&quot;b&quot;}, {id:3,name:&quot;c&quot;}, {id:4,name:&quot;d&quot;} ], user:{ id:1, name:&quot;张三&quot;, sex:&quot;男&quot; } } }) &lt;/script&gt; 注意：在2.2.0+的版本里，当在组件中使用v-for时，key是必须的。key属性只能使用number或者string，必须使用v-bind属性绑定的形式，指定key的值。 &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;/p&gt; v-if和v-show根据表达式的值来决定是否插入元素。 v-if每次都会重新删除或者创建元素，切换消耗性能；v-show只是切换了元素display:none样式，较高的初始渲染消耗。 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;flag=!flag&quot; value=&quot;toggle&quot;/&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是v-if控制&lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是v-show控制&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { flag:true } }) &lt;/script&gt; v-else-if和v-else的使用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B &lt;/div&gt; &lt;div v-else&gt; Not A/B &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { type: &apos;C&apos; } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 时间修饰符修饰符是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 .stop阻止事件冒泡 .prevent阻止默认事件 .capture捕获事件 .self只当事件在该元素本身触发时，触发回调。只会阻止自己身上冒泡行为的触发，并不会真正阻止冒泡行为。 .once事件只触发一次 代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .inner{ height: 150px; background-color: darkcyan; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;div1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;百度&lt;/a&gt; &lt;div class=&quot;inner&quot; @click.capture=&quot;div1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;div1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;百度&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { div1:function(){ console.log(&quot;div1click&quot;) }, btn:function(){ console.log(&quot;btnclick&quot;) }, linkClick:function(){ console.log(&quot;btnclick&quot;) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 样式class样式&lt;div id=&quot;app&quot;&gt; &lt;!--直接绑定--&gt; &lt;h1 v-bind:class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,&apos;类名3&apos;]&quot;&gt;&lt;/h1&gt; &lt;!--直接绑定，简写--&gt; &lt;h1 :class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,&apos;类名3&apos;]&quot;&gt;&lt;/h1&gt; &lt;!--三元运算--&gt; &lt;h1 :class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,flag?&apos;类名3&apos;:&apos;&apos;]&quot;&gt;&lt;/h1&gt; &lt;!--嵌套对象--&gt; &lt;h1 :class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,{&apos;类名3&apos;:flag}]&quot;&gt;&lt;/h1&gt; &lt;!--使用对象--&gt; &lt;h1 :class=&quot;{类名1:true,类名2:true,类名3:true}&quot;&gt;&lt;/h1&gt; &lt;!--抽取对象--&gt; &lt;h1 :class=&quot;classObj&quot;&gt;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { flag: true, classObj:{类名1:true,类名2:true,类名3:true} } }) &lt;/script&gt; 内联样式&lt;div id=&quot;app&quot;&gt; &lt;!--直接绑定--&gt; &lt;h1 :style=&quot;{color:&apos;red&apos;,&apos;font-weight&apos;:200}&quot;&gt;哈哈哈&lt;/h1&gt; &lt;!--data--&gt; &lt;h1 :style=&quot;styleObj1&quot;&gt;哈哈哈&lt;/h1&gt; &lt;!--多个data--&gt; &lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;哈哈哈&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { styleObj1 : {color:&apos;red&apos;,&apos;font-weight&apos;:200}, styleObj2 : {&apos;font-style&apos;:&apos;italic&apos;}, } }) &lt;/script&gt; 过滤器Vue允许你自定义过滤器，被用作一些常见的文本格式化。过滤器可以用在两个地方：双括号插值和v-bind表达式，过滤器应该被添加在js表达式的尾部，由管道符(|)提示。 过滤器中function第一个参数已经被规定死了：永远是管道符前面传递过来的数据。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ message | data1 }}&lt;/p&gt; &lt;p&gt;{{ message | data2(\"嘻嘻\")}}&lt;/p&gt; &lt;p&gt;{{ message | data1 | data3}}&lt;/p&gt; &lt;p&gt;{{ message | data4 }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; //方式一：全局过滤器 Vue.filter(&apos;data1&apos;,function(value){ return value+&quot;嘻嘻&quot; }) //方式二：可以多个参数 Vue.filter(&apos;data2&apos;,function(value,arg1){ return value+arg1 }) //方式三：可以多次调用 Vue.filter(&apos;data3&apos;,function(value){ return value+&quot;哈哈&quot; }) new Vue({ el: &apos;#app&apos;, data: { message: &apos;哈哈哈&apos; }, //方式四：私有过滤器 filters: { data4: function (value) { return value+&quot;嘻嘻&quot; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 自定义键盘修饰符Vue.config.keyCodes.f2 = 113 自定义指令和js相关的最好在inserted中执行；和样式相关的，一般在bind中执行。 全局指令和私有指令。自定义指令下的钩子函数。 https://cn.vuejs.org/v2/guide/custom-directive.html vue实例的生命周期生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。生命周期钩子 = 生命周期函数 = 生命周期事件。 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性。 created：实例已经在内存中创建好，此时data和methods已经创建好，此时还没有开始编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数：当data改变时候才会执行 beforeUpdate：状态更新之前执行此函数， 此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource实现网络请求直接在页面中，通过script标签，引入vue-resource的脚本文件,注意：引用的先后顺序是：先引用Vue的脚本文件，再引用vue-resource的脚本文件； 发送get请求： getInfo() { // get 方式获取数据 this.$http.get(&apos;url&apos;).then(res =&gt; { console.log(res.body); }) } 发送post请求： postInfo() { // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, { name: &apos;zs&apos; }, { emulateJSON: true }).then(res =&gt; { console.log(res.body); }); } 发送JSONP请求获取数据： jsonpInfo() { // JSONP形式从服务器获取数据 this.$http.jsonp(url).then(res =&gt; { console.log(res.body); }); } JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程：- 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 除了vue-resource之外，axios也可以实现数据请求。 全局配置 // 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则 不会启用根路径做拼接； Vue.http.options.root = &apos;http://vue.studyit.io/&apos;; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; 品牌案例&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-model=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panle-body form-inline&quot;&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; class=&quot;btn btn-primary&quot; @click=&quot;add&quot; /&gt; &lt;label&gt; 搜素名字关键字: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;keywords&quot; v-focus v-color=&quot;&apos;blue&apos;&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;item in search(keywords)&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td v-text=&quot;item.name&quot;&gt;&lt;/td&gt; &lt;td&gt;{{item.ctime | dateFormat}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&apos;dateFormat&apos;, function (value,pattern) { var dt = new Date(value) var y = dt.getFullYear(); var m = (dt.getMonth()+1).toString().padStart(2,&apos;0&apos;); var d = dt.getDate().toString().padStart(2,&apos;0&apos;); var hh = dt.getHours().toString().padStart(2,&apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2,&apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2,&apos;0&apos;); // return y + &quot;-&quot; + m + &quot;-&quot; + d // return `${y}-${m}-${d}` return `${y}-${m}-${d} ${hh}-${mm}-${ss}` }) //自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 //全局指令 //参数1：指令名称，不要加v-,调用时候加上v- //参数2：对象 Vue.directive(&apos;focus&apos;,{ bind:function(el){//只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 }, inserted:function(el){//inserted表示元素插入到DOM的时候，会执行inserted函数，只触发一次 el.focus() }, update:function(el){//所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 } }) Vue.directive(&apos;color&apos;,{ bind:function(el,binding){//只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 el.style.color = binding.value } }) var vm = new Vue({ el: &quot;#app&quot;, data: { id:&quot;&quot;, name:&quot;&quot;, list:[ {id:1,name:&apos;奔驰&apos;,ctime:new Date()}, {id:2,name:&apos;宝马&apos;,ctime:new Date()} ], keywords:&quot;&quot; }, methods:{ search:function(keywords){ //方法一 // var newList = [] // this.list.forEach(item =&gt; { // if (item.name.indexOf(keywords) != -1){ // newList.push(item) // } // }) // return newList; //方法二 return this.list.filter(item =&gt; { if(item.name.includes(keywords)){ return item } }) }, add:function(){ console.log(&quot;ok&quot;) var car = {id :this.id, name :this.name,ctime :new Date()} this.list.push(car) this.id = this.name = &apos;&apos; }, del:function(id){ //方式一 // this.list.some((item,i) =&gt; { // if(item.id == id){ // this.list.splice(i,1) // return true; // } // }) //方式二 var index = this.list.findIndex(item =&gt; { if(item.id == id){ return true; } }) this.list.splice(index,1) } }, directives:{ &apos;fontweight&apos;:function(el,binding){//等同于写到了bind和update中去了 el.style.fontWeight = binding.value } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的动画使用Vue官方提供的transition元素，把需要被动画控制的元素，包裹起来。v-enter和v-leave-to：是一个时间点，是进入之前，元素的起始状态，此时还没有开始进入。v-enter-active：入场动画的时间段。v-leave-active：离场动画的时间段。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to{ opacity: 0; transform: translateX(150px); } .v-enter-active, .v-leave-active{ transition: all 0.8s ease; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;我是h3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { flag:false } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 自定义v-前缀给transition加个name属性 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .my-enter, .my-leave-to{ opacity: 0; transform: translateX(150px); } .my-enter-active, .my-leave-active{ transition: all 0.8s ease; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;transition name=&quot;my&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;我是h3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { flag:false } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用第三方animate.css类库实现动画官网 https://daneden.github.io/animate.css/ 举个栗子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/animate.css@3.5.2/animate.min.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :duration=&quot;{ enter: 200, leave: 400}&quot;&gt; &lt;h3 v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;我是h3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { flag:false } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 动画钩子https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90 动画钩子函数的第一个参数：el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象。可以认为，el是通过document.getElementById(‘’) 方式获取到的原生JS DOM对象。 beforeEnter 表示动画入场之前，此时，动画尚未开始，可以在beforeEnter中，设置元素开始动画之前的起始样式 enter表示动画开始之后的样式，这里可以设置小球完成动画之后的，结束状态 el.offsetWidth没有实际的作用，但是，如果不写，出不来动画效果 done，起始就是afterEnter这个函数，也就是说：done是afterEnter函数的引用 动画完成之后，会调用afterEnter 举个例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .ball { width: 15px; height: 15px; border-radius: 50%; background-color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;购物车&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { flag:false }, methods: { beforeEnter: function (el) { el.style.transform = &quot;translate(0, 0)&quot; }, enter: function (el, done) { el.offsetWidth el.style.transform = &quot;translate(150px, 450px)&quot; el.style.transition = &apos;all 1s ease&apos; done() }, afterEnter: function (el) { this.flag = !this.flag } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-for的列表过渡在实现列表过渡的时候，如果需要过渡的元素，是通过v-for循环渲染出来的，不能使用transition包裹，需要使用transitionGroup。如果要为 v-for循环创建的元素设置动画，必须为每一个元素设置 :key 属性。给transition-group添加appear属性，实现页面刚展示出来时候，入场时候的效果。通过为transition-group元素，设置tag属性，指定transition-group渲染为指定的元素，如果不指定tag属性，默认渲染为span标签。 &lt;transition-group&gt;组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的v-move特性，它会在元素的改变定位的过程中应用。v-move和v-leave-active结合使用，能够让列表的过渡更加平缓柔和。 举个例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li { border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; } li:hover { background-color: hotpink; transition: all 0.8s ease; } .v-enter, .v-leave-to { opacity: 0; transform: translateY(80px); } .v-enter-active, .v-leave-active { transition: all 0.6s ease; } .v-move { transition: all 0.6s ease; } .v-leave-active { position: absolute; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; {{item.id}} --- {{item.name}} &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { id: &apos;&apos;, name: &apos;&apos;, list: [ {id: 1, name: &apos;Tom&apos;}, {id: 2, name: &apos;Jim&apos;}, {id: 3, name: &apos;Lucy&apos;} ] }, methods: { add: function () { this.list.push({id: this.id, name: this.name}) this.id = this.name = &apos;&apos; }, del: function (i) { this.list.splice(i, 1) } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件组件：以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可。 组件化：是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 模块化：是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一。 全局组件定义的三种方式&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;my-com1&gt;&lt;/my-com1&gt; &lt;mycom1&gt;&lt;/mycom1&gt; &lt;mycom2&gt;&lt;/mycom2&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;mycom4&gt;&lt;/mycom4&gt; &lt;/div&gt; &lt;!-- 在被控制的 #app 外面,使用template元素,定义组件的HTML模板结构 --&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;h4&gt;好用,不错!&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //方式一： //1.1 使用 Vue.extend 来创建全局的Vue组件 var com1 = Vue.extend({ template: &apos;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&apos; // 通过 template 属性，指定了组件要展示的HTML结构 }) // 1.2 使用 Vue.component(&apos;组件的名称&apos;, 创建出来的组件模板对象) Vue.component(&apos;myCom1&apos;, com1) // 如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 链接； // 如果不使用驼峰,则直接拿名称来使用即可; Vue.component(&apos;mycom1&apos;, com1) // Vue.component 第一个参数:组件的名称,将来在引用组件的时候,就是一个 标签形式 来引入 它的；第二个参数: Vue.extend 创建的组件 Vue.component(&apos;mycom2&apos;, Vue.extend({ template: &apos;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&apos; })) //方式二： // 注意:不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素 Vue.component(&apos;mycom3&apos;, { template: &apos;&lt;div&gt;&lt;h3&gt;这是直接使用 Vue.component 创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;&apos; }) // 方式三： Vue.component(&apos;mycom4&apos;, { template: &apos;#tmpl&apos; }) var vm = new Vue({ el: &apos;#app&apos; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意:不论是哪种方式创建出来的组件,组件的template属性指向的模板内容,必须有且只能有唯一的一个根元素。 私有组件定义通过components定义私有组件： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;template id=&quot;tmpl2&quot;&gt; &lt;h3&gt;这是私有组件&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, components: { // 定义实例内部私有组件的 login: { //方式一： // template: &apos;&lt;h3&gt;这是私有组件&lt;/h3&gt;&apos;, //方式二： template: &apos;#tmpl2&apos; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件中的data和methods 组件可以有自己的data数据，实例中的data可以为一个对象,但是组件中的data必须是一个方法，这个方法内部,还必须返回一个对象才行。组件中 的data数据,使用方式,和实例中的data使用方式完全一样。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;+1&quot; @click=&quot;increment&quot;&gt; &lt;h3&gt;{{count}}&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component(&apos;counter&apos;, { template: &apos;#tmpl&apos;, data: function () { // return dataObj return { count: 0 } }, methods: { increment() { this.count++ } } }) var vm = new Vue({ el: &apos;#app&apos; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件切换v-if方式切换： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=true&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt;&lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }) Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }) var vm = new Vue({ el: &apos;#app&apos;, data: { flag: false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用component元素实现：component是一个占位符,:is属性可以用来指定要展示的组件的名称 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }) Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }) var vm = new Vue({ el: &apos;#app&apos;, data: { comName: &apos;login&apos; // 当前 component 中的 :is 绑定的组件的名称 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件切换动画 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/animate.css@3.5.2/animate.min.css&quot;/&gt; &lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateX(150px); } .v-enter-active, .v-leave-active { transition: all 0.5s ease; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;!-- 通过 mode 属性,设置组件切换时候的模式 --&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }) Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }) var vm = new Vue({ el: &apos;#app&apos;, data: { comName: &apos;login&apos; // 当前 component 中的 :is 绑定的组件的名称 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父组件向子组件传值组件中，默认无法访问到父组件中的data上的数据和methods中的方法。父组件可以在引用子组件的时候，通过属性绑定v-bind:的形式, 把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用。组件中的所有props中的数据，都是通过父组件传递给子组件的。 注意：props中的数据，都是只读的，无法重新赋值。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;com1 v-bind:parentmsg=&quot;msg&quot;&gt;&lt;/com1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { msg: &apos;这是父组件中的数据&apos; }, components: { com1: { template: &apos;&lt;h1 @click=&quot;change&quot;&gt;这是子组件 --- {{ parentmsg }}&lt;/h1&gt;&apos;, props: [&apos;parentmsg&apos;]// 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父组件向子组件传方法父组件向子组件传递方法，使用的是事件绑定机制：v-on, 当我们自定义了一个事件属性之后，那么子组件就能够通过某些方式，来调用传递进去的 这个方法了。子组件通过$emit调用父组件方法。 子组件调用父组件的方法，并传值： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;子组件按钮-触发父组件传递过来的方法&quot; @click=&quot;myclick&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var com2 = { template: &apos;#tmpl&apos;, data() { return { sonmsg: { name: &apos;子组件data&apos;, age: 16 } } }, methods: { myclick() { this.$emit(&apos;func&apos;, this.sonmsg) } } } var vm = new Vue({ el: &apos;#app&apos;, data: { datamsgFormSon: null }, methods: { show(data) { this.datamsgFormSon = data console.log(this.datamsgFormSon) } }, components: { com2 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件案例-评论功能实现存放在localStorage中。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;cmt-box @func=&quot;loadComments&quot;&gt;&lt;/cmt-box&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;span class=&quot;badge&quot;&gt;评论人： {{ item.user }}&lt;/span&gt; {{ item.content }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;发表评论&quot; class=&quot;btn btn-primary&quot; @click=&quot;postComment&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = { data() { return { user: &apos;&apos;, content: &apos;&apos; } }, template: &apos;#tmpl&apos;, methods: { postComment() { var comment = { id: Date.now(), user: this.user, content: this.content } // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) list.unshift(comment) // 重新保存最新的 评论数据 localStorage.setItem(&apos;cmts&apos;, JSON.stringify(list)) this.user = this.content = &apos;&apos; this.$emit(&apos;func&apos;) } } } var vm = new Vue({ el: &apos;#app&apos;, data: { list: [] }, created(){ this.loadComments() }, methods: { loadComments() { // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) this.list = list } }, components: { &apos;cmt-box&apos;: commentBox } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过refs获取元素和组件&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素&quot; @click=&quot;getElement&quot; ref=&quot;mybtn&quot;&gt; &lt;h3 ref=&quot;myh3&quot;&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;login ref=&quot;mylogin&quot;&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;, data() { return { msg: &apos;son msg&apos; } }, methods: { show() { console.log(&apos;调用了子组件的方法&apos;) } } } var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: { getElement() { console.log(this.$refs.myh3.innerText) console.log(this.$refs.mylogin.msg) this.$refs.mylogin.show() } }, components: { login } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 路由后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由。 网站介绍 https://router.vuejs.org/zh/ 基本使用router-view是vue-router提供的元素，专门用来当作占位符的，匹配到的组件，就会展示到router-view中去。 routes:路由匹配规则，每个路由规则，都是一个对象，有两个必须的属性： 属性1是path，表示监听哪个路由链接地址；属性2是component，表示，如果路由是前面匹配到的path，则展示component属性对应的那个组件。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; } var register = { template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; } var routerObj = new VueRouter({ routes: [ {path: &apos;/login&apos;, component: login}, {path: &apos;/register&apos;, component: register} ] }) var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; router-link&lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 重定向routes: [ // 路由匹配规则 { path: &apos;/&apos;, redirect: &apos;/login&apos; }, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 { path: &apos;/login&apos;, component: login }, { path: &apos;/register&apos;, component: register } ] 选中路由高亮方式一：router-link标签中，默认情况 &lt;style&gt; .router-link-active{ color: red; font-weight: 800; font-style: italic; font-size: 18px; text-decoration: underline; } &lt;/style&gt; 方式二：修改router-link-active为myactive，然后再定义样式 var routerObj = new VueRouter({ linkActiveClass: &apos;myactive&apos; }) 路由传参方式一：query方式传递参数 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;登录组件 --- {{ $route.query.id }} --- {{ $route.query.name }}&lt;/h1&gt;&apos;, created(){ // 组件的生命周期钩子函数 console.log(this.$route.query.id) } } var register = { template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; } var routerObj = new VueRouter({ routes: [ {path: &apos;/login&apos;, component: login} ] }) var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方式二：params方式传递参数 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login/10/zs&quot;&gt;登录&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;登录组件 --- {{ $route.params.id }} --- {{ $route.params.name }}&lt;/h1&gt;&apos;, created(){ // 组件的生命周期钩子函数 console.log(this.$route.params.id) } } var register = { template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; } var routerObj = new VueRouter({ routes: [ {path: &apos;/login/:id/:name&apos;, component: login} ] }) var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 路由嵌套使用children属性，实现子路由。同时，子路由的path前面，不要带/，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var account = { template: &apos;#tmpl&apos; } var login = { template: &apos;&lt;h3&gt;登录&lt;/h3&gt;&apos; } var register = { template: &apos;&lt;h3&gt;注册&lt;/h3&gt;&apos; } var router = new VueRouter({ routes: [ { path: &apos;/account&apos;, component: account, children: [ { path: &apos;login&apos;, component: login }, { path: &apos;register&apos;, component: register } ] } ] }) var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 命名视图实现经典布局&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html, body { margin: 0; padding: 0; } .header { background-color: orange; height: 80px; } h1 { margin: 0; padding: 0; font-size: 16px; } .container { display: flex; height: 600px; } .left { background-color: lightgreen; flex: 2; } .main { background-color: lightpink; flex: 8; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var header = { template: &apos;&lt;h1 class=&quot;header&quot;&gt;Header头部区域&lt;/h1&gt;&apos; } var leftBox = { template: &apos;&lt;h1 class=&quot;left&quot;&gt;Left侧边栏区域&lt;/h1&gt;&apos; } var mainBox = { template: &apos;&lt;h1 class=&quot;main&quot;&gt;mainBox主体区域&lt;/h1&gt;&apos; } var router = new VueRouter({ routes: [ { path: &apos;/&apos;, components: { &apos;default&apos;: header, &apos;left&apos;: leftBox, &apos;main&apos;: mainBox } } ] }) var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; watch可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { firstname: &apos;&apos;, lastname: &apos;&apos;, fullname: &apos;&apos; }, methods: {}, watch: { &apos;firstname&apos;: function (newVal, oldVal) { // this.fullname = this.firstname + &apos;-&apos; + this.lastname this.fullname = newVal + &apos;-&apos; + this.lastname }, &apos;lastname&apos;: function (newVal) { this.fullname = this.firstname + &apos;-&apos; + newVal } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; watch监视路由地址的改变 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h3&gt;这是登录子组件&lt;/h3&gt;&apos; } var register = { template: &apos;&lt;h3&gt;这是注册子组件&lt;/h3&gt;&apos; } var router = new VueRouter({ routes: [ { path: &apos;/&apos;, redirect: &apos;/login&apos; }, { path: &apos;/login&apos;, component: login }, { path: &apos;/register&apos;, component: register } ] }) var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, // router: router router, watch: { &apos;$route.path&apos;: function (newVal, oldVal) { // console.log(newVal + &apos; --- &apos; + oldVal) if (newVal === &apos;/login&apos;) { console.log(&apos;欢迎进入登录页面&apos;) } else if (newVal === &apos;/register&apos;) { console.log(&apos;欢迎进入注册页面&apos;) } } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; computed计算属性计算属性关键词:computed。computed是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用methods，在重新渲染的时候，函数总会重新调用执行。 在computed中，可以计算属性，本质是一个方法，只不过，我们在使用这些计算属性的时候，是把它们的名称，直接当作属性来使用的,并不会把计算属性，当作方法去调用。 可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;middlename&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname: &apos;&apos;, lastname: &apos;&apos;, middlename: &apos;&apos; }, methods: {}, computed: { &apos;fullname&apos;: function () { console.log(&apos;ok&apos;) return this.firstname + &apos;-&apos; + this.middlename + &apos;-&apos; + this.lastname } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； webpackwebpack可以解决各个包之间的复杂依赖关系。webpack是基于Node.js开发出来的一个前端项目自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 使用Gulp，是基于task任务的；使用Webpack，是基于整个项目进行构建的。 官网 http://webpack.github.io/ webpack安装的两种方式运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 配置文件打包命令创建webpack.config.js文件： // 导入处理路径的模块 var path = require(&apos;path&apos;); // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.join(__dirname, &apos;src/js/main.js&apos;), // 项目入口文件 output: { // 配置输出选项 path: path.join(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 } } 最后控制台执行webpack。 webpack-dev-server实时打包构建使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 在package.json文件中，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，然后执行npm run dev,发现可以进行实时打包。 但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快。 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了直接访问到index首页，可以指定启动的根目录： &quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 配置package.json修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新，--contentBase src表示直接访问到index首页： &quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open --contentBase src&quot; 配置webpack.config.jswebpack.config.js文件，新增devServer节点如下： devServer:{ hot:true, open:true, port:4321, contentBase:&apos;src&apos; } 在头部引入webpack模块： var webpack = require(&apos;webpack&apos;); 在plugins节点下新增： plugins:[ new webpack.HotModuleReplacementPlugin() ]","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"微信小程序开发","slug":"9.微信小程序开发","date":"2019-02-17T13:22:06.325Z","updated":"2019-04-21T09:02:15.483Z","comments":false,"path":"2019/02/17/9.微信小程序开发/","link":"","permalink":"http://yoursite.com/2019/02/17/9.微信小程序开发/","excerpt":"","text":"调试器断点调试 设置好断点，点击编译，会执行断点，查看Watch可以查看数据。 Stroage缓存信息 AppData页面信息 打印日志console.log(&quot;我是log&quot;) 结构.js配置页面入口，wxml配置页面UI，.json页面的配置文件，wxss类似于css样式。内部的.json和wxss会覆盖外面的。 app.json配置页面&quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ] app.js定义了页面的入口App({ /** * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */ onLaunch: function () { }, /** * 当小程序启动，或从后台进入前台显示，会触发 onShow */ onShow: function (options) { }, /** * 当小程序从前台进入后台，会触发 onHide */ onHide: function () { }, /** * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 */ onError: function (msg) { } }) index.js自己页面的配置Page({ /** * 页面的初始数据 */ data: { }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** * 生命周期函数--监听页面显示 */ onShow: function () { }, /** * 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** * 生命周期函数--监听页面卸载 */ onUnload: function () { }, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** * 用户点击右上角分享 */ onShareAppMessage: function () { } }) index.wxml页面的布局文件视图和渲染组件https://developers.weixin.qq.com/miniprogram/dev/component/ 在wxml中 &lt;text&gt;这里是文本内容&lt;/text&gt; &lt;button type=&quot;default&quot; hover-class=&quot;other-button-hover&quot;&gt; default &lt;/button&gt; &lt;button type=&quot;primary&quot;&gt; primary &lt;/button&gt; 数据绑定在wxml中 &lt;button type=&quot;primary&quot;&gt; {{btnText}} &lt;/button&gt; &lt;text&gt;{{text}}&lt;/text&gt; 在js中 data: { text:&quot;这里是text内容&quot;, btnText:&quot;这里是btn内容&quot; }, 动态绑定wxml中 &lt;text&gt;{{text}}&lt;/text&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;btnClick&quot;&gt; 点击 &lt;/button&gt; js中，在page下 btnClick : function(){ this.setData({ text:&quot;这是新的内容&quot; }) } 两种渲染标签if、else wxml中 &lt;view wx:if=&quot;{{show}}&quot;&gt; {{text}} 1 &lt;/view&gt; &lt;view wx:else=&quot;{{show}}&quot;&gt; {{text}} 2 &lt;/view&gt; js中 var isShow = this.data.show; this.setData({ text: &quot;这是新的内容&quot;, show : !isShow }) for wxml中 &lt;view wx:for=&quot;{{news}}&quot; wx:for-item=&quot;items&quot; wx:for-index=&quot;ix&quot; &gt; {{ix}}-{{items}} &lt;/view&gt; js中 var newsdata = this.data.news; newsdata.shift(); this.setData({ text: &quot;这是新的内容&quot;, show: !isShow,news:newsdata }) 模板使用wxml中引入公共的wxml &lt;include src=&quot;../templates/header&quot; /&gt; 事件点击tab、长按longtab、触摸（touchstart,touchend,touchmove,touchcancle）等 事件冒泡：点击子view，它本身和他的所有父view都会相应，包括点击，长按，触摸事件。其他都是非冒泡事件。 事件的绑定：bind绑定和catch绑定。比如点击事件bindtap和catchtab，区别就是bindtap会事件冒泡，catchtap不会事件冒泡。 事件的对象：类型type，时间戳timeStamp，事件源组件target，当前组件currentTarget，触摸点数touches，dataset等，代码： btnClick : function(event){ console.log(event); }) 案例点击按钮查询，查询输入框中内容 遇到的问题 https://www.cnblogs.com/wholeworld/p/8361577.html 做好后的效果图 app.json中配置页面，app.js中设置网路，代码 getNameInfo: function (name,cb){ wx.request({ url: &apos;https://shanghaicity.openservice.kankanews.com/citizen/repeat?name=&apos;+name, //接口地址 data: { x: &apos;&apos;, y: &apos;&apos; }, header: { &apos;content-type&apos;: &apos;application/json&apos; // 默认值 }, success(res) { //console.log(res.data) cb(res.data) } }) } 页面wxml &lt;view class=&quot;container&quot;&gt; &lt;input placeholder=&quot;请输入您的姓名&quot; bindinput=&quot;nameInput&quot;&gt;&lt;/input&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;btnSearch&quot;&gt;查询&lt;/button&gt; &lt;text wx:if=&quot;{{isShow}}&quot;&gt;查询到上海市姓名是{{resultInfo.name}}的人数为{{resultInfo.count}}人&lt;/text&gt; &lt;/view&gt; 页面wxss input{ border: 1px solid red; width: 90%; margin: 5%; padding: 5px; } text{ margin-top: 20px; } 页面js var app = getApp() Page({ /*** 页面的初始数据 */ data: { myName:null, resultInfo:null, isShow:false }, btnSearch : function(){ var thispage = this; //console.log(this.data.myName) app.getNameInfo(this.data.myName, function (data) {//结果：{count: 0, name: &quot;萧何&quot;} //console.log(data) thispage.setData({resultInfo : data}) thispage.setData({ isShow: true }); }); }, nameInput : function(e){ this.setData({myName:e.detail.value}) } }) 配置页面配置，全局配置，tabBar配置，网络超时配置，debug开启配置 全局配置和页面配置 https://developers.weixin.qq.com/miniprogram/dev/framework/config.html 页面json中配置window可以覆盖全局window配置。 tabBar配置 https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html 比如 { &quot;tabBar&quot;: { &quot;custom&quot;: true, &quot;color&quot;: &quot;#000000&quot;, &quot;selectedColor&quot;: &quot;#000000&quot;, &quot;backgroundColor&quot;: &quot;#000000&quot;, &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;page/component/index&quot;, &quot;text&quot;: &quot;组件&quot;, &quot;iconPath&quot;:&quot;images/icon1.png&quot;, &quot;selectedIconPath&quot;:&quot;images/icon2.png&quot; }, { &quot;pagePath&quot;: &quot;page/API/index&quot;, &quot;text&quot;: &quot;接口&quot;, &quot;iconPath&quot;:&quot;images/icon3.png&quot;, &quot;selectedIconPath&quot;:&quot;images/icon4.png&quot; } ] }, &quot;usingComponents&quot;: {} } 在app.json中配置debug &quot;debug&quot;:true","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"IconFont在Android中的使用介绍","slug":"8.IconFont在Android中的使用介绍","date":"2019-01-25T11:52:51.881Z","updated":"2019-02-11T12:53:43.784Z","comments":false,"path":"2019/01/25/8.IconFont在Android中的使用介绍/","link":"","permalink":"http://yoursite.com/2019/01/25/8.IconFont在Android中的使用介绍/","excerpt":"","text":"iconfont介绍常用iconfont字体库 https://www.iconfont.cn/ http://fontawesome.dashgame.com/ https://ionicons.com/ 优点： 1.IconFont是矢量图标,可以随意设置大小。 2.体积小可以减小APK的体积。 3.一套图标资源可以在不同平台使用(android ,ios,web) 4.很容易实现图文混排，因为都是Icon也被看做为文字. 缺点： 1.添加图标是需要重新制作ttf文件 2.只能支持单色（不支持渐变色图标） ttf文件中每个图片对应的一个unicode码。TextView设置文字的时候，使用对应的unicode码就能显示出图片。 具体使用下载iconfont.ttf文件，放在项目main/assets/iconfont/下 方式一xml中 &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/home&quot; android:textColor=&quot;@android:color/holo_orange_light&quot; android:textSize=&quot;50sp&quot; /&gt; strings中Unicode &lt;string name=&quot;home&quot;&gt;&amp;#xe664;&lt;/string&gt; 最后直接设置 Typeface iconfont1 = Typeface.createFromAsset(getAssets(), &quot;iconfont/iconfont.ttf&quot;); TextView textview1 = findViewById(R.id.tv1); textview1.setTypeface(iconfont1); 方式二自定义TextView public class IconFontView extends AppCompatTextView { private Context context; private boolean isFirst = true; private String text; private int textColor; private String clicked_text; private int clicked_textColor; public IconFontView(Context context) { this(context, null); } public IconFontView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public IconFontView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); this.context = context; init(attrs); } /** 初始化 */ private void init(AttributeSet attrs){ // 设置字体类型 setTypeface(Typeface.createFromAsset(context.getAssets(), &quot;iconfont/iconfont.ttf&quot;)); // 获取配置信息（text &amp;&amp; textColor） getAttrs(attrs); } /** 获得配置信息 */ private void getAttrs(AttributeSet attrs) { TypedArray taCustom = context.obtainStyledAttributes(attrs, R.styleable.IconFontViewAttr); clicked_text = taCustom.getString(R.styleable.IconFontViewAttr_clicked_text); clicked_textColor = taCustom.getColor(R.styleable.IconFontViewAttr_clicked_textColor, 0); taCustom.recycle(); } @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_DOWN){ text = getText().toString(); textColor = getCurrentTextColor(); } return super.onTouchEvent(event); } @Override protected void dispatchSetPressed(boolean pressed) { super.dispatchSetPressed(pressed); if (isDuplicateParentStateEnabled()) { if (pressed){ if(clicked_text != null) this.setText(clicked_text); if(clicked_textColor != 0) this.setTextColor(clicked_textColor); }else { this.setText(text); this.setTextColor(textColor); } } } } 在res/values/attrs中定义属性 &lt;!-- IconFontView属性 --&gt; &lt;declare-styleable name=&quot;IconFontViewAttr&quot;&gt; &lt;attr name=&quot;clicked_text&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;clicked_textColor&quot; format=&quot;color&quot; /&gt; &lt;/declare-styleable&gt; 使用 &lt;com.example.iconfont.IconFontView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hot&quot; android:textColor=&quot;@android:color/holo_red_dark&quot; android:textSize=&quot;50sp&quot; /&gt; strings中Unicode &lt;string name=&quot;hot&quot;&gt;&amp;#xe614;&lt;/string&gt; 补充可以图文混用 &lt;string name=&quot;my&quot;&gt;我可以图文混用&amp;#xe624;啦！！&lt;/string&gt; 使用阿里iconfont可以在demo_index.html文件中查找对应的Unicode fontawesome查找Unicode对照表 https://fontawesome.com/cheatsheet?from=io","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"IconFont","slug":"IconFont","permalink":"http://yoursite.com/tags/IconFont/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"快速入门和详解kotlin","slug":"7.快速入门kotlin","date":"2019-01-23T12:10:22.179Z","updated":"2020-08-05T15:24:37.982Z","comments":false,"path":"2019/01/23/7.快速入门kotlin/","link":"","permalink":"http://yoursite.com/2019/01/23/7.快速入门kotlin/","excerpt":"","text":"快速入门1、资料官方文档 https://kotlinlang.org/docs/reference/ Kotlin源码 https://github.com/JetBrains/kotlin Kotlin官博 https://blog.jetbrains.com/kotlin/ Kotlin微信公众号 Kotlin 2、HelloWorld第一种写法 fun main(args: Array&lt;String&gt;) { println(&quot;Hello World&quot;) } 第二种写法 object HelloWorld { @JvmStatic fun main(args: Array&lt;String&gt;) { println(&quot;Hello&quot;) } } 第三种写法 class HelloWorld { companion object { @JvmStatic fun main(args: Array&lt;String&gt;) { println(&quot;Hello&quot;) } } } 3、基本类型定义var s : String = &quot;Hello&quot; var stringA = &quot;Hello&quot; var int = 5 基本数据类型的定义可以加类型，也可以不加。 lateinit延迟初始化成员变量，先不赋值 private lateinit var string : String val延迟初始化用lazy，使用的时候再赋值 val ss : String by lazy { &quot;赋值&quot; } 数据类型转换 .toInt() .toFloat() 字符串比较 == .equals() 4、定义finalconst val stringB = &quot;Hello&quot; val stringC = &quot;Hello&quot; var是一个可变变量,val是一个只读变量，可以省略类型。 const只能用在顶级属性，以及object对象的属性中（伴随对象也是obejct）。 const val就相当于Java中的final，编译期常量。 5、占位符&quot;${}&quot;var stringG = &quot;IamG&quot; var stringF = &quot;${stringG}&quot; + &quot;dd&quot; println(stringF)//IamGdd 6、数组和遍历val names: Array&lt;String&gt; = arrayOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) val emptyStrings: Array&lt;String?&gt; = arrayOfNulls(10) String?表示可以为null的String类型 基本数据类型定制版 val ints = intArrayOf(1, 3, 5) 基本操作 names.isNotEmpty() //判断空 names.length //数组的长度 names[i] = &quot;Hello&quot; //给第i个成员赋值 print array[i] //输出第i个成员 for遍历(注意..和until) val ints = intArrayOf(1, 3, 5, 7, 9) for (int in ints) { println(int) } for (i in ints.indices){ print(ints[i]) } for ((index,value) in ints.withIndex()){ println(&quot;$index -&gt; $value&quot;) } for (indexedValue in strArrays.withIndex()){ println(&quot;${indexedValue.index} -&gt; ${indexedValue.value}&quot;) } for (i in IntRange(0, ints.size - 1)) { print(ints[i]) } for (i in 0..ints.size - 1) { print(ints[i]) } for (i in 0 until ints.size) { print(ints[i]) } //Lambda方式遍历 ints.forEach{ println(it) } ints.forEach(::println) 7、list和mapvar lists = listOf &lt;String&gt;(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;) for (list in lists) { println(list) } for ((index, valu) in lists.withIndex()) {//角标从零开始，角标和值 println(index.toString() + &quot;-----&quot; + valu) } var map = TreeMap&lt;String, String&gt;() map[&quot;姓名&quot;] = &quot;张三&quot; map[&quot;性别&quot;] = &quot;男&quot; map[&quot;年龄&quot;] = &quot;18&quot; map[&quot;爱好&quot;] = &quot;游泳&quot; 8、静态变量、方法companion object { } 9、方法函数定义方法带参及返回类型 fun stringD(string : String):Boolean{ //... return true } 参数个数不固定 fun stringE(vararg names: String){ } stringE(*Ints) 简化写法 fun add(num1 : Int ,num2 : Int) : Int{ return num1 + num2 } fun add(num1 : Int ,num2 : Int) = num1 + num2 函数作为变量使用 var d = add(1,2) val add = fun(num1: Int, num2: Int): Int { return num1 + num2 } 10、when表达式when用来代替switch fun checkScore(score: Int) : String { var str = when (score) { 100 -&gt;&quot;满分&quot; 99 -&gt; &quot;继续加油&quot; else -&gt;&quot;看好你哦&quot; } return str } 11、实例化类和class实例var data = Date() 不需要new 获得class的实例的两种方式 val clazz1 = DD::class.java val dd = DD() val clazz2 = dd.javaClass 12、继承class Son : Father(){ override fun action(){ //... } } 13、AS转化as中直接转换：两次shift后输入Convert Java File to Kotlin File。 14、Lambda函数入参 -&gt; 返回值 val add = fun(num1: Int, num2: Int): Int { return num1 + num2 } //可以写成 val add = { num1: Int, num2: Int -&gt; num1 + num2 } 过滤空后的输出结果 var strArrays = arrayOf(&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;) strArrays.filter { it.isNotEmpty() }.forEach{ println(it)} 15、空安全String?表示可以为null的String类型。!!表示自己判断不会出现null，但如果出现了null会崩溃。？表示可能会返回null，不会崩溃。 var string: String? = null var len1 = string?.length var len2 = string!!.length//最终会崩溃 16、类 类的创建 class Person(val name:String,val age:Int) 构造方法 class Person(var name: String?, var age:Int) { constructor(name: String):this(name,0) constructor():this(null,0) } get和set var name: String? = null private set// 私有掉set方法 var age: Int = 0 get() { return if (field &lt; 0) 0 else field }//field就是age 类的继承 class QQStepView : View { constructor(context:Context):this(context,null) constructor(context:Context,attrs: AttributeSet?):this(context,attrs,0) constructor(context:Context,attrs: AttributeSet?,defStyleAttr:Int):super(context,attrs,defStyleAttr{ // 写内容 获取自定义属性的内容 } } 或者 class QQStepView(context: Context?, attrs: AttributeSet?) : View(context, attrs) 匿名内部类 //匿名内部类 object:xxx httpUtils.get(object: HttpCallback(){ override fun onError(e: IOException) { } override fun onSuccess() { Log.e(&quot;TAG&quot;,&quot;onSuccess&quot;)} }) 17、运算符重载 class Counter(val dayIndex: Int){ // 操作符重载 + operator fun plus(counter: Counter):Counter{ return Counter(dayIndex+counter.dayIndex) } // 操作符重载 - operator fun minus(counter: Counter):Counter{ return Counter(dayIndex-counter.dayIndex) } } 18、方法扩展 // 对类方法进行扩展 val str = &quot;abc&quot; var strMulit = str.mulit(3) Log.e(&quot;TAG&quot;,&quot;strMulit = $strMulit&quot;) // 对一个类的方法进行扩展 operator fun String.mulit(number: Int): String { val stringBuilder = StringBuilder() for (num in 1..number){ stringBuilder.append(this) } return stringBuilder.toString() } 详解kotlin1、数据类型和函数==和=====表示比较内容，类似于java的equals；===表示比较对象是否相同。 open继承如果一个类允许被继承，那么需要使用open声明。方法想被重写也是要加open。 open class People(name: String, sex: String) { } class Man(name: String, sex: String) : People(name, sex) { } initinit代码比构造函数先执行。 open class People(name: String, sex: String) { init { } } isis类似于java中的instance of。 as父类向下转为子类as类型转换，失败则抛异常，as?如果转换失败，则返回null,不抛异常。 val child : Child? = parent as? Child 只能类型转化：父类对象直接引用子类的成员。 Any父类和Unit返回值Any是Kotlin中的父类，类似于java中的Object。 没有返回值时候，其实返回的是Unit，相当于java中的void。 引用包名导包时候替换其他名字 import 包名...类名1 as xxx val name : xxx = xxx() rangerange表示范围，ClosedRange的子类 0..100 表示 [0,100] 0 until 100 表示 [0,100) i in 0..100 判断i是否在[0,100]中 类中的toStringopen class People(var name: String, var sex: String) { override fun toString(): String { return name + sex } } get和set方法默认已经实现了get/set方法，如果要做处理 class Woman{ var nameA : String = &quot;翠花&quot; get() { print(&quot;get方法&quot;) return field } set(value) { print(&quot;set方法&quot;) field = value } } if可以作为表达式if可以直接作为表达式 val nameB = if (true){ &quot;NameB&quot; } else { &quot;NameBB&quot; } try...catch、when等也可以作为表达式。 标签Outter@for ((index,value) in strArrays.withIndex()){ println(&quot;$index -&gt; $value&quot;) Inner@for (indexedValue in strArrays.withIndex()){ if (...){ break@Outter } } } 接口代理interface Child { fun play() } interface Parent { fun eat() } class People : Child, Parent { override fun play() { } override fun eat() { } } class People1(child: Child,parent: Parent) : Child by child, Parent by parent object类只有一个实例的类；不能自定义构造方法；可以实现接口，继承父类；本质上就是单例模式的最基本实现。 object FF { val ffv : String = &quot;ff&quot; } 静态方法和成员companion object包裹起来静态方法；@JvmStatic和@JvmField加上后，java去调用更方便。 class HelloWorld { @JvmField val TAG : String = &quot;TAG&quot; companion object { @JvmStatic fun main(args: Array&lt;String&gt;) { println(&quot;Hello&quot;) } } } 方法重载方法重载可以用方法上的默认参数代替，想给java用可以加上@JvmOverloads。 @JvmOverloads fun sum(a: Int = 2, b: Int): Int { return a + b } data class类可以定义javabean，自动toString了。 填坑： apply plugin: &apos;kotlin-noarg&apos; apply plugin: &apos;kotlin-allopen&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-noarg:$kotlin_version&quot; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-allopen:$kotlin_version&quot; noArg{ annotation(&quot;xxxx&quot;) } 内部类java定义内部类，默认持有外部类的引用，除非定义为静态的内部类。 Kotlin中内部类默认是静态内部类，inner定义的是非静态内部类 inner class Inner{ } 匿名内部类可以继承父类或者实现多个接口 interface OnClickListener { fun onClick() } class View { var onclick: OnClickListener? = null } val view = View() view.onclick = object : OnClickListener{ override fun onClick() { } } 2、高阶函数对每个元素操作返回新的list val list = listOf(1, 3, 5, 7, 9, 11) val newList = list.map { it * 2 + 3 } 还有 forEach、map、flatMap、reduce、fold、filter、takeWhile、 let、apply、with、use、 joinToString 尾递归 tailrec 3、协程协作程序，解决异步问题。 高阶函数如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数的话，那么该函数就称为高阶函数。 扩展函数-&gt;参考上文，18、方法扩展。 定义函数变量,-&gt;左边是参数类型，右边是返回值，Unit相当于void，无返回值： val a: (String, Int) -&gt; Unit 定义函数 fun num1Andnum2(num1: Int, num2: Int, operation: (Int, Int) -&gt; Int): Int { return operation(num1, num2) }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"强引用、软引用、弱引用、幻象引用","slug":"6.强引用、软引用、弱引用、幻象引用","date":"2019-01-17T12:43:29.131Z","updated":"2019-11-04T13:49:13.910Z","comments":false,"path":"2019/01/17/6.强引用、软引用、弱引用、幻象引用/","link":"","permalink":"http://yoursite.com/2019/01/17/6.强引用、软引用、弱引用、幻象引用/","excerpt":"","text":"Java 程序运行时的内存分配三种空间分别是静态存储区（方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态变量。这块「内存」在程序编译时就已经分配好了，并且在程序整个运行期间都存在。 栈区：当方法被执行时，方法体内的局部变量（包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时。这些局部变量所持有的内存将会自动被释放。 堆区：又称动态内存分配，通常就是指程序运行时直接 new 出来的内存，也就是对象的实例，这部分「内存」在不使用时将会被 Java 垃圾回收器来负责回收。 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储在堆中 —— 因为他们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被 new 出来使用的。 两种算法判断对象需不需要回收：引用计数法(用的少)和GcRoot可达分析算法(大多数)。回收(回收算法)分为两步:需要回收的对象加入队列；调用对象的finalize方法。 常见回收算法 标记清除算法（效率低，节省一些内存） 复制算法 （效率要高，浪费一些内存） 标记整理算法 分代算法 GC回收内存本质上是回收对象，运用可达性分析算法。 在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。 实现的核心是Reference与ReferenceQueue两个类。 强引用Strong Reference就是我们最常见的普通对象引用，Object obj = new Object()中的obj就是强引用。 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。 软引用SoftReference只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出OutOfMemoryError 之前，清理软引用指向的对象。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。 Object aRef = new Object(); SoftReference aSoftRef = new SoftReference(aRef); Object anotherRef = (Object)aSoftRef.get(); ReferenceQueue queue = new ReferenceQueue(); SoftReference ref = new SoftReference(aMyObject, queue); (ref = (EmployeeRef) q.poll()) != null 应用场景：软引用通常用来实现内存敏感的缓存。比如图片缓存框架，从网络上获取图片，然后将获取的图片显示的同时，通过软引用缓存起来。当下次再去网络上获取图片时，首先会检查要获取的图片缓存中是否存在，若存在，直接取出来，不需要再去网络上获取。 View view = findViewById(R.id.button); Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); Drawable drawable = new BitmapDrawable(bitmap); SoftReference&lt;Drawable&gt; drawableSoftReference = new SoftReference&lt;Drawable&gt;(drawable); if(drawableSoftReference != null) { view.setBackground(drawableSoftReference.get()); } 弱引用WeakReference随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。 由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 应用场景：弱应用同样可用于内存敏感的缓存。 在静态内部类中，经常会使用弱引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏。 Glide 图片加载框架的内存缓存就使用到了弱引用缓存机制。 private MyHandler handler = new MyHandler(this); private static class MyHandler extends Handler{ WeakReference&lt;FirstActivity&gt; weakReference; MyHandler(FirstActivity activity) { weakReference = new WeakReference&lt;&gt;(activity); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); switch (msg.what){ } } } 当一个android主线程被创建的时候，同时会有一个Looper对象被创建，而这个Looper对象会实现一个MessageQueue(消息队列)，当我们创建一个handler对象时，而handler的作用就是放入和取出消息从这个消息队列中，每当我们通过handler将一个msg放入消息队列时，这个msg就会持有一个handler对象的引用。 因此当Activity被结束后，这个msg在被取出来之前，这msg会继续存活，但是这个msg持有handler的引用，而handler在Activity中创建，会持有Activity的引用，因而当Activity结束后，Activity对象并不能够被gc回收，因而出现内存泄漏。 在java中所有非静态的对象都会持有当前类的强引用，而静态对象则只会持有当前类的弱引用。 声明为静态后，handler将会持有一个Activity的弱引用，而弱引用会很容易被gc回收，这样就能解决Activity结束后，gc却无法回收的情况。 幻象引用PhantomReference也叫虚引用，不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被finalize 以后，做某些事情的机制。这种引用的get()方法返回总是null。 幻想引用是针对那些已经执行完析构函数之后，仍然需要在执行一些其它操作的对象：比如资源对象的关闭就可以用到这个引用。 虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ReferenceQueue queue = new ReferenceQueue (); PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。 应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"移动web开发记录","slug":"5.移动web开发记录","date":"2019-01-07T12:26:42.093Z","updated":"2019-04-21T09:01:42.578Z","comments":false,"path":"2019/01/07/5.移动web开发记录/","link":"","permalink":"http://yoursite.com/2019/01/07/5.移动web开发记录/","excerpt":"","text":"像素设备独立像素 window.devicePixelRatio 屏幕的物理像素尺寸 window.screen.width window.screen.height 调试模拟调试 谷歌： 火狐： 真机调试：weinre、debuggap、ghostlab。同时保证设备和服务器的网络相通。 视口viewport获取viewport大小 document.documentElement.clientWidth; document.documentElement.clientHeight; pc端:浏览器的可视大小。viewport中子元素当超出viewport的大小时：viewport为具体值时，会出现滚动条；当viewport宽高设为100%时，会自动换行；当子元素也设为百分比，可以不出现滚动条和换行。 移动端：layout viewport和ideal viewport 默认视口大小，layout viewport同样是 document.documentElement.clientWidth; document.documentElement.clientHeight; 理想视口ideal viewport，即设备屏幕区域 window.screen.width window.screen.height 屏幕适配name=&quot;viewport&quot;说明当前meta标签是用来设置viewport的属性的，这个属性只有在移动端才会有效。 控制缩放：nitial-scale = ideal viewport/layout viewport 控制缩放 maximum-scale//最大缩放比例 minimum-scale//最小缩放比例，也是打开默认状态下的 user-scalable//是否可以缩放，yes，no &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,user-scalable=no&quot;&gt; webstorm中快捷键meta:vp+tab &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt;","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"移动web","slug":"移动web","permalink":"http://yoursite.com/tags/移动web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"安卓自定义安全键盘","slug":"4.安卓自定义安全键盘","date":"2019-01-05T09:16:06.970Z","updated":"2019-04-02T14:31:08.844Z","comments":false,"path":"2019/01/05/4.安卓自定义安全键盘/","link":"","permalink":"http://yoursite.com/2019/01/05/4.安卓自定义安全键盘/","excerpt":"","text":"Keyboard我们只需要用到系统提供的两个类：Keyboard和KeyboardView。 res下新建xml，新建Keyboard文件 Keyboard中 android:keyWidth//每一个按键的宽 android:keyHeight//每一个按键的高 android:verticalGap//行与行之间的间隙 android:horizontalGap//列与列之间的间隙 Row的作用是按键的换行，每一个按键Key都在Row中。 Key中 android:keyLabel//按键上的文字 android:codes//输出的文字，对应ASCII表 android:keyIcon//按键放置图片 android:isRepeatable//删除键长按连续删除 宽高、间距的单位既可以是像素，英寸等，也可以是相对于基础取值的百分比，以%p结尾。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;Keyboard xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:horizontalGap=&quot;0px&quot; android:verticalGap=&quot;0px&quot; android:keyHeight=&quot;7.5%p&quot; android:keyWidth=&quot;30%p&quot;&gt; &lt;Row android:verticalGap=&quot;1%p&quot;&gt; &lt;Key android:codes=&quot;49&quot; android:keyLabel=&quot;1&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;50&quot; android:keyLabel=&quot;2&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;51&quot; android:keyLabel=&quot;3&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;Row android:verticalGap=&quot;1%p&quot;&gt; &lt;Key android:codes=&quot;52&quot; android:keyLabel=&quot;4&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;53&quot; android:keyLabel=&quot;5&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;54&quot; android:keyLabel=&quot;6&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;Row android:verticalGap=&quot;1%p&quot;&gt; &lt;Key android:codes=&quot;55&quot; android:keyLabel=&quot;7&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;56&quot; android:keyLabel=&quot;8&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;57&quot; android:keyLabel=&quot;9&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes=&quot;-2&quot; android:keyLabel=&quot;abc&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;48&quot; android:keyLabel=&quot;0&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;-5&quot; android:isRepeatable=&quot;true&quot; android:keyIcon=&quot;@mipmap/ic_delete&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;/Keyboard&gt; KeyboardViewKeyboardView android:keyBackground//键盘背景图 android:keyPreviewLayout//键盘点击时候预览图的布局 android:keyPreviewHeight//键盘点击时候预览图的高度 android:keyTextColor//按键文字的颜色 android:keyTextSize//按键文字大小 android:labelTextSize//如果同时设置了文字+图片的按键 android:shadowColor android:shadowRadius 代码 &lt;android.inputmethodservice.KeyboardView android:id=&quot;@+id/kbv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#999999&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:keyBackground=&quot;@color/colorPrimaryDark&quot; android:keyPreviewHeight=&quot;64dp&quot; android:keyPreviewLayout=&quot;@layout/keyboard_preview&quot; android:keyTextColor=&quot;@android:color/black&quot; android:keyTextSize=&quot;24sp&quot; android:labelTextSize=&quot;18sp&quot; android:paddingTop=&quot;8dip&quot; android:paddingBottom=&quot;8dip&quot; android:shadowColor=&quot;#FFFFFF&quot; android:shadowRadius=&quot;0.0&quot; android:visibility=&quot;gone&quot; /&gt; 使用设置 Keyboard keyboard = new Keyboard(this,R.xml.tea_keyboard_num); keyboardView.setKeyboard(keyboard); keyboardView.setPreviewEnabled(true); keyboardView.setOnKeyboardActionListener(onKeyboardActionListener); OnKeyboardActionListener KeyboardView.OnKeyboardActionListener onKeyboardActionListener = new KeyboardView.OnKeyboardActionListener() { ...... @Override public void onKey(int primaryCode, int[] keyCodes) { if (primaryCode == Keyboard.KEYCODE_CANCEL) {// 完成 } else if (primaryCode == Keyboard.KEYCODE_DELETE) {//回退 Toast.makeText(BoardActivity.this,&quot;delete&quot;,Toast.LENGTH_SHORT).show(); } else if (primaryCode == Keyboard.KEYCODE_SHIFT) {//大小写切换 } else if (primaryCode == Keyboard.KEYCODE_MODE_CHANGE) {//数字键盘切换 } else { } } }; 参考https://github.com/onlyloveyd/LazyKeyboard https://github.com/r17171709/android_demo/tree/master/KeyBoardDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"自定义","slug":"自定义","permalink":"http://yoursite.com/tags/自定义/"},{"name":"键盘","slug":"键盘","permalink":"http://yoursite.com/tags/键盘/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp基本使用及网络封装","slug":"3.OkHttp基本使用及网络封装","date":"2018-12-02T13:32:32.973Z","updated":"2020-07-25T09:45:16.059Z","comments":false,"path":"2018/12/02/3.OkHttp基本使用及网络封装/","link":"","permalink":"http://yoursite.com/2018/12/02/3.OkHttp基本使用及网络封装/","excerpt":"","text":"1、网络基础1.2、Cookie 、Session和TokenCookie 、Session、Token：都是用来做持久化处理的，目的就是让客户端和服务端相互认识。Http请求默认是不持久的没有状态的，谁也不认识谁。 Cookie: 是存放在客户端的信息，这个信息是来自于服务器返回的信息，下次请求带过去，如果用户离开网站后，如果Cookie已过期一般是会被清除的。如果Cookie没过期下次访问网站还是会带过去。（相对危险） Session: 是存放在服务器上面的客户端临时信息，用户离开网站是会被清除的。（相对安全，耗资源） Token（App）”令牌”：用户身份的验证，有点类似于Cookie，相对来说更安全。 1.3、Http缓存Cache-Control（缓存策略）：Public、private、no-cache、max-age 、no-store（不缓存） Expires（缓存的过期策略）：指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。 如果有缓存并且过期了那么发起请求，服务端会给我们数据？（不一定会给）服务器的数据没有变动就不会给，状态码会变为304，自己拿之前过期的缓存。 1.5、HttpsHttp和Https的区别： Https = Http + 加密 + 验证身份 + 完整 端口：Http (80) Https (443) Http的缺点：数据是没有加密传输，可能遭遇窃听；不验证通信方的身份，可能会遭遇伪装；无法验证报文的完整性，可能会遭遇篡改。 TLS/SSL协议：加密：对称加密（AES，DES）+ 非对称加密 (RSA，DSA)；证书：要钱（便宜），建立连接的速度会拖慢，TCP由3次握手变为8次握手。 Http/1.1和Http/2.0的区别： Http/2.0采用二进制格式而非文本格式；Http/2.0支持完全的多路复用；Http/2.0使用报头压缩，降低开销Http/2.0让服务器将响应主动推送给客户端，（带内容推送，不带内容推送的通知）。 2、OkHttp异步和同步：跟线程没什么关系，打电话，同步：打电话 -&gt; 处理（没挂断） -&gt; 反馈；异步：打电话 -&gt; 处理（挂断）-&gt; 打回来 网络框架要怎么处理：网络是耗时的，因此需要开线程，用线程池；处理网络，HttpUrlConnection(简单) 或者输入流+Socket(麻烦)；网络请求头信息处理，缓存的处理，文件格式上传的方式（表单提交，拼格式）；路由的一些操作，Http/2.0复用等等。 OkHttp要点——okio：原生的JavaIO+自定义封装，其实就是对于io的封装;Socket:连接；拦截器。 OkHttp流程： 1、Request里面封装了url，method，header等基本信息，然后通过okhttpClient.newCall(request),将Request转化成了RealCall。 2、RealCall里面有enqueue，通过call.enqueue(),转换成了AsyncCall。 3、AsyncCall是RealCall的内部类，AsyncCall继承了Runnable。AsyncCall给了OKhttp的Dispatcher（线程池），executorService().execute(call); 4、最终去执行了AsyncCall.execute()方法，执行getResponseWithInterceptorChain返回 Response。 synchronized void enqueue(AsyncCall call) { //判断当前正在执行的任务数量，最大是64，正在执行的任务中的host,最大是5 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { //加入到正在执行 runningAsyncCalls.add(call); // 线程池， executorService().execute(call); } else { // 加入准备执行的集合，等待执行 readyAsyncCalls.add(call); } } 2.1、官网和导入官网 http://square.github.io/okhttp/ 引入 compile &apos;com.squareup.okhttp3:okhttp:3.11.0&apos; 2.2、测试地址http://httpbin.org/ http://httpbin.org/get?id=123 http://httpbin.org/post 2.3、get请求同步请求 OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;http://httpbin.org/get?id=123&quot;).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } 异步请求 System.out.println(Thread.currentThread().getId()); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;http://httpbin.org/get?id=123&quot;).build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { if (response.isSuccessful()) { System.out.println(Thread.currentThread().getId()); } } }); 2.4、post请求同步请求，提交表单 OkHttpClient client = new OkHttpClient(); FormBody body = new FormBody .Builder() .add(&quot;name&quot;, &quot;shuaige&quot;) .add(&quot;age&quot;, &quot;19&quot;) .build(); Request request = new Request.Builder().url(&quot;http://httpbin.org/post&quot;).post(body).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } 异步提交，提交json OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(10,TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .build(); Book book = new Book(); book.setName(&quot;android&quot;); //使用Gson Gson gson = new Gson(); //使用Gson将对象转换为json字符串 String json = gson.toJson(book); //MediaType设置Content-Type 标头中包含的媒体类型值 RequestBody requestBody = FormBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), json); Request request = new Request.Builder() .url(&quot;http://172.20.192.168:8080/getbookByJson&quot;)//请求的url .post(requestBody) .build(); //创建Call Call call = okHttpClient.newCall(request); //加入队列 异步操作 call.enqueue(new Callback() { //请求错误回调方法 @Override public void onFailure(Call call, IOException e) { System.out.println(&quot;连接失败&quot;); } @Override public void onResponse(Call call, Response response) throws IOException { System.out.println(response.body().string()); } 2.5、设置url参数-HttpUrlOkHttpClient client = new OkHttpClient(); HttpUrl httpUrl = HttpUrl.parse(&quot;http://httpbin.org/get&quot;). newBuilder(). addQueryParameter(&quot;city&quot;, &quot;beijing&quot;). addQueryParameter(&quot;id&quot;, &quot;123&quot;). build(); String url = httpUrl.toString(); System.out.println(httpUrl.toString());// http://httpbin.org/get?city=beijing&amp;key=123 Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } 2.6、请求头的设置-addHeaderOkHttpClient client = new OkHttpClient(); Request request = new Request.Builder(). url(&quot;http://httpbin.org/get?id=123&quot;). addHeader(&quot;User-Agent&quot;, &quot;this my head&quot;). addHeader(&quot;Accept&quot;, &quot;text/plain, text/html&quot;). build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } 2.7、上传文件RequestBody imageBody = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;), new File(&quot;文件路径+文件名&quot;)); MultipartBody body = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;name&quot;, &quot;name&quot;) .addFormDataPart(&quot;filename&quot;, &quot;文件名&quot;, imageBody).build(); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;http://192.168.1.6:8080/web/UploadServlet&quot;).post(body).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } boundary 2.8、定义拦截器//定义拦截器 Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { long start = System.currentTimeMillis(); Request request = chain.request(); Response response = chain.proceed(request); long end = System.currentTimeMillis(); System.out.println(&quot;interceptor: cost time = &quot; + (end - start)); return response; } }; // 创建 OkHttpClient 对象 OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(interceptor) .build(); 2.9、缓存使用缓存的前提是服务器支持缓存 // 创建缓存对象，缓存文件和缓存大小 Cache cache = new Cache(new File(&quot;cache.cache&quot;), 1024 * 1024); // 创建 OkHttpClient 对象 OkHttpClient client = new OkHttpClient.Builder() .cache(cache) .build(); // 创建 Request 对象 Request request = new Request.Builder() .url(&quot;http://httpbin.org/get?id=id&quot;) .cacheControl(CacheControl.FORCE_NETWORK)//只从网络读取 //.cacheControl(CacheControl.FORCE_CACHE)//只读取缓存 //.cacheControl(new CacheControl.Builder().noCache().build())//永远不使用缓存 //.cacheControl(new CacheControl.Builder().maxStale(365, TimeUnit.DAYS).build())//最大缓存时效365天 .build(); // OkHttpClient 执行 Request try { Response response = client.newCall(request).execute(); Response responseCache = response.cacheResponse(); Response responseNet = response.networkResponse(); if (responseCache != null) { //从缓存响应 System.out.println(&quot;response from cache&quot;); } if (responseNet != null) { //从网络响应 System.out.println(&quot;response from net&quot;); } System.out.println(&quot;response:&quot; + response.body().string()); } catch (IOException e) { e.printStackTrace(); } Okhttp实现缓存方式：在CacheInterceptor缓存拦截器中，根据缓存策略CacheStrategy分配。Cache和DiskLruCache。 2.10、文件下载OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;文件地址&quot;). addHeader(&quot;Accept-Encoding&quot;,&quot;identity&quot;). addHeader(&quot;Range&quot;, &quot;bytes=0-&quot;). build(); try { Response response = client.newCall(request).execute(); System.out.println(&quot;content-length : &quot;+response.body().contentLength()); if (response.isSuccessful()) { Headers headers = response.headers(); for (int i = 0; i &lt; headers.size(); i++) { System.out.println(headers.name(i) + &quot; : &quot; + headers.value(i)); } } } catch (IOException e) { e.printStackTrace(); } content-length和Range。 3、源码分析Volley是基于HttpUrlConnection；OkHttp基于Okio(原生的JavaIO + 自定义封装) + Socket连接。 3.1、OkHttpClient OkHttpClient相当于配置中心，所有的请求都会共享这些配置，比如出错是否重试、共享的连接池。主要配置有： //调度器，主要管理线程，用于调度后台发起的网络请求，有后台总请求数和单主机总请求数的控制。 //private int maxRequests = 64;private int maxRequestsPerHost = 5; final Dispatcher dispatcher; //支持的应用层协议，即HTTP/1.1、HTTP/2等 final List&lt;Protocol&gt; protocols; //应用层支持的Socket设置，即使用明文传输（HTTP）还是某个版本的TLS（用于HTTPS）。 final List&lt;ConnectionSpec&gt; connectionSpecs; //自己定义的拦截器配置 final List&lt;Interceptor&gt; interceptors; //自己定义的和网络请求交互的Interceptor配置。 final List&lt;Interceptor&gt; networkInterceptors; //管理CooKie的控制器 final CookieJar cookieJar; //Cache存储的配置。默认没有，如果要用，需要自己配置存储的文件位置和存储空间上线 final @Nullable Cache cache; //验证HTTPS握手过程中下载到的证书所属者是否和自己要访问的主机名一致 final HostnameVerifier hostnameVerifier; //一般用于防止网站证书被人仿制，开发者可以做自签名 final CertificatePinner certificatePinner; //自动重新认证。配置后，如果401，会直接调用authenticator final Authenticator authenticator; //遇到重定向，是否自动follow在HTTP和HTTPS之间切换重定向 final boolean followSslRedirects; //遇到重定向，是否自动follow final boolean followRedirects; //请求失败是否重试。重试只适用于同一个域名的多个IP切换重试、Socket失效重试等 final boolean retryOnConnectionFailure; //建立连接的超时时间 final int connectTimeout; //发起请求到读到响应数据的超时时间 final int readTimeout; //发起请求并被目标服务器接受的超时时间 final int writeTimeout; CertificatePinner的配置公钥示例： String hostname = &quot;publicobject.com&quot;; CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(hostname, &quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;) .build(); OkHttpClient client = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build(); Request request = new Request.Builder() .url(&quot;https://&quot; + hostname) .build(); client.newCall(request).execute(); 3.2、RealCall newCall(Request)方法会返回一个RealCall对象，它是Call接口的实现。 final class RealCall implements Call { 当调用RealCall.execute()的时候，getResponseWithInterceptorChain()会被调用，它会发起网络请求并拿到返回的响应，装进一个Response对象并作为返回值返回。 Response result = getResponseWithInterceptorChain(); RealCall.enqueue()被调用的时候大同小异，区别在于enqueue会使用Dispatcher的线程池来把请求放在后台线程进行，但实质上使用的同样也是getResponseWithInterceptorChain()方法。 getResponseWithInterceptorChain()方法里做的事：把所有配置好的Interceptor放在一个List里，然后作为参数，创建一个RealInterceptorChain对象，并调用chain.proceed(request)发起请求和获取响应。 RealCall类中的getResponseWithInterceptorChain()方法作用：将请求Request转变成响应Response。 Response getResponseWithInterceptorChain() throws IOException { // 拦截器的一个集合 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 客户端的所有自定义拦截器，可以添加自己定义的 interceptors.addAll(client.interceptors()); // OKhttp 5 个拦截器 ，责任链设计模式，每一个拦截器只处理与他相关的部分 interceptors.add(retryAndFollowUpInterceptor);// 重试 interceptors.add(new BridgeInterceptor(client.cookieJar()));// 基础 interceptors.add(new CacheInterceptor(client.internalCache()));// 缓存 interceptors.add(new ConnectInterceptor(client));// 建立连接,连接服务器 interceptors.add(new CallServerInterceptor(forWebSocket));// 写数据 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); } 3.3、拦截器在RealInterceptorChain中，多个Interceptor会依次调用自己的intercepter方法，方法会做三件事情 1、对请求进行预处理 2、预处理之后，重新调用RealInterceptorChain.proceed()把请求交给下一个Interceptor。 3、在下一个Interceptor处理完成并返回之后，拿到Response进行后续处理 从上到下，每级Interceptor： 1、首先是开发者自己设置的addInterceptor(Interceptor)，在所有其他Interceptor处理之前，进行最早的预处理工作，以及收到Response之后，做最后的善后工作。如果有统一的header要添加，可以在这里设置。 2、RetryAndFollowUpInterceptor： 处理重试的一个拦截器，会去处理一些异常，只要不是致命的异常就会重新发起一次请求（把Request给下级），如果是致命的异常就会抛给上一级；会处理一些重定向等等，比如 3XX 307、407 就会从头部中获取新的路径，生成一个新的请求交给下一级（重新发起一次请求）。 3、BridgeInterceptor 做一个简单的处理，设置一些通用的请求头，Content-Type、Connection、Content-Length的计算和添加、Cookie。做一些返回的处理，如果返回的数据被压缩了采用ZipSource, 保存 Cookie。 4、CacheInterceptor 在缓存可用的情况下，直接读取本地的缓存的数据，如果本地的缓存没有直接去服务器，如果本地的缓存有，首先判断有没有缓存策略，然后判断有没有过期，如果没有过期直接拿缓存，如果过期了需要添加一些之前头部信息如If-Modified-Since,这个时候后台有可能会返回304代表还是可以拿本地缓存，每次读取到新的响应后做一次缓存。 5、ConnectInterceptor findHealthyConnection()找一个连接，首先判断有没有健康的，没有就创建（建立Scoket,握手连接），连接缓存得到一条结论：OkHttp是基于原生的Socket + okio（原生IO的封装）。封装HttpCodec里面封装了okio的Source（输入）和Sink(输出)，我们通过HttpCodec就可以操作 Socket的输入输出，我们就可以像服务器写数据和读取返回数据。 TCP连接（如果是HTTP）或者是建立在TCP连接之上的TLS连接（如果是HTTPS），并且会创建出对应的HttpCodec对象（用于编码解码HTTP请求）。 6、addNetworkInterceptor：开发者自己设置的，这里设置的Interceptor会看到每个请求和响应的数据（包括重定向以及重试的一些中间请求和响应），并且看到的是完整原始数据，而不死没加Content-Length的请求数据，或者Body还没有被gzip解压的响应数据。 7、CallServerInterceptor 它负责实质的请求和响应的I/O操作，即往Socket里写入请求数据和从Socket里读取响应数据。Socket就是TCP的端口。 连接三个核心类（连接复用） RealConnection: 建立连接的一个对象的封装 ConnectionPool：保存了连接 StreamAllocation: 找一些连接，做一下封装 4、Okio程序内部（内存）和外部（本地文件和网络）进行数据交互的过程，就叫输入输出。 从文件里或者从网络上读数据到内存里，就叫输入；从内存里写到文件里或者发送到网络上，就叫输出。Java I/O 作用只有一个：和外界做数据交互。使用流，例如 FileInputStream / FileOutputStream。 Okio特点：基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink，支持 Buffer，可以对 Buffer 进行操作，但不强制使用Buffer。 try (Source source = Okio.buffer(Okio.source(new File(&quot;./io/text.txt&quot;)))) { Buffer buffer = new Buffer(); source.read(buffer, 1024); System.out.println(buffer.readUtf8Line()); System.out.println(buffer.readUtf8Line()); } catch (IOException e) { e.printStackTrace(); }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"http://yoursite.com/tags/OkHttp/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"HTML和CSS基础","slug":"2.html和css基础","date":"2018-12-01T12:15:03.995Z","updated":"2019-07-07T06:51:39.660Z","comments":false,"path":"2018/12/01/2.html和css基础/","link":"","permalink":"http://yoursite.com/2018/12/01/2.html和css基础/","excerpt":"","text":"sublime http://www.sublimetext.com/ https://jingyan.baidu.com/article/925f8cb8dedc12c0dce05674.html https://jingyan.baidu.com/article/ce43664935b90c3772afd377.html 标签&lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h3&gt;&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;h5&gt;&lt;/h5&gt; &lt;h6&gt;&lt;/h6&gt; 段落 &lt;p&gt;&lt;/p&gt; 换行 &lt;hr/&gt; 分割线 &lt;br /&gt; 块 &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; 加粗 &lt;strong&gt;&lt;/strong&gt; &lt;b&gt;&lt;/b&gt; 倾斜 &lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; 删除线 &lt;s&gt;&lt;/s&gt; &lt;del&gt;&lt;/del&gt; 下划线 &lt;u&gt;&lt;/u&gt; &lt;ins&gt;&lt;/ins&gt; 图片 &lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; border=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; 链接 &lt;a href=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt; 锚点定位（跳转） &lt;a href=&quot;#id&quot;&gt;&lt;/a&gt; base设置整体链接状态 &lt;base target=&quot;_blank&quot; /&gt; 特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ¥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2 (上标2) &amp;sup2; ³ 立方3 (上标3) &amp;sup3; 无序列表 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 注意：ul和ol里面之能放li,li里面可以放其他标签。 自定义列表 &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; 表格&lt;table width=&quot;&quot; border=&quot;&quot; align=&quot;&quot; cellpadding=&quot;&quot; cellspacing=&quot;&quot;&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr align=&quot;&quot;&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 属性名 含义 常用属性值 border 设置表格的边框(默认border=”0”无边框) 像素值 ellspacing 设置单元格与单元格边框之间的空白间距 像素值(默认为2像素) cellpadding 设置单元格内容与单元格边框之间的空白间距 像素值(默认为1像素) width 设置表格的宽度 像素值 height 设置表格的高度 像素值 align 设置表格在网页中的水平对齐方式 left、center、 right 合并单元格（rowspan合并行，colspan合并列） &lt;table width=&quot;500&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;13&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;31&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;32&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 效果 input表单 属性 属性值 描述 type text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像形式的提交按钮 file 文件域 name 由用户自定义 控件的名称 value 由用户自定义 input控件中的默认文本值 size 正整数 input控件在页面中的显示宽度 checked checked 定义选择控件默认被选中的项 maxlength 正整数 控件允许输入的最多字符数 注意： 同一组radio中，name要相同。 label标签 &lt;label&gt; 用户名&lt;input type=&quot;text&quot;&gt; &lt;/label&gt; &lt;br /&gt; &lt;label for=&quot;pwd&quot;&gt; 用户名&lt;input type=&quot;text&quot; /&gt; 密码&lt;input type=&quot;password&quot; id=&quot;pwd&quot; /&gt; &lt;/label&gt; textarea标签 &lt;textarea cols=&quot;每行中字符数&quot; rows=&quot;显示的行数&quot;&gt; &lt;/textarea&gt; select标签 &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot; selected=&quot;selected&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;/select&gt; 表单域 &lt;form action=&quot;提交地址url&quot; method=&quot;提交方式get/post&quot;&gt; 用户名&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;submit&quot; /&gt; &lt;/form&gt; 拓展 http://www.w3school.com.cn/ https://developer.mozilla.org/zh-CN/ 引入CSS样式表第一种：行内式（内联样式） &lt;h3 style=&quot;color: pink; font-size: 25px;&quot;&gt;英文版新闻报&lt;/h3&gt; 第二种：内部样式表 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h3 { color: pink; font-size: 60px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;英文版新闻报&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 第三种：外部样式表(外联式) html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;英文版新闻报&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; css文件 h3 { color: pink; font-size: 60px; } CSS选择器之基本选择器第一种：标签选择器（元素选择器） 把某类标签全部选出来。 第二种：类选择器 .类名 { 属性:属性值; } 注意：可以使用中横线命名，不建议使用下划线_,不能数字开头。 多类名选择器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .colred { color: red; } .font20 { font-size: 50px; color: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 class=&quot;colred font20&quot;&gt;英文版新闻报&lt;/h3&gt; &lt;h3 class=&quot;colred&quot;&gt;英文版新闻报&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 注意：空格隔开；样式显示跟类名先后顺序没有关系，受css样式书写的上下顺序有关。 第三种：id选择器 #id { 属性:属性值; } 注意：id只能使用一次，class可以使用多次。 第四种：通配符选择器 *代表所有，?代表单个字符。 * { 属性：属性值; } CSS选择器之复合选择器1、后代选择器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div p { color: pink; } .dd p{ font-size: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;英文版新闻报&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;dd&quot;&gt; &lt;p&gt;英文版新闻报&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2、子代选择器-选择亲儿子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul li &gt; a { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;一级菜单&lt;/a&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;二级菜单&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 3、并集选择器 ** &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div,p,span { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;并集选择器&lt;/div&gt; &lt;p&gt;并集选择器&lt;/p&gt; &lt;span&gt;并集选择器&lt;/span&gt; &lt;h1&gt;并集选择器&lt;/h1&gt; &lt;a href=&quot;#&quot;&gt;并集选择器&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 4、交集选择器(即..又..) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div.red { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;red&quot;&gt;交集选择器&lt;/div&gt; &lt;p class=&quot;red&quot;&gt;交集选择器&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 5、伪类选择器 链接伪类选择器 link /*未访问的链接*/ visited /*已访问的链接*/ hover /*鼠标移动到链接上*/ active /*选定的链接*/ 代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a:link {&lt;!-- 未访问的链接状态 --&gt; color: #333; text-decoration: none; } a:visited {&lt;!-- 已访问的链接 --&gt; color: pink; } a:hover {&lt;!-- 鼠标经过时候样子 --&gt; color: red; } a:active {&lt;!-- 鼠标按下时候样子 --&gt; color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;双十一&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 常见写法 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a { color: #333; text-decoration: none; font-size: 25px; font-weight: 700; } a:hover { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;双十一&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; CSS字体属性font-size字号大小（px、em）、font-family字体 、font-weight字体粗细 、font-style字体风格（倾斜） font-size: 18px; /*font-family: &quot;宋体&quot;;*/ font-family: &quot;\\5B8B\\4F53&quot;; font-weight: bold; /*font-weight: normal;*/ /*font-style: normal;*/ font-style: italic; bold相当于700，normal为400。 font综合设置 选择器{font: font-style font-weight font-size font-family ;} 注意：不能更换顺序。font-size和font-family不能省略。 CSS外观属性color颜色、line-height行间距、text-align文字水平对齐方式(left ,right,center)、text-indent首行缩进、text-decoration文本的装饰。 color: #FF0000; line-height: 24px; text-align: left; text-indent: 2em; text-decoration: line-through; /*none:无装饰、underline:下划线、line-through:删除线*/ 注意：如果行高line-height等于height高度，文字会垂直居中。 一般居中写法 line-height: (=height);text-align: center; backgroundbackground-color: #fff; background-image: url(); background-repeat /* 平铺方式：repeat、no-repeat、repeat-x、repeat-y*/ background-repeat: repeat-x; background-position /* x轴和y轴位置 ，top、bottom、left、right*/ /* background-position: 12px 12px; */ /* 如果只写一个方位，另一个默认居中 */ /* background-position: bottom; */ background-position: center bottom; background-attachment滚动还是固定，默认滚动 /* fixed */ background-attachment: scroll; background简写,没有强制顺序 background: background-color background-image background-repeat background-attachment background-position background: transparent url(image.jpg) repeat scroll 50% 0; 设置透明，最后一位为alpha background: rgba(0, 0, 0, 0.5); 标签显示模式块级元素和行内元素相互转换： div { display: inline; } span { display: block; } 把行内元素转换为行内快元素： a { display: inline-block; } CSS三大特性1、层叠性 样式冲突，以最后样式为准。样式不冲突，不会重叠。 2、继承性 子标签会继承父标签的某些样式。一般继承文字的样式。 3、优先级 !important(无穷大) &gt; 行内样式(1,0,0,0) &gt; id选择器(0,1,0,0) &gt; 类选择器(伪类)(0,0,1,0) &gt; 标签选择器(0,0,0,1) &gt; *选择器和继承选择器(0,0,0,0) 注意 权重相同，就近原则；权重会叠加； 盒子模型1、盒子边框(border) border-width、border-style、border-color border-width: 1px; border-color: red; /* none无边框、solid实线边框、dashed虚线边框、dotted点线边框 */ border-style: dashed; 连写，没有顺序 border: 1px solid red; 边框可以拆开 border-top: 1px solid red; border-bottom: 1px solid green; 去掉所有边框 border: 0; 表格细线边框 table, td { border-collapse: collapse; } 2、内边框(padding)，padding会撑开带width和height盒子。 padding: 10px; padding-left: 10dp; padding: 10px 20px; /* 上下分别10和左右分别20 */ padding: 10px 20px 30px; /* 上10,左右分别20,下30 */ padding: 10px 20px 30px 40px; /* 顺时针，上右下左 */ 注意：如果盒子没有给定宽高，padding不会影响盒子大小。 3、外边距(margin) 清除元素内外边距 * { margin: 0; padding: 0; } 清除li中圆点 li { list-style: none; } 让盒子水平居中,注意，必须给块级盒子设置宽度。 margin: 0 auto; 或者 margin-left: auto; margin-right: auto; text-align: center;/* 内容水平居中 */ 相邻块元素垂直外边距合并问题 /* 一个元素是 */ margin-bottom: 100px; /* 另一个元素是 */ margin-top: 50px; /*合并后的距离为100px，即以大的为准 */ 嵌套块元素垂直外边距合并问题 三种解决办法： border-top: 1px solid red; padding-top: 1px; overflow: hidden; 圆角边框和盒子阴影圆角边框 border-radius: 10px;/* 圆角 */ border-radius: 50%;/* 正方形变成圆 */ border-radius: 10px 20px 30px 40px;/* 左上开始顺时针 */ border-radius: 10px 0;/* 左上右下和右上左下 */ 阴影 box-shadow: 0px 15px 30px 2px rgba(0,0,0,0.4); box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影; 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅CSS颜色值。 inset 可选。将外部阴影(outset)改为内部阴影。 浮动作用：使多个div在一行显示，float属性值有left、right、none。 li使用float可以一行排列。 浮动的盒子，不会超过内边距。浮动脱离标准流，不占位置，会影响下面的标准流。浮动只有左右浮动。 注意 ：浮动可以让元素默认转换为行内块元素。 清除浮动本质：解决父级元素因为子级浮动引起内部高度为0的问题。 父元素自动检测子级元素的高度，以最高为准。常用四种解决办法。 1、额外标签法 在最后一个浮动标签后面新添加一个标签，清除浮动。 clear: both; 2、父级添加overflow 给父级元素添加 overflow: hidden; 3、使用after伪元素清除浮动 给父级元素添加类名clearfix .clearfix:after { content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { *zoom: 1; /* IE6、7 */ } 4、使用before和after双伪元素清除浮动 给父级元素添加类名clearfix .clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; /* IE6、7 */ } 定位定位属性主要包括定位模式和边偏移两部分。 值 描述 static 自动定位 (默认定位方式) relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元索进行定位 fixed 固定定位，相对于浏览器窗口进行定位 1、相对定位 position: relative; top: 100px; left: 100px; 注意：相对定位可以通过边偏移移动位置，但是原来的所占的位置，继续占有。以自己的左上角为基准点定位。 2、绝对定位 position: absolute; top: 100px; left: 100px; 注意：绝对定位不占位置。若所有父元素都没有定位，以浏览器当前屏幕为基准点定位。 绝对定位依据最近的已经定位的父元素进行定位。 子绝父相。正常情况，子级是绝对定位的话，父级要用相对定位。 定位的盒子居中 position: absolute; left: 50%; margin-left: -(宽度/2); top: 50%; margin-top: -(高度/2); 3、固定定位 position: fixed; left: 0; top: 0; 注意：不管父元素有没有定位，都是以浏览器当前屏幕为基准点定位，和父元素没有关系。 模式转换： 绝对定位和固定定位，元素模式发生转换，都转换为行内快模式。 叠放次序(z-index) z-index: 1; 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准值 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 脱标，占有位置 可以 相对自身位置移动(自恋型) 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置(拼爹型) 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置(认死理型) z-index默认为0，取值越大，越居上，如果取值相同，后来者居上。 只有定位的盒子才有z-index。 没有单位。 显示与隐藏display: none;/* 隐藏 */ display: block;/* 显示 */ display隐藏后不保留位置。 visibility: visible;/* 显示 */ visibility: hidden;/* 隐藏 */ visibility隐藏后保留位置。 overflow: hidden; overflow四个属性auto; scroll; hidden; visible; 鼠标样式、轮廓线、防止拖拽文本域鼠标样式 cursor: default;/*default: 默认、 pointer： 小手、 text： 选择、move： 移动*/ 轮廓线 input { outline: none;/* 取消轮廓线 */ border: 1px solid red; } 防止拖拽文本域 textarea { resize: none;/* 不要重新规定尺寸 */ outline: none;/* 取消轮廓线 */ } vertical-align针对行内元素和行内块元素。控制图片和文字位置 img { vertical-align: middle;/* top、bottom */ } 溢出文字隐藏white-space: nowrap;/* 强制在同一行内显示所有文本，直到文本结束或者br */ overflow: hidden;/* 超出部分隐藏 */ text-overflow: ellipsis;/* 超出部分显示省略号 */ 注意：做省略号效果，上面三句都需要。 Sprites为了有效地减少服务器接收和发送请求次数，提高页面加载速度。 CSS精灵是一种处理网页背景图像的方式。 滑动门字体图标icomoon字库 https://icomoon.io/ 阿里icon font字库 http://www.iconfont.cn/ sublime快捷键sublime可以快速提高我们代码的书写方式 1.生成标签直接输入标签名按tab键即可 比如div 然后tab键，就可以生成&lt;div&gt;&lt;/div&gt; 2.如果想要生成多个相同标签加上*就可以了比如div*3 就可以快速生成3个div 3.如果有父子级关系的标签，可以用&gt;比如ul&gt; li就可以了 4.如果有兄弟关系的标签，用+就可以了比如div+p 5.如果生成带有类名或者id名字的，直接写 .demo 或者#two tab 键就可以了","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"HTML标签","slug":"HTML标签","permalink":"http://yoursite.com/tags/HTML标签/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"JavaScript基本语法和DOM和BOM","slug":"1.JavaScript基本语法和DOM和BOM","date":"2018-11-25T14:09:07.125Z","updated":"2019-07-07T06:56:28.811Z","comments":false,"path":"2018/11/25/1.JavaScript基本语法和DOM和BOM/","link":"","permalink":"http://yoursite.com/2018/11/25/1.JavaScript基本语法和DOM和BOM/","excerpt":"","text":"JavaScript介绍js分为三个部分：ECMAScript标准（js的基本语法）、DOM（文档对象模型）、BOM（浏览器对象模型）。 js是一种脚本语言，解释型语言。 JavaScript三种写法&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;我是第一种写法&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;我是第二种写法&apos;)&quot;/&gt; &lt;script language=&quot;JavaScript&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; test.js alert(&quot;我是第三种写法&quot;); 变量和数据类型js中声明变量都用var，js中字符串可以使用单引号，也可以使用双引号。 原始数据类型： number、string、boolean、null、undefined、object 获取变量的数据类型(注意，null获取的类型为object) typeof 变量名;//或者 typeof (变量名); 判断是不是数字（不是数字返回true） isNaN(变量名); 判断字符串长度 字符串变量名.length 其他类型转为数字，Number最严格 parseInt(&quot;10&quot;); parseFloat(&quot;10.02&quot;); Number(&quot;10&quot;); 其他类型转为字符串 变量名.toString();//变量名一定要有意义 String(变量名); 其他类型转为布尔() Boolean(变量); 注意:==和===区别，==只进行值的比较，===对比值和类型。 注意:运算符先后顺序，先&amp;&amp;，后||。 if语句if(条件){ } else if(条件){ } else { } 三元表达式var 变量 = 表达式1 ? 表达式2 : 表达式3; switch语句switch (表达式){ case 值1: 代码1; break; case 值2: 代码2; break; ... default: 代码3; break; } while循环(有可能一次都不执行)while(循环的条件){ 循环体; 计数器++; } do…while(至少执行一次)do{ //循环体 }while(条件); for循环先执行表达式1，然后判断表达式2，如果不成立直接跳出循环。如果成立，执行循环体代码，结束后，跳到表达式3，然后判断表达式2。 for (表达式1; 表达式2; 表达式3) { 循环体; } for(var i = 0; i &lt; 10; i++){ } 调试alert(); console.log(); document.write(&quot;&quot;); 代码调试 break和continue数组var arr1 = new Array();//空数组 var arr2 = new Array(5);//长度为5，每个值是undefined var arr3 = [];//空数组 var arr4 = new Array(10,20,40,55,35);//5个值 var arr5 = [10,30,50,20,40];//5个值 设置某个位置的值 数组名[下标] = 值; 获取某个位置的值 var result = 数组名[下标]; 获取数组长度 数组名.length 数组中存储的数据类型可以不一样。 函数函数的定义 function 函数名(){ 函数体 } 函数的调用 函数名(); 函数的参数 function 函数名(参数名){ 函数体 } 注意:参数不需要定义var。形参指函数定义时小括号中的变量。实参指函数在调用时候小括号中传入的值。形参和实参个数可以不一致。 函数的返回值 function getSum(x,y){ return x + y; } var result = getSum(10,30); 函数的数据类型是function arguments对象伪数组arguments可以获取传入的每个参数的值 function f1(){ arguments.length; console.log(arguments) } f1(10,20,30,50); 匿名函数（函数表达式）var f1 = function (){ console.log(&quot;dsds&quot;); } //匿名函数不能直接调用 f1(); 函数的自调用（一次性）(function (){ console.log(&quot;ddddds&quot;); })(); 函数作为参数（回调函数）注意f2不要加括号 function f1(fn){ fn(); } function f2(){ console.log(&quot;原来这样&quot;); } f1(f2); 函数作为返回值注意ff(); function f1(){ console.log(&quot;原来&quot;); return function (){ console.log(&quot;原来这样&quot;); }; } var ff = f1(); ff(); 作用域全局变量：用var声明的。可以在页面的任何位置使用。页面不关闭，全局变量不会释放，会占空间，消耗内存。 局部变量：函数function中定义的变量。外面不能使用。 块级作用域：一对大括号中声明的变量。在js中，括号外面也能使用块级作用域中的变量。函数除外。 全局作用域：全局变量的适用范围。 局部作用域：局部变量的适用范围。 隐式全局变量：声明变量没有用var。函数中声明的局部变量，函数外面不可以访问。函数中声明的隐式全局变量，函数外面可以访问。 全局变量不能被删除，隐式全局变量可以被删除。使用var是不会被删除，没有var是可以删除。 var num1 = 10; num2 = 20; delete num1; delete num2; console.log(typeof num1);//number console.log(num1 + 10);//20 console.log(typeof num2);//underfine 预解析变量的声明和函数的声明被提前了。 把变量的声明提前了。局部作用域中局部变量声明也会提前，只提前在局部作用域中。 console.log(num);//underfine var num = 10; 函数的声明提前了。 f1(); function f1(){ console.log(&quot;dd&quot;);//dd } 注意： 结果为underfine f1(); var num = 20; function f1(){ console.log(num);//underfine } 结果为20 var num = 20; function f1(){ console.log(num);//20 } f1(); 结果为underfine var num = 20; function f1(){ console.log(num);//underfine var num = 30; } f1(); 结果为一个报错，其余为9，因为b和c为隐式全局变量，a是局部变量。 f1(); console.log(c); console.log(b); console.log(a);//报错 function f1(){ var a = b = c = 9; console.log(c); console.log(b); console.log(a); 结果为f1();报错，预解析f1是变量，调用f1();报错。 f1(); var f1 = function (){ console.log(a); var a = 9; } 创建对象1、调用系统的构造函数创建对象 var people = new Object(); //添加属性 people.name = &quot;小李&quot;; people.age = 18; //添加方法 people.eat = function(){ console.log(&quot;吃&quot;); }; //调用 people.eat(); 获取变量或者对象属于什么类型 instanceof 工厂模式创建对象 function createObject(name,age){ var obj = new Object(); obj.name = name; obj.age = age; obj.say = function (){ console.log(&quot;我叫&quot;+this.name+&quot;，今年&quot;+this.age); }; return obj; } var person1 = createObject(&quot;小李&quot;,20); person1.say(); 2、自定义构造函数创建对象 函数和构造函数区别，首字母是不是大写 function Person(name,age){ this.name = name; this.age = age; this.say = function (){ console.log(&quot;我叫&quot;+this.name+&quot;，今年&quot;+this.age); }; } var obj = new Person(&quot;小明&quot;,20); console.log(obj.age); obj.say(); 3、字面量的方式创建对象 var obj = { name : &quot;jsop&quot;, say : function (){ console.log(&quot;I am &quot; + this.name); } }; obj.say(); JSON格式的数据遍历访问属性的另一种写法：[&quot;&quot;] var obj = { name : &quot;jsop&quot;, say : function (){ console.log(&quot;I am &quot; + this.name); } }; obj.say(); 遍历 var json = { &quot;name&quot; : &quot;jsop&quot;, &quot;age&quot; : 18 }; for(var key in json){ console.log(key); console.log(json[key]); } 内置对象(系统提供的)https://developer.mozilla.org/zh-CN/ Math Math.random()//[0,1)范围 Date var dt = new Date();//当前时间 console.log(dt.valueOf());//毫秒值 String .replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;); .slice(开始索引，结束索引)；//截取 .split();//切割 Array .push(值);//给数组追加值，在最后添加，返回值是数组长度 .unshift();//给数组追加值，在最前添加，返回值是数组长度 .pop();//删除数组最后的值，返回删除的值 .shift();//删除数组第一个的值，返回删除的值 DOM-文档对象模型文档：document 元素element：页面中的每个标签，都是一个元素，每个元素都可以看成是一个对象。 节点node：页面中所有的内容都是节点，包括标签，属性，文本。 根元素：html标签。 获取元素对象document.getElementById(&quot;id&quot;) &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; id=&quot;btn&quot;&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).onclick = function (){ alert(&quot;哈哈&quot;); }; &lt;/script&gt; &lt;/body&gt; document.getElementsByTagName(&quot;标签名&quot;) 返回一个伪数组 var pObjs = document.getElementsByTagName(&quot;p&quot;) for (var i = 0; i &lt; pObjs.length;i++){ pObjs[i].innerText = &quot;哈哈哈&quot;; } 和document.getElementsByTagName类似的有：document.getElementsByName获取的是name伪数组，document.getElementsByClassName获取的是class伪数组 document.getElementsByTagName–排他功能 &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;script &gt; var objs = document.getElementsByTagName(&quot;input&quot;) for (var i = 0; i &lt; objs.length;i++){ objs[i].onclick = function () { for (var j = 0; j &lt; objs.length;j++){ objs[j].value = &quot;显示&quot;; } this.value= &quot;点击&quot;; }; } &lt;/script&gt; 根据选择器的方式获取元素 &lt;input type=&quot;button&quot; value=&quot;show&quot; id=&quot;btn&quot; class=&quot;cls&quot;/&gt; &lt;script &gt; document.querySelector(&quot;#btn&quot;).onclick = function(){ alert(&quot;哈哈&quot;); }; var objs = document.querySelectorAll(&quot;cls&quot;);//伪数组 &lt;/script&gt; 小结 根据id属性的值获取元素，返回来的是一个元素对象document.getELementById(&quot;id属性的值&quot;); 根据标签名字获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象document.getELementsByTagName(&quot;标签名字&quot;); 下面的几个，有的浏览器不支持 根据name属性的值获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象document.getELementsByName (&quot;name属性的值&quot;) 根据类样式的名字来获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象document.getELementsByClassName(&quot;类样式的名字&quot;)根据选择器获取元素，返回来的是一个元素对象document.querySelector( &quot;选择器的名字&quot;); 对象属性class设置使用className document.getElementById(&quot;dd&quot;).className = &quot;cls&quot;; 获取body、title、html document.body document.title document.documentElement 阻止超链接跳转 &lt;a href=&quot;http://www.baidu.com&quot; id=&quot;ak&quot;&gt;百度&lt;/a&gt; &lt;script &gt; document.getElementById(&quot;ak&quot;).onclick = function (){ alert(&quot;哈啊哈&quot;); return false; }; &lt;/script&gt; 鼠标进入和离开 .onmouseover .onmouseout 文本框获取焦点和失去焦点 .onfocus .onblur 键盘弹起 .onkeyup 获取输入框输入长度value.length &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;txt&quot;/&gt; &lt;script &gt; document.getElementById(&quot;txt&quot;).onblur = function(){ alert(this.value.length); }; &lt;/script&gt; innerText和textContent、innerHTML凡是成对的标签，设置文本内容，都使用innerText属性,同样，获取文本内容是.innerText。 document.getElementById(&quot;p1&quot;).innerText=&quot;这是设置文本p&quot;; 单数不兼容。innerText：谷歌，火狐支持，IE8不支持；textContent：谷歌，火狐，IE8都支持。 封装 //设置 function setInnerText(element,text){ if(typeof element.textContent == &quot;underfined&quot;){//不支持 element.innerText = text; } else{//支持 lement.textContent = text; } } //获取 function getInnerText(element){ if(typeof element.textContent == &quot;underfined&quot;) {//不支持 return element.innerText; } else{//支持 return element.textContent; } } innerText和innerHTML都可以设置设置文本，innerHTML还可以设置标签。 innerText可以获取标签中的文本，但是标签中还有标签，那么最里面的标签文本内容也能获取。innerHTML可以获取标签中的所有文本，包括标签。 .innerHTML = &quot;haha&quot;; .innerHTML = &quot;&lt;p&gt;这是p&lt;/p&gt;&gt;&quot;; 自定义属性自定义属性获取：getAttribute。自定义属性动态设置：setAttribute &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; ul{ list-style: none; cursor: pointer; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;王五&lt;/li&gt; &lt;li&gt;赵六&lt;/li&gt; &lt;/ul&gt; &lt;script &gt; var list = document.getElementsByTagName(&quot;li&quot;); for(var i = 0; i &lt; list.length; i ++){ list[i].setAttribute(&quot;score&quot;,(i+1)*10); list[i].onclick = function(){ alert(this.getAttribute(&quot;score&quot;)); }; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 移除自定义属性 .removeAttribute(&quot;name&quot;) 移除class .removeAttribute(&quot;class&quot;); 设置backgroundImage .style.backgroundImage = &quot;url(&quot; + src + &quot;)&quot;; 节点节点的类型 nodeType:1、标签，2、属性，3、文本。 节点的名字 nodeName:标签节点：大写的标签名字；属性节点：小写的属性名字；文本节点：#text 节点的值 nodeValue:标签节点：null;属性节点：属性值；文本节点：文本内容。 获取父节点和父元素 .parentNode .parentElement 子节点和子元素 .childNodes .children 第一个子节点和子元素 .firstChild//IE8是元素 .firstElementChild//IE8不支持 最后一个子节点和子元素 .lastChild//IE8是元素 .lastElementChild//IE8不支持 某元素的前一个兄弟节点和元素 .previousSibling//IE8是元素 .previousElementSlbling//IE8不支持 某元素的后一个兄弟节点和元素 .nextSibling//IE8是元素 .nextElementSlbling//IE8不支持 获取节点 .getAttributeNode(&quot;属性名&quot;); 元素的创建三种方式 1、document.write(&quot;标签的代码及内容&quot;) 缺陷：如果是在页面加载完毕后，通过这种方式创建的，页面上存在的所有的内容全部被干掉。 2、对象.innerHTML = &quot;标签及代码&quot; 3、document.createElement(&quot;标签的名字&quot;) 注意：要追加到父级元素，appendChild &lt;input type=&quot;button&quot; value=&quot;追加&quot; id=&quot;btn&quot;/&gt; &lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).onclick = function (){ var pObj = document.createElement(&quot;P&quot;); pObj.innerText = &quot;这是p&quot;; document.getElementById(&quot;dv&quot;).appendChild(pObj); }; &lt;/script&gt; 把新的子元素插到第一个子元素前面 .insertBefore(新元素，旧元素); 移除父级元素中的第一个元素 .removeChild(父元素对象.firstElementChild); 移除父级元素中的所有元素 while(父元素对象.firstElementChild){ .removeChild(父元素对象.firstElementChild); } createElement只创建一个元素 &lt;input type=&quot;button&quot; value=&quot;追加&quot; id=&quot;btn&quot;/&gt; &lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).onclick = function (){ if(!document.getElementById(&quot;dv&quot;).firstElementChild){ var pObj = document.createElement(&quot;P&quot;); pObj.innerText = &quot;这是p&quot;; document.getElementById(&quot;dv&quot;).appendChild(pObj); } }; &lt;/script&gt; 元素绑定多个事件.addEventListener和.attachEvent&lt;input type=&quot;button&quot; value=&quot;多个事件&quot; id=&quot;btn&quot;/&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;,function(){ console.log(&quot;哈哈&quot;); },false); document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;,function(){ console.log(&quot;嘻嘻&quot;); },false); &lt;/script&gt; 兼容性.addEventListener支持谷歌火狐，.attachEvent支持IE function commonAddEventListener(element,type,fn){ if(element.addEventListener()){ element.addEventListener(type,fn,false); } else if (element.attachEvent()){ element.attachEvent(&quot;on&quot; + type,fn); } else{ element[&quot;on&quot; + type] = fn; } } addEventListener和attachEvent都可以为元素绑定事件。它们的不同点有：参数个数不一样；addEventListener中事件类型没有on,attachEvent中事件类型有on;addEventListener中this指当前绑定的事件，attachEvent中this指window。 元素解绑事件解绑onclick、addEventListener、attachEvent .onclick = null; .removeEventListener(&quot;click&quot;,&quot;解绑函数名&quot;,false); .detachEvent(&quot;onclick&quot;,&quot;解绑函数名&quot;); 事件冒泡指多个元素嵌套，有层次关系，这些元素都注册了相同事件，如果里面的元素事件触发了，那么外面的元素的该事件自动的触发了。 阻止事件冒泡 window.event.cancelBubble = true;//谷歌和IE支持，火狐不支持 window.event.stopPropagation();//谷歌和火狐支持，IE不支持 事件的三个阶段addEventListener第三个参数控制事件阶段的。 1、事件的捕获阶段，从外向内。 2、事件的目标阶段， .eventPhase 3、事件的冒泡阶段，从内向外。 为同一个元素绑定多个不同事件，指定的是同一个事件处理函数 .onclick = f; .onmouseover = f; .onmouseout = f; function f (e){ switch (e.type){ case &quot;click&quot;: break; case &quot;mouseover&quot;: break; case &quot;mouseout&quot;: break; } } BOM浏览器对象模型。 window:浏览器的顶级对象； document:页面中的顶级对象。 页面中的所用内容都是属于浏览器的，页面中的内容也都是window的。 alert() prompt() confirm() onloadonload使用 window.onload = function(){ document.getElementById(&quot;btn&quot;).onclick = function (){ }; }; onunload页面关闭后触发的事件；onbeforeunload页面关闭前触发的事件(IE8支持)。 location属性 window.location.hash//#及后面内容 window.location.host//主机名及端口号 window.location.hostname//主机名 window.location.pathname//路径 window.location.port//端口号 window.location.protocol//协议，http window.location.search//？及后面内容 方法 window.location.href = &quot;设置跳转页面地址&quot;;//可后退 window.location.assign(&quot;设置跳转页面地址&quot;);//可后退 window.location.reload();//刷新，重新加载 window.location.replace(&quot;设置跳转页面地址&quot;);//不可后退 historywindow.history.back(); window.history.forward(); window.history.go();//整数和负数代表前进和后退 navigatorwindow.navigator.platform//判断浏览器所在的系统平台类型 window.navigator.userAgent 定时器反复执行 var timeId = window.setInterval(function(){},1000);//设置定时 window.clearInterval(timeId);//停止定时 一次性定时器 var timeId = window.setTimeout(function(){},1000); clearTimeout(timeId);//清除定时缓存空间 offset获取元素的宽和高（包含边框） .offsetWidth;//数字类型，没有px .offsetHeight; 获取元素的left和top， .offsetLeft; .offsetTop; 注意： 没有脱离文档流时，和父级元素的margin、padding、border，自己的margin，有关系。脱离文档流时，和自己的margin、left，有关系。 scroll元素中内容实际的宽和高，不包含边框，没有内容，就是宽高 .scrollWidth; .scrollHeight; 向左或者向上卷曲出去的距离 .scrollLeft; .scrollTop; 滚动事件 .onscroll 滚动距离计算 var top = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var left = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; client可视区域（没有边框）边框内的宽高 .clientWidth; .clientHeight; 左边框和上边框的宽度 .clientLeft; .clientTop; 获取元素的样式属性值window.getComputedStyle(元素对象,null).属性;//谷歌，火狐 元素对象.currentStyle.属性;//IE8 兼容代码 function getStyle(element,attr){ if(window.getComputedStyle){ return window.getComputedStyle(element,attr)[attr];//谷歌，火狐 } else{ return element.currentStyle[attr]; } } 其他透明度 .style.opacity =","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]}]}