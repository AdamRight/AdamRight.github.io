{"meta":{"title":"Jiang Space","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[{"title":"about","date":"2021-03-25T13:55:49.000Z","updated":"2021-03-25T13:55:49.141Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"量化杂记","slug":"46.量化杂记","date":"2021-04-07T13:55:49.407Z","updated":"2021-06-13T15:30:32.094Z","comments":false,"path":"2021/04/07/46.量化杂记/","link":"","permalink":"http://yoursite.com/2021/04/07/46.%E9%87%8F%E5%8C%96%E6%9D%82%E8%AE%B0/","excerpt":"","text":"启动jupyter 启动：jupyter notebook pandas基础 pandas基础： # -*- coding: utf-8 -*- &quot;&quot;&quot; 程序开头注释 功能：本程序主要介绍pandas最最常用的一些方法。这些方法在之后的课程、作业中都会用到。 &quot;&quot;&quot; import pandas as pd # 将pandas作为第三方库导入，我们一般为pandas取一个别名叫做pd # =====导入数据 df = pd.read_csv( # 该参数为数据在电脑中的路径，可以不填写 filepath_or_buffer=&apos;/Users/jxing/Desktop/201704课程/20170423_class3/data/sz000002.csv&apos;, # 该参数代表数据的分隔符，csv文件默认是逗号。其他常见的是&apos;\\t&apos; sep=&apos;,&apos;, # 该参数代表跳过数据文件的的第1行不读入 skiprows=1, # nrows，只读取前n行数据，若不指定，读入全部的数据 nrows=15, # 将指定列的数据识别为日期格式。若不指定，时间数据将会以字符串形式读入。一开始先不用。 # parse_dates=[&apos;交易日期&apos;], # 将指定列设置为index。若不指定，index默认为0, 1, 2, 3, 4... # index_col=[&apos;交易日期&apos;], # 读取指定的这几列数据，其他数据不读取。若不指定，读入全部列 usecols=[&apos;交易日期&apos;, &apos;股票代码&apos;, &apos;股票名称&apos;, &apos;收盘价&apos;, &apos;涨跌幅&apos;, &apos;成交量&apos;, &apos;新浪概念&apos;, &apos;MACD_金叉死叉&apos;], # 当某行数据有问题时，报错。设定为False时即不报错，直接跳过该行。当数据比较脏乱的时候用这个。 error_bad_lines=False, # 将数据中的null识别为空值 na_values=&apos;NULL&apos;, # 更多其他参数，请直接搜索&quot;pandas read_csv&quot;，要去逐个查看一下。比较重要的，header等 ) # print df # 使用read_csv导入数据非常方便 # 导入的数据的数据类型是DataFrame。 # 导入数据主要使用read系列函数 # 还有read_table、read_excel、read_json等，他们的参数内容都是大同小异，可以自行搜索查看。 # =====看数据 # print df.shape # 输出dataframe有多少行、多少列。 # print df.shape[0] # 取行数量，相应的列数量就是df.shape[1] # print df.columns # 顺序输出每一列的名字，演示如何for语句遍历。 # print df.index # 顺序输出每一行的名字，可以for语句遍历。 # print df.dtypes # 数据每一列的类型不一样，比如数字、字符串、日期等。该方法输出每一列变量类型 # print df.head(3) # 看前3行的数据，默认是5。与自然语言很接近 # print df.tail(3) # 看最后3行的数据，默认是5。 # print df.sample(n=3) # 随机抽取3行，想要去固定比例的话，可以用frac参数 # print df.describe() # 非常方便的函数，对每一列数据有直观感受；只会对数字类型的列有效 # 对print出的数据格式进行修正 # pd.set_option(&apos;expand_frame_repr&apos;, False) # 当列太多时不换行 # pd.set_option(&apos;max_colwidth&apos;, 8) # 设定每一列的最大宽度，恢复原设置的方法，pd.reset_option(&apos;max_colwidth&apos;) # 更多设置请见http://pandas.pydata.org/pandas-docs/stable/options.html # =====如何选取指定的行、列 # print df[&apos;股票代码&apos;] # 根据列名称来选取，读取的数据是Series类型 # print df[[&apos;股票代码&apos;, &apos;收盘价&apos;]] # 同时选取多列，需要两个括号，读取的数据是DataFrame类型 # print df[[0, 1, 2]] # 也可以通过列的position来选取 # loc操作：通过label（columns和index的名字）来读取数据 # print df.loc[&apos;12/12/2016&apos;] # 选取指定的某一行，读取的数据是Series类型 # print df.loc[&apos;13/12/2016&apos;: &apos;06/12/2016&apos;] # 选取在此范围内的多行，和在list中slice操作类似，读取的数据是DataFrame类型 # print df.loc[:, &apos;股票代码&apos;:&apos;收盘价&apos;] # 选取在此范围内的多列，读取的数据是DataFrame类型 # print df.loc[&apos;13/12/2016&apos;: &apos;06/12/2016&apos;, &apos;股票代码&apos;:&apos;收盘价&apos;] # 读取指定的多行、多列。逗号之前是行的范围，逗号之后是列的范围。读取的数据是DataFrame类型 # print df.loc[:, :] # 读取所有行、所有列，读取的数据是DataFrame类型 # print df.at[&apos;12/12/2016&apos;, &apos;股票代码&apos;] # 使用at读取指定的某个元素。loc也行，但是at更高效。 # iloc操作：通过position来读取数据 # print df.iloc[0] # 以index选取某一行，读取的数据是Series类型 # print df.iloc[1:3] # 选取在此范围内的多行，读取的数据是DataFrame类型 # print df.iloc[:, 1:3] # 选取在此范围内的多列，读取的数据是DataFrame类型 # print df.iloc[1:3, 1:3] # 读取指定的多行、多列，读取的数据是DataFrame类型 # print df.iloc[:, :] # 读取所有行、所有列，读取的数据是DataFrame类型 # print df.iat[1, 1] # 使用iat读取指定的某个元素。使用iloc也行，但是iat更高效。 # =====列操作 # 行列加减乘除 # print df[&apos;股票名称&apos;] + &apos;_地产&apos; # 字符串列可以直接加上字符串，对整列进行操作 # print df[&apos;收盘价&apos;] * 100 # 数字列直接加上或者乘以数字，对整列进行操作。 # print df[&apos;收盘价&apos;] * df[&apos;成交量&apos;] # 两列之间可以直接操作。收盘价*成交量计算出的是什么？ # 新增一列 # df[&apos;股票名称+行业&apos;] = df[&apos;股票名称&apos;] + &apos;_地产&apos; # =====统计函数 # print df[&apos;收盘价&apos;].mean() # 求一整列的均值，返回一个数。会自动排除空值。 # print df[[&apos;收盘价&apos;, &apos;成交量&apos;]].mean() # 求两列的均值，返回两个数，Series # print df[[&apos;收盘价&apos;, &apos;成交量&apos;]] # print df[[&apos;收盘价&apos;, &apos;成交量&apos;]].mean(axis=1) # 求两列的均值，返回DataFrame。axis=0或者1要搞清楚。 # axis=1，代表对整几列进行操作。axis=0（默认）代表对几行进行操作。实际中弄混很正常，到时候试一下就知道了。 # print df[&apos;收盘价&apos;].max() # 最大值 # print df[&apos;收盘价&apos;].min() # 最小值 # print df[&apos;收盘价&apos;].std() # 标准差 # print df[&apos;收盘价&apos;].count() # 非空的数据的数量 # print df[&apos;收盘价&apos;].median() # 中位数 # print df[&apos;收盘价&apos;].quantile(0.25) # 25%分位数 # 肯定还有其他的函数计算其他的指标，在实际使用中遇到可以自己搜索 # =====shift类函数、删除列的方式 # df[&apos;昨天收盘价&apos;] = df[&apos;收盘价&apos;].shift(-1) # 读取上一行的数据，若参数设定为3，就是读取上三行的数据；若参数设定为-1，就是读取下一行的数据； # print df[[&apos;收盘价&apos;, &apos;昨天收盘价&apos;]] # del df[&apos;昨天收盘价&apos;] # 删除某一列的方法 # df[&apos;涨跌&apos;] = df[&apos;收盘价&apos;].diff(-1) # 求本行数据和上一行数据相减得到的值 # print df[[&apos;收盘价&apos;, &apos;涨跌&apos;]] # df.drop([&apos;涨跌&apos;], axis=1, inplace=True) # 删除某一列的另外一种方式，inplace参数指是否替代原来的df # print df # df[&apos;涨跌幅_计算&apos;] = df[&apos;收盘价&apos;].pct_change(-1) # 类似于diff，但是求的是两个数直接的比例，相当于求涨跌幅 # =====cum(cumulative)类函数 # df[&apos;成交量_cum&apos;] = df[&apos;成交量&apos;].cumsum() # 该列的累加值 # print df[[&apos;成交量&apos;, &apos;成交量_cum&apos;]] # print (df[&apos;涨跌幅&apos;] + 1.0).cumprod() # 该列的累乘值，此处计算的就是资金曲线，假设初始1元钱。 # =====其他列函数 # df[&apos;收盘价_排名&apos;] = df[&apos;收盘价&apos;].rank(ascending=True, pct=False) # 输出排名。ascending参数代表是顺序还是逆序。pct参数代表输出的是排名还是排名比例 # print df[[&apos;收盘价&apos;, &apos;收盘价_排名&apos;]] # del df[&apos;收盘价_排名&apos;] # print df[&apos;股票代码&apos;].value_counts() # 计数。统计该列中每个元素出现的次数。返回的数据是Series # =====筛选操作，根据指定的条件，筛选出相关拿数据。 # print df[&apos;股票代码&apos;] == &apos;sh000002&apos; # 判断股票代码是否等于sz000002 # print df[df[&apos;股票代码&apos;] == &apos;sz000002&apos;] # 将判断为True的输出：选取股票代码等于sz000002的行 # print df[df[&apos;股票代码&apos;].isin([&apos;sz000002&apos;, &apos;sz000003 &apos;, &apos;sz000004&apos;])] # 选取股票代码等于sz000002的行 # print df[df[&apos;收盘价&apos;] &gt;= 24.0] # 选取收盘价大于24的行 # print df[(df.index &gt;= &apos;03/12/2016&apos;) &amp; (df.index &lt;= &apos;06/12/2016&apos;)] # 两个条件，或者的话就是| # =====缺失值处理：原始数据中存在缺失值，如何处理？ # 删除缺失值 # print df.dropna(how=&apos;any&apos;) # 将带有空值的行删除。how=&apos;any&apos;意味着，该行中只要有一个空值，就会删除，可以改成all。 # print df.dropna(subset=[&apos;MACD_金叉死叉&apos;, &apos;涨跌幅&apos;], how=&apos;all&apos;) # subset参数指定在特定的列中判断空值。 # all代表全部为空，才会删除该行；any只要一个为空，就删除该行。 # 补全缺失值 # print df.fillna(value=&apos;没有金叉死叉&apos;) # 直接将缺失值赋值为固定的值 # df[&apos;MACD_金叉死叉&apos;].fillna(value=df[&apos;收盘价&apos;], inplace=True) # 直接将缺失值赋值其他列的数据 # print df.fillna(method=&apos;ffill&apos;) # 向上寻找最近的一个非空值，以该值来填充缺失的位置，全称forward fill，非常有用 # print df.fillna(method=&apos;bfill&apos;) # 向下寻找最近的一个非空值，以该值来填充确实的位置，全称backward fill # 找出缺失值 # print df.notnull() # 判断是否为空值，反向函数为isnull() # print df[df[&apos;MACD_金叉死叉&apos;].notnull()] # 将&apos;MACD_金叉死叉&apos;列为空的行输出 # =====排序函数 # df.reset_index(inplace=True) # print df.sort_values(by=[&apos;交易日期&apos;], ascending=1) # by参数指定按照什么进行排序，acsending参数指定是顺序还是逆序，1顺序，0逆序 # print df.sort_values(by=[&apos;股票名称&apos;, &apos;交易日期&apos;], ascending=[1, 1]) # 按照多列进行排序 # =====两个df上下合并操作，append操作 # df.reset_index(inplace=True) # df1 = df.iloc[0:10][[&apos;交易日期&apos;, &apos;股票代码&apos;, &apos;收盘价&apos;, &apos;涨跌幅&apos;]] # print df1 # df2 = df.iloc[5:15][[&apos;交易日期&apos;, &apos;股票名称&apos;, &apos;收盘价&apos;, &apos;涨跌幅&apos;]] # print df2 # print df1.append(df2) # append操作，将df1和df2上下拼接起来。注意观察拼接之后的index # df3 = df1.append(df2, ignore_index=True) # ignore_index参数，用户重新确定index # print df3 # =====对数据进行去重 # df3中有重复的行数，我们如何将重复的行数去除？ # df3.drop_duplicates( # subset=[&apos;收盘价&apos;, &apos;交易日期&apos;], # subset参数用来指定根据哪类类数据来判断是否重复。若不指定，则用全部列的数据来判断是否重复 # keep=&apos;first&apos;, # 在去除重复值的时候，我们是保留上面一行还是下面一行？first保留上面一行，last保留下面一行，False就是一行都不保留 # inplace=True # ) # print df3 # =====其他常用重要函数 # print df.rename(columns=&#123;&apos;MACD_金叉死叉&apos;: &apos;金叉死叉&apos;, &apos;涨跌幅&apos;: &apos;涨幅&apos;&#125;) # rename函数给变量修改名字。使用dict将要修改的名字传给columns参数 # print df.empty # 判断一个df是不是为空，此处输出不为空 # print pd.DataFrame().empty # pd.DataFrame()创建一个空的DataFrame，此处输出为空 # print df.T # 将数据转置，行变成列，很有用 # =====字符串处理 # print df[&apos;股票代码&apos;] # print &apos;sz000002&apos;[:2] # print df[&apos;股票代码&apos;].str[:2] # print df[&apos;股票代码&apos;].str.upper() # 加上str之后可以使用常见的字符串函数对整列进行操作 # print df[&apos;股票代码&apos;].str.lower() # print df[&apos;股票代码&apos;].str.len() # 计算字符串的长度,length # df[&apos;股票代码&apos;].str.strip() # strip操作，把字符串两边的空格去掉 # print df[&apos;股票代码&apos;].str.contains(&apos;sh&apos;) # 判断字符串中是否包含某些特定字符 # print df[&apos;股票代码&apos;].str.replace(&apos;sz&apos;, &apos;sh&apos;) # 进行替换，将sz替换成sh # split操作 # print df[&apos;新浪概念&apos;].str.split(&apos;；&apos;) # 对字符串进行分割 # print df[&apos;新浪概念&apos;].str.split(&apos;；&apos;).str[:2] # 分割后取第一个位置 # print df[&apos;新浪概念&apos;].str.split(&apos;；&apos;, expand=True) # 分割后并且将数据分列 # # 更多字符串函数请见：http://pandas.pydata.org/pandas-docs/stable/text.html#method-summary # =====时间处理 # 导入数据时将index参数注释掉 # df[&apos;交易日期&apos;] = pd.to_datetime(df[&apos;交易日期&apos;]) # 将交易日期由字符串改为时间变量 # print df[&apos;交易日期&apos;] # print df.iloc[0][&apos;交易日期&apos;] # print df.dtypes # print pd.to_datetime(&apos;1999年01月01日&apos;) # pd.to_datetime函数：将字符串转变为时间变量 # print df.at[0, &apos;交易日期&apos;] # print df[&apos;交易日期&apos;].dt.year # 输出这个日期的年份。相应的month是月份，day是天数，还有hour, minute, second # print df[&apos;交易日期&apos;].dt.week # 这一天是一年当中的第几周 # print df[&apos;交易日期&apos;].dt.dayofyear # 这一天是一年当中的第几天 # print df[&apos;交易日期&apos;].dt.dayofweek # 这一天是这一周当中的第几天，0代表星期一 # print df[&apos;交易日期&apos;].dt.weekday # 和上面函数相同，更加常用 # print df[&apos;交易日期&apos;].dt.weekday_name # 和上面函数相同，返回的是星期几的英文，用于报表的制作。 # print df[&apos;交易日期&apos;].dt.days_in_month # 这一天是这一月当中的第几天 # print df[&apos;交易日期&apos;].dt.is_month_end # 这一天是否是该月的开头，是否存在is_month_end？ # print df[&apos;交易日期&apos;] + pd.Timedelta(days=1) # 增加一天，Timedelta用于表示时间差数据 # print (df[&apos;交易日期&apos;] + pd.Timedelta(days=1)) - df[&apos;交易日期&apos;] # 增加一天然后再减去今天的日期 # =====rolling、expanding操作 # 计算&apos;收盘价&apos;这一列的均值 # print df[&apos;收盘价&apos;].mean() # 如何得到每一天的最近3天收盘价的均值呢？即如何计算常用的移动平均线？ # 使用rolling函数 # df[&apos;收盘价_3天均值&apos;] = df[&apos;收盘价&apos;].rolling(5).mean() # print df[[&apos;收盘价&apos;, &apos;收盘价_3天均值&apos;]] # rolling(n)即为取最近n行数据的意思，只计算这n行数据。后面可以接各类计算函数，例如max、min、std等 # print df[&apos;收盘价&apos;].rolling(3).max() # print df[&apos;收盘价&apos;].rolling(3).min() # print df[&apos;收盘价&apos;].rolling(3).std() # rolling可以计算每天的最近3天的均值，如果想计算每天的从一开始至今的均值，应该如何计算？ # 使用expanding操作 # df[&apos;收盘价_至今均值&apos;] = df[&apos;收盘价&apos;].expanding().mean() # print df[[&apos;收盘价&apos;, &apos;收盘价_至今均值&apos;]] # expanding即为取从头至今的数据。后面可以接各类计算函数 # print df[&apos;收盘价&apos;].expanding().max() # print df[&apos;收盘价&apos;].expanding().min() # print df[&apos;收盘价&apos;].expanding().std() # rolling和expanding简直是为量化领域量身定制的方法，经常会用到。 # =====输出 # print df # df.to_csv(&apos;output.csv&apos;, encoding=&apos;gbk&apos;, index=False) # =====文档 # 以上是我认为最常用的函数 # 哪里可以看到全部的函数？http://pandas.pydata.org/pandas-docs/stable/api.html # 一般的使用方法 resample resample获取周、月数据。将数据转换为制定周期：开盘价（周期第1天）、收盘价（周期最后1天）、最高价（周期内）、最低价（周期内）。 import pandas as pd import datetime import time import os pd.set_option(&apos;expand_frame_repr&apos;, False) # 当列太多时不换行 pd.set_option(&apos;max_row&apos;,4000)#最多行数 # =====读入数据 df = pd.read_csv(&apos;G:/share//note/000001上证指数.csv&apos;, encoding=&apos;gbk&apos;) df.columns = [i for i in df.columns] df = df[[&apos;日期&apos;,&apos;收盘价&apos;,&apos;开盘价&apos;,&apos;最高价&apos;,&apos;最低价&apos;,&apos;涨跌幅&apos;]] df.sort_values(by=[&apos;日期&apos;], inplace=True) df[&apos;日期&apos;] = pd.to_datetime(df[&apos;日期&apos;]) # 最近十二年数据 df = df[df[&apos;日期&apos;] &gt;= &apos;2009-04-12&apos;] df.reset_index(inplace=True, drop=True) print(df) def transfer_price_freq(data, time_freq): &quot;&quot;&quot; 将数据转换为制定周期：开盘价（周期第1天）、收盘价（周期最后1天）、最高价（周期内）、最低价（周期内） :param data: :param time_freq: :return: &quot;&quot;&quot; df_trans = pd.DataFrame() df_trans[&apos;开盘价&apos;] = data[&apos;开盘价&apos;].resample(time_freq).first() df_trans[&apos;收盘价&apos;] = data[&apos;收盘价&apos;].resample(time_freq).last() df_trans[&apos;最高价&apos;] = data[&apos;最高价&apos;].resample(time_freq).max() df_trans[&apos;最低价&apos;] = data[&apos;最低价&apos;].resample(time_freq).min() return df_trans # 转换index df = df.set_index(df[&apos;日期&apos;]) #print(transfer_price_freq(df,&apos;M&apos;)) print(transfer_price_freq(df,&apos;W&apos;)) shift涨跌幅 def calculate_change_pct(data): &quot;&quot;&quot; 涨跌幅 = (当期收盘价-前期收盘价) / 前期收盘价 :param data: dataframe，带有收盘价 :return: dataframe，带有涨跌幅 &quot;&quot;&quot; data[&apos;close_pct&apos;] = (data[&apos;close&apos;] - data[&apos;close&apos;].shift(1)) \\ / data[&apos;close&apos;].shift(1) return data 数据存储和读取 def update_daily_price(stock_code, type=&apos;price&apos;): # 3.1是否存在文件：不存在-重新获取，存在-&gt;3.2 file_root = data_root + type + &apos;/&apos; + stock_code + &apos;.csv&apos; if os.path.exists(file_root): # 如果存在对应文件 # 3.2获取增量数据（code，startsdate=对应股票csv中最新日期，enddate=今天） startdate = pd.read_csv(file_root, usecols=[&apos;date&apos;])[&apos;date&apos;].iloc[-1] df = get_single_price(stock_code, &apos;daily&apos;, startdate, datetime.datetime.today()) # 3.3追加到已有文件中 export_data(df, stock_code, &apos;price&apos;, &apos;a&apos;) else: # 重新获取该股票行情数据 df = get_single_price(stock_code, &apos;daily&apos;) export_data(df, stock_code, &apos;price&apos;) print(&quot;股票数据已经更新成功：&quot;, stock_code) def export_data(data, filename, type, mode=None): &quot;&quot;&quot; 导出股票相关数据 :param data: :param filename: :param type: 股票数据类型，可以是：price、finance :param mode: a代表追加，none代表默认w写入 :return: &quot;&quot;&quot; file_root = data_root + type + &apos;/&apos; + filename + &apos;.csv&apos; data.index.names = [&apos;date&apos;] if mode == &apos;a&apos;: data.to_csv(file_root, mode=mode, header=False) # 删除重复值 data = pd.read_csv(file_root) # 读取数据 data = data.drop_duplicates(subset=[&apos;date&apos;]) # 以日期列为准 data.to_csv(file_root, index=False) # 重新写入 else: data.to_csv(file_root) # 判断一下file是否存在 &gt; 存在：追加 / 不存在：保持 print(&apos;已成功存储至：&apos;, file_root) 计算交易指标 import pandas as pd import numpy as np import datetime import matplotlib.pyplot as plt def get_single_price(): &quot;&quot;&quot; 获取单数据 &quot;&quot;&quot; pd.set_option(&apos;expand_frame_repr&apos;, False) # 当列太多时不换行 pd.set_option(&apos;max_row&apos;,4000)#最多行数 # =====读入数据 df = pd.read_csv(&apos;G:/share/note/000001上证指数.csv&apos;, encoding=&apos;gbk&apos;) df.columns = [i for i in df.columns] df = df[[&apos;日期&apos;,&apos;收盘价&apos;,&apos;开盘价&apos;,&apos;最高价&apos;,&apos;最低价&apos;,&apos;涨跌幅&apos;]] df.sort_values(by=[&apos;日期&apos;], inplace=True) df[&apos;日期&apos;] = pd.to_datetime(df[&apos;日期&apos;]) # 最近十二年数据 df = df[df[&apos;日期&apos;] &gt;= &apos;2009-04-12&apos;] df.reset_index(inplace=True, drop=True) df = df.set_index(df[&apos;日期&apos;]) return df def compose_signal(data): &quot;&quot;&quot; 整合信号 :param data: :return: &quot;&quot;&quot; data[&apos;buy_signal&apos;] = np.where((data[&apos;buy_signal&apos;] == 1) &amp; (data[&apos;buy_signal&apos;].shift(1) == 1), 0, data[&apos;buy_signal&apos;]) data[&apos;sell_signal&apos;] = np.where((data[&apos;sell_signal&apos;] == -1) &amp; (data[&apos;sell_signal&apos;].shift(1) == -1), 0, data[&apos;sell_signal&apos;]) data[&apos;signal&apos;] = data[&apos;buy_signal&apos;] + data[&apos;sell_signal&apos;] return data def calculate_prof_pct(data): &quot;&quot;&quot; 计算单次收益率：开仓、平仓（开仓的全部股数） :param data: :return: &quot;&quot;&quot; data = data[data[&apos;signal&apos;] != 0] # 筛选 data[&apos;profit_pct&apos;] = (data[&apos;收盘价&apos;] - data[&apos;收盘价&apos;].shift(1)) / data[&apos;收盘价&apos;].shift(1) data = data[data[&apos;signal&apos;] == -1] return data def calculate_cum_prof(data): &quot;&quot;&quot; 计算累计收益率 :param data: dataframe :return: &quot;&quot;&quot; data[&apos;cum_profit&apos;] = pd.DataFrame(1 + data[&apos;profit_pct&apos;]).cumprod() - 1 return data def caculate_max_drawdown(data): &quot;&quot;&quot; 计算最大回撤比 :param data: :return: &quot;&quot;&quot; # 选取时间周期（时间窗口） window = 252 # 选取时间周期中的最大净值 data[&apos;roll_max&apos;] = data[&apos;收盘价&apos;].rolling(window=window, min_periods=1).max() # 计算当天的回撤比 = (谷值 — 峰值)/峰值 = 谷值/峰值 - 1 data[&apos;daily_dd&apos;] = data[&apos;收盘价&apos;] / data[&apos;roll_max&apos;] - 1 # 选取时间周期内最大的回撤比，即最大回撤 data[&apos;max_dd&apos;] = data[&apos;daily_dd&apos;].rolling(window, min_periods=1).min() return data def calculate_sharpe(data): &quot;&quot;&quot; 计算夏普比率，返回的是年化的夏普比率 :param data: dataframe, stock :return: float &quot;&quot;&quot; # 公式：sharpe = (回报率的均值 - 无风险利率) / 回报率的标准差 daily_return = data[&apos;收盘价&apos;].pct_change() avg_return = daily_return.mean() sd_reutrn = daily_return.std() # 计算夏普：每日收益率 * 252 = 每年收益率 sharpe = avg_return / sd_reutrn sharpe_year = sharpe * np.sqrt(252) return sharpe, sharpe_year def week_period_strategy(data): &quot;&quot;&quot; 周期选股（周四买，周一卖） &quot;&quot;&quot; # 新建周期字段 data[&apos;weekday&apos;] = data.index.weekday # 周四买入 data[&apos;buy_signal&apos;] = np.where((data[&apos;weekday&apos;] == 3), 1, 0) # 周一卖出 data[&apos;sell_signal&apos;] = np.where((data[&apos;weekday&apos;] == 0), -1, 0) data = compose_signal(data) # 整合信号 data = calculate_prof_pct(data) # 计算收益 data = calculate_cum_prof(data) # 计算累计收益率 # data = caculate_max_drawdown(data) # 最大回撤 return data if __name__ == &apos;__main__&apos;: df = get_single_price() df = week_period_strategy(df) df = df[[&apos;收盘价&apos;,&apos;开盘价&apos;,&apos;涨跌幅&apos;,&apos;signal&apos;,&apos;profit_pct&apos;,&apos;cum_profit&apos;]] caculate_max_drawdown(df) df[[&apos;daily_dd&apos;,&apos;daily_dd&apos;]].plot() plt.show() print(df) df[&apos;profit_pct&apos;].plot() plt.show() df[&apos;cum_profit&apos;].plot() plt.show() #计算夏普比率 sharpe = calculate_sharpe(df) print(sharpe) 双曲均线多股比较 import pandas as pd import numpy as np import matplotlib.pyplot as plt def get_single_price(code): &quot;&quot;&quot; 获取单数据 &quot;&quot;&quot; pd.set_option(&apos;expand_frame_repr&apos;, False) # 当列太多时不换行 pd.set_option(&apos;max_row&apos;,4000)#最多行数 # =====读入数据 df = pd.read_csv(&apos;G:/share/note/&apos; + code + &apos;.csv&apos;, encoding=&apos;gbk&apos;) df.columns = [i for i in df.columns] df = df[[&apos;日期&apos;,&apos;收盘价&apos;,&apos;开盘价&apos;,&apos;最高价&apos;,&apos;最低价&apos;,&apos;涨跌幅&apos;]] df.sort_values(by=[&apos;日期&apos;], inplace=True) df[&apos;日期&apos;] = pd.to_datetime(df[&apos;日期&apos;]) # 最近数据 df = df[df[&apos;日期&apos;] &gt;= &apos;2019-01-01&apos;] df.reset_index(inplace=True, drop=True) df = df.set_index(df[&apos;日期&apos;]) return df def compose_signal(data): &quot;&quot;&quot; 整合信号 :param data: :return: &quot;&quot;&quot; data[&apos;buy_signal&apos;] = np.where((data[&apos;buy_signal&apos;] == 1) &amp; (data[&apos;buy_signal&apos;].shift(1) == 1), 0, data[&apos;buy_signal&apos;]) data[&apos;sell_signal&apos;] = np.where((data[&apos;sell_signal&apos;] == -1) &amp; (data[&apos;sell_signal&apos;].shift(1) == -1), 0, data[&apos;sell_signal&apos;]) data[&apos;signal&apos;] = data[&apos;buy_signal&apos;] + data[&apos;sell_signal&apos;] return data def calculate_prof_pct(data): &quot;&quot;&quot; 计算单次收益率：开仓、平仓（开仓的全部股数） :param data: :return: &quot;&quot;&quot; data = data[data[&apos;signal&apos;] != 0] # 筛选 data[&apos;profit_pct&apos;] = (data[&apos;收盘价&apos;] - data[&apos;收盘价&apos;].shift(1)) / data[&apos;收盘价&apos;].shift(1) # 数据预览 #print(data[[&apos;收盘价&apos;, &apos;short_ma&apos;, &apos;long_ma&apos;,&apos;signal&apos;,&apos;profit_pct&apos;]]) data = data[data[&apos;signal&apos;] == -1] return data def calculate_cum_prof(data): &quot;&quot;&quot; 计算累计收益率 :param data: dataframe :return: &quot;&quot;&quot; data[&apos;cum_profit&apos;] = pd.DataFrame(1 + data[&apos;profit_pct&apos;]).cumprod() - 1 return data def ma_strategy(data, short_window=5, long_window=20): &quot;&quot;&quot; 双均线策略 :param data: dataframe, 投资标的行情数据（必须包含收盘价） :param short_window: 短期n日移动平均线，默认5 :param long_window: 长期n日移动平均线，默认20 :return: &quot;&quot;&quot; data = pd.DataFrame(data) # 计算技术指标：ma短期、ma长期 data[&apos;short_ma&apos;] = data[&apos;收盘价&apos;].rolling(window=short_window).mean() data[&apos;long_ma&apos;] = data[&apos;收盘价&apos;].rolling(window=long_window).mean() # 生成信号：金叉买入、死叉卖出 data[&apos;buy_signal&apos;] = np.where(data[&apos;short_ma&apos;] &gt; data[&apos;long_ma&apos;], 1, 0) data[&apos;sell_signal&apos;] = np.where(data[&apos;short_ma&apos;] &lt; data[&apos;long_ma&apos;], -1, 0) # 过滤信号 data = compose_signal(data) # 计算单次收益 data = calculate_prof_pct(data) # print(data.describe()) # 计算累计收益 data = calculate_cum_prof(data) # 删除多余的columns data.drop(labels=[&apos;buy_signal&apos;, &apos;sell_signal&apos;], axis=1) return data if __name__ == &apos;__main__&apos;: # 股票列表 stocks = [&apos;000001上证指数&apos;, &apos;000300沪深300&apos;, &apos;000905中证500&apos;] # 存放累计收益率 cum_profits = pd.DataFrame() # 循环获取数据 for code in stocks: df = get_single_price(code) # 调用双均线策略 df = ma_strategy(df) cum_profits[code] = df[&apos;cum_profit&apos;].reset_index(drop=True) # 存储累计收益率 # 折线图 df[&apos;cum_profit&apos;].plot(label=code) # 筛选有信号点 # df = df[df[&apos;signal&apos;] != 0] # 预览数据 print(&quot;开仓次数：&quot;, int(len(df))) #print(df[[&apos;日期&apos;,&apos;收盘价&apos;, &apos;signal&apos;, &apos;cum_profit&apos;]]) # 预览 print(cum_profits) # 可视化 # cum_profits.plot() plt.legend() plt.title(&apos;Comparison of Ma Strategy Profits&apos;) plt.show() P值计算 p值越小，可能就越赚钱。p_value &lt; 0.05。 import matplotlib.pyplot as plt from scipy import stats def ttest(data_return): &quot;&quot;&quot; 对策略收益进行t检验 :param strat_return: dataframe,单次收益率 :return: float,t值和p值 &quot;&quot;&quot; # 调用假设检验ttest函数：scipy t, p = stats.ttest_1samp(data_return, 0, nan_policy=&apos;omit&apos;) # 判断是否与理论均值有显著性差异:α=0.05 p_value = p / 2 # 获取单边p值 # 打印 print(&quot;t-value:&quot;, t) print(&quot;p-value:&quot;, p_value) print(&quot;是否可以拒绝[H0]收益均值=0：&quot;, p_value &lt; 0.05) return t, p_value if __name__ == &apos;__main__&apos;: # 股票列表 stocks = [&apos;000001.XSHE&apos;, &apos;000858.XSHE&apos;, &apos;002594.XSHE&apos;] for code in stocks: print(code) df = get_single_price(code, &apos;daily&apos;, &apos;2016-12-01&apos;, &apos;2021-01-01&apos;) df = ma_strategy(df) # 调用双均线策略 # 策略的单次收益率 returns = df[&apos;profit_pct&apos;] # print(returns) # 绘制一下分布图用于观察 # plt.hist(returns, bins=30) # plt.show() # 对多个股票进行计算、测试 ttest(returns) 资源网站 github开源项目： http://sunshowerc.github.io/fund/#/ https://github.com/x2rr/funds 东方财富： //BOLL + MACD https://www.eastmoney.com/ 聚宽： https://www.joinquant.com 数据下载： https://query1.finance.yahoo.com/v7/finance/download/000001.SS?period1=1262304000&amp;period2=1579106020&amp;interval=1d&amp;events=history&amp;crumb=t6/7IIwak4j https://fundsuggest.eastmoney.com/FundSearch/api/FundSearchAPI.ashx?m=10&amp;t=700&amp;IsNeedBaseInfo=0&amp;IsNeedZTInfo=0&amp;key=$&#123;key&#125;&amp;_=$&#123;Date.now()&#125; http://quotes.money.163.com/service/chddata.html?code=0000905&amp;start=19901219&amp;end=20200913&apos; 我们从得到的链接入手来分析：http://quotes.money.163.com/service/chddata.html?code=1000002&amp;start=19910129&amp;end=20161006&amp;fields=TCLOSE;HIGH;LOW;TOPEN;LCLOSE;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER;TCAP;MCAP 其中： code: 深市六位代码前加“1”，沪市股票代码前加“0” start: 开始日期，如果想得到每只股票的所有历史交易数据，可以以公司上市日期来表达，8位数字，分别为yyyymmdd end: 结束日期，表示的也是yyyymmdd八位数字 fields字段包括了开盘价、最高价、最低价、收盘价等。。。 code的另一种获取方式：访问 http://quotes.money.163.com/stock，然后搜索股票，然后再浏览器的链接上获得股票code。 举例-下载数据文件： import os import requests import time # 时间格式：20160320 timeParams = time.strftime(&quot;%Y%m%d&quot;, time.localtime()) # 文件名和文件路径 urls = [(&apos;000905中证500.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000905&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000016上证50.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000016&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000300沪深300.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000300&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000922中证红利.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000922&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399812养老产业.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399812&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000991全指医药.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000991&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000827中证环保.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000827&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399975证券公司.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399975&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399971中证传媒.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399971&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399006创业板指.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399006&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000932中证消费.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000932&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399986中证银行.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399986&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399967中证军工.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399967&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000001上证指数.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000001&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399001深证成指.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399001&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000993全指信息.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000993&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;399330深证100.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=1399330&amp;start=19901219&amp;end=%s&quot; % timeParams), (&apos;000903中证100.csv&apos;,&quot;http://quotes.money.163.com/service/chddata.html?code=0000903&amp;start=19901219&amp;end=%s&quot; % timeParams)] def url_response(url): path,url = url print(url) r = requests.get(url,stream= True) with open(path,&apos;wb&apos;) as f: for ch in r: f.write(ch) for x in urls: url_response(x) 操作 import pandas as pd import datetime import datetime pd.set_option(&apos;expand_frame_repr&apos;, False) # 当列太多时不换行 pd.set_option(&apos;max_row&apos;,4000)#最多行数 # =====读入数据 df = pd.read_csv(&apos;G:/share/04/note/.ipynb_checkpoints/000905中证500.csv&apos;, encoding=&apos;gbk&apos;) df.columns = [i for i in df.columns] df = df[[&apos;日期&apos;,&apos;收盘价&apos;,&apos;开盘价&apos;,&apos;最高价&apos;,&apos;最低价&apos;,&apos;涨跌幅&apos;]] df.sort_values(by=[&apos;日期&apos;], inplace=True) df[&apos;日期&apos;] = pd.to_datetime(df[&apos;日期&apos;]) # 最近十二年数据 df = df[df[&apos;日期&apos;] &gt;= &apos;2009-04-12&apos;] df.reset_index(inplace=True, drop=True) # # =====计算复权价 #df[&apos;复权因子&apos;] = (df[&apos;涨跌幅&apos;] + 1.0).cumprod() # initial_price = df.iloc[0][&apos;收盘价&apos;] / (1 + df.iloc[0][&apos;涨跌幅&apos;]) # 计算上市价格 # df[&apos;收盘价_后复权&apos;] = initial_price * df[&apos;复权因子&apos;] # 相乘得到复权价 # df[&apos;开盘价_后复权&apos;] = df[&apos;开盘价&apos;] / df[&apos;收盘价&apos;] * df[&apos;收盘价_后复权&apos;] # df[&apos;最高价_后复权&apos;] = df[&apos;最高价&apos;] / df[&apos;收盘价&apos;] * df[&apos;收盘价_后复权&apos;] # df[&apos;最低价_后复权&apos;] = df[&apos;最低价&apos;] / df[&apos;收盘价&apos;] * df[&apos;收盘价_后复权&apos;] # # df[[&apos;开盘价&apos;, &apos;最高价&apos;, &apos;最低价&apos;, &apos;收盘价&apos;]] = df[[&apos;开盘价_后复权&apos;, &apos;最高价_后复权&apos;, &apos;最低价_后复权&apos;, &apos;收盘价_后复权&apos;]] # # df = df[[&apos;日期&apos;, &apos;股票代码&apos;, &apos;开盘价&apos;, &apos;最高价&apos;, &apos;最低价&apos;, &apos;收盘价&apos;, &apos;涨跌幅&apos;, &apos;开盘价_后复权&apos;, &apos;最高价_后复权&apos;, &apos;最低价_后复权&apos;, &apos;收盘价_后复权&apos;]] # df = df[[&apos;日期&apos;, &apos;收盘价&apos;, &apos;涨跌幅&apos;, &apos;开盘价_后复权&apos;, &apos;最高价_后复权&apos;, &apos;最低价_后复权&apos;, &apos;收盘价_后复权&apos;]] # =====计算均线策略 # 均线策略： # 当短期均线由下向上穿过长期均线的时候，第二天以开盘价全仓买入并在之后一直持有股票。 # 当短期均线由上向下穿过长期均线的时候，第二天以开盘价卖出全部股票并在之后一直空仓，直到下一次买入。 # ===计算均线 ma_short = 1 # 短期均线。ma代表：moving_average ma_long = 20 # 长期均线 df[&apos;ma_short&apos;] = df[&apos;收盘价&apos;].rolling(ma_short, min_periods=1).mean() df[&apos;ma_long&apos;] = df[&apos;收盘价&apos;].rolling(ma_long, min_periods=1).mean() # ===找出买入信号 # 当天的短期均线大于等于长期均线 condition1 = (df[&apos;ma_short&apos;] &gt;= df[&apos;ma_long&apos;]) # 上个交易日的短期均线小于长期均线 condition2 = (df[&apos;ma_short&apos;].shift(1) &lt; df[&apos;ma_long&apos;].shift(1)) # 将买入信号当天的signal设置为1 df.loc[condition1 &amp; condition2, &apos;signal&apos;] = 1 # ===找出卖出信号 # 当天的短期均线小于等于长期均线 condition1 = (df[&apos;ma_short&apos;] &lt;= df[&apos;ma_long&apos;]) # 上个交易日的短期均线大于长期均线 condition2 = (df[&apos;ma_short&apos;].shift(1) &gt; df[&apos;ma_long&apos;].shift(1)) # 将买入信号当天的signal设置为0 df.loc[condition1 &amp; condition2, &apos;signal&apos;] = 0 # 将无关的变量删除 # df.drop([&apos;ma_short&apos;, &apos;ma_long&apos;], axis=1, inplace=True) # =====由signal计算出实际的每天持有股票仓位 # ===计算仓位 # signal的计算运用了收盘价，是每天收盘之后产生的信号，到第二天的时候，仓位position才会改变。 # 例如2009-11-17产生买入信号，2009-11-18仓位才会编变成1。满仓用1表示，空仓用0表示 df[&apos;pos&apos;] = df[&apos;signal&apos;].shift() df[&apos;pos&apos;].fillna(method=&apos;ffill&apos;, inplace=True) df[&apos;pos&apos;].fillna(value=0, inplace=True) # 将初始行数的position补全为0 # 涨跌幅定义为今日收盘价减去昨日收盘价 #rise = df[&apos;收盘价&apos;].diff() #df[&apos;rise&apos;] = rise # 涨跌幅定义为今日收盘价减去昨日收盘价/昨日收盘价 #rets = df[&apos;收盘价&apos;].pct_change() * 100 #df[&apos;涨跌幅&apos;] = rets print(df) #print(df[(df.signal &gt; 0.5) | (df.signal == 0.0)]) print(&quot;-----------------------------------------------------&quot;) print (df[&apos;收盘价&apos;].describe()) print(&quot;-----------------------------------------------------&quot;) print(df[&apos;收盘价&apos;].max()) # 最大值 print(df[&apos;收盘价&apos;].min()) # 最小值 print(df[&apos;收盘价&apos;].std()) # 标准差 print(df[&apos;收盘价&apos;].count()) # 非空的数据的数量 print(df[&apos;收盘价&apos;].median()) # 中位数 print(df[&apos;收盘价&apos;].quantile(0.25)) # 25%分位数 print(df[&apos;收盘价&apos;].mean()) #平均值 杂记 下降行情-&gt;最低-&gt;上升行情-&gt;最高-&gt;下降行情 量化投资：本质是数据里面找规律。市场越不成熟越有效。 择时策略：比如移动平均线：20日的平均值，股价超过这个值就买入，股价低于这个值就卖掉；或者平均值比上次大就买入，平均值比上次小就卖出。 股票的量化投资可以说是一种价值投资，我们所做的也是去挖掘市场中的价值股票，而并非去预测股票涨跌来进行投资等等（至少目前机构不会采取这种方式指导投资）。 量化投资涵盖了整个交易过程，需要一个完整的作为研究的量化回测框架和实盘交易系统作为支撑。 https://www.ricequant.com/ 每个投资策略的收益率可以分解成为两部分:一部分与市场完全相关，整个市场的平均收益率乘以一个贝塔系数。贝塔可以称为这个投资组合的系统风险。另一部分和整个市场无关的叫做阿尔法(Alpha)。 1、Alpha很难得，Beta很容易。2、Alpha就是精选个股，跑赢市场。3、Beta就是有市场行情时跟上，有风险时候躲避。 多因子选股策略是一种应用十分广泛的选股策略，其基本思想就是找到某些和收益率最相关的因子。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"量化","slug":"量化","permalink":"http://yoursite.com/tags/%E9%87%8F%E5%8C%96/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"Spring Boot和maven","slug":"45.Spring Boot和maven","date":"2021-03-01T13:37:14.254Z","updated":"2021-07-06T15:10:34.562Z","comments":false,"path":"2021/03/01/45.Spring Boot和maven/","link":"","permalink":"http://yoursite.com/2021/03/01/45.Spring%20Boot%E5%92%8Cmaven/","excerpt":"","text":"Spring Boot介绍 Spring Boot是便捷搭建基于Spring的工程脚手架。其最主要作用就是帮助开发人员快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让开发人员关注业务而非配置。 我们可以使用Spring Boot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 快速搭建 Spring Initializr（jdk1.8默认即可）–&gt; 完善项目信息 –&gt; spring web starter pom.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;HelloSpringBoot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;HelloSpringBoot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; Application文件： @SpringBootApplication public class HelloSpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloSpringBootApplication.class, args); &#125; &#125; Controller文件： import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController &#123; @GetMapping(value=&quot;/hello&quot;) public String hello()&#123; return &quot;Hello Spring Boot&quot;; &#125; &#125; 访问http://localhost:8080/hello即可以返回Hello Spring Boot。 Druid 引入： &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; 写法一： 创建数据库 springboot_test ，在项目resources下新建 jdbc.properties 文件： jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://192.168.1.13:3306/springboot_test jdbc.username=root jdbc.password=123456 JdbcConfig 类: import com.alibaba.druid.pool.DruidDataSource; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import javax.sql.DataSource; @Configuration @PropertySource(&quot;classpath:jdbc.properties&quot;) public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.url&#125;&quot;) String url; @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;) String driverClassName; @Value(&quot;$&#123;jdbc.username&#125;&quot;) String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; &#125; 写法二：@ConfigurationProperties可以在类上，也可以在方法上： 在项目resources下 application.properties： jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://192.168.1.13:3306/springboot_test jdbc.username=root jdbc.password=123456 JdbcConfig 类: import com.alibaba.druid.pool.DruidDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; @Configuration public class JdbcConfig &#123; //prefix = &quot;jdbc&quot; 中的jdbc指的是 jdbc.password=123456 中的jdbc @Bean @ConfigurationProperties(prefix = &quot;jdbc&quot;) public DataSource dataSource() &#123; return new DruidDataSource(); &#125; &#125; 两种写法写完后，使用： @Autowired private DataSource dataSource; System.out.println(&quot;dataSource: &quot; + dataSource); yml文件配置 yaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。 yml配置文件的特征：树状层级结构展示配置项；配置项之间如果有关系的话需要分行空两格；配置项如果有值的话，那么需要在 :之后空一格再写配置项值； jdbc: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/hehe username: root password: 123456 key: abc: cba def: - g - h - j 多个yml配置文件，在spring boot中是被允许的。这些配置文件的名称必须为 application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。 #激活配置文件;需要指定其它的配置文件名称,abc,def就是application-abc.yml，application-def.yml spring: profiles: active: abc,def 如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。 lombok应用 添加lombok对应的依赖到项目pom.xml文件: &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 在Bean上使用： @Data ：自动提供getter和setter、hashCode、equals、toString等方法 @Getter：自动提供getter方法 @Setter：自动提供setter方法 @Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。 修改项目tomcat端口 yml文件方式 #tomcat端口 server: port: 80 application.properties中修改端口和path： server.port=8082 server.servlet.context-path=/shiyanlou/ 静态资源 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public SpringMVC拦截器 编写拦截器（实现HandlerInterceptor）: import lombok.extern.slf4j.Slf4j; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Slf4j public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.debug(&quot;这是MyInterceptor的preHandle方法。&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.debug(&quot;这是MyInterceptor的postHandle方法。&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.debug(&quot;这是MyInterceptor的afterCompletion方法。&quot;); &#125; &#125; 编写配置类实现 WebMvcConfigurer，在该类中添加各种组件: import com.jiangtea.interceptor.MyInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MvcConfig implements WebMvcConfigurer &#123; //注册拦截器 @Bean public MyInterceptor myInterceptor()&#123; return new MyInterceptor(); &#125; //添加拦截器到spring mvc拦截器链 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor()).addPathPatterns(&quot;/*&quot;); &#125; &#125; 设置日志级别： #日志记录级别 logging: level: com.jiangtea: debug org.springframework: info 整合事务和连接池 配置Spring Boot自带默认的 hikari数据库连接池和使用 @Transactional注解进行事务配置。 pom.xml文件中： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; application.properties： spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/springboot_test?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false spring.datasource.username=root spring.datasource.password=123456 spring.datasource.hikari.minimum-idle=5 spring.datasource.hikari.maximum-pool-size=15 spring.datasource.hikari.auto-commit=true spring.datasource.hikari.idle-timeout=30000 spring.datasource.hikari.pool-name=hikariCP spring.datasource.hikari.max-lifetime=1800000 spring.datasource.hikari.connection-timeout=30000 spring.datasource.hikari.connection-test-query=SELECT 1 UserService类： import com.jiangtea.pojo.User; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service public class UserService &#123; //根据id查询 public User queryById(Long id)&#123; return new User(); &#125; //新增保存用户 @Transactional public void saveUser(User user)&#123; System.out.println(&quot;新增用户... &quot;); &#125; &#125; 使用： @Autowired private DataSource dataSource; Spring Boot整合Mybatis pom.xml文件中： &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; application.yml配置： mybatis: # 实体类别名包路径 type-aliases-package: com.jiangtea.pojo # 映射文件路径 # mapper-locations: classpath:mappers/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 扫描mybatis所有的业务mapper接口配置： import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication // 扫描mybatis所有的业务mapper接口 @MapperScan(&quot;com.jiangtea.mapper&quot;) public class HelloSpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloSpringBootApplication.class, args); &#125; &#125; 整合通用Mapper pom.xml文件中： &lt;!-- 通用mapper --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; 继承Mapper&lt;User&gt;: import com.jiangtea.pojo.User; import tk.mybatis.mapper.common.Mapper; public interface UserMapper extends Mapper&lt;User&gt; &#123; &#125; 修改启动引导类Application中的Mapper扫描注解，注意修改成tk.mybatis.spring.annotation.MapperScan: import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication // 扫描mybatis所有的业务mapper接口 @MapperScan(&quot;com.jiangtea.mapper&quot;) public class HelloSpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloSpringBootApplication.class, args); &#125; &#125; 修改User实体类添加jpa注解: import lombok.Data; import tk.mybatis.mapper.annotation.KeySql; import javax.persistence.Id; import javax.persistence.Table; import java.util.Date; @Data @Table(name = &quot;tb_user&quot;) public class User &#123; @Id //主键回填 @KeySql(useGeneratedKeys = true) private Long id; private String userName; private String password; private String name; private Integer age; private Integer sex; private Date birthday; private String note; private Date created; private Date updated; &#125; UserService： import com.jiangtea.mapper.UserMapper; import com.jiangtea.pojo.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service public class UserService &#123; @Autowired private UserMapper userMapper; //根据id查询 public User queryById(Long id)&#123; return userMapper.selectByPrimaryKey(id); &#125; //新增保存用户 @Transactional public void saveUser(User user)&#123; System.out.println(&quot;新增用户... &quot;); //选择性新增；如果属性为空则该属性不会出现在insert语句上 userMapper.insertSelective(user); int i = 1/0; &#125; &#125; 编写Controller： import com.jiangtea.pojo.User; import com.jiangtea.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.sql.DataSource; @RestController public class HelloController &#123; @Autowired private DataSource dataSource; @Autowired private UserService userService; /** * 根据用户id查询用户 * @param id 用户id * @return 用户 */ @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User queryById(@PathVariable Long id)&#123; return userService.queryById(id); &#125; @GetMapping(&quot;hello&quot;) public String hello()&#123; System.out.println(&quot; DataSource = &quot; + dataSource); return &quot;Hello, Spring Boot!&quot;; &#125; &#125; 开始测试-测试地址：http://localhost:8082/user/7 : Spring Boot整合Junit 添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; 在类UserService上按 ctrl+shift+T 选择 JUnit4 创建测试类： import com.jiangtea.pojo.User; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.Date; @RunWith(SpringRunner.class) @SpringBootTest public class UserServiceTest &#123; @Autowired private UserService userService; @Test public void queryById() &#123; User user = userService.queryById(8L); System.out.println(&quot;user = &quot; + user); &#125; @Test public void saveUser() &#123; User user = new User(); user.setUserName(&quot;test2&quot;); user.setName(&quot;test2&quot;); user.setAge(13); user.setPassword(&quot;123456&quot;); user.setSex(1); user.setCreated(new Date()); userService.saveUser(user); &#125; &#125; 注意添加 @SpringBootTest。 Spring Boot整合redis 添加依赖: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 配置application.yml中修改redis的连接参数（redis需要启动）: spring: redis: host: localhost port: 6379 编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set） import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.test.context.junit4.SpringRunner; import java.util.List; import java.util.Set; @RunWith(SpringRunner.class) @SpringBootTest public class RedisTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void test()&#123; //string 字符串 //redisTemplate.opsForValue().set(&quot;str&quot;, &quot;hehe&quot;); redisTemplate.boundValueOps(&quot;str&quot;).set(&quot;hehe&quot;); System.out.println(&quot;str = &quot; + redisTemplate.opsForValue().get(&quot;str&quot;)); //hash 散列 redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;name&quot;, &quot;hehe&quot;); redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;age&quot;, 13); //获取所有域 Set set = redisTemplate.boundHashOps(&quot;h_key&quot;).keys(); System.out.println(&quot; hash散列的所有域：&quot; + set); //获取所有值 List list = redisTemplate.boundHashOps(&quot;h_key&quot;).values(); System.out.println(&quot; hash散列的所有域的值：&quot; + list); //list 列表 redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;c&quot;); redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;b&quot;); redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;a&quot;); //获取全部元素 list = redisTemplate.boundListOps(&quot;l_key&quot;).range(0, -1); System.out.println(&quot; list列表中的所有元素：&quot; + list); // set 集合 redisTemplate.boundSetOps(&quot;s_key&quot;).add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); set = redisTemplate.boundSetOps(&quot;s_key&quot;).members(); System.out.println(&quot; set集合中的所有元素：&quot; + set); // sorted set 有序集合 redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;a&quot;, 30); redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;b&quot;, 20); redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;c&quot;, 10); set = redisTemplate.boundZSetOps(&quot;z_key&quot;).range(0, -1); System.out.println(&quot; zset有序集合中的所有元素：&quot; + set); &#125; &#125; Spring Boot项目部署 pom添加打包组件: &lt;build&gt; &lt;plugins&gt; &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 可以点击右边栏maven的Lifecycle中的package进行打包。 部署：java -jar 打好的jar包名字。 maven介绍 maven 是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。 依赖管理：就是对jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。 项目构建：通过maven的一个命令就可以完成项目从清理、编译、测试、报告、打包，部署整个过程。 maven常用命令：clean(清理)、compile(编译)、test(测试)、package(打包)、install(安装)。 maven的依赖范围 maven的依赖范围： 依赖范围 对于编译classpath有效 对于测试classpath有效 对于运行时classpath有效 例子 compile Y Y Y spring-core test - Y - Junit provided Y Y - servlet-api runtime - Y Y JDBC驱动 system Y Y - 本地的，maven仓库之外的类库 通过scope指定依赖范围，默认是compile： &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; maven的依赖冲突 排除依赖：可以使用exclusions标签将传递过来的依赖排除出去。 &lt;exclusions&gt; &lt;exclusion&gt; .... &lt;/exclusion&gt; &lt;/exclusions&gt; 版本锁定:采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。 版本锁定的使用方式：第一步：在dependencyManagement标签中锁定依赖的版本;第二步：在dependencies标签中声明需要导入的maven坐标。 &lt;!--锁定jar包的版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; maven分模块构建 分模块父工程的打包方式必须为pom： &lt;!--父工程的打包方式必须为pom--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 子工程： &lt;!--表示当前maven工程继承了maven_parent父工程--&gt; &lt;parent&gt; &lt;artifactId&gt;maven_parent&lt;/artifactId&gt; &lt;groupId&gt;com.study&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; 当前子工程依赖 子工程maven_dao： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.study&lt;/groupId&gt; &lt;artifactId&gt;maven_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; maven工程的聚合：在maven工程的pom.xml文件中可以使用&lt;modules&gt;标签将其他maven工程聚合到一起，聚合的目的是为了进行统一操作。例如拆分后的maven工程有多个，如果要进行打包，就需要针对每个工程分别执行打包命令，操作起来非常繁琐。这时就可以使用&lt;modules&gt;标签将这些工程统一聚合到maven工程中，需要打包的时候，只需要在此工程中执行一次打包命令，其下被聚合的工程就都会被打包了。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"JVM虚拟机底层原理","slug":"44.JVM虚拟机底层原理","date":"2020-11-06T13:23:12.892Z","updated":"2021-03-26T14:41:59.392Z","comments":false,"path":"2020/11/06/44.JVM虚拟机底层原理/","link":"","permalink":"http://yoursite.com/2020/11/06/44.JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"介绍 JVM概念：Java Virtual Machine:java程序的运行环境（java二进制字节码的运行环境）。 区别： JVM + 基础类库 = JRE JVM + 基础类库 + 编译归工具 = JDK 类加载器：ClassLoader JVM内存结构：方法区（Method Area）、堆（Heap）、虚拟机栈（JVM Stacks）、程序计数器（PC Register）、本地方法栈（Nataive Method Stacks）。 执行引擎：解释器（Interpreter）、即时编译器（JIT Compiler）、垃圾回收（GC）。 JVM内存结构JVM内存结构之程序计数器 指令执行流程：jvm指令交给解释器，解释器再翻译成机器码，机器码再交给CPU运行。 程序计数器（寄存器）（Program Counter Register）作用：记住下一条jvm指令的执行地址。 程序计数器特点:每个线程都有自己的程序计数器，是线程私有的。不会存在内存溢出。 JVM内存结构之虚拟机栈 Java虚拟机栈（Java Virtual Machine Stacks）：每个线程运行时需要的内存空间，称为虚拟机栈。 栈帧：每个方法调用运行时候需要的内存。一个栈内可能有多个栈帧。比如，方法一调用了方法二，方法二调用了方法三。 活动栈帧：正在执行的那个方法，即栈顶部的栈帧。每个线程只能有一个活动栈帧。 垃圾回收是否涉及栈内存？ 不需要，弹出栈。 栈内存分配越大越好吗？递归时候大内存较好，但是栈内存大了会影响线程数量。 方法内的局部变量是否线程安全？ 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的。如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。下面代码，只有m1()方法是线程安全的。 public static void m1() &#123; StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString()); &#125; public static void m2(StringBuilder sb) &#123; sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString()); &#125; public static StringBuilder m3() &#123; StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); return sb; &#125; 栈内存溢出（java.lang.StackOverflowError）：栈帧过多导致栈内存溢出（比如，递归）；栈帧过大导致栈内存溢出（该情况较少）。 JVM内存结构之本地方法栈 本地方法：不是java代码编写的方法。这些本地方法使用的内存就是本地方法栈。 protected native Object clone() throws CloneNotSupportedException; JVM内存结构之堆 堆(Heap):通过new关键字，创建对象都会使用堆内存。 堆特点：它是线程共享的，堆中对象都需要考虑线程安全的问题；有垃圾回收机制。 内存溢出（java.lang.OutOfMemoryError） JVM内存结构之方法区 方法区：所有Java虚拟机线程共享的区域。它存储了和类结构相关的信息，如运行时常量池，成员变量，方法，构造方法。 方法区在虚拟机启动时候就被创建了。方法区也会内存溢出。 常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池：常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。 常量池中的信息，都会被加载到运行时常量池中。 StringTable JVM1.6中StringTable存放在永久代方法区中；1.8中将StringTable存放在堆中了。 StringTable是hashtable结构，不能扩容。 String s1 = &quot;a&quot;; // 懒惰的 String s2 = &quot;b&quot;; String s3 = &quot;ab&quot;; String s4 = s1 + s2; // new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() -&gt; new String(&quot;ab&quot;) String s5 = &quot;a&quot; + &quot;b&quot;; // javac 在编译期间的优化，结果已经在编译期确定为ab System.out.println(s3 == s4);//false，s3在串池中，s4在堆中 System.out.println(s3 == s5);//true intern():将字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回。 String x = &quot;ab&quot;; String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);// 堆 String s2 = s.intern(); System.out.println( s2 == x);//true System.out.println( s == x );//false 面试题 String s1 = &quot;a&quot;; String s2 = &quot;b&quot;; String s3 = &quot;a&quot; + &quot;b&quot;; // ab String s4 = s1 + s2; // new String(&quot;ab&quot;) String s5 = &quot;ab&quot;; String s6 = s4.intern(); // 问 System.out.println(s3 == s4); // false System.out.println(s3 == s5); // true System.out.println(s3 == s6); // true String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;); // new String(&quot;cd&quot;) String x1 = &quot;cd&quot;; x2.intern();//x2入池失败 System.out.println(x1 == x2);//false // 调换了位置 String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;); // new String(&quot;cd&quot;) x2.intern();//x2入池成功 String x1 = &quot;cd&quot;; System.out.println(x1 == x2);//true StringTable 特性： 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder （1.8） 字符串常量拼接的原理是编译期优化 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回 StringTable会GC垃圾回收。 垃圾回收判断对象是否可以回收之引用计数法 被引用几次就计数几，当计数零时候就没有引用的了，可以回收。弊端：两个对象相互引用，就无法回收。 判断对象是否可以回收之可达性分析算法 Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。 根对象（GC Root）：肯定不能当成垃圾被回收的对象称为根对象。一个对象没有被根对象直接或者间接引用，就可以被回收。 扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收该对象。 五种引用 强引用：只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收。 软引用（SoftReference）：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象；可以配合引用队列来释放软引用自身。 弱引用（WeakReference）：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象。可以配合引用队列来释放弱引用自身。 虚引用（PhantomReference）：必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由Reference Handler 线程调用虚引用相关方法释放直接内存。 终结器引用（FinalReference）:无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次GC时才能回收被引用对象。 强引用和软引用代码： private static final int _4MB = 4 * 1024 * 1024; List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; list.add(new byte[_4MB]); &#125; System.in.read(); // 软引用：list --&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]); System.out.println(ref.get()); list.add(ref); System.out.println(list.size()); &#125; System.out.println(&quot;循环结束：&quot; + list.size()); for (SoftReference&lt;byte[]&gt; ref : list) &#123; System.out.println(ref.get()); &#125; 软引用配合引用队列使用，自动清除无用的软引用： private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) &#123; List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); // 引用队列 ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去 SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue); System.out.println(ref.get()); list.add(ref); System.out.println(list.size()); &#125; // 从队列中获取无用的 软引用对象，并移除 Reference&lt;? extends byte[]&gt; poll = queue.poll(); while( poll != null) &#123; list.remove(poll); poll = queue.poll(); &#125; System.out.println(&quot;===========================&quot;); for (SoftReference&lt;byte[]&gt; reference : list) &#123; System.out.println(reference.get()); &#125; &#125; 弱引用演示代码： private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) &#123; // list --&gt; WeakReference --&gt; byte[] List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]); list.add(ref); for (WeakReference&lt;byte[]&gt; w : list) &#123; System.out.print(w.get()+&quot; &quot;); &#125; System.out.println(); &#125; System.out.println(&quot;循环结束：&quot; + list.size()); &#125; 垃圾回收算法之标记清除 Mark Sweep:先标记垃圾，再清除垃圾。优点：速度快。缺点：空间不连续，产生内存碎片。 垃圾回收算法之标记整理 Mark Compact:优点：不会产生内存碎片，缺点：速度慢。 垃圾回收算法之复制 Copy:内存空间划分为FROM和TO两个区域。在FROM垃圾回收后，复制到TO区域，不会有内存碎片，然后TO变成了FROM。需要占用双倍内存空间。 分代垃圾回收 堆内存分为：老年代（长时间使用的内存区域）和新生代（分为：伊甸园eden、幸存区From、幸存区To）。 新生代new generation垃圾回收：Minor GC。 老年代tenured generation垃圾回收：Full GC。 对象首先分配在伊甸园eden区域。新生代空间不足时，触发 minor gc，使用复制垃圾回收算法，将伊甸园和from存活的对象使用 copy 复制到 to 中，存活的对象年龄加1并且交换 from to。 minor gc 会引发 stop the world，暂停其它用户的线程（因为对象地址会改变），等垃圾回收结束，用户线程才恢复运行。 当新生代中的对象年龄超过阈值时，会晋升至老年代，最大寿命是15（4bit）。 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，stop the world的时间更长。老年代垃圾回收的算法是标记清除或者标记整理。 首次存储一个新对象：如果新生代空间不足，老年代充足，会直接存储在老年代中；如果新生代空间不足，老年代空间也不足，会OOM。 子线程的OOM不会导致主线程的结束。 相关VM参数： 堆初始大小 -Xms 堆最大大小 -Xmx 或 -XX:MaxHeapSize=size 新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC 垃圾回收器 串行：单线程，堆内存较小，适合个人电脑。XX:+UseSerialGC = Serial（新生代-复制算法） + SerialOld（老年代-标记整理算法）。 吞吐量优先：多线程，堆内存较大，多核cpu。让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高。 -XX:+UseParallelGC ~ -XX:+UseParallelOldGC -XX:GCTimeRatio=ratio -XX:MaxGCPauseMillis=ms -XX:ParallelGCThreads=n 响应时间优先：多线程，堆内存较大，多核cpu。尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5。 -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads -XX:CMSInitiatingOccupancyFraction=percent -XX:+CMSScavengeBeforeRemark Garbage First","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"python高级","slug":"43.python高级","date":"2020-09-09T13:27:06.765Z","updated":"2021-03-26T14:41:55.008Z","comments":false,"path":"2020/09/09/43.python高级/","link":"","permalink":"http://yoursite.com/2020/09/09/43.python%E9%AB%98%E7%BA%A7/","excerpt":"","text":"多任务编程 多任务是指在同一时间内执行多个任务，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。 多任务的执行方式：并发和并行。 并发:在一段时间内交替去执行任务。 并行:对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。 一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。 多进程 进程使用： #导入进程包 import multiprocessing #创建子进程并指定执行的任务 sub_process = multiprocessing.Process (target=任务名) #启动进程执行任务 sub_process.start() Process进程类的说明： group：指定进程组，目前只能使用None target：执行的目标任务名 name：进程名字 args：以元组方式给执行任务传参 kwargs：以字典方式给执行任务传参 Process创建的实例对象的常用方法: start()：启动子进程实例（创建子进程） join()：等待子进程执行结束 terminate()：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性: name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 代码： import multiprocessing import time # 跳舞任务 def dance(): for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 唱歌任务 def sing(): for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &apos;__main__&apos;: # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 进程编号 获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。 获取进程编号的两种操作:获取当前进程编号和获取当前父进程编号。 获取当前进程编号 os.getpid() 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &apos;__main__&apos;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 运行结果： main: 10796 main: &lt;_MainProcess name=&apos;MainProcess&apos; parent=None started&gt; dance: 2388 dance: &lt;Process name=&apos;myprocess1&apos; parent=10796 started&gt; 跳舞中... sing: 2220 sing: &lt;Process name=&apos;Process-2&apos; parent=10796 started&gt; 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... 获取当前父进程编号 os.getppid() 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;dance的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;sing的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &apos;__main__&apos;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 运行结果： main: 4832 main: &lt;_MainProcess name=&apos;MainProcess&apos; parent=None started&gt; dance: 14372 dance: &lt;Process name=&apos;myprocess1&apos; parent=4832 started&gt; sing: 8948 sing: &lt;Process name=&apos;Process-2&apos; parent=4832 started&gt; dance的父进程编号: 4832 跳舞中... sing的父进程编号: 4832 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... 进程执行带有参数的任务 Process类执行任务并给任务传参数有两种方式:args 表示以元组的方式给执行任务传参;kwargs 表示以字典方式给执行任务传参。 args参数的使用，示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &apos;__main__&apos;: # 创建子进程 # args: 以元组的方式给任务传入参数 sub_process = multiprocessing.Process(target=task, args=(5,)) sub_process.start() 元组方式传参一定要和参数的顺序保持一致。 kwargs参数的使用,示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &apos;__main__&apos;: # 创建子进程 # kwargs: 表示以字典方式传入参数 sub_process = multiprocessing.Process(target=task, kwargs=&#123;&quot;count&quot;: 3&#125;) sub_process.start() 字典方式传参字典中的key一定要和参数名保持一致。 进程的注意点 进程之间不共享全局变量：子线程和主线程之间，以及子线程和子线程之间都不共享。创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。 主进程会等待所有的子进程执行结束再结束。 守护主进程就是主进程退出子进程销毁不再执行。 子进程对象.daemon = True 子进程销毁:子进程执行结束。 # 让子进程销毁 子进程对象.terminate() 保证主进程正常退出的示例代码: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &apos;__main__&apos;: # 创建子进程 sub_process = multiprocessing.Process(target=task) # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程 # sub_process.daemon = True sub_process.start() time.sleep(0.5) print(&quot;over&quot;) # 让子进程销毁 sub_process.terminate() exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁 多线程的使用 线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。 多线程的使用 #导入线程模块 import threading #创建子线程并指定执行的任务 sub_thread = threading.Thread(target=任务名) #启动线程执行任务 sub_thread.start() 线程类Thread参数说明 group: 线程组，目前只能使用None target: 执行的目标任务名 args: 以元组的方式给执行任务传参 kwargs: 以字典方式给执行任务传参 name: 线程名，一般不用设置 代码 import threading import time # 唱歌任务 def sing(): # 扩展：获取当前线程 # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在唱歌...%d&quot; % i) time.sleep(1) # 跳舞任务 def dance(): # 扩展：获取当前线程 # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在跳舞...%d&quot; % i) time.sleep(1) if __name__ == &apos;__main__&apos;: # 扩展： 获取当前线程 # print(&quot;当前执行的线程为：&quot;, threading.current_thread()) # 创建唱歌的线程 # target： 线程执行的函数名 sing_thread = threading.Thread(target=sing) # 创建跳舞的线程 dance_thread = threading.Thread(target=dance) # 开启线程 sing_thread.start() dance_thread.start() 线程执行带有参数的任务 Thread类执行任务并给任务传参数有两种方式:args表示以元组的方式给执行任务传参;kwargs表示以字典方式给执行任务传参。 元组方式传参(args)，元组方式传参一定要和参数的顺序保持一致： import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &apos;__main__&apos;: # 创建子线程 # args: 以元组的方式给任务传入参数 sub_thread = threading.Thread(target=task, args=(5,)) sub_thread.start() 字典方式传参(kwargs),字典方式传参字典中的key一定要和参数名保持一致: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &apos;__main__&apos;: # 创建子线程 # kwargs: 表示以字典方式传入参数 sub_thread = threading.Thread(target=task, kwargs=&#123;&quot;count&quot;: 3&#125;) sub_thread.start() 线程的注意点 线程之间执行是无序的，它是由cpu调度决定的，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。 进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。 主线程会等待所有的子线程执行结束再结束。 守护主线程:主线程退出子线程销毁不再执行。 #设置守护主线程有两种方式： threading.Thread(target=show_info, daemon=True) 线程对象.setDaemon(True) 线程之间共享全局变量，多线程同时对全局变量操作数据会发生错误。 全局变量数据错误的解决办法:线程同步: 保证同一时刻只能有一个线程去操作全局变量。 线程同步的方式:线程等待(join)；互斥锁。 线程等待的示例代码: # 启动线程 first_thread.start() # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程 # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行 first_thread.join() # 启动线程 second_thread.start() 互斥锁 互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。 互斥锁使用步骤: # 创建锁 mutex = threading.Lock() # 上锁 mutex.acquire() ...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定... # 释放锁 mutex.release() acquire和release方法之间的代码同一时刻只能有一个线程去操作。如果在调用acquire方法的时候，其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。 示例代码： import threading # 定义全局变量 g_num = 0 # 创建全局互斥锁 lock = threading.Lock() # 循环一次给全局变量加1 def sum_num1(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 释放锁 lock.release() # 循环一次给全局变量加1 def sum_num2(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) # 释放锁 lock.release() if __name__ == &apos;__main__&apos;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() second_thread.start() # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待 # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行 互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题。使用互斥锁会影响代码的执行效率，多任务改成了单任务执行。互斥锁如果没有使用好容易出现死锁的情况。 死锁 死锁: 一直等待对方释放锁的情景就是死锁。死锁的结果会造成应用程序的停止响应，不能再处理其它任务了。 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) # 当下标越界需要释放锁，让后面的线程还可以取值 lock.release() return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &apos;__main__&apos;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 进程和线程的对比 线程是依附在进程里面的，没有进程就没有线程。一个进程默认提供一条线程，进程可以创建多个线程。 多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。 多进程可以使用cpu的多核运行，多线程可以共享全局变量。 线程不能单独执行必须依附在进程里面。 进程之间不共享全局变量。 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步。 网络编程TCP客户端程序开发 TCP客户端程序开发步骤：创建客户端套接字对象、和服务端套接字建立连接、发送数据、接收数据、关闭客户端套接字。 socket类： #导入socket模块 import socket #创建客户端socket对象 socket.socket(AddressFamily, Type) 参数说明:AddressFamily表示IP地址类型, 分为TPv4和IPv6。Type 表示传输协议类型。 方法说明: connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号 send(data) 表示发送数据，data是二进制数据 recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度 示例代码： import socket if __name__ == &apos;__main__&apos;: # 创建tcp客户端套接字 # 1. AF_INET：表示ipv4 # 2. SOCK_STREAM: tcp传输协议 tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 和服务端应用程序建立连接 tcp_client_socket.connect((&quot;192.168.52.1&quot;, 8080)) # 代码执行到此，说明连接建立成功 # 准备发送的数据 send_data = &quot;你好服务端，我是客户端!&quot;.encode(&quot;gbk&quot;) # 发送数据 tcp_client_socket.send(send_data) # 接收数据, 这次接收的数据最大字节数是1024 recv_data = tcp_client_socket.recv(1024) # 返回的直接是服务端程序发送的二进制数据 print(recv_data) # 对数据进行解码 recv_content = recv_data.decode(&quot;gbk&quot;) print(&quot;接收服务端的数据为:&quot;, recv_content) # 关闭套接字 tcp_client_socket.close() #str.encode(编码格式) 表示把字符串编码成为二进制 #data.decode(编码格式) 表示把二进制解码成为字符串 TCP服务端程序开发 TCP服务端程序开发步骤回顾:创建服务端端套接字对象、绑定端口号、设置监听、等待接受客户端的连接请求、接收数据、发送数据、关闭套接字。 socket类： #导入 socket 模块 import socket #创建服务端 socket 对象 socket.socket(AddressFamily, Type) 参数说明:AddressFamily表示IP地址类型, 分为TPv4和IPv6。Type表示传输协议类型。 方法说明: bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。 listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。 accept() 表示等待接受客户端的连接请求 send(data) 表示发送数据，data 是二进制数据 recv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度 示例代码： import socket if __name__ == &apos;__main__&apos;: # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用，让程序退出端口号立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 给程序绑定端口号 tcp_server_socket.bind((&quot;&quot;, 8989)) # 设置监听 # 128:最大等待建立连接的个数， 提示： 目前是单任务的服务端，同一时刻只能服务与一个客户端，后续使用多任务能够让服务端同时服务与多个客户端， # 不需要让客户端进行等待建立连接 # listen后的这个套接字只负责接收客户端连接请求，不能收发消息，收发消息使用返回的这个新套接字来完成 tcp_server_socket.listen(128) # 等待客户端建立连接的请求, 只有客户端和服务端建立连接成功代码才会解阻塞，代码才能继续往下执行 # 1. 专门和客户端通信的套接字： service_client_socket # 2. 客户端的ip地址和端口号： ip_port service_client_socket, ip_port = tcp_server_socket.accept() # 代码执行到此说明连接建立成功 print(&quot;客户端的ip地址和端口号:&quot;, ip_port) # 接收客户端发送的数据, 这次接收数据的最大字节数是1024 recv_data = service_client_socket.recv(1024) # 获取数据的长度 recv_data_length = len(recv_data) print(&quot;接收数据的长度为:&quot;, recv_data_length) # 对二进制数据进行解码 recv_content = recv_data.decode(&quot;gbk&quot;) print(&quot;接收客户端的数据为:&quot;, recv_content) # 准备发送的数据 send_data = &quot;ok, 问题正在处理中...&quot;.encode(&quot;gbk&quot;) # 发送数据给客户端 service_client_socket.send(send_data) # 关闭服务与客户端的套接字， 终止和客户端通信的服务 service_client_socket.close() # 关闭服务端的套接字, 终止和客户端提供建立连接请求的服务 tcp_server_socket.close() 说明:当客户端和服务端建立连接后，服务端程序退出后端口号不会立即释放，需要等待大概1-2分钟。 解决办法有两种:更换服务端端口号;设置端口号复用(推荐使用)，也就是说让服务端程序退出后端口号立即释放。 设置端口号复用的代码如下: # 参数1: 表示当前套接字 # 参数2: 设置端口号复用选项 # 参数3: 设置端口号复用选项对应的值 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) TCP网络应用程序的注意点 当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先建立连接。 TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。 TCP 服务端程序必须绑定端口号，否则客户端找不到这个 TCP 服务端程序。 listen 后的套接字是被动套接字，只负责接收新的客户端的连接请求，不能收发消息。 当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个新的套接字，收发客户端消息使用该套接字。 关闭 accept 返回的套接字意味着和这个客户端已经通信完毕。 关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。 当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0，服务端可以通过返回数据的长度来判断客户端是否已经下线，反之服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0。 多任务版TCP服务端程序开发 完成多任务，可以使用线程，比进程更加节省内存资源。 实现步骤： 编写一个TCP服务端程序，循环等待接受客户端的连接请求。 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。 把创建的子线程设置成为守护主线程，防止主线程无法退出。 示例代码: import socket import threading # 处理客户端的请求操作 def handle_client_request(service_client_socket, ip_port): # 循环接收客户端发送的数据 while True: # 接收客户端发送的数据 recv_data = service_client_socket.recv(1024) # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败 # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据 if recv_data: print(recv_data.decode(&quot;gbk&quot;), ip_port) # 回复 service_client_socket.send(&quot;ok，问题正在处理中...&quot;.encode(&quot;gbk&quot;)) else: print(&quot;客户端下线了:&quot;, ip_port) break # 终止和客户端进行通信 service_client_socket.close() if __name__ == &apos;__main__&apos;: # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用，让程序退出端口号立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9090)) # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求 tcp_server_socket.listen(128) # 循环等待接收客户端的连接请求 while True: # 等待接收客户端的连接请求 service_client_socket, ip_port = tcp_server_socket.accept() print(&quot;客户端连接成功:&quot;, ip_port) # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息 sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程 sub_thread.start() # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行 # tcp_server_socket.close() socket之send和recv原理剖析 当创建一个TCP socket对象的时候会有一个发送缓冲区和一个接收缓冲区，这个发送和接收缓冲区指的就是内存中的一片空间。 send原理剖析：send是不是直接把数据发给服务端?不是，要想发数据，必须得通过网卡发送数据，应用程序是无法直接通过网卡发送数据的，它需要调用操作系统接口，也就是说，应用程序把发送的数据先写入到发送缓冲区(内存中的一片空间)，再由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡。 recv原理剖析：recv是不是直接从客户端接收数据?不是，应用软件是无法直接通过网卡接收数据的，它需要调用操作系统接口，由操作系统通过网卡接收数据，把接收的数据写入到接收缓冲区(内存中的一片空间），应用程序再从接收缓存区获取客户端发送的数据。 不管是recv还是send都不是直接接收到对方的数据和发送数据到对方，发送数据会写入到发送缓冲区，接收数据是从接收缓冲区来读取，发送数据和接收数据最终是由操作系统控制网卡来完成。 静态Web服务器启动python自带静态Web服务 静态Web服务器：可以为发出请求的浏览器提供静态文档的程序。 搭建Python自带的静态Web服务器 python -m http.server 端口号 -m表示运行包里面的模块，执行这个命令的时候，需要进入你自己指定静态文件的目录，然后通过浏览器就能访问对应的html文件了，这样一个静态的web服务器就搭建好了。 开发自己的静态Web服务器 实现步骤:编写一个TCP服务端程序、获取浏览器发送的http请求报文数据、读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。 示例代码： import socket if __name__ == &apos;__main__&apos;: # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) with open(&quot;static/index.html&quot;, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) # 关闭服务与客户端的套接字 new_socket.close() 开发自己的静态Web服务器返回指定页面数据 返回指定页面数据的实现步骤:获取用户请求资源的路径；根据请求资源的路径，读取指定文件的数据；组装指定文件数据的响应报文，发送给浏览器；判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器。 import socket def main(): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() if __name__ == &apos;__main__&apos;: main() 静态Web服务器-多任务版 多任务版web服务器程序的实现步骤:当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。把创建的子线程设置成为守护主线程，防止主线程无法退出。 import socket import threading # 处理客户端的请求 def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() # 程序入口函数 def main(): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() print(ip_port) # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start() if __name__ == &apos;__main__&apos;: main() 静态Web服务器-面向对象开发 实现步骤:把提供服务的Web服务器抽象成一个类(HTTPWebServer)；提供Web服务器的初始化方法，在初始化方法里面创建socket对象；提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。 import socket import threading # 定义web服务器类 class HttpWebServer(object): def __init__(self): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) # 保存创建成功的服务器套接字 self.tcp_server_socket = tcp_server_socket # 处理客户端的请求 @staticmethod def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() # 启动web服务器进行工作 def start(self): while True: # 等待接受客户端的连接请求 new_socket, ip_port = self.tcp_server_socket.accept() # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start() # 程序入口函数 def main(): # 创建web服务器对象 web_server = HttpWebServer() # 启动web服务器进行工作 web_server.start() if __name__ == &apos;__main__&apos;: main() 命令行启动动态绑定端口号 实现步骤:获取执行python程序的终端命令行参数;判断参数的类型，设置端口号必须是整型;给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号。 import socket import threading import sys # 定义web服务器类 class HttpWebServer(object): def __init__(self, port): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, port)) # 设置监听 tcp_server_socket.listen(128) # 保存创建成功的服务器套接字 self.tcp_server_socket = tcp_server_socket # 处理客户端的请求 @staticmethod def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() # 启动web服务器进行工作 def start(self): while True: # 等待接受客户端的连接请求 new_socket, ip_port = self.tcp_server_socket.accept() # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start() # 程序入口函数 def main(): print(sys.argv) # 判断命令行参数是否等于2, if len(sys.argv) != 2: print(&quot;执行命令如下: python3 xxx.py 8000&quot;) return # 判断字符串是否都是数字组成 if not sys.argv[1].isdigit(): print(&quot;执行命令如下: python3 xxx.py 8000&quot;) return # 获取终端命令行参数 port = int(sys.argv[1]) # 创建web服务器对象 web_server = HttpWebServer(port) # 启动web服务器进行工作 web_server.start() if __name__ == &apos;__main__&apos;: main() 数据库介绍 数据库就是存储和管理数据的仓库，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。 数据库的分类：关系型数据库和非关系型数据库。 关系型数据库:是指采用了关系模型来组织数据的数据库，简单来说，关系模型指的就是二维表格模型。 关系型数据库中核心元素：数据行、数据列、数据表、数据库(数据表的集合)。 常用的关系型数据库:Oracle、Microsoft SQL Server、MySQL、SQLite。 非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。 常用的非关系型数据库:MongoDB、Redis。 数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件。 SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。 SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。 SQL语言主要分为： DQL：数据查询语言，用于对数据进行查询，如select DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback DCL：数据控制语言，进行授权与权限回收，如grant、revoke DDL：数据定义语言，进行数据库、表的管理等，如create、drop 对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可。SQL语言不区分大小写。 数据类型和约束 数据库中的数据保存在数据表中，在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，比如:数据类型和约束。 数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。 常用数据类型如下: 整数：int，bit 小数：decimal 字符串：varchar,char 日期时间: date, time, datetime 枚举类型(enum) decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位. char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为’ab ‘，3表示字符数 varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’，3表示字符数 对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径. 字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客 数据约束约束是指数据在数据类型限定的基础上额外增加的要求. 常见的约束如下: 主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned. 非空 not null: 此字段不允许填写空值. 惟一 unique: 此字段的值不允许重复. 默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准. 外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常. 整数类型： 类型 字节大小 有符号范围(Signed) 无符号范围(Unsigned) TINYINT 1 -128 ~ 127 0 ~ 255 SMALLINT 2 -32768 ~ 32767 0 ~ 65535 MEDIUMINT 3 -8388608 ~ 8388607 0 ~ 16777215 INT/INTEGER 4 -2147483648 ~2147483647 0 ~ 4294967295 BIGINT 8 -9223372036854775808 ~ 9223372036854775807 0 ~ 18446744073709551615 字符串： 类型 说明 使用场景 CHAR 固定长度，小型数据 身份证号、手机号、电话、密码 VARCHAR 可变长度，小型数据 姓名、地址、品牌、型号 TEXT 可变长度，字符个数大于 4000 存储小型文章或者新闻 LONGTEXT 可变长度， 极大型文本数据 存储极大型文本数据 时间类型： 类型 字节大小 示例 DATE 4 ‘2020-01-01’ TIME 3 ‘12:29:59’ DATETIME 8 ‘2020-01-01 12:29:59’ YEAR 1 ‘2017’ TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC Navicat Navicat 是一个数据库图形化客户端软件, 可以以安全并且简单的方式对数据库进行操作。 新建数据库：字符集: 就是编码格式，选择utf8的国际通用编码格式, 支持中文。排序规则: utf8_general_ci 表示大小写不敏感，不区分大小写字母,a 和 A 在字符判断中会被当做一样的处理，区分大小写可以选择utf8_bin。 命令行客户端MySQL的使用 登录数据库: mysql -uroot -p 显示当前时间： select now(); 登出(退出)数据库: quit 或 exit 或 ctrl + d 数据库操作 查看所有数据库： show databases; 创建数据库： create database 数据库名 charset=utf8; 例： create database python charset=utf8; 使用数据库： use 数据库名; 查看当前使用的数据库： select database(); 删除数据库-慎重： drop database 数据库名; 例： drop database python; 表结构操作 查看当前数据库中所有表： show tables; 创建表： create table students( id int unsigned primary key auto_increment not null, name varchar(20) not null, age tinyint unsigned default 0, height decimal(5,2), gender enum(&apos;男&apos;,&apos;女&apos;,&apos;人妖&apos;,&apos;保密&apos;) ); 说明: create table 表名( 字段名称 数据类型 可选的约束条件, column1 datatype contrai, ... ); 修改表-添加字段： alter table 表名 add 列名 类型 约束; 例： alter table students add birthday datetime; 修改表-修改字段类型： alter table 表名 modify 列名 类型 约束; 例： alter table students modify birthday date not null; 说明: modify: 只能修改字段类型或者约束，不能修改字段名 修改表-修改字段名和字段类型： alter table 表名 change 原名 新名 类型及约束; 例： alter table students change birthday birth datetime not null; 说明: change: 既能对字段重命名又能修改字段类型还能修改约束 修改表-删除字段： alter table 表名 drop 列名; 例： alter table students drop birthday; 查看创表SQL语句： show create table 表名; 例： show create table students; 查看创库SQL语句： show create database 数据库名; 例： show create database mytest; 删除表： drop table 表名; 例： drop table students; 表数据操作 查询数据： 1. 查询所有列 select * from 表名; 例： select * from students; 2. 查询指定列 select 列1,列2,... from 表名; 例： select id,name from students; 添加数据： 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应 insert into 表名 values (...) 例: insert into students values(0, &apos;xx&apos;, default, default, &apos;男&apos;); 2. 部分列插入：值的顺序与给出的列顺序对应 insert into 表名 (列1,...) values(值1,...) 例: insert into students(name, age) values(&apos;王二小&apos;, 15); 3. 全列多行插入 insert into 表名 values(...),(...)...; 例: insert into students values(0, &apos;张飞&apos;, 55, 1.75, &apos;男&apos;),(0, &apos;关羽&apos;, 58, 1.85, &apos;男&apos;); 4. 部分列多行插入 insert into 表名(列1,...) values(值1,...),(值1,...)...; 例： insert into students(name, height) values(&apos;刘备&apos;, 1.75),(&apos;曹操&apos;, 1.6); 说明: 主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)。在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值 修改数据： update 表名 set 列1=值1,列2=值2... where 条件 例： update students set age = 18, gender = &apos;女&apos; where id = 6; 删除数据： delete from 表名 where 条件 例： delete from students where id=5; 问题:上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。 添加删除表示字段，0表示未删除 1表示删除 alter table students add isdelete bit default 0; 逻辑删除数据 update students set isdelete = 1 where id = 8; 说明:逻辑删除，本质就是修改操作。 as和distinct关键字 as关键字：在使用SQL语句显示结果的时候，往往在屏幕显示的字段名并不具备良好的可读性，此时可以使用 as 给字段起一个别名。 使用 as 给字段起别名： select id as 序号, name as 名字, gender as 性别 from students; 可以通过 as 给表起别名 -- 如果是单表查询 可以省略表名 select id, name, gender from students; -- 表名.字段名 select students.id,students.name,students.gender from students; -- 可以通过 as 给表起别名 select s.id,s.name,s.gender from students as s; distinct关键字：distinct可以去除重复数据行。 select distinct 列1,... from 表名; 例： 查询班级中学生的性别 select name, gender from students; -- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct select distinct name, gender from students; where条件查询 使用where条件查询可以对表中的数据进行筛选，条件成立的记录会出现在结果集中。 格式如下: select * from 表名 where 条件; 例： select * from students where id = 1; 比较运算符查询（=、&gt;、&gt;=、&lt;、&lt;=、!= 或 &lt;&gt;）： 例1：查询编号大于3的学生: select * from students where id &gt; 3; 例2：查询编号不大于4的学生: select * from students where id &lt;= 4; 例3：查询姓名不是“黄蓉”的学生: select * from students where name != &apos;黄蓉&apos;; 例4：查询没被删除的学生: select * from students where is_delete=0; 逻辑运算符查询（and、or、not） 例1：查询编号大于3的女同学: select * from students where id &gt; 3 and gender=0; 例2：查询编号小于4或没被删除的学生: select * from students where id &lt; 4 or is_delete=0; 例3：查询年龄不在10岁到15岁之间的学生: select * from students where not (age &gt;= 10 and age &lt;= 15); 说明:多个条件判断想要作为一个整体，可以结合()。 模糊查询(like是模糊查询关键字、%表示任意多个任意字符、_表示一个任意字符）： 例1：查询姓黄的学生: select * from students where name like &apos;黄%&apos;; 例2：查询姓黄并且“名”是一个字的学生: select * from students where name like &apos;黄_&apos;; 例3：查询姓黄或叫靖的学生: select * from students where name like &apos;黄%&apos; or name like &apos;%靖&apos;; 范围查询(between .. and .. 表示在一个连续的范围内查询、in 表示在一个非连续的范围内查询）： 例1：查询编号为3至8的学生: select * from students where id between 3 and 8; 例2：查询编号不是3至8的男生: select * from students where (not id between 3 and 8) and gender=&apos;男&apos;; 空判断查询（判断为空使用: is null、判断非空使用: is not null）： 例1：查询没有填写身高的学生: select * from students where height is null; 排序 排序查询语法： select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...] 语法说明:先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推。asc从小到大排列，即升序。desc从大到小排序，即降序。默认按照列值从小到大排列（即asc）。 例1：查询未删除男生信息，按学号降序: select * from students where gender=1 and is_delete=0 order by id desc; 例2：显示所有的学生信息，先按照年龄从大--&gt;小排序，当年龄相同时 按照身高从高--&gt;矮排序: select * from students order by age desc,height desc; 分页查询 分页查询的语法 select * from 表名 limit start,count 说明:limit是分页查询关键字；start表示开始行索引，默认是0；count表示查询条数。 查询前3行男生信息: select * from students where gender=1 limit 0,3; 简写： select * from students where gender=1 limit 3; 已知每页显示m条数据，求第n页显示的数据 查询学生表，获取第n页数据的SQL语句: select * from students limit (n-1)*m,m 聚合函数 聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。 常用的聚合函数: count(col): 表示求指定列的总行数 max(col): 表示求指定列的最大值 min(col): 表示求指定列的最小值 sum(col): 表示求指定列的和 avg(col): 表示求指定列的平均值 求总行数 -- 返回非NULL数据的总行数. select count(height) from students; -- 返回总行数，包含null值记录; select count(*) from students; 求最大值 -- 查询女生的编号最大值 select max(id) from students where gender = 2; 求最小值 -- 查询未删除的学生最小编号 select min(id) from students where is_delete = 0; 求和 -- 查询男生的总身高 select sum(height) from students where gender = 1; -- 平均身高 select sum(height) / count(*) from students where gender = 1; 求平均值 -- 求男生的平均身高, 聚合函数不统计null值，平均身高有误 select avg(height) from students where gender = 1; -- 求男生的平均身高, 包含身高是null的 select avg(ifnull(height,0)) from students where gender = 1; 说明：ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。 聚合函数的特点：聚合函数默认忽略字段为null的记录，要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。 分组查询 分组查询介绍：将查询结果按照指定字段进行分组，字段中数据相等的分为一组。 语法格式如下： GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP] 说明:列名: 是指按照指定字段的值进行分组。HAVING 条件表达式: 用来过滤分组后的数据。WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果。 group by可用于单个字段分组，也可用于多个字段分组： -- 根据gender字段来分组 select gender from students group by gender; -- 根据name和gender字段进行分组 select name, gender from students group by name, gender; group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割： -- 根据gender字段进行分组， 查询gender字段和分组的name字段信息 select gender,group_concat(name) from students group by gender; group by + 聚合函数的使用: -- 统计不同性别的人的平均年龄 select gender,avg(age) from students group by gender; -- 统计不同性别的人的个数 select gender,count(*) from students group by gender; group by + having的使用: -- 根据gender字段进行分组，统计分组条数大于2的 select gender,count(*) from students group by gender having count(*)&gt;2; group by + with rollup的使用: -- 根据gender字段进行分组，汇总总人数 select gender,count(*) from students group by gender with rollup; -- 根据gender字段进行分组，汇总所有人的年龄 select gender,group_concat(age) from students group by gender with rollup; 内连接查询 连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。 连接查询可以分为:内连接查询、左连接查询、右连接查询、自连接查询。 内连接查询：查询两个表中符合条件的共有记录。 语法格式: select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2 说明:inner join 就是内连接查询关键字。on 就是连接查询条件 例1：使用内连接查询学生表与班级表: select * from students as s inner join classes as c on s.cls_id = c.id; 左连接查询 左连接查询：以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充。 语法格式: select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2 说明:left join 就是左连接查询关键字；on 就是连接查询条件；表1是左表；表2是右表。 例1：使用左连接查询学生表与班级表: select * from students as s left join classes as c on s.cls_id = c.id; 右连接查询 以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充。 右连接查询语法格式: select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2 说明:right join 就是右连接查询关键字；on 就是连接查询条件；表1是左表；表2是右表。 使用右连接查询学生表与班级表: select * from students as s right join classes as c on s.cls_id = c.id; 自连接查询 左表和右表是同一个表，根据连接查询条件查询两个表中的数据。 自连接查询的用法: select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &apos;山西省&apos;; 子查询 在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询. 主查询和子查询的关系:子查询是嵌入到主查询中;子查询是辅助主查询的,要么充当条件,要么充当数据源;子查询是可以独立存在的语句,是一条完整的 select 语句。 例1. 查询大于平均年龄的学生: select * from students where age &gt; (select avg(age) from students); 例2. 查询学生在班的所有班级名字: select name from classes where id in (select cls_id from students where cls_id is not null); 例3. 查找年龄最大,身高最高的学生: select * from students where (age, height) = (select max(age), max(height) from students); 数据库设计之三范式 第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。 第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 E-R模型即实体-关系模型，E-R模型就是描述数据库存储数据的结构模型。E-R模型由实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。 外键SQL语句的编写 外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性。 添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段); 删除外键约束: alter table 表名 drop foreign key 外键名; 对于已经存在的字段添加外键约束： -- 为cls_id字段添加外键约束 alter table students add foreign key(cls_id) references classes(id); 在创建数据表时设置外键约束： -- 创建学校表 create table school( id int not null primary key auto_increment, name varchar(10) ); -- 创建老师表 create table teacher( id int not null primary key auto_increment, name varchar(10), s_id int not null, foreign key(s_id) references school(id) ); 删除外键约束 -- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称 show create table teacher; -- 获取名称之后就可以根据名称来删除外键约束 alter table teacher drop foreign key 外键名; 将查询结果插入到其它表中 把查询结果插入到指定表中，也就是表复制: insert into .. select .. SQL语句 把goods表中的cate_name商品分类添加到good_cates商品分类表: -- 查询goods表中商品的分类信息 select cate_name from goods group by cate_name; -- 将查询结果插入到good_cates表中 insert into good_cates(name) select cate_name from goods group by cate_name; -- 添加移动设备分类信息 insert into good_cates(name) values(&apos;移动设备&apos;); 使用连接更新表中某个字段数据 连接更新表中数据使用: update .. join .. 将goods表中的分类名称更改成商品分类表中对应的分类id -- 查看goods表中的商品分类名称对应的商品分类id select * from goods inner join good_cates on goods.cate_name = good_cates.name; -- 把该语句中from 后的语句理解为一张虚表 update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id; 创建表并给某个字段添加数据 创建表并给字段插入数据使用: create table .. select 语句 创建品牌表 -- 查询品牌信息 select brand_name from goods group by brand_name; -- 通过create table ...select来创建数据表并且同时插入数据 -- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值 create table good_brands ( id int unsigned primary key auto_increment, name varchar(40) not null) select brand_name as name from goods group by brand_name; 说明:create table .. select 列名 ..表示创建表并插入数据 更新goods表中的品牌信息 -- 将goods表中的品牌名称更改成品牌表中对应的品牌id update goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id; 修改表结构 alter table 语句 把 cate_name 和 brand_name 字段分别改成 cate_id和 brand_id 字段，类型都改成int类型: -- 查看表结构 desc goods; -- 通过alter table语句修改表结构 alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null; 事务 事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。事务能够保证数据的完整性和一致性，让用户的操作更加安全。 事务的特性: 原子性: 强调事务中的多个操作时一个整体 一致性: 强调数据库中不会保存不一致状态 隔离性: 强调数据库中事务之间相互不可见 持久性: 强调数据库能永久保存数据，一旦提交就不可撤销 MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚。开启事务使用 begin 或者 start transaction;回滚事务使用 rollback。 常用的表的存储引擎是 InnoDB 和 MyISAM。InnoDB 是支持事务的；MyISAM 不支持事务，优势是访问速度快，对事务没有要求或者以select、insert为主的都可以使用该存储引擎来创建表。 事务演练的SQL语句: begin; insert into students(name) values(&apos;李白&apos;); -- 查询数据，此时有新增的数据, 注意: 如果这里后续没有执行提交事务操作，那么数据是没有真正的更新到物理表中 select * from students; -- 只有这里提交事务，才把数据真正插入到物理表中 commit; -- 新打开一个终端，重新连接MySQL数据库，查询students表,这时没有显示新增的数据，说明之前的事务没有提交，这就是事务的隔离性 -- 一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的 select * from students; 索引 索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。 查看表中已有索引: show index from 表名; 说明:主键列会自动创建索引 索引的创建: -- alter table 表名 add index 索引名[可选](列名, ..) -- 给name字段添加索引 alter table classes add index my_name (name); 说明:索引名不指定，默认使用字段名。 索引的删除: -- alter table 表名 drop index 索引名 -- 如果不知道索引名，可以查看创表sql语句 show create table classes; alter table classes drop index my_name; 联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。 -- 创建联合索引 alter table teacher add index (name,age); 联合索引的好处:减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。 联合索引的最左原则：在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持name、name和age组合查询,而不支持单独age 查询，因为没有用到创建的联合索引。 最左原则示例: -- 下面的查询使用到了联合索引 select * from stu where name=&apos;张三&apos; -- 这里使用了联合索引的name部分 select * from stu where name=&apos;李四&apos; and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 -- 下面的查询没有使用到联合索引 select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合 PyMySQL的使用 使用代码的方式操作数据库就称为数据库编程。 win电脑cd到python的安装目录Scripts文件夹下 安装： pip install pymysql pymysql的使用: #导包 import pymysql #创建连接对象 pymysql.connect(参数列表) #获取游标对象 cursor =conn.cursor() #执行SQL语句 row_count = cursor.execute(sql) #获取查询结果集 result = cursor.fetchall() #将修改操作提交到数据库 conn.commit() #回滚数据 conn.rollback() #关闭游标 cursor.close() #关闭连接 conn.close() 查询操作: import pymysql # 创建连接对象 conn = pymysql.connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, password=&apos;*****&apos;, database=&apos;python&apos;, charset=&apos;utf8&apos;) # 获取游标对象 cursor = conn.cursor() # 查询 SQL 语句 sql = &quot;select * from test;&quot; # 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数 row_count = cursor.execute(sql) print(&quot;SQL 语句执行影响的行数%d&quot; % row_count) # 取出结果集中一行数据, 例如:(1, &apos;张三&apos;) #print(cursor.fetchone()) # 取出结果集中的所有数据, 例如:((1, &apos;张三&apos;), (2, &apos;李四&apos;), (3, &apos;王五&apos;)) for line in cursor.fetchall(): print(line) # 关闭游标 cursor.close() # 关闭连接 conn.close() 增删改操作： import pymysql # 创建连接对象 conn = pymysql.connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, password=&apos;824699&apos;,database=&apos;python&apos;, charset=&apos;utf8&apos;) # 获取游标对象 cursor = conn.cursor() try: # 添加 SQL 语句 # sql = &quot;insert into test(name) values(&apos;刘璐&apos;), (&apos;王美丽&apos;);&quot; # 删除 SQ L语句 # sql = &quot;delete from test where id = 2;&quot; # 修改 SQL 语句 sql = &quot;update test set name = &apos;王铁蛋&apos; where id = 1;&quot; # 执行 SQL 语句 row_count = cursor.execute(sql) print(&quot;SQL 语句执行影响的行数%d&quot; % row_count) # 提交数据到数据库 conn.commit() except Exception as e: # 回滚数据， 即撤销刚刚的SQL语句操作 conn.rollback() # 关闭游标 cursor.close() # 关闭连接 conn.close() 什么是SQL注入?用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。 如何防止SQL注入?SQL语句参数化 SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作。将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给。execute方法中第二个参数。 防止SQL注入的示例代码: from pymysql import connect def main(): find_name = input(&quot;请输入物品名称：&quot;) # 创建Connection连接 conn = connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;mysql&apos;,database=&apos;jing_dong&apos;,charset=&apos;utf8&apos;) # 获得Cursor对象 cs1 = conn.cursor() # 非安全的方式 # 输入 &apos; or 1 = 1 or &apos; (单引号也要输入) # sql = &quot;select * from goods where name=&apos;%s&apos;&quot; % find_name # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql) # # 执行select语句，并返回受影响的行数：查询所有数据 # count = cs1.execute(sql) # 安全的方式 # 构造参数列表 params = [find_name] # 执行select语句，并返回受影响的行数：查询所有数据 count = cs1.execute(&quot;select * from goods where name=%s&quot;, params) # 注意： # 如果要是有多个参数，需要进行参数化 # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可 # %s 不需要带引号 # 打印受影响的行数 print(count) # 获取查询的结果 # result = cs1.fetchone() result = cs1.fetchall() # 打印查询的结果 print(result) # 关闭Cursor对象 cs1.close() # 关闭Connection对象 conn.close() if __name__ == &apos;__main__&apos;: main() 闭包 闭包的定义:在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。 闭包的形成条件:在函数嵌套(函数里面再定义函数)的前提下；内部函数使用了外部函数的变量(还包括外部函数的参数)；外部函数返回了内部函数。 示例代码 # 定义一个外部函数 def func_out(num1): # 定义一个内部函数 def func_inner(num2): # 内部函数使用了外部函数的变量(num1) result = num1 + num2 print(&quot;结果是:&quot;, result) # 外部函数返回了内部函数，这里返回的内部函数就是闭包 return func_inner # 创建闭包实例 f = func_out(1) # 执行闭包 f(2) #结果是: 3 f(3) #结果是: 4 闭包不仅可以保存外部函数的变量还可以提高代码的可重用行。 修改闭包内使用的外部函数变量使用 nonlocal 关键字来完成。 # 定义一个外部函数 def func_out(num1): # 定义一个内部函数 def func_inner(num2): # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1 nonlocal num1 # 告诉解释器，此处使用的是 外部变量a # 修改外部变量num1 num1 = 10 # 内部函数使用了外部函数的变量(num1) result = num1 + num2 print(&quot;结果是:&quot;, result) #print(num1) # func_inner(1) # print(num1) # 外部函数返回了内部函数，这里返回的内部函数就是闭包 return func_inner # 创建闭包实例 f = func_out(1) # 执行闭包 f(2) #结果是: 12 装饰器 就是给已有函数增加额外功能的函数，它本质上就是一个闭包函数。 装饰器的功能特点:不修改已有函数的源代码；不修改已有函数的调用方式；给已有函数增加额外的功能。 装饰器的语法格式: # 装饰器 # def decorator(fn): # fn:被装饰的目标函数. # def inner(): # &apos;&apos;&apos;执行函数之前&apos;&apos;&apos; # fn() # 执行被装饰的目标函数 # &apos;&apos;&apos;执行函数之后&apos;&apos;&apos; # return inner 示例代码： # 添加一个登录验证的功能 def check(fn): def inner(): print(&quot;请先登录....&quot;) fn() return inner def comment(): print(&quot;发表评论&quot;) # 使用装饰器来装饰函数 comment = check(comment) comment() 闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。 语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰: # 添加一个登录验证的功能 def check(fn): print(&quot;装饰器函数执行了&quot;) def inner(): print(&quot;请先登录....&quot;) fn() return inner # 使用语法糖方式来装饰函数 @check def comment(): print(&quot;发表评论&quot;) comment() 装饰器实现已有函数执行时间的统计: import time # 装饰器函数 def get_time(func): def inner(): begin = time.time() func() end = time.time() print(&quot;函数执行花费%f&quot; % (end-begin)) return inner @get_time def func1(): for i in range(100000): print(i) func1() 装饰带有参数的函数: # 添加输出日志的功能 def logging(fn): def inner(num1, num2): print(&quot;--正在努力计算--&quot;) fn(num1, num2) return inner # 使用装饰器装饰函数 @logging def sum_num(a, b): result = a + b print(result) sum_num(1, 2) 装饰带有返回值的函数: # 添加输出日志的功能 def logging(fn): def inner(num1, num2): print(&quot;--正在努力计算--&quot;) result = fn(num1, num2) return result return inner # 使用装饰器装饰函数 @logging def sum_num(a, b): result = a + b return result result = sum_num(1, 2) print(result) 装饰带有不定长参数的函数: # 添加输出日志的功能 def logging(fn): def inner(*args, **kwargs): print(&quot;--正在努力计算--&quot;) fn(*args, **kwargs) return inner # 使用语法糖装饰函数 @logging def sum_num(*args, **kwargs): result = 0 for value in args: result += value for value in kwargs.values(): result += value print(result) sum_num(1, 2, a=10) 通用装饰器： # 添加输出日志的功能 def logging(fn): def inner(*args, **kwargs): print(&quot;--正在努力计算--&quot;) result = fn(*args, **kwargs) return result return inner # 使用语法糖装饰函数 @logging def sum_num(*args, **kwargs): result = 0 for value in args: result += value for value in kwargs.values(): result += value return result @logging def subtraction(a, b): result = a - b print(result) result = sum_num(1, 2, a=10) print(result) subtraction(4, 2) 多个装饰器的使用示例代码： def make_div(func): &quot;&quot;&quot;对被装饰的函数的返回值 div标签&quot;&quot;&quot; def inner(*args, **kwargs): return &quot;&lt;div&gt;&quot; + func() + &quot;&lt;/div&gt;&quot; return inner def make_p(func): &quot;&quot;&quot;对被装饰的函数的返回值 p标签&quot;&quot;&quot; def inner(*args, **kwargs): return &quot;&lt;p&gt;&quot; + func() + &quot;&lt;/p&gt;&quot; return inner # 装饰过程: 1 content = make_p(content) 2 content = make_div(content) # content = make_div(make_p(content)) @make_div @make_p def content(): return &quot;人生苦短&quot; result = content() print(result) 多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程 带有参数的装饰器:在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。 # 添加输出日志的功能 def logging(flag): def decorator(fn): def inner(num1, num2): if flag == &quot;+&quot;: print(&quot;--正在努力加法计算--&quot;) elif flag == &quot;-&quot;: print(&quot;--正在努力减法计算--&quot;) result = fn(num1, num2) return result return inner # 返回装饰器 return decorator # 使用装饰器装饰函数 @logging(&quot;+&quot;) def add(a, b): result = a + b return result @logging(&quot;-&quot;) def sub(a, b): result = a - b return result result = add(1, 2) print(result) result = sub(1, 2) print(result) 类装饰器： class Check(object): def __init__(self, fn): # 初始化操作在此完成 self.__fn = fn # 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。 def __call__(self, *args, **kwargs): # 添加装饰功能 print(&quot;请先登陆...&quot;) self.__fn() @Check def comment(): print(&quot;发表评论&quot;) comment() @Check 等价于 comment = Check(comment), 所以需要提供一个init方法，并多增加一个fn参数。 要想类的实例对象能够像函数一样调用，需要在类里面使用call方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。 在call方法里进行对fn函数的装饰，可以添加额外的功能。 mini-web框架概述 使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序，简称web框架。 和静态资源相反, 动态资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。 WSGI协议:它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。 正则表达式property属性 property属性就是负责把一个方法当做属性进行使用，这样做可以简化代码使用。定义property属性有两种方式：装饰器方式和类属性方式。 装饰器方式： class Person(object): def __init__(self): self.__age = 0 # 装饰器方式的property, 把age方法当做属性使用, 表示当获取属性时会执行下面修饰的方法 @property def age(self): return self.__age # 把age方法当做属性使用, 表示当设置属性时会执行下面修饰的方法 @age.setter def age(self, new_age): if new_age &gt;= 150: print(&quot;成精了&quot;) else: self.__age = new_age # 创建person p = Person() print(p.age) p.age = 100 print(p.age) p.age = 1000 @property表示把方法当做属性使用, 表示当获取属性时会执行下面修饰的方法。@方法名.setter 表示把方法当做属性使用,表示当设置属性时会执行下面修饰的方法。装饰器方式的property属性修饰的方法名一定要一样。 类属性方式: class Person(object): def __init__(self): self.__age = 0 def get_age(self): &quot;&quot;&quot;当获取age属性的时候会执行该方法&quot;&quot;&quot; return self.__age def set_age(self, new_age): &quot;&quot;&quot;当设置age属性的时候会执行该方法&quot;&quot;&quot; if new_age &gt;= 150: print(&quot;成精了&quot;) else: self.__age = new_age # 类属性方式的property属性 age = property(get_age, set_age) # 创建person p = Person() print(p.age) p.age = 100 print(p.age) p.age = 1000 property的参数说明:第一个参数是获取属性时要执行的方法;第二个参数是设置属性时要执行的方法。 with语句和上下文管理器 向文件中写入数据的示例代码: try: # 1、以读的方式打开文件 f = open(&quot;1.txt&quot;, &quot;r&quot;) # 2、读取文件内容 f.write(&quot;xxxxx&quot;) except IOError as e: print(&quot;文件操作出错&quot;, e) finally: # 3、关闭文件 f.close() 这种方法代码过于冗长,Python提供了 with 语句的这种写法，既简单又安全，并且 with 语句执行完成以后自动调用关闭文件操作，即使出现异常也会自动调用关闭文件操作。 with 语句的示例代码: # 1、以写的方式打开文件 with open(&quot;1.txt&quot;, &quot;w&quot;) as f: # 2、读取文件内容 f.write(&quot;hello world&quot;) 一个类只要实现了__enter__()和__exit__()这个两个方法，通过该类创建的对象我们就称之为上下文管理器。上下文管理器可以使用 with 语句，with语句之所以这么强大，背后是由上下文管理器做支撑的。 自定义上下文管理器类,模拟文件操作: class File(object): # 初始化方法 def __init__(self, file_name, file_model): # 定义变量保存文件名和打开模式 self.file_name = file_name self.file_model = file_model # 上文方法 def __enter__(self): print(&quot;进入上文方法&quot;) # 返回文件资源 self.file = open(self.file_name,self.file_model) return self.file # 下文方法 def __exit__(self, exc_type, exc_val, exc_tb): print(&quot;进入下文方法&quot;) self.file.close() if __name__ == &apos;__main__&apos;: # 使用with管理文件 with File(&quot;1.txt&quot;, &quot;r&quot;) as file: file_data = file.read() print(file_data) __enter__表示上文方法，需要返回一个操作文件对象。__exit__表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法。 假如想要让一个函数成为上下文管理器，Python 还提供了一个@contextmanager的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 上面的语句在__enter__方法中执行，yield 下面的语句在__exit__方法中执行，紧跟在 yield 后面的参数是函数的返回值。 # 导入装饰器 from contextlib import contextmanager # 装饰器装饰函数，让其称为一个上下文管理器对象 @contextmanager def my_open(path, mode): try: # 打开文件 file = open(file_name, file_mode) # yield之前的代码好比是上文方法 yield file except Exception as e: print(e) finally: print(&quot;over&quot;) # yield下面的代码好比是下文方法 file.close() # 使用with语句 with my_open(&apos;out.txt&apos;, &apos;w&apos;) as f: f.write(&quot;hello , the simplest context manager&quot;) 生成器的创建方式 根据程序员制定的规则循环生成数据，当条件不成立时则生成数据结束。数据不是一次性全部生成处理，而是使用一个，再生成一个，可以节约大量的内存。创建生成器的方式：生成器推导式和 yield 关键字。 生成器推导式: # 创建生成器 my_generator = (i * 2 for i in range(5)) print(my_generator) # next获取生成器下一个值 # value = next(my_generator) # print(value) # 遍历生成器 for value in my_generator: print(value) 代码说明:next 函数获取生成器中的下一个值;for 循环遍历生成器中的每一个值。 yield 关键字: 只要在def函数里面看到有 yield 关键字那么就是生成器。 def mygenerater(n): for i in range(n): print(&apos;开始生成...&apos;) yield i print(&apos;完成一次...&apos;) if __name__ == &apos;__main__&apos;: g = mygenerater(2) # 获取生成器中下一个值 # result = next(g) # print(result) # while True: # try: # result = next(g) # print(result) # except StopIteration as e: # break # # for遍历生成器, for 循环内部自动处理了停止迭代异常，使用起来更加方便 for i in g: print(i) 代码说明:代码执行到 yield 会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行。生成器如果把数据生成完成，再次获取生成器中的下一个数据会抛出一个StopIteration 异常，表示停止迭代异常。while 循环内部没有处理异常操作，需要手动添加处理异常操作。for 循环内部自动处理了停止迭代异常，使用起来更加方便，推荐大家使用。 深拷贝和浅拷贝","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"Linux命令","slug":"42.Linux命令","date":"2020-09-09T13:06:10.253Z","updated":"2021-03-26T14:41:50.562Z","comments":false,"path":"2020/09/09/42.Linux命令/","link":"","permalink":"http://yoursite.com/2020/09/09/42.Linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"LinuxLinux主要目录速查表 /：根目录，一般根目录下只存放目录，在 linux 下有且只有一个根目录，所有的东西都是从这里开始。当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录 /bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等 /boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 ~ 表示当前用户的家目录 ~edu 表示用户 edu 的家目录 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载 /opt：给主机额外安装软件所摆放的目录 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等 /root：系统管理员root的家目录 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 /usr：应用程序存放目录 /usr/bin：存放应用程序 /usr/share：存放共享数据 /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包 /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /var：放置系统执行过程中经常变化的文件 /var/log：随时更改的日志文件 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动后，其 PID 存放在该目录下 Ubuntu操作系统是属于Linux操作系统中的一种。Ubuntu 没有盘符这个概念，只有一个根目录/，所有文件都在它下面。 主要目录说明:/：根目录。/bin：可执行二进制文件的目录。/etc：系统配置文件存放的目录。/home：用户家目录。 文件 在Linux中文件没有扩展名，可以通过颜色区分，也可以通过命令来区分file 文件名。在Linux中文件分为：普通文件、目录文件、设备文件、管道文件、链接文件。 文件权限 读权限（r）、写权限（w）、可执行权限（x）。通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。 d rwx rwx rwx 第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后9个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。每一个用户都有它自身的读、写和执行权限。 常用Linux命令 ctrl + shift + = //放大终端窗口的字体显示 ctrl + - //缩小终端窗口的字体显示 ls //查看当前文件夹下的内容 pwd //查看当前所在文件夹 cd //切换文件夹 touch [文件名] //如果文件不存在，新建文件 mkdir [目录名] //创建目录，参数-p可递归创建目录 rm [文件名] //删除指定的文件名 rm -r [文件夹名] //删除指定的文件 clear //清屏 tree //以树状方式显示目录信息 Linux文件或者目录名称最长可以有256个字符，.代表当前目录，..代表上一级目录，以.开头的文件为隐藏文件，需要用-a参数才能显示。 ls -a //查看所有文件包含隐藏文件 ls -l //以列表形式查看文件，不包含隐藏文件 ls -lh //以列表形式查看文件，不包含隐藏文件 ，按照1024倍数显示&#123;KB MB GB&#125; ls -all //以列表形式查看文件，包含隐藏文件 快捷方式【ll】 通配符： 【*】 匹配任意多个字符【0-256】 a* 一个以上字符 256以下 【?】 匹配任意一个字符 a？ 两个字符 【[a-z]】 区间法 匹配a到z的所有字符 只能确定一个字符 【[abcde]】 穷举法 权值法 匹配abcde的所有字符 只能确定一个字符 重定向命令 //Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。 ls &gt; test.txt //test.txt 如果不存在，则创建，存在则覆盖其内容。 &gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 切换工作目录： cd ~ 切换到当前用户的主目录 cd .. 切换到上级目录 cd - 切换到上一次目录 查看或者合并文件内容： cat 文件名 cat a.txt b.txt &gt; c.txt 建立链接文件：ln //如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在。 //硬链接和拷贝（复制）区别:无论修改了哪一个链接之后的文件,两个文件都会改变,保持一致,但是拷贝不会。 ln 源文件 链接文件 //软链接文件不占磁盘空间 但是删除源文件会影响软链接文件 ln -s 源文件 链接文件 搜索文件里的文本内容： //行首,搜寻以a开头的行 grep -n &apos;^a&apos; 1.txt //行尾,搜寻以 ke 结束的行 grep -n &apos;ke$&apos; 1.txt //匹配 [] 里中一系列字符中的一个:搜寻匹配单词signal、signaL、Signal、SignaL的行 grep -n &apos;[Ss]igna[Ll]&apos; 1.txt //匹配一个非换行符的字符:匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae grep -n &apos;e.e&apos; 1.txt 计算文件行数或字数： wc 文件名 -l 统计行数 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -c 统计字节数 -m 统计字符数。这个标志不能与 -c 标志一起使用。 查找文件： find ./ -name test.sh //查找当前目录下所有名为test.sh的文件 find ./ -name &apos;*.sh&apos; //查找当前目录下所有后缀为.sh的文件 find ./ -name &quot;[A-Z]*&quot; //查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M //查找在/tmp 目录下等于2M的文件 find /tmp -size +2M //查找在/tmp 目录下大于2M的文件 find /tmp -size -2M //查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M //查找当前目录下大于4k，小于5M的文件 find ./ -perm 0777 //查找当前目录下权限为 777 的文件或目录 拷贝文件：cp cp vim_configure/ code/ -ivr //把文件夹 vim_configure 拷贝到 code 目录里： 移动文件：mv 获取文件类型： file 文件名 归档管理：tar //tar [参数] 打包文件名 文件 tar -cvf text.tar 1.text 2.text 3.text //解归档 tar -xvf test.tar //一步归档压缩:把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz tar zcvf test.tar.gz 1.c 2.c 3.c 4.c //一步解归档压缩 tar zxvf 文件名.tar.gz 文件压缩解压：gzip //tar与gzip命令结合使用实现文件打包、压缩。tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。 gzip text.tar //解压缩：生成了一个文件 归档文件名.tar gzip -d 归档文件名.tar.gz 文件压缩解压：bzip2 //bzip2压缩： tar -cjvf 文件名.tar.bz2 文件1 文件2 //bzip2解压缩： tar -xjvf 文件名.tar.bz2 -C 路径 文件压缩解压：zip、unzip //压缩 zip 文件名 文件1 文件2 生成一个文件为：文件名.zip //unzip解压缩： unzip 文件名.zip -C 路径 查看命令位置：which 用户、权限管理 查看当前用户：whoami 查看登录用户：who -m 切换用户 su //切换到root用户 su root //切换到root用户 su 普通用户 //切换到普通用户 su - 普通用户 //切换到普通用户，同时切换普通用户所在的目录 添加、删除组账号： groupadd 新建组账号 groupdel 组账号 修改用户所在组： usermod -g 用户组 用户名 添加组： groupadd 组名 // 添加组 需要用户权限 groupdel 组名 //删除组 需要用户权限和清空组成员 usermod -g 组名 用户名1 用户名2】//修改用户所在组：需要用户权限 修改文件权限：chmod 修改文件权限有两种使用格式：字母法与数字法。 //字母法： chmod u/g/o/a +/-/= rwx 文件 [ u/g/o/a ] 含义 u user 表示该文件的所有者 g group 表示与该文件的所有者属于同一组( group )者，即用户组 o other 表示其他以外的人 a all 表示这三者皆是 [ +-= ] 含义 + 增加权限 - 撤销权限 = 设定权限 rwx 含义 r read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。 w write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。 x excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。 //数字法：“rwx” 这些权限也可以用数字来代替 r 读取权限，数字代号为 &quot;4&quot; w 写入权限，数字代号为 &quot;2&quot; x 执行权限，数字代号为 &quot;1&quot; - 不具任何权限，数字代号为 &quot;0&quot; chmod u=rwx,g=rx,o=r filename //就等同于：chmod u=7,g=5,o=4 filename chmod 751 file //文件所有者：读、写、执行权限、同组用户：读、执行的权限、其它用户：执行的权限 修改文件所有者：chown 修改文件所属组：chgrp 系统管理 查看当前日历：cal 显示或设置时间：date 查看进程信息：ps 动态显示进程：top 终止进程：kill 后台程序：&amp;、jobs、fg 关机重启：reboot、shutdown、init VI VI编辑器有两个模式：文本编辑模式 命令行处理模式： 1、vi 文件名 2、vim 操作编辑器： 【i】在光标当前位置插入 【a】在光标右侧位置插入 【o】在光标下一行位置开启新的一行插入 【O】在光标上一行位置开启新的一行插入 【I】在光标当前行行首插入 【A】在光标当前行行尾插入 退出编辑器： 【ZZ】保存退出 【:wq】保存退出 【:x】保存退出 【:w 文件名】保存到指定文件中 【:q】 保存退出 针对未修改的文件 注意：未保存文件会提示 无法退出 【:q!】 强制退出 退出 不保存 【:! 命令】暂时离开vi 执行其他命令 编辑器操作： 【[n]x】删除光标位置后面n个字符 【[n]X】删除光标位置前面n个字符 【D】删除光标所在位置后面到行尾的所有字符 【[n]dd】删除光标所在行及下面n行 剪切 【p】在光标下一行粘贴 【[n]yy】复制光标所在行及下面n行 【dG】删除光标所在行到文件结尾 【J】合并光标所在行和下一行 中间用空格连接 【.】执行上一次命令行操作 【u】撤销 编辑器定位： 【ctrl+b】回滚 行号减小 【ctrl+f】前滚 行号增加 【gg】定位在文件第一行行首 【G】定位在文件最后一行行首 【:$】定位在文件最后一行行首 【[n]G | [n]gg】定位在m行 注意：在查找一些特殊含义的字符时，需要加上转义字符 【/内容】查找 【n】查找下一个 【N】查找上一个 【?】查找上一次的所搜内容 【/^word】 查找以word开头的内容 【/word$】 查找以word结尾的内容 【/.】查找任意一个字符 【/*】查找任意多个字符 编辑器替换： 【r】替换光标所在位置的字符 【:r 文件名】在光标当前行的下一行插入一个文件 每次添加只能添加一个文件 【:s/a/b/g】将光标所在行的a替换为b 【:g/a/s//b/g】将文件中所有a替换为b 【:n1,n2s/a/b/g】将行区间n1到n2的行中所有的a替换为b 编辑器设置： 【:set ic】搜索时不区分大小写 【:set noic】搜索时区分大小写 :set nu //显示行号 :set nonu //不显示行号 SSH 使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。 Xshell：是一个Windows平台下的SSH、TELNET和RLOGIN终端软件。它使得用户能轻松和安全地在Windows平台上访问Unix/Linux 主机。 Xftp：是一个应用于 Windows 平台的 FTP 和 SFTP 文件传输程序。Xftp能安全地在Unix/Linux 和 Windows 平台之间传输文件。 补充一些重定向命令 终端内容保存到文件使用重定向有两种方式: &gt; 和 &gt;&gt;。&gt; 表示每次只写入最新的数据，原有数据不保留。&gt;&gt; 表示每次在原有数据的基础上进行追加，原有数据会保留。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"python基础","slug":"41.python基础","date":"2020-09-05T14:17:33.777Z","updated":"2021-03-26T14:41:45.309Z","comments":false,"path":"2020/09/05/41.python基础/","link":"","permalink":"http://yoursite.com/2020/09/05/41.python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"变量 数据都是临时存储在内存中，为了更快速的查找或使用这个数据，通常我们把这个数据在内存中存储之后定义一个名称，这个名称就是变量。 变量就是一个存储数据的时候当前数据所在的内存地址的名字而已。 定义变量： 变量名 = 值 my_name = &apos;TOM&apos; print(my_name)#TOM 数据类型 数据类型 整型：int 浮点型：float 字符串：str 布尔型：bool 列表：list 元组：tuple 集合：set 字典：dict 检测数据类型的方法：type() a = 1 print(type(a)) # &lt;class &apos;int&apos;&gt; -- 整型 b = 1.1 print(type(b)) # &lt;class &apos;float&apos;&gt; -- 浮点型 c = True print(type(c)) # &lt;class &apos;bool&apos;&gt; -- 布尔型 d = &apos;12345&apos; print(type(d)) # &lt;class &apos;str&apos;&gt; -- 字符串 e = [10, 20, 30] print(type(e)) # &lt;class &apos;list&apos;&gt; -- 列表 f = (10, 20, 30) print(type(f)) # &lt;class &apos;tuple&apos;&gt; -- 元组 h = &#123;10, 20, 30&#125; print(type(h)) # &lt;class &apos;set&apos;&gt; -- 集合 g = &#123;&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 20&#125; print(type(g)) # &lt;class &apos;dict&apos;&gt; -- 字典 输出 格式符号 转换 %s 字符串 %d 有符号的十进制整数 %f 浮点数 %c 字符 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写ox） %X 十六进制整数（大写OX） %e 科学计数法（小写’e’） %E 科学计数法（大写’E’） %g %f和%e的简写 %G %f和%E的简写 技巧 %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出 %.2f，表示小数点后显示的小数位数。 格式化字符串除了%s，还可以写为f&#39;&#123;表达式&#125;&#39; age = 18 name = &apos;TOM&apos; weight = 75.5 student_id = 1 # 我的名字是TOM print(&apos;我的名字是%s&apos; % name) # 我的学号是0001 print(&apos;我的学号是%4d&apos; % student_id) # 我的体重是75.50公斤 print(&apos;我的体重是%.2f公斤&apos; % weight) # 我的名字是TOM，明年19岁了 print(&apos;我的名字是%s，明年%d岁了&apos; % (name, age + 1)) # 我的名字是TOM，明年19岁了 print(f&apos;我的名字是&#123;name&#125;, 明年&#123;age + 1&#125;岁了&apos;) 输入 input(&quot;提示信息&quot;) 在Python中，input会把接收到的任意用户输入的数据都当做字符串处理。 password = input(&apos;请输入您的密码：&apos;) print(f&apos;您输入的密码是&#123;password&#125;&apos;) # &lt;class &apos;str&apos;&gt; print(type(password)) 转换数据类型 函数 说明 int(x [,base ]) 将x转换为一个整数 float(x) 将x转换为一个浮点数 complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个Unicode字符 ord(x ) 将一个字符转换为它的ASCII整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 bin(x ) 将一个整数转换为一个二进制字符串 # 1. float() -- 转换成浮点型 num1 = 1 print(float(num1)) print(type(float(num1))) # 2. str() -- 转换成字符串类型 num2 = 10 print(type(str(num2))) # 3. tuple() -- 将一个序列转换成元组 list1 = [10, 20, 30] print(tuple(list1)) print(type(tuple(list1))) # 4. list() -- 将一个序列转换成列表 t1 = (100, 200, 300) print(list(t1)) print(type(list(t1))) # 5. eval() -- 将字符串中的数据转换成Python表达式原本类型 str1 = &apos;10&apos; str2 = &apos;[1, 2, 3]&apos; str3 = &apos;(1000, 2000, 3000)&apos; print(type(eval(str1))) print(type(eval(str2))) print(type(eval(str3))) 运算符 运算符 描述 实例 + 加 1 + 1 输出结果为 2 - 减 1-1 输出结果为 0 * 乘 2 * 2 输出结果为 4 / 除 10 / 2 输出结果为 5 // 整除 9 // 4 输出结果为2 % 取余 9 % 4 输出结果为 1 ** 指数 2 * 4 输出结果为 16，即 2 2 2 2 () 小括号 小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9 多个变量赋值 num1, float1, str1 = 10, 0.5, &apos;hello world&apos; print(num1) print(float1) print(str1) 多变量赋相同值 a = b = 10 print(a) print(b) 运算符 逻辑表达式 描述 实例 and x and y 布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 True and False， 返回 False。 or x or y 布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。 False or True， 返回 True。 not not x 布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not True 返回 False, not False 返回 True 数字之间的逻辑运算 a = 0 b = 1 c = 2 # and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字 print(a and b) # 0 print(b and a) # 0 print(b and c) # 2 print(c and b) # 1 # or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字 print(a or b) # 1 print(a or c) # 2 print(b or c) # 1 if语句基本使用 语法： if 条件1: 代码... ...... elif 条件2： 代码 ...... ...... else: 以上条件都不成立执行执行的代码 实例： age = int(input(&apos;请输入您的年龄：&apos;)) if age &lt; 18: print(f&apos;您的年龄是&#123;age&#125;,童工一枚&apos;) elif (age &gt;= 18) and (age &lt;= 60): print(f&apos;您的年龄是&#123;age&#125;,合法工龄&apos;) elif age &gt; 60: print(f&apos;您的年龄是&#123;age&#125;,可以退休&apos;) 猜拳游戏 # 导入random模块 import random # 计算电脑出拳的随机数字 computer = random.randint(0, 2) print(computer) player = int(input(&apos;请出拳：0-石头，1-剪刀，2-布：&apos;)) # 玩家胜利 p0:c1 或 p1:c2 或 p2:c0 if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0): print(&apos;玩家获胜&apos;) # 平局：玩家 == 电脑 elif player == computer: print(&apos;平局&apos;) else: print(&apos;电脑获胜&apos;) 三元运算符 语法： 值1 if 条件 else 值2 a = 1 b = 2 c = a if a &gt; b else b print(c) 循环while while的语法 while 条件: 代码 ...... 计算1-100累加和： i = 1 result = 0 while i &lt;= 100: result += i i += 1 print(result)#5050 for循环 语法 for 临时变量 in 序列: 代码 ...... 使用 str1 = &apos;HelloWorld&apos; for i in str1: print(i) while…else 语法 while 条件: 代码 else: 循环正常结束之后要执行的代码 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。 for…else 语法 for 临时变量 in 序列: 代码 ... else: 循环正常结束之后要执行的代码 break终止循环不会执行else下方缩进的代码。continue退出循环的方式，执行else下方缩进的代码。 字符串三引号字符串 name3 = &apos;&apos;&apos; Tom &apos;&apos;&apos; name4 = &quot;&quot;&quot; Rose &quot;&quot;&quot; a = &apos;&apos;&apos; i am Tom, nice to meet you! &apos;&apos;&apos; b = &quot;&quot;&quot; i am Rose, nice to meet you! &quot;&quot;&quot; 注意：三引号形式的字符串支持换行。 切片 注意：字符串下标从0开始。 切片语法 序列[开始位置下标:结束位置下标:步长] 注意:不包含结束位置下标对应的数据， 正负整数均可；步长是选取间隔，正负整数均可，默认步长为1。 name = &quot;abcdefg&quot; print(name[2:5:1]) # cde print(name[2:5]) # cde print(name[:5]) # abcde print(name[1:]) # bcdefg print(name[:]) # abcdefg print(name[::2]) # aceg print(name[:-1]) # abcdef, 负1表示倒数第一个数据 print(name[-4:-1]) # def print(name[::-1]) # gfedcba find 检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则返回-1。 #开始和结束位置下标可以省略，表示在整个字符串序列中查找 字符串序列.find(子串, 开始位置下标, 结束位置下标) mystr = &quot;hello world and Python&quot; print(mystr.find(&apos;and&apos;)) # 12 print(mystr.find(&apos;and&apos;, 15, 30)) # -1 print(mystr.find(&apos;ands&apos;)) # -1 rfind()和find()功能相同，但查找方向为右侧开始。 index 检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则报异常。 #开始和结束位置下标可以省略，表示在整个字符串序列中查找。 字符串序列.index(子串, 开始位置下标, 结束位置下标) mystr = &quot;hello world and Python&quot; print(mystr.index(&apos;and&apos;)) # 12 print(mystr.index(&apos;ands&apos;)) # 报错 rindex()index()功能相同，但查找方向为右侧开始。 count 返回某个子串在字符串中出现的次数。 #开始和结束位置下标可以省略，表示在整个字符串序列中查找。 字符串序列.count(子串, 开始位置下标, 结束位置下标) mystr = &quot;hello world and Python&quot; print(mystr.count(&apos;and&apos;)) # 1 print(mystr.count(&apos;ands&apos;)) # 0 replace 替换 #替换次数如果查出子串出现次数，则替换次数为该子串出现次数。 字符串序列.replace(旧子串, 新子串, 替换次数) mystr = &quot;hello world and Python and&quot; # 结果：hello world he Python he print(mystr.replace(&apos;and&apos;, &apos;he&apos;)) # 结果：hello world he Python he print(mystr.replace(&apos;and&apos;, &apos;he&apos;, 10)) # 结果：hello world and Python and print(mystr) 注意：数据按照是否能直接修改分为可变类型和不可变类型两种。字符串类型的数据修改的时候不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型。 split 按照指定字符分割字符串。 字符串序列.split(分割字符, num) 注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。 mystr = &quot;hello world and Python and it&quot; # [&apos;hello world &apos;, &apos; Python &apos;, &apos; it&apos;] print(mystr.split(&apos;and&apos;)) # [&apos;hello world &apos;, &apos; Python &apos;, &apos; it&apos;] print(mystr.split(&apos;and&apos;, 2)) # [&apos;hello&apos;, &apos;world&apos;, &apos;and&apos;, &apos;Python&apos;, &apos;and&apos;, &apos;it&apos;] print(mystr.split(&apos; &apos;)) # [&apos;hello&apos;, &apos;world&apos;, &apos;and Python and it&apos;] print(mystr.split(&apos; &apos;, 2)) 注意：如果分割字符是原有字符串中的子串，分割后则丢失该子串。 join 用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。 字符或子串.join(多字符串组成的序列) list1 = [&apos;mm&apos;, &apos;nn&apos;, &apos;bb&apos;, &apos;vv&apos;] t1 = (&apos;aa&apos;, &apos;b&apos;, &apos;cc&apos;, &apos;ddd&apos;) # 结果：mm_nn_bb_vv print(&apos;_&apos;.join(list1)) # 结果：aa...b...cc...ddd print(&apos;...&apos;.join(t1)) capitalize 将字符串第一个字符转换成大写。 mystr = &quot;hello world and Python and it&quot; # 结果：Hello world and python and it print(mystr.capitalize()) 注意：capitalize()函数转换后，只字符串第一个字符大写，其他的字符全都小写。 title 将字符串每个单词首字母转换成大写。 mystr = &quot;hello world and Python and it&quot; # 结果：Hello World And Python And It print(mystr.title()) lower和upper lower()：将字符串中大写转小写。 mystr = &quot;hello world and Python and it&quot; # 结果：hello world and python and it print(mystr.lower()) upper()：将字符串中小写转大写。 mystr = &quot;hello world and Python and it&quot; # 结果：HELLO WORLD AND PYTHON AND IT print(mystr.upper()) lstrip和rstrip和strip lstrip()：删除字符串左侧空白字符。 rstrip()：删除字符串右侧空白字符。 strip()：删除字符串两侧空白字符。 ljust和rjust和center ljust()：返回一个原字符串左对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串。 rjust()：返回一个原字符串右对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。 center()：返回一个原字符串居中对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。 mystr = &quot;hello world and Python and it&quot; # 结果：hello world and Python and it....... print(mystr.ljust(36,&apos;.&apos;)) # 结果：.......hello world and Python and it print(mystr.rjust(36,&apos;.&apos;)) # 结果：...hello world and Python and it.... print(mystr.center(36,&apos;.&apos;)) startswith和endswith startswith()：检查字符串是否是以指定子串开头，是则返回True，否则返回False。如果设置开始和结束位置下标，则在指定范围内检查。 字符串序列.startswith(子串, 开始位置下标, 结束位置下标) mystr = &quot;hello world and Python and it&quot; # 结果：True print(mystr.startswith(&apos;hello&apos;)) # 结果False print(mystr.startswith(&apos;hello&apos;, 5, 20)) endswith()：检查字符串是否是以指定子串结尾，是则返回True，否则返回False。如果设置开始和结束位置下标，则在指定范围内检查。 字符串序列.endswith(子串, 开始位置下标, 结束位置下标) mystr = &quot;hello world and Python and it&quot; # 结果：True print(mystr.endswith(&apos;it&apos;)) # 结果：False print(mystr.endswith(&apos;Python&apos;, 2, 20)) isalpha 如果字符串至少有一个字符并且所有字符都是字母则返回True, 否则返回 False。 mystr1 = &apos;hello&apos; mystr2 = &apos;hello12345&apos; # 结果：True print(mystr1.isalpha()) # 结果：False print(mystr2.isalpha()) isdigit 如果字符串只包含数字则返回True否则返回 False。 mystr1 = &apos;aaa12345&apos; mystr2 = &apos;12345&apos; # 结果： False print(mystr1.isdigit()) # 结果：False print(mystr2.isdigit()) isalnum 如果字符串至少有一个字符并且所有字符都是字母或数字则返回True,否则返回False。 mystr1 = &apos;aaa12345&apos; mystr2 = &apos;12345-&apos; # 结果：True print(mystr1.isalnum()) # 结果：False print(mystr2.isalnum()) isspace 如果字符串中只包含空白，则返回True，否则返回False。 mystr1 = &apos;1 2 3 4 5&apos; mystr2 = &apos; &apos; # 结果：False print(mystr1.isspace()) # 结果：True print(mystr2.isspace()) 列表 列表可以一次性存储多个数据，且可以为不同数据类型。可以对这些数据进行的操作有：增、删、改、查。 下标 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(name_list[0]) # Tom print(name_list[1]) # Lily print(name_list[2]) # Rose index 返回指定数据所在位置的下标 。 列表序列.index(数据, 开始位置下标, 结束位置下标) name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(name_list.index(&apos;Lily&apos;, 0, 2)) # 1 注意：如果查找的数据不存在则报错。 count 统计指定数据在当前列表中出现的次数。 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(name_list.count(&apos;Lily&apos;)) # 1 len 访问列表长度，即列表中数据的个数。 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(len(name_list)) # 3 in和not in in：判断指定数据在某个列表序列，如果在返回True，否则返回False name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] # 结果：True print(&apos;Lily&apos; in name_list) # 结果：False print(&apos;Lilys&apos; in name_list) not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] # 结果：False print(&apos;Lily&apos; not in name_list) # 结果：True print(&apos;Lilys&apos; not in name_list) append 列表结尾追加数据。 列表序列.append(数据) name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.append(&apos;xiaoming&apos;) # 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, &apos;xiaoming&apos;] print(name_list) 列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。 如果append()追加的数据是一个序列，则追加整个序列到列表 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.append([&apos;xiaoming&apos;, &apos;xiaohong&apos;]) # 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, [&apos;xiaoming&apos;, &apos;xiaohong&apos;]] print(name_list) extend 列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表。 列表序列.extend(数据) #单个数据 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.extend(&apos;xiaoming&apos;) # 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, &apos;x&apos;, &apos;i&apos;, &apos;a&apos;, &apos;o&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;] print(name_list) ​#序列数据 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.extend([&apos;xiaoming&apos;, &apos;xiaohong&apos;]) # 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;, &apos;xiaoming&apos;, &apos;xiaohong&apos;] print(name_list) insert 指定位置新增数据。 列表序列.insert(位置下标, 数据) name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.insert(1, &apos;xiaoming&apos;) # 结果：[&apos;Tom&apos;, &apos;xiaoming&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(name_list) del #del 目标 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] # 结果：报错提示：name &apos;name_list&apos; is not defined del name_list print(name_list) ​#删除指定数据 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] del name_list[0] # 结果：[&apos;Lily&apos;, &apos;Rose&apos;] print(name_list) pop 删除指定下标的数据(默认为最后一个)，并返回该数据。 #列表序列.pop(下标) name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] del_name = name_list.pop(1) # 结果：Lily print(del_name) # 结果：[&apos;Tom&apos;, &apos;Rose&apos;] print(name_list) remove 移除列表中某个数据的第一个匹配项。 #列表序列.remove(数据) name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.remove(&apos;Rose&apos;) # 结果：[&apos;Tom&apos;, &apos;Lily&apos;] print(name_list) clear 清空列表 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list.clear() print(name_list) # 结果： [] 修改指定下标数据 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_list[0] = &apos;aaa&apos; # 结果：[&apos;aaa&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(name_list) 逆置reverse num_list = [1, 5, 2, 3, 6, 8] num_list.reverse() # 结果：[8, 6, 3, 2, 5, 1] print(num_list) 排序sort 列表序列.sort( key=None, reverse=False) 注意：reverse表示排序规则，reverse = True 降序， reverse = False 升序（默认） num_list = [1, 5, 2, 3, 6, 8] num_list.sort() # 结果：[1, 2, 3, 5, 6, 8] print(num_list) 复制copy name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] name_li2 = name_list.copy() # 结果：[&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] print(name_li2) while遍历列表 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] i = 0 while i &lt; len(name_list): print(name_list[i]) i += 1 for遍历列表 name_list = [&apos;Tom&apos;, &apos;Lily&apos;, &apos;Rose&apos;] for i in name_list: print(i) 元组 一个元组可以存储多个数据，元组内的数据是不能修改的。元组特点：定义元组使用小括号，且逗号隔开各个数据，数据可以是不同的数据类型。 #多个数据元组 t1 = (10, 20, 30) #单个数据元组 t2 = (10,) print(type(t2)) # tuple t3 = (20) print(type(t3)) # int 注意：如果定义的元组只有一个数据，那么这个数据后面也要添加逗号，否则数据类型为唯一的这个数据的数据类型。 按下标查找数据 tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;) print(tuple1[0]) # aa index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index方法相同。 tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;) print(tuple1.index(&apos;aa&apos;)) # 0 count()：统计某个数据在当前元组出现的次数。 tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;) print(tuple1.count(&apos;bb&apos;)) # 2 len()：统计元组中数据的个数。 tuple1 = (&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;bb&apos;) print(len(tuple1)) # 4 注意：元组内的直接数据如果修改则立即报错 但是如果元组里面有列表，修改列表里面的数据则是支持的，故自觉很重要。 tuple2 = (10, 20, [&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;], 50, 30) print(tuple2[2]) # 访问到列表 # 结果：(10, 20, [&apos;aaaaa&apos;, &apos;bb&apos;, &apos;cc&apos;], 50, 30) tuple2[2][0] = &apos;aaaaa&apos; print(tuple2) 字典 字典里面的数据是以键值对形式出现，字典数据和数据顺序没有关系，即字典不支持下标，后期无论数据如何变化，只需要按照对应的键的名字查找数据即可。 字典特点：符号为大括号；数据为键值对形式出现；各个键值对之间用逗号隔开。 # 有数据字典 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; # 空字典 dict2 = &#123;&#125; 一般称冒号前面的为键(key)，简称k；冒号后面的为值(value)，简称v。 增和改 写法：字典序列[key] = 值 注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; dict1[&apos;name&apos;] = &apos;Rose&apos; # 结果：&#123;&apos;name&apos;: &apos;Rose&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; print(dict1) dict1[&apos;id&apos;] = 110 # &#123;&apos;name&apos;: &apos;Rose&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;, &apos;id&apos;: 110&#125; print(dict1) 注意：字典为可变类型。 删 del()/del：删除字典或删除字典中指定键值对。 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; del dict1[&apos;gender&apos;] # 结果：&#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20&#125; print(dict1) clear()：清空字典 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; dict1.clear() print(dict1) # &#123;&#125; key值查找 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; print(dict1[&apos;name&apos;]) # Tom print(dict1[&apos;id&apos;]) # 报错 如果当前查找的key存在，则返回对应的值；否则则报错。 get 字典序列.get(key, 默认值) 注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; print(dict1.get(&apos;name&apos;)) # Tom print(dict1.get(&apos;id&apos;, 110)) # 110 print(dict1.get(&apos;id&apos;)) # None keys dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; print(dict1.keys()) # dict_keys([&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;]) values dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; print(dict1.values()) # dict_values([&apos;Tom&apos;, 20, &apos;男&apos;]) items dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; print(dict1.items()) # dict_items([(&apos;name&apos;, &apos;Tom&apos;), (&apos;age&apos;, 20), (&apos;gender&apos;, &apos;男&apos;)]) 遍历字典的key dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; for key in dict1.keys(): print(key) 遍历字典的value dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; for value in dict1.values(): print(value) 遍历字典的元素 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; for item in dict1.items(): print(item) 遍历字典的键值对 dict1 = &#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;男&apos;&#125; for key, value in dict1.items(): print(f&apos;&#123;key&#125; = &#123;value&#125;&apos;) 集合 创建集合使用&#123;&#125;或set()，但是如果要创建空集合只能使用set()，因为&#123;&#125;用来创建空字典。 s1 = &#123;10, 20, 30, 40, 50&#125; print(s1)#&#123;40, 10, 50, 20, 30&#125; s2 = &#123;10, 30, 20, 10, 30, 40, 30, 50&#125; print(s2)#&#123;40, 10, 50, 20, 30&#125; s3 = set(&apos;abcdefg&apos;) print(s3) s4 = set() print(type(s4)) # set s5 = &#123;&#125; print(type(s5)) # dict 特点：集合可以去掉重复数据；集合数据是无序的，故不支持下标。 增加数据 add() s1 = &#123;10, 20&#125; s1.add(100) s1.add(10) print(s1) # &#123;100, 10, 20&#125; 因为集合有去重功能，所以，当向集合内追加的数据是当前集合已有数据的话，则不进行任何操作。 update(), 追加的数据是序列。 s1 = &#123;10, 20&#125; # s1.update(100) # 报错 s1.update([100, 200]) s1.update(&apos;abc&apos;) print(s1) 删除数据 remove()，删除集合中的指定数据，如果数据不存在则报错。 s1 = &#123;10, 20&#125; s1.remove(10) print(s1) s1.remove(10) # 报错 print(s1) discard()，删除集合中的指定数据，如果数据不存在也不会报错。 s1 = &#123;10, 20&#125; s1.discard(10) print(s1) s1.discard(10) print(s1) pop()，随机删除集合中的某个数据，并返回这个数据。 s1 = &#123;10, 20, 30, 40, 50&#125; del_num = s1.pop() print(del_num) print(s1) 查找数据 in：判断数据在集合序列。not in：判断数据不在集合序列 s1 = &#123;10, 20, 30, 40, 50&#125; print(10 in s1) print(10 not in s1) 公共操作运算符 运算符 描述 支持的容器类型 + 合并 字符串、列表、元组 * 复制 字符串、列表、元组 in 元素是否存在 字符串、列表、元组、字典 not in 元素是否不存在 字符串、列表、元组、字典 +: # 1. 字符串 str1 = &apos;aa&apos; str2 = &apos;bb&apos; str3 = str1 + str2 print(str3) # aabb # 2. 列表 list1 = [1, 2] list2 = [10, 20] list3 = list1 + list2 print(list3) # [1, 2, 10, 20] # 3. 元组 t1 = (1, 2) t2 = (10, 20) t3 = t1 + t2 print(t3) #(1, 2, 10, 20) *: # 1. 字符串 print(&apos;-&apos; * 10) # ---------- # 2. 列表 list1 = [&apos;hello&apos;] print(list1 * 4) # [&apos;hello&apos;, &apos;hello&apos;, &apos;hello&apos;, &apos;hello&apos;] # 3. 元组 t1 = (&apos;world&apos;,) print(t1 * 4) # (&apos;world&apos;, &apos;world&apos;, &apos;world&apos;, &apos;world&apos;) in或not in: # 1. 字符串 print(&apos;a&apos; in &apos;abcd&apos;) # True print(&apos;a&apos; not in &apos;abcd&apos;) # False # 2. 列表 list1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] print(&apos;a&apos; in list1) # True print(&apos;a&apos; not in list1) # False # 3. 元组 t1 = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;) print(&apos;aa&apos; in t1) # False print(&apos;aa&apos; not in t1) # True 公共方法 函数 描述 len() 计算容器中元素个数 del 或 del() 删除 max() 返回容器中元素最大值 min() 返回容器中元素最小值 range(start, end, step) 生成从start到end的数字，步长为 step，供for循环使用 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 len() # 1. 字符串 str1 = &apos;abcdefg&apos; print(len(str1)) # 7 # 2. 列表 list1 = [10, 20, 30, 40] print(len(list1)) # 4 # 3. 元组 t1 = (10, 20, 30, 40, 50) print(len(t1)) # 5 # 4. 集合 s1 = &#123;10, 20, 30&#125; print(len(s1)) # 3 # 5. 字典 dict1 = &#123;&apos;name&apos;: &apos;Rose&apos;, &apos;age&apos;: 18&#125; print(len(dict1)) # 2 del() # 1. 字符串 str1 = &apos;abcdefg&apos; del str1 print(str1)#error # 2. 列表 list1 = [10, 20, 30, 40] del(list1[0]) print(list1) # [20, 30, 40] max() # 1. 字符串 str1 = &apos;abcdefg&apos; print(max(str1)) # g # 2. 列表 list1 = [10, 20, 30, 40] print(max(list1)) # 40 min() # 1. 字符串 str1 = &apos;abcdefg&apos; print(min(str1)) # a # 2. 列表 list1 = [10, 20, 30, 40] print(min(list1)) # 10 range() # 1 2 3 4 5 6 7 8 9 for i in range(1, 10, 1): print(i) # 1 3 5 7 9 for i in range(1, 10, 2): print(i) # 0 1 2 3 4 5 6 7 8 9 for i in range(10): print(i) 注意：range()生成的序列不包含end数字。 enumerate() enumerate(可遍历对象, start=0) 注意：start参数用来设置遍历数据的下标的起始值，默认为0。 list1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] for i in enumerate(list1): print(i)#(0, &apos;a&apos;)(1, &apos;b&apos;)(2, &apos;c&apos;)(4, &apos;e&apos;) for index, char in enumerate(list1, start=1): print(f&apos;下标是&#123;index&#125;, 对应的字符是&#123;char&#125;&apos;)#下标是1, 对应的字符是a... 容器类型转换 tuple()：将某个序列转换成元组 list1 = [10, 20, 30, 40, 50, 20] s1 = &#123;100, 200, 300, 400, 500&#125; print(tuple(list1))#(10, 20, 30, 40, 50, 20) print(tuple(s1))#(100, 200, 300, 400, 500) list()：将某个序列转换成列表 t1 = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;) s1 = &#123;100, 200, 300, 400, 500&#125; print(list(t1))#[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] print(list(s1))#[100, 200, 300, 400, 500] set()：将某个序列转换成集合 list1 = [10, 20, 30, 40, 50, 20] t1 = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;) print(set(list1))#&#123;40, 10, 50, 20, 30&#125; print(set(t1))#&#123;&apos;c&apos;, &apos;d&apos;, &apos;a&apos;, &apos;b&apos;, &apos;e&apos;&#125; 注意：集合可以快速完成列表去重；集合不支持下标 推导式列表推导式 用一个表达式创建一个有规律的列表或控制一个有规律列表。列表推导式又叫列表生成式。 创建一个0-10的列表。 #while循环实现 # 1. 准备一个空列表 list1 = [] # 2. 书写循环，依次追加数字到空列表list1中 i = 0 while i &lt; 10: list1.append(i) i += 1 print(list1) #for循环实现 list1 = [] for i in range(10): list1.append(i) print(list1) #列表推导式实现 list1 = [i for i in range(10)] print(list1) 带if的列表推导式 创建0-10的偶数列表: #range()步长实现 list1 = [i for i in range(0, 10, 2)] print(list1) #if实现 list1 = [i for i in range(10) if i % 2 == 0] print(list1) 多个for循环实现列表推导式 创建列表如下： [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] 代码如下： list1 = [(i, j) for i in range(1, 3) for j in range(3)] print(list1) 字典推导式 如下两个列表，如何快速合并为一个字典？ list1 = [&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;] list2 = [&apos;Tom&apos;, 20, &apos;man&apos;] 字典推导式作用：快速合并列表为字典或提取字典中目标数据。 创建一个字典：字典key是1-5数字，value是这个数字的2次方： dict1 = &#123;i: i**2 for i in range(1, 5)&#125; print(dict1) # &#123;1: 1, 2: 4, 3: 9, 4: 16&#125; 将两个列表合并为一个字典： list1 = [&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;] list2 = [&apos;Tom&apos;, 20, &apos;man&apos;] dict1 = &#123;list1[i]: list2[i] for i in range(len(list1))&#125; print(dict1) 提取字典中目标数据 counts = &#123;&apos;MBP&apos;: 268, &apos;HP&apos;: 125, &apos;DELL&apos;: 201, &apos;Lenovo&apos;: 199, &apos;acer&apos;: 99&#125; # 需求：提取上述电脑数量大于等于200的字典数据 count1 = &#123;key: value for key, value in counts.items() if value &gt;= 200&#125; print(count1) # &#123;&apos;MBP&apos;: 268, &apos;DELL&apos;: 201&#125; 集合推导式 创建一个集合，数据为下方列表的2次方。 list1 = [1, 1, 2] 代码如下： list1 = [1, 1, 2] set1 = &#123;i ** 2 for i in list1&#125; print(set1) # &#123;1, 4&#125; 注意：集合有数据去重功能。 函数基础 函数就是将一段具有独立功能的代码块整合到一个整体并命名，在需要的位置调用这个名称即可完成对应的需求。函数在开发过程中，可以更高效的实现代码重用。 定义函数： def 函数名(参数): 代码1 代码2 ...... 调用函数 函数名(参数) 注意：不同的需求，参数可有可无。在Python中，函数必须先定义后使用。一定是先定义函数，后调用函数。 代码 def sum_num(a, b): return a + b # 用result变量保存函数返回值 result = sum_num(1, 2) print(result) 函数的说明文档help(函数名) def sum_num(a, b): &quot;&quot;&quot; 求和函数 &quot;&quot;&quot; return a + b help(sum_num) 函数提高变量作用域 变量作用域指的是变量生效的范围，主要分为两类：局部变量和全局变量。 局部变量：定义在函数体内部的变量，即只在函数体内部生效。局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。 全局变量：指的是在函数体内、外都能生效的变量。 a = 100 def testA(): print(a) def testB(): a = 200 print(a) testA() # 100 testB() # 200 print(f&apos;全局变量a = &#123;a&#125;&apos;) # 全局变量a = 100 在testB函数内部的a = 200中的变量a是在修改全局变量a吗？不是。testB函数内部的a = 200是定义了一个局部变量。 如何在函数体内部修改全局变量？ a = 100 def testA(): print(a) def testB(): # global 关键字声明a是全局变量 global a a = 200 print(a) testA() # 100 testB() # 200 print(f&apos;全局变量a = &#123;a&#125;&apos;) # 全局变量a = 200 函数的返回值 如果一个函数要有多个返回值，该如何书写代码？ def return_num(): return 1, 2 result = return_num() print(result) # (1, 2) 注意：return a, b写法，返回多个数据的时候，默认是元组类型。return后面可以连接列表、元组或字典，以返回多个值。 参数 位置参数：调用函数时根据函数定义的参数位置来传递参数。 def user_info(name, age, gender): print(f&apos;您的名字是&#123;name&#125;, 年龄是&#123;age&#125;, 性别是&#123;gender&#125;&apos;) user_info(&apos;TOM&apos;, 20, &apos;男&apos;) 注意：传递和定义参数的顺序及个数必须一致。 关键字参数：函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。 def user_info(name, age, gender): print(f&apos;您的名字是&#123;name&#125;, 年龄是&#123;age&#125;, 性别是&#123;gender&#125;&apos;) user_info(&apos;Rose&apos;, age=20, gender=&apos;女&apos;) user_info(&apos;小明&apos;, gender=&apos;男&apos;, age=16) 注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。 缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。 def user_info(name, age, gender=&apos;男&apos;): print(f&apos;您的名字是&#123;name&#125;, 年龄是&#123;age&#125;, 性别是&#123;gender&#125;&apos;) user_info(&apos;TOM&apos;, 20) user_info(&apos;Rose&apos;, 18, &apos;女&apos;) 不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 def user_info(*args): print(args) # (&apos;TOM&apos;,) user_info(&apos;TOM&apos;) # (&apos;TOM&apos;, 18) user_info(&apos;TOM&apos;, 18) 注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。 包裹关键字传递 def user_info(**kwargs): print(kwargs) # &#123;&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 18, &apos;id&apos;: 110&#125; user_info(name=&apos;TOM&apos;, age=18, id=110) 综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。 拆包和交换变量值 拆包：元组 def return_num(): return 100, 200 num1, num2 = return_num() print(num1) # 100 print(num2) # 200 拆包：字典 dict1 = &#123;&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 18&#125; a, b = dict1 # 对字典进行拆包，取出来的是字典的key print(a) # name print(b) # age print(dict1[a]) # TOM print(dict1[b]) # 18 交换变量值 交换两个变量的值。借助第三变量存储数据。 # 1. 定义中间变量 c = 0 # 2. 将a的数据存储到c c = a # 3. 将b的数据20赋值到a，此时a = 20 a = b #4. 将之前c的数据10赋值到b，此时b = 10 b = c print(a) # 20 print(b) # 10 交换两个变量的值。方法二 a, b = 1, 2 a, b = b, a print(a) # 2 print(b) # 1 引用 在python中，值是靠引用来传递来的。我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标识。 # 1. int类型 a = 1 b = a print(b) # 1 print(id(a)) # 140708464157520 print(id(b)) # 140708464157520 a = 2 print(b) # 1,说明int类型为不可变类型 print(id(a)) # 140708464157552，此时得到是的数据2的内存地址 print(id(b)) # 140708464157520 # 2. 列表 aa = [10, 20] bb = aa print(id(aa)) # 2325297783432 print(id(bb)) # 2325297783432 aa.append(30) print(bb) # [10, 20, 30], 列表为可变类型 print(id(aa)) # 2325297783432 print(id(bb)) # 2325297783432 引用当做实参，代码如下： def test1(a): print(a) print(id(a)) a += a print(a) print(id(a)) # int：计算前后id值不同 b = 100 test1(b) # 列表：计算前后id值相同 c = [11, 22] test1(c) 可变和不可变类型 所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变。 可变类型：列表、字典、集合。 不可变类型：整型、浮点型、字符串、元组。 递归 3以内数字累加和 # 3 + 2 + 1 def sum_numbers(num): # 1.如果是1，直接返回1 -- 出口 if num == 1: return 1 # 2.如果不是1，重复执行累加并返回结果 return num + sum_numbers(num-1) sum_result = sum_numbers(3) # 输出结果为6 print(sum_result) lambda表达式 如果一个函数有一个返回值，并且只有一句代码，可以使用lambda简化。 lambda语法 lambda 参数列表 ： 表达式 注意：lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用。lambda表达式能接收任何数量的参数但只能返回一个表达式的值。 # 函数 def fn1(): return 200 print(fn1) print(fn1()) # lambda表达式,无参数 fn2 = lambda: 100 print(fn2) print(fn2()) 注意：直接打印lambda表达式，输出的是此lambda的内存地址 计算a + b def add(a, b): return a + b result = add(1, 2) print(result) #lambda实现,有参数 fn1 = lambda a, b: a + b print(fn1(1, 2)) lambda的参数形式，默认参数 fn1 = lambda a, b, c=100: a + b + c print(fn1(10, 20)) 可变参数：*args fn1 = lambda *args: args print(fn1(10, 20, 30)) 注意：这里的可变参数传入到lambda之后，返回值为元组。 可变参数：**kwargs fn1 = lambda **kwargs: kwargs print(fn1(name=&apos;python&apos;, age=20)) lambda的应用，带判断的lambda fn1 = lambda a, b: a if a &gt; b else b print(fn1(1000, 500)) lambda的应用，列表数据按字典key的值排序 students = [ &#123;&apos;name&apos;: &apos;TOM&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;ROSE&apos;, &apos;age&apos;: 19&#125;, &#123;&apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 22&#125; ] # 按name值升序排列 students.sort(key=lambda x: x[&apos;name&apos;]) print(students) # 按name值降序排列 students.sort(key=lambda x: x[&apos;name&apos;], reverse=True) print(students) # 按age值升序排列 students.sort(key=lambda x: x[&apos;age&apos;]) print(students) 高阶函数 把函数作为参数传入，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。 体验高阶函数: #数字求绝对值计算 abs(-10) # 10 #数字的四舍五入计算 round(1.2) # 1 round(1.9) # 2 #需求：任意两个数字，按照指定要求整理数字后再进行求和计算。 #方法1 def add_num(a, b): return abs(a) + abs(b) result = add_num(-1, 2) print(result) # 3 #方法2 def sum_num(a, b, f): return f(a) + f(b) result = sum_num(-1, 2, abs) print(result) # 3 注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。 内置高阶函数map():map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。 #计算`list1`序列中各个数字的2次方。 list1 = [1, 2, 3, 4, 5] def func(x): return x ** 2 result = map(func, list1) print(result) # &lt;map object at 0x0000013769653198&gt; print(list(result)) # [1, 4, 9, 16, 25] reduce():reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。 #计算`list1`序列中各个数字的累加和。 import functools list1 = [1, 2, 3, 4, 5] def func(a, b): return a + b result = functools.reduce(func, list1) print(result) # 15 filter():filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个filter对象。如果要转换为列表, 可以使用list()来转换。 list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def func(x): return x % 2 == 0 result = filter(func, list1) print(result) # &lt;filter object at 0x0000017AF9DC3198&gt; print(list(result)) # [2, 4, 6, 8, 10] 文件操作 文件操作的作用就是把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力。 关闭文件 f.close()。 打开一个已经存在的文件，或者创建一个新文件，语法如下： open(name, mode) #name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。 #mode：设置打开文件的模式(访问模式)：只读、写入、追加等。 打开文件模式 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 写: #语法 对象对象.write(&apos;内容&apos;) # 1. 打开文件 f = open(&apos;test.txt&apos;, &apos;w&apos;) # 2.文件写入 f.write(&apos;hello world&apos;) # 3. 关闭文件 f.close() 注意：w和a模式：如果文件不存在则创建该文件；如果文件存在，w模式先清空再写入，a模式直接末尾追加。r模式：如果文件不存在则报错。 读： read() 文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。 readlines()：可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。 f = open(&apos;test.txt&apos;) content = f.readlines() # [&apos;hello world\\n&apos;, &apos;abcdefg\\n&apos;, &apos;aaa\\n&apos;, &apos;bbb\\n&apos;, &apos;ccc&apos;] print(content) # 关闭文件 f.close() readline()一次读取一行内容。 f = open(&apos;test.txt&apos;) content = f.readline() print(f&apos;第一行：&#123;content&#125;&apos;) content = f.readline() print(f&apos;第二行：&#123;content&#125;&apos;) seek()：用来移动文件指针。 文件对象.seek(偏移量, 起始位置) #起始位置：0：文件开头；1：当前位置；2：文件结尾 文件备份：用户输入当前目录下任意文件名，程序完成对该文件的备份功能(备份文件名为xx[备份]后缀，例如：test[备份].txt)。 old_name = input(&apos;请输入您要备份的文件名：&apos;) # 提取文件后缀点的下标 index = old_name.rfind(&apos;.&apos;) # print(index) # 后缀中.的下标 # print(old_name[:index]) # 源文件名（无后缀） # 组织新文件名 旧文件名 + [备份] + 后缀 new_name = old_name[:index] + &apos;[备份]&apos; + old_name[index:] # 打印新文件名（带后缀） # print(new_name) # 打开文件 old_f = open(old_name, &apos;rb&apos;) new_f = open(new_name, &apos;wb&apos;) # 将源文件数据写入备份文件 while True: con = old_f.read(1024) if len(con) == 0: break new_f.write(con) # 关闭文件 old_f.close() new_f.close() 文件和文件夹的操作:在Python中文件和文件夹的操作要借助os模块里面的相关功能，具体步骤如下： #导入os模块 import os #使用os模块相关功能 os.函数名() 文件重命名 os.rename(目标文件名, 新文件名) 删除文件 os.remove(目标文件名) 创建文件夹 os.mkdir(文件夹名字) 删除文件夹 os.rmdir(文件夹名字) 获取当前目录 os.getcwd() 改变默认目录 os.chdir(目录) 获取目录列表 os.listdir(目录) 批量修改文件名，既可添加指定字符串，又能删除指定字符串。 import os # 设置重命名标识：如果为1则添加指定字符，flag取值为2则删除指定字符 flag = 1 # 获取指定目录 dir_name = &apos;./&apos; # 获取指定目录的文件列表 file_list = os.listdir(dir_name) # print(file_list) # 遍历文件列表内的文件 for name in file_list: # 添加指定字符 if flag == 1: new_name = &apos;Python-&apos; + name # 删除指定字符 elif flag == 2: num = len(&apos;Python-&apos;) new_name = name[num:] # 打印新文件名，测试程序正确性 print(new_name) # 重命名 os.rename(dir_name+name, dir_name+new_name) 面向对象基础 面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。 类和对象的关系：用类去创建一个对象。 定义类:Python2中类分为：经典类 和 新式类。 class 类名(): 代码 ...... class Washer(): def wash(self): print(&apos;我会洗衣服&apos;) 注意：类名要满足标识符命名规则，同时遵循大驼峰命名习惯。 经典类：不由任意内置类型派生出的类，称之为经典类 class 类名: 代码 ...... 创建对象：对象又名实例。 对象名 = 类名() # 创建对象 haier1 = Washer() # &lt;__main__.Washer object at 0x0000018B7B224240&gt; print(haier1) # haier对象调用实例方法 haier1.wash() 注意：创建对象的过程也叫实例化对象。 self指的是调用该函数的对象。 # 1. 定义类 class Washer(): def wash(self): print(&apos;我会洗衣服&apos;) # &lt;__main__.Washer object at 0x0000024BA2B34240&gt; print(self) # 2. 创建对象 haier1 = Washer() # &lt;__main__.Washer object at 0x0000018B7B224240&gt; print(haier1) # haier1对象调用实例方法 haier1.wash() haier2 = Washer() # &lt;__main__.Washer object at 0x0000022005857EF0&gt; print(haier2) 注意：打印对象和self得到的结果是一致的，都是当前对象的内存中存储地址。 类外面添加对象属性 对象名.属性名 = 值 haier1.width = 500 haier1.height = 800 类外面获取对象属性 对象名.属性名 print(f&apos;haier1洗衣机的宽度是&#123;haier1.width&#125;&apos;) print(f&apos;haier1洗衣机的高度是&#123;haier1.height&#125;&apos;) 类里面获取对象属性 self.属性名 # 定义类 class Washer(): def print_info(self): # 类里面获取实例属性 print(f&apos;haier1洗衣机的宽度是&#123;self.width&#125;&apos;) print(f&apos;haier1洗衣机的高度是&#123;self.height&#125;&apos;) # 创建对象 haier1 = Washer() # 添加实例属性 haier1.width = 500 haier1.height = 800 haier1.print_info() 魔法方法 在Python中，__xx__()的函数叫做魔法方法，指的是具有特殊功能的函数。 __init__()方法的作用：初始化对象。 class Washer(): # 定义初始化功能的函数 def __init__(self): # 添加实例属性 self.width = 500 self.height = 800 def print_info(self): # 类里面调用实例属性 print(f&apos;洗衣机的宽度是&#123;self.width&#125;, 高度是&#123;self.height&#125;&apos;) haier1 = Washer() haier1.print_info() 注意：__init__()方法，在创建一个对象时默认被调用，不需要手动调用。__init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。 带参数的__init__()： class Washer(): def __init__(self, width, height): self.width = width self.height = height def print_info(self): print(f&apos;洗衣机的宽度是&#123;self.width&#125;&apos;) print(f&apos;洗衣机的高度是&#123;self.height&#125;&apos;) haier1 = Washer(10, 20) haier1.print_info() haier2 = Washer(30, 40) haier2.print_info() __str__()：当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了__str__方法，那么就会打印从在这个方法中return的数据。 class Washer(): def __init__(self, width, height): self.width = width self.height = height def __str__(self): return &apos;这是海尔洗衣机的说明书&apos; haier1 = Washer(10, 20) # 这是海尔洗衣机的说明书 print(haier1) __del__()：当删除对象时，python解释器也会默认调用__del__()方法。 class Washer(): def __init__(self, width, height): self.width = width self.height = height def __del__(self): print(f&apos;&#123;self&#125;对象已经被删除&apos;) haier1 = Washer(10, 20) # &lt;__main__.Washer object at 0x0000026118223278&gt;对象已经被删除 del haier1 面向对象之继承 经典类或旧式类：不由任意内置类型派生出的类，称之为经典类。 class 类名: 代码 ...... 新式类 class 类名(object): 代码 Python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，具体如下： # 父类A class A(object): def __init__(self): self.num = 1 def info_print(self): print(self.num) # 子类B class B(A): pass result = B() result.info_print() # 1 在Python中，所有类默认继承object类，object类是顶级类或基类；其他子类叫做派生类。 单继承 # 1. 师父类 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) # 2. 徒弟类 class Prentice(Master): pass # 3. 创建对象daqiu daqiu = Prentice() # 4. 对象访问实例属性 print(daqiu.kongfu) # 5. 对象调用实例方法 daqiu.make_cake() 多继承 所谓多继承意思就是一个类同时继承了多个父类。 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) # 创建学校类 class School(object): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class Prentice(School, Master): pass daqiu = Prentice() print(daqiu.kongfu) daqiu.make_cake() 注意：当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。 子类重写父类同名方法和属性 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class School(object): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) # 独创配方 class Prentice(School, Master): def __init__(self): self.kongfu = &apos;[独创煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) daqiu = Prentice() print(daqiu.kongfu) daqiu.make_cake() print(Prentice.__mro__) 子类和父类具有同名属性和方法，默认使用子类的同名属性和方法。 子类调用父类的同名方法和属性 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class School(object): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class Prentice(School, Master): def __init__(self): self.kongfu = &apos;[独创煎饼果子配方]&apos; def make_cake(self): # 如果是先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化 self.__init__() print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) # 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化 def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) daqiu = Prentice() daqiu.make_cake() daqiu.make_master_cake() daqiu.make_school_cake() daqiu.make_cake() 多层继承 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class School(object): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class Prentice(School, Master): def __init__(self): self.kongfu = &apos;[独创煎饼果子配方]&apos; def make_cake(self): self.__init__() print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) # 徒孙类 class Tusun(Prentice): pass xiaoqiu = Tusun() xiaoqiu.make_cake() xiaoqiu.make_school_cake() xiaoqiu.make_master_cake() super()调用父类方法 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class School(Master): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) # 方法2.1 # super(School, self).__init__() # super(School, self).make_cake() # 方法2.2 super().__init__() super().make_cake() class Prentice(School): def __init__(self): self.kongfu = &apos;[独创煎饼果子技术]&apos; def make_cake(self): self.__init__() print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) # 子类调用父类的同名方法和属性：把父类的同名属性和方法再次封装 def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) # 一次性调用父类的同名属性和方法 def make_old_cake(self): # 方法一：代码冗余；父类类名如果变化，这里代码需要频繁修改 # Master.__init__(self) # Master.make_cake(self) # School.__init__(self) # School.make_cake(self) # 方法二: super() # 方法2.1 super(当前类名, self).函数() # super(Prentice, self).__init__() # super(Prentice, self).make_cake() # 方法2.2 super().函数() super().__init__() super().make_cake() daqiu = Prentice() daqiu.make_old_cake() 注意：使用super() 可以自动查找父类。调用顺序遵循 __mro__ 类属性的顺序。比较适合单继承使用。 私有权限 定义私有属性和方法 在Python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类。 设置私有权限的方法：在属性名和方法名前面加上两个下划线__。 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class School(object): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class Prentice(School, Master): def __init__(self): self.kongfu = &apos;[独创煎饼果子配方]&apos; # 定义私有属性 self.__money = 2000000 # 定义私有方法 def __info_print(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) # 徒孙类 class Tusun(Prentice): pass daqiu = Prentice() # 对象不能访问私有属性和私有方法 # print(daqiu.__money) # daqiu.__info_print() xiaoqiu = Tusun() # 子类无法继承父类的私有属性和私有方法 # print(xiaoqiu.__money) # 无法访问实例属性__money # xiaoqiu.__info_print() 注意：私有属性和私有方法只能在类里面访问和修改。 获取和修改私有属性值 在Python中，一般定义函数名get_xx用来获取私有属性，定义set_xx用来修改私有属性值。 class Master(object): def __init__(self): self.kongfu = &apos;[古法煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class School(object): def __init__(self): self.kongfu = &apos;[school煎饼果子配方]&apos; def make_cake(self): print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) class Prentice(School, Master): def __init__(self): self.kongfu = &apos;[独创煎饼果子配方]&apos; self.__money = 2000000 # 获取私有属性 def get_money(self): return self.__money # 修改私有属性 def set_money(self): self.__money = 500 def __info_print(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(f&apos;运用&#123;self.kongfu&#125;制作煎饼果子&apos;) def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) # 徒孙类 class Tusun(Prentice): pass daqiu = Prentice() xiaoqiu = Tusun() # 调用get_money函数获取私有属性money的值 print(xiaoqiu.get_money()) # 调用set_money函数修改私有属性money的值 xiaoqiu.set_money() print(xiaoqiu.get_money()) 面向对象之其他面向对象三大特性 封装：将属性和方法书写到类的里面的操作即为封装，封装可以为属性和方法添加私有权限。 继承：子类默认继承父类的所有属性和方法，子类可以重写父类属性和方法。 多态：传入不同的对象，产生不同的结果 多态 多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）。 多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果 class Dog(object): def work(self): # 父类提供统一的方法，哪怕是空方法 print(&apos;指哪打哪...&apos;) class ArmyDog(Dog): # 继承Dog类 def work(self): # 子类重写父类同名方法 print(&apos;追击敌人...&apos;) class DrugDog(Dog): def work(self): print(&apos;追查毒品...&apos;) class Person(object): def work_with_dog(self, dog): # 传入不同的对象，执行不同的代码，即不同的work函数 dog.work() ad = ArmyDog() dd = DrugDog() daqiu = Person() daqiu.work_with_dog(ad) daqiu.work_with_dog(dd) 类属性和实例属性 类属性就是类对象所拥有的属性，它被该类的所有实例对象所共有。类属性可以使用类对象或实例对象访问。 class Dog(object): tooth = 10 wangcai = Dog() xiaohei = Dog() print(Dog.tooth) # 10 print(wangcai.tooth) # 10 print(xiaohei.tooth) # 10 修改类属性 类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了一个实例属性。 class Dog(object): tooth = 10 wangcai = Dog() xiaohei = Dog() # 修改类属性 Dog.tooth = 12 print(Dog.tooth) # 12 print(wangcai.tooth) # 12 print(xiaohei.tooth) # 12 # 不能通过对象修改属性，如果这样操作，实则是创建了一个实例属性 wangcai.tooth = 20 print(Dog.tooth) # 12 print(wangcai.tooth) # 20 print(xiaohei.tooth) # 12 实例属性 class Dog(object): def __init__(self): self.age = 5 def info_print(self): print(self.age) wangcai = Dog() print(wangcai.age) # 5 # print(Dog.age) # 报错：实例属性不能通过类访问 wangcai.info_print() # 5 类方法 类方法特点:需要用装饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数。 当方法中需要使用类对象(如访问私有类属性等)时，定义类方法。类方法一般和类属性配合使用。 class Dog(object): __tooth = 10 @classmethod def get_tooth(cls): return cls.__tooth wangcai = Dog() result = wangcai.get_tooth() print(result) # 10 静态方法 静态方法特点：需要通过装饰器@staticmethod来进行修饰，静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）。静态方法也能够通过 实例对象 和 类对象 去访问。 当方法中 既不需要使用实例对象(如实例对象，实例属性)，也不需要使用类对象 (如类属性、类方法、创建实例等)时，定义静态方法。取消不需要的参数传递，有利于减少不必要的内存占用和性能消耗。 class Dog(object): @staticmethod def info_print(): print(&apos;这是一个狗类，用于创建狗实例....&apos;) wangcai = Dog() # 静态方法既可以使用对象访问又可以使用类访问 wangcai.info_print() Dog.info_print() 异常 当检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常”。 例如：以r方式打开一个不存在的文件。 open(&apos;test.txt&apos;, &apos;r&apos;) 异常的写法 try: 可能发生错误的代码 except: 如果出现异常执行的代码 需求：尝试以r模式打开文件，如果文件不存在，则以w方式打开。 try: f = open(&apos;test.txt&apos;, &apos;r&apos;) except: f = open(&apos;test.txt&apos;, &apos;w&apos;) 捕获指定异常 try: 可能发生错误的代码 except 异常类型: 如果捕获到该异常类型执行的代码 捕获多个指定异常：当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。 try: print(1/0) except (NameError, ZeroDivisionError): print(&apos;有错误&apos;) 捕获异常描述信息 try: print(num) except (NameError, ZeroDivisionError) as result: print(result) 捕获所有异常：Exception是所有程序异常类的父类。 try: print(num) except Exception as result: print(result) 异常的else：else表示的是如果没有异常要执行的代码。 try: print(1) except Exception as result: print(result) else: print(&apos;我是else，是没有异常的时候执行的代码&apos;) 异常的finally:finally表示的是无论是否异常都要执行的代码，例如关闭文件。 try: f = open(&apos;test.txt&apos;, &apos;r&apos;) except Exception as result: f = open(&apos;test.txt&apos;, &apos;w&apos;) else: print(&apos;没有异常，真开心&apos;) finally: f.close() 自定义异常:在Python中，抛出自定义异常的语法为raise 异常类对象。 需求：密码长度不足，则报异常（用户输入密码，如果输入的长度不足3位，则报错，即抛出自定义异常，并捕获该异常）。 # 自定义异常类，继承Exception class ShortInputError(Exception): def __init__(self, length, min_len): self.length = length self.min_len = min_len # 设置抛出异常的描述信息 def __str__(self): return f&apos;你输入的长度是&#123;self.length&#125;, 不能少于&#123;self.min_len&#125;个字符&apos; def main(): try: con = input(&apos;请输入密码：&apos;) if len(con) &lt; 3: raise ShortInputError(len(con), 3) except Exception as result: print(result) else: print(&apos;密码已经输入完成&apos;) main() 模块 Python模块(Module)，是一个Python文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 模块能定义函数，类和变量，模块里也能包含可执行的代码。 导入模块的方式 import 模块名 from 模块名 import 功能名 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 import # 1. 导入模块 import 模块名 import 模块名1, 模块名2... # 2. 调用功能 模块名.功能名() # 体验 import math print(math.sqrt(9)) # 3.0 from..import.. from 模块名 import 功能1, 功能2, 功能3... # 体验 from math import sqrt print(sqrt(9)) from .. import * from 模块名 import * # 体验 from math import * print(sqrt(9)) as定义别名 # 模块定义别名 import 模块名 as 别名 # 功能定义别名 from 模块名 import 功能 as 别名 # 体验 # 模块别名 import time as tt tt.sleep(2) print(&apos;hello&apos;) # 功能别名 from time import sleep as sl sl(2) print(&apos;hello&apos;) 制作模块 制作模块:在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块名必须要符合标识符命名规则。 新建一个Python文件，命名为my_module1.py，并定义testA函数。 def testA(a, b): print(a + b) 在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息。例如，在my_module1.py文件中添加测试代码。 def testA(a, b): print(a + b) testA(1, 1) 此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行testA函数的调用。 解决办法如下： def testA(a, b): print(a + b) # 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行testA函数调用 if __name__ == &apos;__main__&apos;: testA(1, 1) 调用模块 import my_module1 my_module1.testA(1, 1) 模块定位顺序 如果使用from .. import ..或from .. import *导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是后面导入的模块的功能。 # 模块1代码 def my_test(a, b): print(a + b) # 模块2代码 def my_test(a, b): print(a - b) # 导入模块和调用功能代码 from my_module1 import my_test from my_module2 import my_test # my_test函数是模块2中的函数 my_test(1, 1) 当导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 注意 自己的文件名不要和已有模块名重复，否则导致模块功能无法使用 使用from 模块名 import 功能的时候，如果功能名字重复，调用到的是最后定义或导入的功能。 __all__ 如果一个模块文件中有__all__变量，当使用from xxx import *导入时，只能导入这个列表中的元素。 # my_module1模块代码 __all__ = [&apos;testA&apos;] def testA(): print(&apos;testA&apos;) def testB(): print(&apos;testB&apos;) # 导入模块的文件代码 from my_module1 import * testA() testB()# 报错 包 包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py 文件，那么这个文件夹就称之为包。 制作包：[New] — [Python Package] — 输入包名 — [OK] — 新建功能模块(有联系的模块)。 注意：新建包后，包内部会自动创建__init__.py文件，这个文件控制着包的导入行为。 新建包mypackage，新建包内模块：my_module1 和 my_module2，模块内代码如下 # my_module1 print(1) def info_print1(): print(&apos;my_module1&apos;) # my_module2 print(2) def info_print2(): print(&apos;my_module2&apos;) 导入包 # 方法一 import 包名.模块名 包名.模块名.目标 # 体验 import my_package.my_module1 my_package.my_module1.info_print1() #方法二：必须在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块列表。 from 包名 import * 模块名.目标 # 体验 from my_package import * my_module1.info_print1()","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"从oc到swift","slug":"40.从oc到swift","date":"2020-08-29T08:31:43.733Z","updated":"2021-03-26T14:41:41.248Z","comments":false,"path":"2020/08/29/40.从oc到swift/","link":"","permalink":"http://yoursite.com/2020/08/29/40.%E4%BB%8Eoc%E5%88%B0swift/","excerpt":"","text":"Objective-C介绍 OC程序的源文件后缀名为.m。 m代表message，代表OC的消息机制。OC语言完全兼容C语言，所以在.m文件中可以写C语言的任何代码，甚至C++的代 码也可以写在.m文件下。 #import 指令:同一个文件，无论被#import多少次，在预编译的时候只会包含1次。包括#import &quot;&quot;和#import &lt;&gt;。 .m是Objective-C的源文件。.mm是Objective-C++的源文件。 .h是头文件，包含方法，属性的声明。.m是类的实现文件，参与编译的文件，用来实现类中声明的方法。 Boolean类型数据允许取值true或false,也可以是0或非0的整数替代true和false。 @try &#123; //可能出错的代码块 &#125; @catch (NSException *exception) &#123; // 一旦出了错 可以的补救代码。 &#125; @finally &#123; //无论出错不出错都会执行的代 &#125; 面向对象设计四个个主要特征: 抽象性、 封装性、 多态性、 继承性。 NSLog NSLog 是printf函数的增强版 NSLog(@&quot;Hello World!&quot;); @&quot;&quot;这个符号表示将一个C的字符串转化为OC中的字符串对象NSString。 OC字符串必须使用@符号开头。@符号放置的位置在双引号外面。在打印OC字符串的时候使用格式控制符%@ 。NSString类型的指针变量只能存储OC字符串常量的地址。 OC中大部分的关键字都是以@开头的,比如@interface,@implementation,@end。 类 .h文件为类的声明文件，用于声明成员变量、方法。类的声明使用关键字 @interface和@end。.h中的方法只是做一个声明，并不对方法进行实现。 .m：类的实现文件，用于实现.h中声明的方法。类的实现使用关键字 @implementation和@end。 方法的声明和实现，都必须以+ 或者 - 开头。 +表示类方法（静态方法）, -表示对象方法（动态方法）。 在.h中声明的所有方法作用域都是public类型，不能更改。 成员变量的常用作用域有3种: @public 全局都可以访问 @protected 只能在类内部和子类中访问 @private 只能在类内部访问 创建对象 创建对象的写法 类名 * 对象名 = [类名 new]; 只要是用new操作符定义的实体就会在堆内存中开辟一个新的空间。1）在堆中开辟一段存储空间 2）初始化成员变量（写在类声明大括号中的属性就叫做成员变量，也叫做实例变量） 3）返回开辟空间的首地址。 访问对象的属性可以用： 对象-&gt;对象成员； 方法 oc没有严格的方法重载. 在oc中方法名不允许相同。 OC中的方法分为：对象方法和类方法。 对象方法：对象方法以-开头如-（void）xx ;对象方法只能由对象来调用;对象方法中可以访问当前对象的成员变量;调用格式[对象名 对象方法名] 。凡事类型都用()括起来。 类方法：以+开头如+（void）xxx;类方法只能由类来调用;类方法中不能访问实例变量(成员变量)，因为类方法由类来调用，并没有创建存储空间来存储类中的成员变量;调用格式：[类名 类方法名]。 有参方法，冒号也是方法名的一部分 //返回值类型 void ; 方法名run: : :，参数有3个，都是int型的，参数的参数名 steps km times - (void)run:(int)steps :(int)km :(int)times; // 声明三个带参数的方法，方法名是 runWith: andWith: andWith: - (void)runWith:(int)steps andWith:(int)km andWith:(int)times; 有参方法的调用： //[对象名 方法名 参数] [zhansgan eat:@&quot;辣条&quot;]; // [对象名 方法名:参数:参数]; [zhansgan run:3 :10 :5]; [zhansgan runWith:5 andWith:20 andWith:2]; 对象的存储 类创建对象，每个对象在内存中都占据一定的存储空间，每个对象都有一份属于自己的单独的成员变量，所有的对象公用类的成员方法，方法在整个内存中只有一份，类本身在内存中占据一份存储空间，类的方法存储于此。 每一个对象都包含一个isa指针，这个指针指向当前对象所属的类。 当调用方法的时候如[p eat] 表示给p所指向的对象发送一条eat消息，表示要调用对象的eat方法，此时对象会顺着内部的isa指针找到存储于类中的方法，开始执行，此时方法所修改的所有的信息，都是对应的对象的。 pragma mark #pragma mark -//“-”后面不能随手敲个空格 #pragma mark 分组（标识）名称 常见错误 @interface @end和@implementation @end不能嵌套包含。 只有类的声明没有类的实现，会报错。 NSString NSString是Objective-C中核心处理字符串的类之一。 创建常量字符串，注意使用“@”符号： NSString * str = @&quot;hahahaha&quot;; NSString * str2 = [[NSString alloc] initWithString:str]; 创建空字符串，给予赋值： NSString * str1 = [NSString new ]; str1 = @&quot;啊哈哈哈&quot;; 创建格式化字符串：占位符（由一个%加一个字符组成）： NSString * str3 = [NSString stringWithFormat:@&quot;图片 xxxx %02d- %02d.jpg&quot;,9,1]; NSLog(@&quot;Hello, World! %@ &quot;,str3);//图片 xxxx %09- %01.jpg 计算字符串长度 NSLog(@&quot;字符串的长度 %ld&quot;, [str2 length]); 对象与对象之间的关系 一个对象作为另外1个对象的成员变量 //女孩有一部手机 @interface Girl :NSObject &#123; Phone *_phone; &#125; @end //女孩用手机打电话 @interface Girl :NSObject - (void)callWithPhone:(Phone *)phone; @end 组合关系:1个对象是由多个对象组合起来的。比如：计算机对象，是由主板对象、CPU对象、内存对象、硬盘对象组合起来的。 依赖关系：就是一个对象要1件事情的时候必须有另一个对象。比如，B类是A类⽅方法的参数，我们就说A类依赖于B类。 关联关系:当一个对象拥有另外一个对象的时候, 当B对象为A对象的成员变量的时候,B对象与A对象之间存在一种关联关系。 面向对象设计原则 单一职责原则、开放封闭原则 类方法OC中的方法分为两种 对象方法 以“-”减号开头的方法就是对象方法。对象方法的调用，必须创建对象，然后通过对象名去调用。 声明 -（返回值类型）方法名：（参数类型）参数名称； - (void)square : (int)num; 类方法 以+加号开头的方法叫做类方法。这个方法不依赖于对象，不需要创建对象来调用，而是直接使用类名调用。 +（返回值类型）方法名：（参数类型）参数名称； + (void)square : (int)num; 类方法使用注意事项： 1. 类方法中不能访问成员变量。 2. 类方法和对象方法可以同名。 3. 类方法中不能通过self调用同名方法，会死循环。 4. 对象方法当中可以通过类名直接调用类方法。 5. 在没有属性时，建议使用类方法。 匿名对象没有名字的对象。 self关键字 self是一个指针变量，用于在方法中指向调用该方法的对象。 self的应用场景 1）用在类方法中，代表当前类。 2）用在对象方法中，代表当前对象。 3）访问成员变量：self-&gt;成员变量。 self使用注意 在对象方法中 【self 对象方法】； // 死循环 在类方法中 【self 对象方法】； // 死循环 封装封装:把复杂的数据或者操作进行隐藏,只操作数据或者方法的接口。封装的好处:隐藏成员变量，不让外部直接访问，提高安全性。控制外界访问成员权限。 set方法 命名规范：方法名必须以set开头。set后面跟成员变量名称，成员变量的首字母必须大写。返回值一定是void。一定要接收一个参数，而且参数类型跟成员变量类型一致。形参的名称不能跟成员变量名一样。 - (void)set成员变量名 (首字母大写，去掉下划线) : (成员变量类型)成员变量名称 （去掉下划线）； - (void)setAge:(int)age; get方法 命名规范：肯定有返回值，返回值类型肯定与成员变量类型一致。方法名跟成员变量名一样。不需要接收任何参数 格式： - （成员变量类型）成员变量名称（去掉下划线）; - (int) age; 使用 // Student类的声明 @interface Student : NSObject &#123; int _age; &#125; - (void)setAge:(int)newAge;//set方法 - (int)age;//get方法 @end //Student类实现: @implementation Student //setter方法实现 - (void)setAge:(int)newAge &#123; _age = newAge; &#125; //getter方法 - (int)age &#123; return _age; &#125; @end 调用: Student *s = [Student new]; // 设置age的值 [s setAge:10]; // 取出age的值 int age = [s age]; // 输出 NSLog(@&quot;age is %d&quot;, age); 类的继承和派生 OC中的继承是单继承:也就是说一个类只能一个父类,不能继承多个父类。子类不能定义和父类同名的成员变量,但是可以继承父类的变量。 基类的私有属性@private能被继承,不能被使用。@public公有成员能被继承,也能被外部方法访问。@protected保护成员能够被继承、在子类中使用,但不能够被外部函数访问。在@interface @end之间声明的成员变量如果不做特别的说明,那么其默认是 protected的。 在类的实现即.m文件，@implementation中也可以声明成员变量,是@private的。 方法的重写：从父类继承的方法,可能这个方法并不适合子类,可以在子类中重写父类的方法。 @interface Animal : NSObject &#123; int _tuiNum; //腿的个数 int _eyeNum; //眼睛个数 &#125; -(void)setTuiNum:(int)tuiNum; -(int)tuiNum; -(void)setEyeNum:(int)eyeNum; -(int)eyeNum; -(void)eat; -(void)run; @end #import &quot;Animal.h&quot; @interface Dog : Animal &#123; &#125; -(void)eat; //覆盖父类的eat的方法 @end 重写之后,父类的对象调用父类的方法;子类的对象,调用子类的方法,不会引起冲突。从父类继承的方法,不适用于子类时,可以直接声明父类的同名方法,并定义。不用考虑父类中,方法已存在的问题。 重写后,子类可以通过super调用父类的方法。 - （void）eat &#123; [super eat]; &#125; 私有方法 OC中并没有像Java中提供的私有方法,OC中的私有,可以理解为相对私有。 方法在.m中实现,不在.h中声明,此时该方法被称为私有方法:私有方法不可以被子类继承 @interface MyClass &#123; // 添加变量 &#125; - (void)PublicMethod;//公共方法,可以被继承类继承 @end // 而在类的.m文件中,直接实现的方法： - (void)PrivateMethod &#123; //// &#125; @end 多态 多态:同一种行为,对于不同的事物具有不同的表现形式。多态的条件:有继承关系、有方法重写。 父类的声明变量指向子类对象。如果存在多态,父类是可以访问子类特有的方法。 类对象的用法 可以用来调用方法 Dog *d = [Dog new]; Dog *d1 = [Dog new]; Class c = [d1 class]; // 用类名调用类方法 [Dog test]; [c test]; 可以用来初始化对象 Class c = [Dog class]; [c test]; // 用类对象创建对象 Dog *d = [c new]; [d eat]; SEL方法选择器 SEL类型作用:可以定义变量；可以用来作为方法的形参；可以用来作为方法的实参。 Static关键 static修饰局部变量:延长布局变量的生命周期。 static修饰全局变量:当前变量只能在当前文件中使用。 static修饰函数:函数只能在当前文件中使用。 使用static修饰实例变量是不被允许的。 使用static修饰方法也是不被允许的。 使用static@interface和@end之间是不被允许的（写局部变量本来就不被允许）。 //狗类的声明 static int m=10; //此句话也可以放到.m中 @interface Dog:NSObject &#123; int _speed; &#125; -(void)run; @end // Dog.m文件内容 #import &quot;Dog.h&quot; #pragma mark 狗类的实现 @implementation Dog -(void)run&#123; //定义局部静态变量 m static int m=10; NSLog(@&quot;m = %d&quot;,m); m++; &#125; @end 注意Static型全局变量的可见性,局限于当前.m文件，其他的文件中的类,无法访问到该变量。 点语法 点语法是编译器特性，当编译器看到对象使用点语法，会自动把点语法转换为调用set或get方法的形式。 Student *stu = [Student new]; // 设置age的值 stu.age = 10; // 等价于[stu setAge:10]; // 取出age的值 int age = stu.age; // 等价于int age = [stu age]; // 输出 NSLog(@&quot;age is %i&quot;, age); self在set方法中使用 - (void)setAge:(int)age &#123; self.age = age; &#125; 错误用法，会死循环。 上面的代码相当于： - (void)setAge:(int)age &#123; [self setAge:age]; &#125; self在get方法中使用 - (int)age &#123; return self.age; &#125; 错误用法：死循环。 相当于： - (int)age &#123; return [self age]; &#125; property关键字 @property是编译器的指令。它告诉编译器,声明属性的set、get方法。好处是:免去我们手工书写get和set方法繁琐的代码。 格式： @property 类型 方法名 @property int age; //相当于进行了age的set和get方法的声明 -(void)setAge:(int)age; -(int)age; synthesize关键字 如果@synthesize变量名要先在.h文件中声明 @property int age; .h -(void)setAge:(int)age; -(int)age; .m @synthesize age;展开形式如下: -(void)setAge:(int)age &#123; self-&gt;age = age; &#125; -(int)age &#123; return age; &#125; @property和@synthesize搭配使用,用于简化set和get方法的定义和实现。 id类型 id类型应用场景 //狗的类,狗继承自动物 Dog *dog = [Dog new]; [dog run]; //定义多态类型 NSObjcet *dog1 = [Dog new]; [(Dog *)dog run]; //定义id类型 id dog2 = [Dog new]; [obj run]; id作为成员变量 // 类的声明 @interface Person : NSObject @property int age; @property id obj; // 可以接收任何对象 @end // 类的实现 @implementation Person @end // main函数 int main() &#123; Person *p = [Person new]; [p setObj:@&quot;小王子&quot;]; NSLog(@&quot;%d&quot;,[p obj]); return 0; &#125; 构造方法 构造方法:用来初始化对象实例变量值的方法,是个对象方法,-开头。 完整的创建一个可用的对象: Person *p=[Person new]; new方法的内部会分别调用两个方法来完成3件事情:使用alloc方法来分配存储空间(返回分配的对象);使用init方法来对对象进行初始化；返回对象的首地址。 可以把new方法拆开如下:调用类方法+alloc分配存储空间,返回未经初始化的对象 Person *p1=[Person alloc]; 调用对象方法-init进行初始化,返回对象本身 Person *p2=[p1 init]; 以上两个过程整合为一句: Person *p=[[Person alloc] init]; init方法就是构造方法,是用来初始化对象的方法,注意这是一个对象方法,以减号开头。默认初始化完毕后,所有成员变量的值都为0。 自定义构造方法的代码实现 问题1：给Hero类定义一个构造方法,自定义名字信息。 // 声明 @property NSString *name; - (instancetype)initWithName:(NSString *)name； // 实现 - (instancetype)initWithName:(NSString *)name &#123; if (self = [super init]) &#123; _name = name; &#125; return self; &#125; @end 问题2：给Hero类定义一个构造方法,自定义名字信息和年龄。 // 声明 @property NSString *name; @property int age; - (instancetype)initWithName:(NSString *)name andAge:(int)age； // 实现 - (instancetype)initWithName:(NSString *)name andAge:(int)age &#123; if (self = [super init]) &#123; _name = name; _age = age; &#125; return self; &#125; @end NSMutableArray 数组长度不固定，可以随便往里面添加或者删除元素。 创建可变数组 NSMutableArray *arrayM = [NSMutableArray array]; 数组添加成员 - (void)addObject:(ObjectType)object; 删除数组成员 // 用成员名进行删除 - (void)removeObject:(ObjectType)object; // 删除指定位置的元素 - (void)removeObjectAtIndex:(NSUInteger)index; swift处理值缺失的情况 ?代表可能值确实，可以使用if let或者??来处理。 var optionalName: String? = &quot;John Appleseed&quot; var greeting = &quot;Hello!&quot; //如果不是 nil，会将值解包并赋给 let 后面的常量 if let name = optionalName &#123; greeting = &quot;Hello, \\(name)&quot; &#125; print(greeting)//Hello, John Appleseed ??前面的变量为nil，则用??后面的变量；??前面的不为nil，则用??前面的变量。 let nickName: String? = nil let fullName: String = &quot;John Appleseed&quot; let informalGreeting = &quot;Hi \\(nickName ?? fullName)&quot; print(informalGreeting)//Hi John Appleseed 快速上手 使用let来声明常量，使用var来声明变量。 int转String let label = &quot;The width is&quot; let width = 94 let widthLabel = label + String(width) 或者 let apples = 3 let appleSummary = &quot;I have \\(apples) apples.&quot; 使用方括号[]来创建数组和字典。数组添加元素用append。 初始化一个空数组或者空字典： let emptyArray = [String]() let emptyDictionary = [String: Float]() 使用 for-in、while 和 repeat-while 来进行循环。 switch：不需要在每个子句结尾写 break。 let vegetable = &quot;red pepper&quot; switch vegetable &#123; case &quot;celery&quot;: print(&quot;Add some raisins and make ants on a log.&quot;) case &quot;cucumber&quot;, &quot;watercress&quot;: print(&quot;That would make a good tea sandwich.&quot;) case let x where x.hasSuffix(&quot;pepper&quot;): print(&quot;Is it a spicy \\(x)?&quot;) default: print(&quot;Everything tastes good in soup.&quot;) &#125; 字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。 let interestingNumbers = [ &quot;Prime&quot;: [2, 3, 5, 7, 11, 13], &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8], &quot;Square&quot;: [1, 4, 9, 16, 25], ] var largest = 0 for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125; &#125; print(largest) while var n = 2 while n &lt; 100 &#123; n *= 2 &#125; print(n)//128 var m = 2 repeat &#123; m *= 2 &#125; while m &lt; 100 print(m)//128 ..&lt;来表示下标范围,不包含上界。如果想包含的话需要使用 ...： var total = 0 for i in 0..&lt;4 &#123; total += i &#125; print(total)//6 条件循环： for i in 1...10 where i % 2 == 0&#123; print(i) &#125; 倒叙遍历： for i in (1...10).reversed()&#123; print(i) &#125; 生成随机数： Int.random(in: 1...6)//1-6之间随机数 四舍五入double，返回double： round(4.44) //4.0 使用func来声明一个函数，使用-&gt;来指定函数返回值的类型。 func greet(person: String, day: String) -&gt; String &#123; return &quot;Hello \\(person), today is \\(day).&quot; &#125; print(greet(person:&quot;Bob&quot;, day: &quot;Tuesday&quot;))//Hello Bob, today is Tuesday. 使用元组来生成复合值，比如让一个函数返回多个值。该元组的元素可以用名称或数字来获取: func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum) &#125; let statistics = calculateStatistics(scores:[5, 3, 100, 3, 9]) print(statistics.sum)//120 print(statistics.2)//120 两个参数名时候的外部参数和内部参数： func numSun(wai nei : Int) &#123; print(nei) &#125; numSun(wai: 3) func numSun(_ nei : Int) &#123; print(nei) &#125; numSun(3) 函数可以嵌套。 函数可以作为另一个函数的返回值: func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne &#125; var increment = makeIncrementer() increment(7)//8 函数也可以当做参数传入另一个函数: func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false &#125; func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10 &#125; var numbers = [20, 19, 7, 12] var bol = hasAnyMatches(list: numbers, condition: lessThanTen) print(&quot;\\(bol)&quot;) 闭包: numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number return result &#125;) //或者 var numbers = [20, 19, 7, 12] let mappedNumbers = numbers.map(&#123; number in 3 * number &#125;) print(mappedNumbers)//[60, 57, 21, 36] 使用 class 和类名来创建一个类。 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。 使用 init 来创建一个构造器。 class NamedShape &#123; var numberOfSides: Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func simpleDescription() -&gt; String &#123; return &quot;A shape with \\(numberOfSides) sides.&quot; &#125; &#125; 如果需要在对象释放之前进行一些清理工作，使用 deinit 创建一个析构函数。 使用 enum 来创建一个枚举。 使用 struct 来创建一个结构体。结构体是传值，类是传引用。 使用 protocol 来声明一个协议。mutating。extension。 其他 给Image View重新设置Assets资源图片： @IBOutlet weak var leftImage: UIImageView! leftImage.image = UIImage(named: &quot;show2&quot;) 摇晃手机结束： override func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; &#125; 设置view的tag，然后同一个方法中区分： @IBAction func tagBtn(_ sender: UIButton) &#123; print(sender.tag) &#125; 播放音频： import AVFoundation var player: AVAudioPlayer! func palyAV() &#123; let url = Bundle.main.url(forResource: &quot;文件名&quot;, withExtension: &quot;格式名&quot;) do&#123; player = try AVAudioPlayer(contentsOf: url!) player.play() &#125; catch &#123; &#125; &#125; 弹出框： let alter = UIAlertController(title: &quot;title&quot;, message: &quot;message&quot;, preferredStyle: .alert) alter.addAction(UIAlertAction(title: &quot;ok&quot;, style: .default, handler: &#123;(_) in print(&quot;点击了ok&quot;) &#125;)) present(alter,animated: true,completion: nil) 动态设置宽度： rightImage.frame.size.width = view.frame.width / 10 UI control拖拽控件，可以选择Outlet和Action。 Autoresizing:设置上下左右宽高六个属性。 stackview 页面控件：View Controller。输入框：Text Field。 技巧 图标制作网站： https://appicon.co/ 快捷键 command + R 编译运行 command + m 最小化 command + z 撤销 command + d 复制粘贴出来一个选中的ui控件 command + 删除键 光标在一行的最后位置，删除整行/删除光标前的内容 局域网真机调试： Window-Devices and Simulators iOS https://github.com/dequan1331/HybridPageKit","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"数据结构和算法","slug":"37.数据结构和算法","date":"2020-07-06T14:19:40.708Z","updated":"2021-03-26T14:41:29.526Z","comments":false,"path":"2020/07/06/37.数据结构和算法/","link":"","permalink":"http://yoursite.com/2020/07/06/37.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"介绍1、数据结构分类 数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据。 把数据结构分为逻辑结构和物理结构两大类。 逻辑结构分类：集合结构、线性结构、树形结构、图形结构。 物理结构：顺序存储结构、链式存储结构。 顺序存储结构：把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。查找快、插入删除慢。 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。查找慢，增删快。 2、算法介绍 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。根据一定的条件，对一些数据进行计算，得到需要的结果。 一个优秀的算法追求以下两个目标：1.花最少的时间完成需求；2.占用最少的内存空间完成需求。 3、算法的时间复杂度 算法的时间复杂度分析 事后分析估算方法：计算方法执行时间System.currentTimeMillis()。 事前分析估算方法：算法采用的策略和方案；问题的输入规模(所谓的问题输入规模就是输入量的多少)。最重要的就是把核心操作的次数和输入规模关联起来。 总结：随着输入规模的增大，算法的常数操作可以忽略不计。随着输入规模的增大，与最高次项相乘的常数可以忽略。最高次项的指数大的，随着n的增长，结果也会变得增长特别快。算法函数中n最高次幂越小，算法效率越高。 4、时间复杂度大O记法 执行次数=执行时间。用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。 大O阶的表示法有以下几个规则可以使用： 1.用常数1取代运行时间中的所有加法常数； 2.在修改后的运行次数中，只保留高阶项； 3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数。 复杂程度从低到高依次为：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)。 5、算法的空间复杂度 数据类型 内存占用字节数：byte 1、short 2、int 4、long 8、float 4、double 8、boolean 1、char 2。 计算机访问内存的方式都是一次一个字节。 一个引用（机器地址）需要8个字节表示： Date date = new Date()；//则date这个变量需要占用8个字节来表示 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 一般内存的使用，如果不够8个字节，都会被自动填充为8字节。 java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。 int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节 排序1、Comparable接口 public class Student implements Comparable&lt;Student&gt;&#123; private String username; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125; @Override public int compareTo(Student o) &#123; return this.getAge()-o.getAge(); &#125; &#125; public class TestComparable &#123; public static void main(String[] args) &#123; //创建两个Student对象，并调用getMax方法，完成测试 Student s1 = new Student(); s1.setUsername(&quot;张三&quot;); s1.setAge(18); Student s2 = new Student(); s2.setUsername(&quot;李四&quot;); s2.setAge(20); Comparable max = getMax(s1, s2); System.out.println(max); &#125; public static Comparable getMax(Comparable c1,Comparable c2)&#123; int result = c1.compareTo(c2); //如果result&lt;0,则c1比c2小； //如果result&gt;0，则c1比c2大； //如果result==0,则c1和c2一样大； if (result&gt;=0)&#123; return c1; &#125;else&#123; return c2; &#125; &#125; &#125; 2、冒泡排序 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。最终最后位置的元素就是最大值。 public class Bubble &#123; /* * 对数组的元素进行排序 */ public static void sort(Comparable[] a)&#123; for(int i=a.length-1;i&gt;0;i--)&#123; for(int j=0;j&lt;i;j++)&#123; //比较索引j和索引j+1处的值 if (greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125; &#125; /* * 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; public class BubbleTest &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;4,5,6,3,2,1&#125;; Bubble.sort(arr); System.out.println(Arrays.toString(arr));//&#123;1,2,3,4,5,6&#125; &#125; &#125; 冒泡排序的时间复杂度为O(N^2)。 3、选择排序 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引。然后交换第一个索引处和最小值所在的索引处的值。 public class Selection &#123; /* 对数组中的元素进行排序 */ public static void sort(Comparable[] a)&#123; for(int i=0;i&lt;=a.length-2;i++)&#123; //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置 int minIndex = i; for(int j=i+1;j&lt;a.length;j++)&#123; //需要比较最小索引minIndex处的值和j索引处的值； if (greater(a[minIndex],a[j]))&#123; minIndex=j; &#125; &#125; //交换最小元素所在索引minIndex处的值和索引i处的值 exch(a,i,minIndex); &#125; &#125; /* 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; public class SelectionTest &#123; public static void main(String[] args) &#123; //原始数据 Integer[] a = &#123;4,6,8,7,9,2,10,1&#125;; Selection.sort(a); System.out.println(Arrays.toString(a));//&#123;1,2,4,5,7,8,9,10&#125; &#125; &#125; 时间复杂度为O(N^2)。 4、插入排序 把所有的元素分为两组，已经排序的和未排序的；找到未排序的组中的第一个元素，向已经排序的组中进行插入；倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。类似打扑克牌时，新牌往手里牌的排序。 public class Insertion &#123; /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; //比较索引j处的值和索引j-1处的值，如果索引j-1处的值比索引j处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可； if (greater(a[j-1],a[j]))&#123; exch(a,j-1,j); &#125;else&#123; break; &#125; &#125; &#125; &#125; /* 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; public class InsertionTest &#123; public static void main(String[] args) &#123; Integer[] a = &#123;4,3,2,10,12,1,5,6&#125;; Insertion.sort(a); System.out.println(Arrays.toString(a));//&#123;1,2,3,4,5,6,10,12&#125; &#125; &#125; 时间复杂度为O(N^2)。 5、希尔排序 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；对分好组的每一组数据完成插入排序；减小增长量，最小减为1，重复第二步操作。 增长量h的确定： int h=1 while(h&lt;(数组长度/2))&#123; h=2h+1 &#125; //循环结束后我们就可以确定h的最大值 //h的减小规则为： h=h/2 代码 public class Shell &#123; /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a)&#123; //1.根据数组a的长度，确定增长量h的初始值； int h = 1; while(h&lt;a.length/2)&#123; h=2*h+1; &#125; //2.希尔排序 while(h&gt;=1)&#123; //排序 //2.1.找到待插入的元素 for (int i=h;i&lt;a.length;i++)&#123; //2.2把待插入的元素插入到有序数列中 for (int j=i;j&gt;=h;j-=h)&#123; //待插入的元素是a[j],比较a[j]和a[j-h] if (greater(a[j-h],a[j]))&#123; //交换元素 exch(a,j-h,j); &#125;else&#123; //待插入元素已经找到了合适的位置，结束循环； break; &#125; &#125; &#125; //减小h的值 h= h/2; &#125; &#125; /* 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; public class ShellTest &#123; public static void main(String[] args) &#123; Integer[] a = &#123;9,1,2,5,7,4,8,6,3,5&#125;; Shell.sort(a); System.out.println(Arrays.toString(a));//&#123;1,2,3,4,5,5,6,7,8,9&#125; &#125; &#125; 6、归并排序 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。将相邻的两个子组进行合并成一个有序的大组；不断的重复步骤2，直到最终只有一个组为止。 public class Merge &#123; //归并所需要的辅助数组 private static Comparable[] assist; /* 比较v元素是否小于w元素 */ private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w)&lt;0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a, int i, int j) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a) &#123; //1.初始化辅助数组assist； assist = new Comparable[a.length]; //2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引； int lo=0; int hi=a.length-1; //3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序 sort(a,lo,hi); &#125; /* 对数组a中从lo到hi的元素进行排序 */ private static void sort(Comparable[] a, int lo, int hi) &#123; //做安全性校验； if (hi&lt;=lo)&#123; return; &#125; //对lo到hi之间的数据进行分为两个组 int mid = lo+(hi-lo)/2;// 5,9 mid=7 //分别对每一组数据进行排序 sort(a,lo,mid); sort(a,mid+1,hi); //再把两个组中的数据进行归并 merge(a,lo,mid,hi); &#125; /* 对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并 */ private static void merge(Comparable[] a, int lo, int mid, int hi) &#123; //定义三个指针 int i=lo; int p1=lo; int p2=mid+1; //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处 while(p1&lt;=mid &amp;&amp; p2&lt;=hi)&#123; //比较对应索引处的值 if (less(a[p1],a[p2]))&#123; assist[i++] = a[p1++]; &#125;else&#123; assist[i++]=a[p2++]; &#125; &#125; //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处 while(p1&lt;=mid)&#123; assist[i++]=a[p1++]; &#125; //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处 while(p2&lt;=hi)&#123; assist[i++]=a[p2++]; &#125; //把辅助数组中的元素拷贝到原数组中 for(int index=lo;index&lt;=hi;index++)&#123; a[index]=assist[index]; &#125; &#125; &#125; public class MergeTest &#123; public static void main(String[] args) &#123; Integer[] a = &#123;8,4,5,7,1,3,6,2&#125;; Merge.sort(a); System.out.println(Arrays.toString(a));//&#123;1,2,3,4,5,6,7,8&#125; &#125; &#125; 归并排序的时间复杂度为O(nlogn)。归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。 7、快速排序 首先设定一个分界值，通过该分界值将数组分成左右两部分；将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值； 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。 切分原理：把一个数组切分成两个子数组的基本思想： 1.找一个基准值，用两个指针分别指向数组的头部和尾部； 2.先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置； 3.再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置； 4.交换当前左边指针位置和右边指针位置的元素； 5.重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。 public class Quick &#123; /* 比较v元素是否小于w元素 */ private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a, int i, int j) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; //对数组内的元素进行排序 public static void sort(Comparable[] a) &#123; int lo = 0; int hi = a.length-1; sort(a,lo,hi); &#125; //对数组a中从索引lo到索引hi之间的元素进行排序 private static void sort(Comparable[] a, int lo, int hi) &#123; //安全性校验 if (hi&lt;=lo)&#123; return; &#125; //需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）； int partition = partition(a, lo, hi);//返回的是分组的分界值所在的索引，分界值位置变换后的索引 //让左子组有序 sort(a,lo,partition-1); //让右子组有序 sort(a,partition+1,hi); &#125; //对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引 public static int partition(Comparable[] a, int lo, int hi) &#123; //确定分界值 Comparable key = a[lo]; //定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置 int left=lo; int right=hi+1; //切分 while(true)&#123; //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止 while(less(key,a[--right]))&#123; if (right==lo)&#123; break; &#125; &#125; //再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止 while(less(a[++left],key))&#123; if (left==hi)&#123; break; &#125; &#125; //判断 left&gt;=right,如果是，则证明元素扫描完毕，结束循环，如果不是，则交换元素即可 if (left&gt;=right)&#123; break; &#125;else&#123; exch(a,left,right); &#125; &#125; //交换分界值 exch(a,lo,right); return right; &#125; &#125; public class QuickTest &#123; public static void main(String[] args) &#123; Integer[] a= &#123;6, 1, 2, 7, 9, 3, 4, 5, 8&#125;; Quick.sort(a); System.out.println(Arrays.toString(a));//&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; &#125; &#125; 快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。 快速排序的时间复杂度为O(nlogn)。 8、排序的稳定性 数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。 如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。 稳定排序算法：冒泡排序、插入排序、归并排序。 不稳定的排序算法：选择排序、希尔排序、快速排序。 线性表 若A元素在B元素的前面，则称A为B的前驱元素。若B元素在A元素的后面，则称B为A的后继元素。 第一个数据元素没有前驱，这个数据元素被称为头结点；最后一个数据元素没有后继，这个数据元素被称为尾结点；除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。 线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。 顺序表 顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。 基本API、扩容、缩容、SequenceList能支持foreach循环，则需要做如下操作：让SequenceList实现Iterable接口，重写iterator方法；在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法。 public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;&#123; //存储元素的数组 private T[] eles; //记录当前顺序表中的元素个数 private int N; //构造方法 public SequenceList(int capacity)&#123; //初始化数组 this.eles=(T[])new Object[capacity]; //初始化长度 this.N=0; &#125; //将一个线性表置为空表 public void clear()&#123; this.N=0; &#125; //判断当前线性表是否为空表 public boolean isEmpty()&#123; return N==0; &#125; //获取线性表的长度 public int length()&#123; return N; &#125; //获取指定位置的元素 public T get(int i)&#123; return eles[i]; &#125; //向线型表中添加元素t public void insert(T t)&#123; if (N==eles.length)&#123; resize(2*eles.length); &#125; eles[N++]=t; &#125; //在i元素处插入元素t public void insert(int i,T t)&#123; if (N==eles.length)&#123; resize(2*eles.length); &#125; //先把i索引处的元素及其后面的元素依次向后移动一位 for(int index=N;index&gt;i;index--)&#123; eles[index]=eles[index-1]; &#125; //再把t元素放到i索引处即可 eles[i]=t; //元素个数+1 N++; &#125; //删除指定位置i处的元素，并返回该元素 public T remove(int i)&#123; //记录索引i处的值 T current = eles[i]; //索引i后面元素依次向前移动一位即可 for(int index=i;index&lt;N-1;index++)&#123; eles[index]=eles[index+1]; &#125; //元素个数-1 N--; if (N&lt;eles.length/4)&#123; resize(eles.length/2); &#125; return current; &#125; //查找t元素第一次出现的位置 public int indexOf(T t)&#123; for(int i=0;i&lt;N;i++)&#123; if (eles[i].equals(t))&#123; return i; &#125; &#125; return -1; &#125; //根据参数newSize，重置eles的大小 public void resize(int newSize)&#123; //定义一个临时数组，指向原数组 T[] temp=eles; //创建新数组 eles=(T[])new Object[newSize]; //把原数组的数据拷贝到新数组即可 for(int i=0;i&lt;N;i++)&#123; eles[i]=temp[i]; &#125; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new SIterator(); &#125; private class SIterator implements Iterator&#123; private int cusor; public SIterator()&#123; this.cusor=0; &#125; @Override public boolean hasNext() &#123; return cusor&lt;N; &#125; @Override public Object next() &#123; return eles[cusor++]; &#125; &#125; &#125; 测试 public class SequenceListTest &#123; public static void main(String[] args) &#123; //创建顺序表对象 SequenceList&lt;String&gt; sl = new SequenceList&lt;&gt;(10); //测试插入 sl.insert(&quot;姚明&quot;); sl.insert(&quot;科比&quot;); sl.insert(&quot;麦迪&quot;); sl.insert(1,&quot;詹姆斯&quot;); for (String s : sl) &#123; System.out.println(s); &#125; System.out.println(&quot;------------------------------------------&quot;); //测试获取 String getResult = sl.get(1); System.out.println(&quot;获取索引1处的结果为：&quot;+getResult); //测试删除 String removeResult = sl.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); //测试清空 sl.clear(); System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length()); &#125; &#125; 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显。 java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查、扩容、遍历等功能。 链表 链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。 public class Node&lt;T&gt; &#123; //存储元素 public T item; //指向下一个结点 public Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; public static void main(String[] args) throws Exception &#123; //构建结点 Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(11, null); Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(13, null); Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(12, null); Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(8, null); Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(9, null); //生成链表 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; &#125; 单向链表 单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。 实现基本API、遍历、链表的反转。 public class LinkList&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录头结点 private Node head; //记录链表的长度 private int N; //结点类 private class Node &#123; //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; public LinkList() &#123; //初始化头结点、 this.head = new Node(null,null); //初始化元素个数 this.N=0; &#125; //清空链表 public void clear() &#123; head.next=null; this.N=0; &#125; //获取链表的长度 public int length() &#123; return N; &#125; //判断链表是否为空 public boolean isEmpty() &#123; return N==0; &#125; //获取指定位置i出的元素 public T get(int i) &#123; //通过循环,从头结点开始往后找，依次找i次，就可以找到对应的元素 Node n = head.next; for(int index=0;index&lt;i;index++)&#123; n=n.next; &#125; return n.item; &#125; //向链表中添加元素t public void insert(T t) &#123; //找到当前最后一个结点 Node n = head; while(n.next!=null)&#123; n=n.next; &#125; //创建新结点，保存元素t Node newNode = new Node(t, null); //让当前最后一个结点指向新结点 n.next=newNode; //元素的个数+1 N++; &#125; //向指定位置i出，添加元素t public void insert(int i, T t) &#123; //找到i位置前一个结点 Node pre = head; for(int index=0;index&lt;=i-1;index++)&#123; pre=pre.next; &#125; //找到i位置的结点 Node curr = pre.next; //创建新结点，并且新结点需要指向原来i位置的结点 Node newNode = new Node(t, curr); //原来i位置的前一个节点指向新结点即可 pre.next=newNode; //元素的个数+1 N++; &#125; //删除指定位置i处的元素，并返回被删除的元素 public T remove(int i) &#123; //找到i位置的前一个节点 Node pre = head; for(int index=0;index&lt;=i-1;i++)&#123; pre=pre.next; &#125; //要找到i位置的结点 Node curr = pre.next; //找到i位置的下一个结点 Node nextNode = curr.next; //前一个结点指向下一个结点 pre.next=nextNode; //元素个数-1 N--; return curr.item; &#125; //查找元素t在链表中第一次出现的位置 public int indexOf(T t) &#123; //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，就找到了 Node n = head; for(int i=0;n.next!=null;i++)&#123; n=n.next; if (n.item.equals(t))&#123; return i; &#125; &#125; return -1; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new LIterator(); &#125; private class LIterator implements Iterator&#123; private Node n; public LIterator()&#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n = n.next; return n.item; &#125; &#125; //用来反转整个链表 public void reverse()&#123; //判断当前链表是否为空链表，如果是空链表，则结束运行，如果不是，则调用重载的reverse方法完成反转 if (isEmpty())&#123; return; &#125; reverse(head.next); &#125; //反转指定的结点curr，并把反转后的结点返回 public Node reverse(Node curr)&#123; if (curr.next==null)&#123; head.next=curr; return curr; &#125; //递归的反转当前结点curr的下一个结点；返回值就是链表反转后，当前结点的上一个结点 Node pre = reverse(curr.next); //让返回的结点的下一个结点变为当前结点curr； pre.next=curr; //把当前结点的下一个结点变为null curr.next=null; return curr; &#125; &#125; 测试 public class LinkListTest &#123; public static void main(String[] args) &#123; //创建顺序表对象 LinkList&lt;String&gt; sl = new LinkList&lt;&gt;(); //测试插入 sl.insert(&quot;姚明&quot;); sl.insert(&quot;科比&quot;); sl.insert(&quot;麦迪&quot;); sl.insert(1,&quot;詹姆斯&quot;); for (String s : sl) &#123; System.out.println(s); &#125; System.out.println(&quot;------------------------------------------&quot;); //测试获取 String getResult = sl.get(1); System.out.println(&quot;获取索引1处的结果为：&quot;+getResult); //测试删除 String removeResult = sl.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); //测试清空 sl.clear(); System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length()); &#125; &#125; 双向链表 双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。 实现基本API、遍历。 public class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt; &#123; //首结点 private Node head; //最后一个结点 private Node last; //链表的长度 private int N; //结点类 private class Node&#123; public Node(T item, Node pre, Node next) &#123; this.item = item; this.pre = pre; this.next = next; &#125; //存储数据 public T item; //指向上一个结点 public Node pre; //指向下一个结点 public Node next; &#125; public TowWayLinkList() &#123; //初始化头结点和尾结点 this.head = new Node(null,null,null); this.last=null; //初始化元素个数 this.N=0; &#125; //清空链表 public void clear()&#123; this.head.next=null; this.head.pre=null; this.head.item=null; this.last=null; this.N=0; &#125; //获取链表长度 public int length()&#123; return N; &#125; //判断链表是否为空 public boolean isEmpty()&#123; return N==0; &#125; //获取第一个元素 public T getFirst()&#123; if (isEmpty())&#123; return null; &#125; return head.next.item; &#125; //获取最后一个元素 public T getLast()&#123; if (isEmpty())&#123; return null; &#125; return last.item; &#125; //插入元素t public void insert(T t)&#123; if (isEmpty())&#123; //如果链表为空： //创建新的结点 Node newNode = new Node(t,head, null); //让新结点称为尾结点 last=newNode; //让头结点指向尾结点 head.next=last; &#125;else &#123; //如果链表不为空 Node oldLast = last; //创建新的结点 Node newNode = new Node(t, oldLast, null); //让当前的尾结点指向新结点 oldLast.next=newNode; //让新结点称为尾结点 last = newNode; &#125; //元素个数+1 N++; &#125; //向指定位置i处插入元素t public void insert(int i,T t)&#123; //找到i位置的前一个结点 Node pre = head; for(int index=0;index&lt;i;index++)&#123; pre=pre.next; &#125; //找到i位置的结点 Node curr = pre.next; //创建新结点 Node newNode = new Node(t, pre, curr); //让i位置的前一个结点的下一个结点变为新结点 pre.next=newNode; //让i位置的前一个结点变为新结点 curr.pre=newNode; //元素个数+1 N++; &#125; //获取指定位置i处的元素 public T get(int i)&#123; Node n = head.next; for(int index=0;index&lt;i;index++)&#123; n=n.next; &#125; return n.item; &#125; //找到元素t在链表中第一次出现的位置 public int indexOf(T t)&#123; Node n = head; for(int i=0;n.next!=null;i++)&#123; n=n.next; if (n.next.equals(t))&#123; return i; &#125; &#125; return -1; &#125; //删除位置i处的元素，并返回该元素 public T remove(int i)&#123; //找到i位置的前一个结点 Node pre = head; for(int index=0;index&lt;i;index++)&#123; pre=pre.next; &#125; //找到i位置的结点 Node curr = pre.next; //找到i位置的下一个结点 Node nextNode= curr.next; //让i位置的前一个结点的下一个结点变为i位置的下一个结点 pre.next=nextNode; //让i位置的下一个结点的上一个结点变为i位置的前一个结点 nextNode.pre=pre; //元素的个数-1 N--; return curr.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new TIterator(); &#125; private class TIterator implements Iterator&#123; private Node n; public TIterator()&#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; &#125; 测试 public class TowWayLinkListTest &#123; public static void main(String[] args) &#123; //创建双向链表对象 TowWayLinkList&lt;String&gt; sl = new TowWayLinkList&lt;&gt;(); //测试插入 sl.insert(&quot;姚明&quot;); sl.insert(&quot;科比&quot;); sl.insert(&quot;麦迪&quot;); sl.insert(1,&quot;詹姆斯&quot;); for (String s : sl) &#123; System.out.println(s); &#125; System.out.println(&quot;--------------------------------------&quot;); System.out.println(&quot;第一个元素是：&quot;+sl.getFirst()); System.out.println(&quot;最后一个元素是：&quot;+sl.getLast()); System.out.println(&quot;------------------------------------------&quot;); //测试获取 String getResult = sl.get(1); System.out.println(&quot;获取索引1处的结果为：&quot;+getResult); //测试删除 String removeResult = sl.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); //测试清空 sl.clear(); System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length()); &#125; &#125; java中LinkedList集合也是使用双向链表实现，结点类有三个域，并提供了增删改查等相关方法。 链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,同时它并没有涉及的元素的交换。 相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。 快慢指针 快慢指针获取中间值。slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。 public class FastSlowTest &#123; public static void main(String[] args) throws Exception &#123; //创建结点 Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null); Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null); Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null); Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null); Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null); Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null); Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null); //完成结点之间的指向 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven; //查找中间值 String mid = getMid(first); System.out.println(&quot;中间值为：&quot;+mid); &#125; /** * @param first 链表的首结点 * @return 链表的中间结点的值 */ public static String getMid(Node&lt;String&gt; first) &#123; //定义两个指针 Node&lt;String&gt; fast = first; Node&lt;String&gt; slow = first; //使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值 while(fast!=null &amp;&amp;fast.next!=null)&#123; //变化fast的值和slow的值 fast = fast.next.next; slow=slow.next; &#125; return slow.item; &#125; //结点类 private static class Node&lt;T&gt; &#123; //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; &#125; 快慢指针检查是否有环。两个指针有速度差，那么迟早两个指针会相遇，只要相遇那么就说明有环。 public class CircleListCheckTest &#123; public static void main(String[] args) throws Exception &#123; //创建结点 Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null); Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null); Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null); Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null); Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null); Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null); Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null); //完成结点之间的指向 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven; // //产生环 // seven.next = third; //判断链表是否有环 boolean circle = isCircle(first); System.out.println(&quot;first链表中是否有环：&quot;+circle); &#125; /** * 判断链表中是否有环 * @param first 链表首结点 * @return ture为有环，false为无环 */ public static boolean isCircle(Node&lt;String&gt; first) &#123; //定义快慢指针 Node&lt;String&gt; fast = first; Node&lt;String&gt; slow = first; //遍历链表，如果快慢指针指向了同一个结点，那么证明有环 while(fast!=null &amp;&amp; fast.next!=null)&#123; //变换fast和slow fast = fast.next.next; slow = slow.next; if (fast.equals(slow))&#123; return true; &#125; &#125; return false; &#125; //结点类 private static class Node&lt;T&gt; &#123; //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; &#125; 快慢指针查找有环链表入口。当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。 public class CircleListInTest &#123; public static void main(String[] args) throws Exception &#123; Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null); Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null); Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null); Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null); Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null); Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null); Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null); //完成结点之间的指向 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven; //产生环 seven.next = third; //查找环的入口结点 Node&lt;String&gt; entrance = getEntrance(first); System.out.println(&quot;first链表中环的入口结点元素为：&quot;+entrance.item); &#125; /** * 查找有环链表中环的入口结点 * @param first 链表首结点 * @return 环的入口结点 */ public static Node getEntrance(Node&lt;String&gt; first) &#123; //定义快慢指针 Node&lt;String&gt; fast = first; Node&lt;String&gt; slow = first; Node&lt;String&gt; temp = null; //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口 while(fast!=null &amp;&amp; fast.next!=null)&#123; //变换快慢指针 fast = fast.next.next; slow = slow.next; //判断快慢指针是否相遇 if (fast.equals(slow))&#123; temp = first; continue; &#125; //让临时结点变换 if (temp!=null)&#123; temp = temp.next; //判断临时指针是否和慢指针相遇 if (temp.equals(slow))&#123; break; &#125; &#125; &#125; return temp; &#125; //结点类 private static class Node&lt;T&gt; &#123; //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; &#125; 循环链表 在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。 约瑟夫问题 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；使用计数器count，记录当前报数的值；遍历链表，每循环一次，count++；判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0。 public class JosephTest &#123; public static void main(String[] args) &#123; //解决约瑟夫问题 //1.构建循环链表，包含41个结点，分别存储1~41之间的值 //用来就首结点 Node&lt;Integer&gt; first = null; //用来记录前一个结点 Node&lt;Integer&gt; pre = null; for(int i = 1;i&lt;=41;i++)&#123; //如果是第一个结点 if (i==1)&#123; first = new Node&lt;&gt;(i,null); pre = first; continue; &#125; //如果不是第一个结点 Node&lt;Integer&gt; newNode = new Node&lt;&gt;(i, null); pre.next=newNode; pre=newNode; //如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first,变为循环链表了 if (i==41)&#123; pre.next=first; &#125; &#125; //2.需要count计数器，模拟报数 int count=0; //3.遍历循环链表 //记录每次遍历拿到的结点，默认从首结点开始 Node&lt;Integer&gt; n = first; //记录当前结点的上一个结点 Node&lt;Integer&gt; before = null; while(n!=n.next)&#123; //模拟报数 count++; //判断当前报数是不是为3 if (count==3)&#123; //如果是3，则把当前结点删除调用，打印当前结点，重置count=0，让当前结点n后移 before.next=n.next; System.out.print(n.item+&quot;,&quot;); count=0; n=n.next; &#125;else&#123; //如果不是3，让before变为当前结点，让当前结点后移； before=n; n=n.next; &#125; &#125; //打印最后一个元素 System.out.println(n.item); &#125; //结点类 private static class Node&lt;T&gt; &#123; //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; &#125; 栈 栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。 我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。 代码实现 压栈、弹栈、遍历。 public class Stack&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录首结点 private Node head; //栈中元素的个数 private int N; private class Node&#123; public T item; public Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; public Stack() &#123; this.head = new Node(null,null); this.N=0; &#125; //判断当前栈中元素个数是否为0 public boolean isEmpty()&#123; return N==0; &#125; //获取栈中元素的个数 public int size()&#123; return N; &#125; //把t元素压入栈 public void push(T t)&#123; //找到首结点指向的第一个结点 Node oldFirst = head.next; //创建新结点 Node newNode = new Node(t, null); //让首结点指向新结点 head.next = newNode; //让新结点指向原来的第一个结点 newNode.next=oldFirst; //元素个数+1； N++; &#125; //弹出栈顶元素 public T pop()&#123; //找到首结点指向的第一个结点 Node oldFirst = head.next; if (oldFirst==null)&#123; return null; &#125; //让首结点指向原来第一个结点的下一个结点 head.next=oldFirst.next; //元素个数-1； N--; return oldFirst.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new SIterator(); &#125; private class SIterator implements Iterator&#123; private Node n; public SIterator()&#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n = n.next; return n.item; &#125; &#125; &#125;- 测试 public class StackTest &#123; public static void main(String[] args) &#123; //创建栈对象 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); //测试压栈 stack.push(&quot;a&quot;); stack.push(&quot;b&quot;); stack.push(&quot;c&quot;); stack.push(&quot;d&quot;); for (String item : stack) &#123; System.out.println(item); &#125; System.out.println(&quot;------------------------------&quot;); //测试弹栈 String result = stack.pop(); System.out.println(&quot;弹出的元素是：&quot;+result); System.out.println(&quot;剩余的元素个数：&quot;+stack.size()); &#125; &#125; 括号匹配问题 给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。 创建一个栈用来存储左括号；从左往右遍历字符串，拿到每一个字符；判断该字符是不是左括号，如果是，放入栈中存储；判断该字符是不是右括号，如果不是，继续下一次循环；如果该字符是右括号，则从栈中弹出一个元素t；判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号；循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配。 public class BracketsMatchTest &#123; public static void main(String[] args) &#123; String str = &quot;上海(长安)())&quot;; boolean match = isMatch(str); System.out.println(str+&quot;中的括号是否匹配：&quot;+match); &#125; /** * 判断str中的括号是否匹配 * @param str 括号组成的字符串 * @return 如果匹配，返回true，如果不匹配，返回false */ public static boolean isMatch(String str)&#123; //1.创建栈对象，用来存储左括号 Stack&lt;String&gt; chars = new Stack&lt;&gt;(); //2.从左往右遍历字符串 for (int i = 0; i &lt; str.length(); i++) &#123; String currChar = str.charAt(i)+ &quot;&quot;; //3.判断当前字符是否为左括号，如果是，则把字符放入到栈中 if (currChar.equals(&quot;(&quot;))&#123; chars.push(currChar); &#125;else if(currChar.equals(&quot;)&quot;))&#123; //4.继续判断当前字符是否是有括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null,如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号 String pop = chars.pop(); if (pop==null)&#123; return false; &#125; &#125; &#125; //5.判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配 if (chars.size()==0)&#123; return true; &#125;else&#123; return false; &#125; &#125; &#125; 逆波兰表达式求值 创建一个栈对象oprands存储操作数；从左往右遍历逆波兰表达式，得到每一个字符串；判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中；如果是运算符，则从oprands栈中弹出两个操作数o1,o2；使用该运算符计算o1和o2，得到结果result；把该结果压入oprands栈中 ；遍历结束后，拿出栈中最终的结果返回。 public class ReversePolishNotationTest &#123; public static void main(String[] args) &#123; //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9 String[] notation = &#123;&quot;3&quot;, &quot;17&quot;, &quot;15&quot;, &quot;-&quot;, &quot;*&quot;, &quot;18&quot;, &quot;6&quot;, &quot;/&quot;, &quot;+&quot;&#125;; int result = caculate(notation); System.out.println(&quot;逆波兰表达式的结果为：&quot; + result); &#125; /** * @param notaion 逆波兰表达式的数组表示方式 * @return 逆波兰表达式的计算结果 */ public static int caculate(String[] notaion) &#123; //1.定义一个栈，用来存储操作数 Stack&lt;Integer&gt; oprands = new Stack&lt;&gt;(); //2.从左往右遍历逆波兰表达式，得到每一个元素 for (int i = 0; i &lt; notaion.length; i++) &#123; String curr = notaion[i]; //3.判断当前元素是运算符还是操作数 Integer o1; Integer o2; Integer result; switch (curr) &#123; case &quot;+&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 + o1; oprands.push(result); break; case &quot;-&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 - o1; oprands.push(result); break; case &quot;*&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 * o1; oprands.push(result); break; case &quot;/&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 / o1; oprands.push(result); break; default: //5.操作数，把该操作数放入到栈中； oprands.push(Integer.parseInt(curr)); break; &#125; &#125; //6.得到栈中最后一个元素，就是逆波兰表达式的结果 int result = oprands.pop(); return result; &#125; &#125; 队列 队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。 实现 插入、删除、遍历。 public class Queue&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录首结点 private Node head; //记录最后一个结点 private Node last; //记录队列中元素的个数 private int N; private class Node&#123; public T item; public Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; public Queue() &#123; this.head = new Node(null,null); this.last=null; this.N=0; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return N==0; &#125; //返回队列中元素的个数 public int size()&#123; return N; &#125; //向队列中插入元素t public void enqueue(T t)&#123; if (last==null)&#123; //当前尾结点last为null last= new Node(t,null); head.next=last; &#125; else &#123; //当前尾结点last不为null Node oldLast = last; last = new Node(t, null); oldLast.next=last; &#125; //元素个数+1 N++; &#125; //从队列中拿出一个元素 public T dequeue()&#123; if (isEmpty())&#123; return null; &#125; Node oldFirst = head.next; head.next = oldFirst.next; N--; //因为出队列其实是在删除元素，因此如果队列中的元素被删除完了，需要重置last=null; if (isEmpty())&#123; last=null; &#125; return oldFirst.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new QIterator(); &#125; private class QIterator implements Iterator&#123; private Node n; public QIterator()&#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n = n.next; return n.item; &#125; &#125; &#125; 测试 public class QueueTest &#123; public static void main(String[] args) &#123; //创建队列对象 Queue&lt;String&gt; q = new Queue&lt;&gt;(); //测试队列的enqueue方法 q.enqueue(&quot;a&quot;); q.enqueue(&quot;b&quot;); q.enqueue(&quot;c&quot;); q.enqueue(&quot;d&quot;); for (String str : q) &#123; System.out.println(str); &#125; System.out.println(&quot;-------------------------------&quot;); //测试队列的dequeue方法 String result = q.dequeue(); System.out.println(&quot;出队列的元素是：&quot;+result); System.out.println(&quot;剩余的元素个数：&quot;+q.size()); &#125; &#125; 符号表 符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。符号表中，键具有唯一性。 实现 public class SymbolTable&lt;Key,Value&gt; &#123; //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node&#123; //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key, Value value, Node next) &#123; this.key = key; this.value = value; this.next = next; &#125; &#125; public SymbolTable() &#123; this.head = new Node(null,null,null); this.N=0; &#125; //获取符号表中键值对的个数 public int size()&#123; return N; &#125; //往符号表中插入键值对 public void put(Key key,Value value)&#123; //符号表中已经存在了键为key的键值对，那么只需要找到该结点，替换值为value即可 Node n = head; while(n.next!=null)&#123; //变换n n = n.next; //判断n结点存储的键是否为key，如果是，则替换n结点的值 if (n.key.equals(key))&#123; n.value = value; return; &#125; &#125; //如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部 head.next=新结点即可 Node newNode = new Node(key, value, null); Node oldFirst = head.next; newNode.next = oldFirst; head.next = newNode; //元素个数+1； N++; &#125; //删除符号表中键为key的键值对 public void delete(Key key)&#123; //找到键为key的结点，把该结点从链表中删除 Node n = head; while(n.next!=null)&#123; //判断n结点的下一个结点的键是否为key，如果是，就删除该结点 if (n.next.key.equals(key))&#123; n.next = n.next.next; N--; return; &#125; //变换n n = n.next; &#125; &#125; //从符号表中获取key对应的值 public Value get(Key key)&#123; //找到键为key的结点 Node n = head; while(n.next!=null)&#123; //变换n n = n.next; if (n.key.equals(key))&#123; return n.value; &#125; &#125; return null; &#125; &#125; 测试 public class SymbolTableTest &#123; public static void main(String[] args) &#123; //创建符号表对象 SymbolTable&lt;Integer, String&gt; symbolTable = new SymbolTable&lt;&gt;(); //测试put方法（插入,替换） symbolTable.put(1,&quot;乔峰&quot;); symbolTable.put(2,&quot;虚竹&quot;); symbolTable.put(3,&quot;段誉&quot;); System.out.println(&quot;插入完毕后，元素的个数为:&quot;+symbolTable.size()); symbolTable.put(2, &quot;慕容复&quot;); System.out.println(&quot;替换完毕后的元素的个数为:&quot;+symbolTable.size()); //测试get方法 System.out.println(&quot;替换完毕后，键2对应的值为:&quot;+symbolTable.get(2)); //测试删除方法 symbolTable.delete(2); System.out.println(&quot;删除完毕后，元素的个数:&quot;+symbolTable.size()); &#125; &#125; 有序符号表 要根据键的大小进行排序，插入数据时要考虑顺序。 public class OrderSymbolTable&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node&#123; //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key, Value value, Node next) &#123; this.key = key; this.value = value; this.next = next; &#125; &#125; public OrderSymbolTable() &#123; this.head = new Node(null,null,null); this.N=0; &#125; //获取符号表中键值对的个数 public int size()&#123; return N; &#125; //往符号表中插入键值对 public void put(Key key,Value value)&#123; //定义两个Node变量，分别记录当前结点和当前结点的上一个结点 Node curr = head.next; Node pre = head; while(curr!=null &amp;&amp; key.compareTo(curr.key)&gt;0)&#123; //变换当前结点和前一个结点即可 pre = curr; curr = curr.next; &#125; //如果当前结点curr的键和要插入的key一样，则替换 if (curr!=null &amp;&amp; key.compareTo(curr.key)==0)&#123; curr.value = value; return; &#125; //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前 Node newNode = new Node(key, value, curr); pre.next = newNode; //元素的个数+1； N++; &#125; //删除符号表中键为key的键值对 public void delete(Key key)&#123; //找到键为key的结点，把该结点从链表中删除 Node n = head; while(n.next!=null)&#123; //判断n结点的下一个结点的键是否为key，如果是，就删除该结点 if (n.next.key.equals(key))&#123; n.next = n.next.next; N--; return; &#125; //变换n n = n.next; &#125; &#125; //从符号表中获取key对应的值 public Value get(Key key)&#123; //找到键为key的结点 Node n = head; while(n.next!=null)&#123; //变换n n = n.next; if (n.key.equals(key))&#123; return n.value; &#125; &#125; return null; &#125; &#125; 测试 public class OrderSymbolTableTest &#123; public static void main(String[] args) &#123; //创建有序符号表对象 OrderSymbolTable&lt;Integer, String&gt; table = new OrderSymbolTable&lt;&gt;(); table.put(1,&quot;张三&quot;); table.put(2,&quot;李四&quot;); table.put(4,&quot;赵六&quot;); table.put(7,&quot;田七&quot;); table.put(3,&quot;王五&quot;); &#125; &#125; 二叉树定义 树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。树具有以下特点：每个结点有零个或多个子结点；没有父结点的结点为根结点；每一个非根结点只有一个父结点；每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树。 结点的度：一个结点含有的子树的个数称为该结点的度。 叶结点：度为0的结点称为叶结点，也可以叫做终端结点。 分支结点：度不为0的结点称为分支结点，也可以叫做非终端结点。 结点的层次：从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。 结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。 树的度：树中所有结点的度的最大值。 树的高度(深度)：树中结点的最大层次。 森林：m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树。 孩子结点：一个结点的直接后继结点称为该结点的孩子结点。 双亲结点(父结点)：一个结点的直接前驱称为该结点的双亲结点。 兄弟结点：同一双亲结点的孩子结点间互称兄弟结点。 二叉树就是度不超过2的树(每个结点最多有两个子结点)。 一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。 完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 二叉查找树基于链表的实现 插入方法put实现思想：如果当前树中没有任何一个结点，则直接把新结点当做根结点使用。如果当前树不为空，则从根结点开始：如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。 查询方法get实现思想：从根节点开始：如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；如果要查询的key等于当前结点的key，则树中返回当前结点的value。 删除方法delete实现思想：找到被删除结点；找到被删除结点右子树中的最小结点minNode；删除右子树中的最小结点；让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树；让被删除结点的父节点指向最小结点minNode。 查找最小键、查找最大键。 把树由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式： 前序遍历：先访问根结点，然后再访问左子树，最后访问右子树。中序遍历：先访问左子树，中间访问根节点，最后访问右子树。后序遍历：先访问左子树，再访问右子树，最后访问根节点。 前序遍历步骤：把当前结点的key放入到队列中;找到当前结点的左子树，如果不为空，递归遍历左子树；找到当前结点的右子树，如果不为空，递归遍历右子树。 中序遍历实现步骤：找到当前结点的左子树，如果不为空，递归遍历左子树；把当前结点的key放入到队列中;找到当前结点的右子树，如果不为空，递归遍历右子树。 后序遍历实现步骤：找到当前结点的左子树，如果不为空，递归遍历左子树；找到当前结点的右子树，如果不为空，递归遍历右子树；把当前结点的key放入到队列中。 层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值。实现步骤：创建队列，存储每一层的结点；使用循环从队列中弹出一个结点：获取当前结点的key；如果当前结点的左子结点不为空，则把左子结点放入到队列中；如果当前结点的右子结点不为空，则把右子结点放入到队列中。 最大深度：如果根结点为空，则最大深度为0；计算左子树的最大深度；计算右子树的最大深度；当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1。 public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; //记录根结点 private Node root; //记录树中元素的个数 private int N; private class Node &#123; //存储键 public Key key; //存储值 private Value value; //记录左子结点 public Node left; //记录右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; //获取树中元素的个数 public int size() &#123; return N; &#125; //向树中添加元素key-value public void put(Key key, Value value) &#123; root = put(root, key, value); &#125; //向指定的树x中添加key-value,并返回添加元素后新的树 private Node put(Node x, Key key, Value value) &#123; //如果x子树为空， if (x==null)&#123; N++; return new Node(key,value, null,null); &#125; //如果x子树不为空 //比较x结点的键和key的大小： int cmp = key.compareTo(x.key); if (cmp&gt;0)&#123; //如果key大于x结点的键，则继续找x结点的右子树 x.right = put(x.right,key,value); &#125;else if(cmp&lt;0)&#123; //如果key小于x结点的键，则继续找x结点的左子树 x.left = put(x.left,key,value); &#125;else&#123; //如果key等于x结点的键，则替换x结点的值为value即可 x.value = value; &#125; return x; &#125; //查询树中指定key对应的value public Value get(Key key) &#123; return get(root,key); &#125; //从指定的树x中，查找key对应的值 public Value get(Node x, Key key) &#123; //x树为null if (x==null)&#123; return null; &#125; //x树不为null //比较key和x结点的键的大小 int cmp = key.compareTo(x.key); if (cmp&gt;0)&#123; //如果key大于x结点的键，则继续找x结点的右子树 return get(x.right,key); &#125;else if(cmp&lt;0)&#123; //如果key小于x结点的键，则继续找x结点的左子树 return get(x.left,key); &#125;else&#123; //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可 return x.value; &#125; &#125; //删除树中key对应的value public void delete(Key key) &#123; delete(root, key); &#125; //删除指定树x中的key对应的value，并返回删除后的新树 public Node delete(Node x, Key key) &#123; //x树为null if (x==null)&#123; return null; &#125; //x树不为null int cmp = key.compareTo(x.key); if (cmp&gt;0)&#123; //如果key大于x结点的键，则继续找x结点的右子树 x.right = delete(x.right,key); &#125;else if(cmp&lt;0)&#123; //如果key小于x结点的键，则继续找x结点的左子树 x.left = delete(x.left,key); &#125;else&#123; //如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x； //让元素个数-1 N--; //得找到右子树中最小的结点 if (x.right==null)&#123; return x.left; &#125; if (x.left==null)&#123; return x.right; &#125; Node minNode = x.right; while(minNode.left!=null)&#123; minNode = minNode.left; &#125; //删除右子树中最小的结点 Node n = x.right; while(n.left!=null)&#123; if (n.left.left==null)&#123; n.left=null; &#125;else&#123; //变换n结点即可 n = n.left; &#125; &#125; //让x结点的左子树成为minNode的左子树 minNode.left = x.left; //让x结点的右子树成为minNode的右子树 minNode.right = x.right; //让x结点的父结点指向minNode x = minNode; &#125; return x; &#125; //查找整个树中最小的键 public Key min()&#123; return min(root).key; &#125; //在指定树x中找出最小键所在的结点 private Node min(Node x)&#123; //需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点 if (x.left!=null)&#123; return min(x.left); &#125;else&#123; return x; &#125; &#125; //在整个树中找到最大的键 public Key max()&#123; return max(root).key; &#125; //在指定的树x中，找到最大的键所在的结点 public Node max(Node x)&#123; //判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点 if (x.right!=null)&#123; return max(x.right); &#125;else&#123; return x; &#125; &#125; //获取整个树中所有的键 public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); preErgodic(root, keys); return keys; &#125; //获取指定树x的所有键，并放到keys队列中 private void preErgodic(Node x,Queue&lt;Key&gt; keys)&#123; if (x==null)&#123; return; &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的左子树 if (x.left!=null)&#123; preErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if (x.right!=null)&#123; preErgodic(x.right,keys); &#125; &#125; //使用中序遍历获取树中所有的键 public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); midErgodic(root,keys); return keys; &#125; //使用中序遍历，获取指定树x中所有的键，并存放到key中 private void midErgodic(Node x,Queue&lt;Key&gt; keys)&#123; if (x==null)&#123; return; &#125; //先递归，把左子树中的键放到keys中 if (x.left!=null)&#123; midErgodic(x.left,keys); &#125; //把当前结点x的键放到keys中 keys.enqueue(x.key); //在递归，把右子树中的键放到keys中 if(x.right!=null)&#123; midErgodic(x.right,keys); &#125; &#125; //使用后序遍历，把整个树中所有的键返回 public Queue&lt;Key&gt; afterErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); afterErgodic(root,keys); return keys; &#125; //使用后序遍历，把指定树x中所有的键放入到keys中 private void afterErgodic(Node x,Queue&lt;Key&gt; keys)&#123; if (x==null)&#123; return ; &#125; //通过递归把左子树中所有的键放入到keys中 if (x.left!=null)&#123; afterErgodic(x.left,keys); &#125; //通过递归把右子树中所有的键放入到keys中 if (x.right!=null)&#123; afterErgodic(x.right,keys); &#125; //把x结点的键放入到keys中 keys.enqueue(x.key); &#125; //使用层序遍历，获取整个树中所有的键 public Queue&lt;Key&gt; layerErgodic()&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes = new Queue&lt;&gt;(); //默认，往队列中放入根结点 nodes.enqueue(root); while(!nodes.isEmpty())&#123; //从队列中弹出一个结点，把key放入到keys中 Node n = nodes.dequeue(); keys.enqueue(n.key); //判断当前结点还有没有左子结点，如果有，则放入到nodes中 if (n.left!=null)&#123; nodes.enqueue(n.left); &#125; //判断当前结点还有没有右子结点，如果有，则放入到nodes中 if (n.right!=null)&#123; nodes.enqueue(n.right); &#125; &#125; return keys; &#125; //获取整个树的最大深度 public int maxDepth()&#123; return maxDepth(root); &#125; //获取指定树x的最大深度 private int maxDepth(Node x)&#123; if (x==null)&#123; return 0; &#125; //x的最大深度 int max=0; //左子树的最大深度 int maxL=0; //右子树的最大深度 int maxR=0; //计算x结点左子树的最大深度 if (x.left!=null)&#123; maxL = maxDepth(x.left); &#125; //计算x结点右子树的最大深度 if (x.right!=null)&#123; maxR = maxDepth(x.right); &#125; //比较左子树最大深度和右子树最大深度，取较大值+1即可 max = maxL&gt;maxR?maxL+1:maxR+1; return max; &#125; &#125; 代码测试 public class BinaryTreeTest &#123; public static void main(String[] args) &#123; //创建二叉查找树对象 BinaryTree&lt;Integer, String&gt; tree = new BinaryTree&lt;&gt;(); //测试插入 tree.put(1,&quot;张三&quot;); tree.put(2,&quot;李四&quot;); tree.put(3,&quot;王五&quot;); System.out.println(&quot;插入完毕后元素的个数：&quot;+tree.size()); //测试获取 System.out.println(&quot;键2对应的元素是：&quot;+tree.get(2)); //测试删除 tree.delete(3); System.out.println(&quot;删除后的元素个数：&quot;+tree.size()); System.out.println(&quot;删除后键3对应的元素:&quot;+tree.get(3)); &#125; &#125; 遍历测试 public class BinaryTreeErgodicTest &#123; /*//测试前序遍历 public static void main(String[] args) &#123; //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.preErgodic(); for (String key : keys) &#123; String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; &#125;*/ //测试中序遍历 /* public static void main(String[] args) &#123; //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.midErgodic(); for (String key : keys) &#123; String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; &#125;*/ //测试后序遍历 /*public static void main(String[] args) &#123; //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.afterErgodic(); for (String key : keys) &#123; String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; &#125;*/ //测试层序遍历 public static void main(String[] args) &#123; //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //遍历 Queue&lt;String&gt; keys = tree.layerErgodic(); for (String key : keys) &#123; String value = tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; &#125; &#125; 最大深度测试 public class BinaryTreeMaxDepthTest &#123; public static void main(String[] args) &#123; //创建树对象 BinaryTree&lt;String, String&gt; tree = new BinaryTree&lt;&gt;(); //往树中添加数据 tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); int maxDepth = tree.maxDepth(); System.out.println(maxDepth); &#125; &#125; 折纸问题 纸条对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up。 根结点为下折痕；每一个结点的左子结点为下折痕；每一个结点的右子结点为上折痕。 public class PagerFoldingTest &#123; public static void main(String[] args) &#123; //模拟这只过程，产生树 Node&lt;String&gt; tree = createTree(2); //遍历树，打印每个结点 printTree(tree); &#125; //通过模拟对折N次纸，产生树 public static Node&lt;String&gt; createTree(int N)&#123; //定义根结点 Node&lt;String&gt; root=null; for (int i = 0; i &lt; N; i++) &#123; //1.当前是第一次对折 if (i==0)&#123; root = new Node&lt;&gt;(&quot;down&quot;,null,null); continue; &#125; //2.当前不是第一次对折 //定义一个辅助队列，通过层序遍历的思想，找到叶子结点，叶子结点添加子节点 Queue&lt;Node&gt; queue = new Queue&lt;&gt;(); queue.enqueue(root); //循环遍历队列 while(!queue.isEmpty())&#123; //从队列中弹出一个结点 Node&lt;String&gt; tmp = queue.dequeue(); //如果有左子结点，则把左子结点放入到队列中 if (tmp.left!=null)&#123; queue.enqueue(tmp.left); &#125; //如果有右子结点，则把右子结点放入到队列中 if (tmp.right!=null)&#123; queue.enqueue(tmp.right); &#125; //如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可 if (tmp.left==null &amp;&amp; tmp.right==null)&#123; tmp.left = new Node&lt;String&gt;(&quot;down&quot;, null,null); tmp.right = new Node&lt;String&gt;(&quot;up&quot;,null,null); &#125; &#125; &#125; return root; &#125; //打印树中每个结点到控制台 public static void printTree(Node&lt;String&gt; root)&#123; //需要使用中序遍历完成 if (root==null)&#123; return; &#125; //打印左子树的每个结点 if (root.left!=null)&#123; printTree(root.left); &#125; //打印当前结点 System.out.print(root.item+&quot; &quot;); //打印右子树的每个结点 if (root.right!=null)&#123; printTree(root.right); &#125; &#125; //结点类 private static class Node&lt;T&gt;&#123; public T item;//存储元素 public Node left; public Node right; public Node(T item, Node left, Node right) &#123; this.item = item; this.left = left; this.right = right; &#125; &#125; &#125; 堆 堆通常可以被看做是一棵完全二叉树的数组对象。 完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。 二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。 如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。 每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟之前的二叉查找树是有区别的。 API实现 如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。 当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。 public class Heap&lt;T extends Comparable&lt;T&gt;&gt; &#123; //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public Heap(int capacity) &#123; this.items= (T[]) new Comparable[capacity+1]; this.N=0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i,int j)&#123; return items[i].compareTo(items[j])&lt;0; &#125; //交换堆中i索引和j索引处的值 private void exch(int i,int j)&#123; T temp = items[i]; items[i] = items[j]; items[j] = temp; &#125; //往堆中插入一个元素 public void insert(T t)&#123; items[++N]=t; swim(N); &#125; //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k)&#123; //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置 while(k&gt;1)&#123; //比较当前结点和其父结点 if (less(k/2,k))&#123; exch(k/2,k); &#125; k = k/2; &#125; &#125; //删除堆中最大的元素,并返回这个最大元素 public T delMax()&#123; T max = items[1]; //交换索引1处的元素和最大索引处的元素，让完全二叉树中最右侧的元素变为临时根结点 exch(1,N); //最大索引处的元素删除掉 items[N]=null; //元素个数-1 N--; //通过下沉调整堆，让堆重新有序 sink(1); return max; &#125; //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k)&#123; //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置 while(2*k&lt;=N)&#123; //获取当前结点的子结点中的较大结点 int max;//记录较大结点所在的索引 if (2*k+1&lt;=N)&#123; if (less(2*k,2*k+1))&#123; max=2*k+1; &#125;else&#123; max=2*k; &#125; &#125;else &#123; max = 2*k; &#125; //比较当前结点和较大结点的值 if (!less(k,max))&#123; break; &#125; //交换k索引处的值和max索引处的值 exch(k,max); //变换k的值 k = max; &#125; &#125; public static void main(String[] args) &#123; Heap&lt;String&gt; heap = new Heap&lt;String&gt;(20); heap.insert(&quot;A&quot;); heap.insert(&quot;B&quot;); heap.insert(&quot;C&quot;); heap.insert(&quot;D&quot;); heap.insert(&quot;E&quot;); heap.insert(&quot;F&quot;); heap.insert(&quot;G&quot;); String del; while((del=heap.delMax())!=null)&#123; System.out.print(del+&quot;,&quot;); &#125; &#125; &#125; 测试 public class HeapTest &#123; public static void main(String[] args) &#123; //创建堆对象 Heap&lt;String&gt; heap = new Heap&lt;&gt;(10); //往堆中存入字符串数据 heap.insert(&quot;A&quot;); heap.insert(&quot;B&quot;); heap.insert(&quot;C&quot;); heap.insert(&quot;D&quot;); heap.insert(&quot;E&quot;); heap.insert(&quot;F&quot;); heap.insert(&quot;G&quot;); //通过循环从堆中删除数据 String result = null; while((result = heap.delMax())!=null)&#123; System.out.print(result+&quot; &quot;); &#125; &#125; &#125; 利用堆进行排序 构造堆；得到堆顶元素，这个值就是最大值；交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；重复上述步骤，直到堆中剩一个元素为止。 堆构造过程：创建一个新数组，把原数组0~length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后对扫描到的每一个元素做下沉调整即可。 堆排序过程：对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。将堆顶元素和堆中最后一个元素交换位置；通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)；重复上面步骤，直到堆中剩最后一个元素。 实现： public class HeapSort &#123; //判断heap堆中索引i处的元素是否小于索引j处的元素 private static boolean less(Comparable[] heap, int i, int j) &#123; return heap[i].compareTo(heap[j])&lt;0; &#125; //交换heap堆中i索引和j索引处的值 private static void exch(Comparable[] heap, int i, int j) &#123; Comparable tmp = heap[i]; heap[i] = heap[j]; heap[j] = tmp; &#125; //根据原数组source，构造出堆heap private static void createHeap(Comparable[] source, Comparable[] heap) &#123; //把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆 System.arraycopy(source,0,heap,1,source.length); //对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描) for (int i = (heap.length)/2;i&gt;0;i--)&#123; sink(heap,i,heap.length-1); &#125; &#125; //对source数组中的数据从小到大排序 public static void sort(Comparable[] source) &#123; //构建堆 Comparable[] heap = new Comparable[source.length+1]; createHeap(source,heap); //定义一个变量，记录未排序的元素中最大的索引 int N = heap.length-1; //通过循环，交换1索引处的元素和排序的元素中最大的索引处的元素 while(N!=1)&#123; //交换元素 exch(heap,1,N); //排序交换后最大元素所在的索引，让它不要参与堆的下沉调整 N--; //需要对索引1处的元素进行对的下沉调整 sink(heap,1, N); &#125; //把heap中的数据复制到原数组source中 System.arraycopy(heap,1,source,0,source.length); &#125; //在heap堆中，对target处的元素做下沉，范围是0~range private static void sink(Comparable[] heap, int target, int range)&#123; while(2*target&lt;=range)&#123; //1.找出当前结点的较大的子结点 int max; if (2*target+1&lt;=range)&#123; if (less(heap,2*target,2*target+1))&#123; max = 2*target+1; &#125;else&#123; max = 2*target; &#125; &#125;else&#123; max = 2*target; &#125; //2.比较当前结点的值和较大子结点的值 if (!less(heap,target,max))&#123; break; &#125; exch(heap,target,max); target = max; &#125; &#125; &#125; 测试 public class HeapSortTest &#123; public static void main(String[] args) &#123; //待排序数组 String[] arr = &#123;&quot;S&quot;,&quot;O&quot;,&quot;R&quot;,&quot;T&quot;,&quot;E&quot;,&quot;X&quot;,&quot;A&quot;,&quot;M&quot;,&quot;P&quot;,&quot;L&quot;,&quot;E&quot;&#125;; //通过HeapSort对数组中的元素进行排序 HeapSort.sort(arr); //打印排序后数组中的元素 System.out.println(Arrays.toString(arr)); &#125; &#125; 优先队列最大优先队列 可以获取并删除队列中最大的值。基于堆区实现最大优先队列。 public class MaxPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123; //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public MaxPriorityQueue(int capacity) &#123; this.items = (T[]) new Comparable[capacity+1]; this.N= 0; &#125; //获取队列中元素的个数 public int size() &#123; return N; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i, int j) &#123; return items[i].compareTo(items[j])&lt;0; &#125; //交换堆中i索引和j索引处的值 private void exch(int i, int j) &#123; T tmp = items[i]; items[i] = items[j]; items[j] = tmp; &#125; //往堆中插入一个元素 public void insert(T t) &#123; items[++N] = t; swim(N); &#125; //删除堆中最大的元素,并返回这个最大元素 public T delMax() &#123; T max = items[1]; exch(1,N); N--; sink(1); return max; &#125; //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) &#123; while(k&gt;1)&#123; if (less(k/2,k))&#123; exch(k/2,k); &#125; k = k/2; &#125; &#125; //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) &#123; while(2*k&lt;=N)&#123; int max; if (2*k+1&lt;=N)&#123; if (less(2*k,2*k+1))&#123; max=2*k+1; &#125;else&#123; max = 2*k; &#125; &#125;else &#123; max = 2*k; &#125; if (!less(k,max))&#123; break; &#125; exch(k,max); k = max; &#125; &#125; &#125; 测试 public class MaxPriorityQueueTest &#123; public static void main(String[] args) &#123; //创建优先队列 MaxPriorityQueue&lt;String&gt; queue = new MaxPriorityQueue&lt;&gt;(10); //往队列中存储元素 queue.insert(&quot;A&quot;); queue.insert(&quot;B&quot;); queue.insert(&quot;C&quot;); queue.insert(&quot;D&quot;); queue.insert(&quot;E&quot;); queue.insert(&quot;F&quot;); queue.insert(&quot;G&quot;); //通过循环从队列中获取最大的元素 while(!queue.isEmpty())&#123; String max = queue.delMax(); System.out.print(max+&quot; &quot;); &#125; &#125; &#125; 最小优先队列 可以获取并删除队列中最小的值。基于堆来完成最小优先队列：最小的元素放在数组的索引1处；每个结点的数据总是小于等于它的两个子结点的数据。 public class MinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123; //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public MinPriorityQueue(int capacity) &#123; this.items = (T[]) new Comparable[capacity+1]; this.N=0; &#125; //获取队列中元素的个数 public int size() &#123; return N; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i, int j) &#123; return items[i].compareTo(items[j])&lt;0; &#125; //交换堆中i索引和j索引处的值 private void exch(int i, int j) &#123; T tmp = items[i]; items[i] = items[j]; items[j] = tmp; &#125; //往堆中插入一个元素 public void insert(T t) &#123; items[++N] = t; swim(N); &#125; //删除堆中最小的元素,并返回这个最小元素 public T delMin() &#123; T min = items[1]; exch(1,N); N--; sink(1); return min; &#125; //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) &#123; //通过循环比较当前结点和其父结点的大小 while(k&gt;1)&#123; if (less(k,k/2))&#123; exch(k,k/2); &#125; k = k/2; &#125; &#125; //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) &#123; //通过循环比较当前结点和其子结点中的较小值 while(2*k&lt;=N)&#123; //1.找到子结点中的较小值 int min; if (2*k+1&lt;=N)&#123; if (less(2*k, 2*k+1))&#123; min = 2*k; &#125;else&#123; min = 2*k+1; &#125; &#125;else&#123; min = 2*k; &#125; //2.判断当前结点和较小值的大小 if (less(k,min))&#123; break; &#125; exch(k,min); k = min; &#125; &#125; &#125; 测试 public class MinPriorityQueueTest &#123; public static void main(String[] args) &#123; //创建最小优先队列对象 MinPriorityQueue&lt;String&gt; queue = new MinPriorityQueue&lt;String&gt;(10); //往队列中存数据 queue.insert(&quot;G&quot;); queue.insert(&quot;F&quot;); queue.insert(&quot;E&quot;); queue.insert(&quot;D&quot;); queue.insert(&quot;C&quot;); queue.insert(&quot;B&quot;); queue.insert(&quot;A&quot;); //通过循环获取最小优先队列中的元素 while(!queue.isEmpty())&#123; String min = queue.delMin(); System.out.print(min+&quot; &quot;); &#125; &#125; &#125; 索引优先队列 存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。 用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。 数组int[]pq,来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。 数组int[] qp,用来存储pq的逆序。例如：在pq数组中：pq[1]=6;那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1。 代码实现 public class IndexMinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123; //存储堆中的元素 private T[] items; //保存每个元素在items数组中的索引，pq数组需要堆有序 private int[] pq; //保存qp的逆序，pq的值作为索引，pq的索引作为值 private int[] qp; //记录堆中元素的个数 private int N; public IndexMinPriorityQueue(int capacity) &#123; this.items = (T[]) new Comparable[capacity+1]; this.pq = new int[capacity+1]; this.qp= new int[capacity+1]; this.N = 0; //默认情况下，队列中没有存储任何数据，让qp中的元素都为-1； for (int i = 0; i &lt; qp.length; i++) &#123; qp[i]=-1; &#125; &#125; //获取队列中元素的个数 public int size() &#123; return N; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i, int j) &#123; return items[pq[i]].compareTo(items[pq[j]])&lt;0; &#125; //交换堆中i索引和j索引处的值 private void exch(int i, int j) &#123; //交换pq中的数据 int tmp = pq[i]; pq[i] = pq[j]; pq[j] = tmp; //更新qp中的数据 qp[pq[i]]=i; qp[pq[j]] =j; &#125; //判断k对应的元素是否存在 public boolean contains(int k) &#123; return qp[k] !=-1; &#125; //最小元素关联的索引 public int minIndex() &#123; return pq[1]; &#125; //往队列中插入一个元素,并关联索引i public void insert(int i, T t) &#123; //判断i是否已经被关联，如果已经被关联，则不让插入 if (contains(i))&#123; return; &#125; //元素个数+1 N++; //把数据存储到items对应的i位置处 items[i] = t; //把i存储到pq中 pq[N] = i; //通过qp来记录pq中的i qp[i]=N; //通过堆上浮完成堆的调整 swim(N); &#125; //删除队列中最小的元素,并返回该元素关联的索引 public int delMin() &#123; //获取最小元素关联的索引 int minIndex = pq[1]; //交换pq中索引1处和最大索引处的元素 exch(1,N); //删除qp中对应的内容 qp[pq[N]] = -1; //删除pq最大索引处的内容 pq[N]=-1; //删除items中对应的内容 items[minIndex] = null; //元素个数-1 N--; //下沉调整 sink(1); return minIndex; &#125; //删除索引i关联的元素 public void delete(int i) &#123; //找到i在pq中的索引 int k = qp[i]; //交换pq中索引k处的值和索引N处的值 exch(k,N); //删除qp中的内容 qp[pq[N]] = -1; //删除pq中的内容 pq[N]=-1; //删除items中的内容 items[k]=null; //元素的数量-1 N--; //堆的调整 sink(k); swim(k); &#125; //把与索引i关联的元素修改为为t public void changeItem(int i, T t) &#123; //修改items数组中i位置的元素为t items[i] = t; //找到i在pq中出现的位置 int k = qp[i]; //堆调整 sink(k); swim(k); &#125; //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) &#123; while(k&gt;1)&#123; if (less(k,k/2))&#123; exch(k,k/2); &#125; k = k/2; &#125; &#125; //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) &#123; while(2*k&lt;=N)&#123; //找到子结点中的较小值 int min; if (2*k+1&lt;=N)&#123; if (less(2*k,2*k+1))&#123; min = 2*k; &#125;else&#123; min = 2*k+1; &#125; &#125;else&#123; min = 2*k; &#125; //比较当前结点和较小值 if (less(k,min))&#123; break; &#125; exch(k,min); k = min; &#125; &#125; &#125; 测试代码 public class IndexMinPriorityQueueTest &#123; public static void main(String[] args) &#123; //创建索引最小优先队列对象 IndexMinPriorityQueue&lt;String&gt; queue = new IndexMinPriorityQueue&lt;&gt;(10); //往队列中添加元素 queue.insert(0,&quot;A&quot;); queue.insert(1,&quot;C&quot;); queue.insert(2,&quot;F&quot;); //测试修改 queue.changeItem(2,&quot;B&quot;); //测试删除 while(!queue.isEmpty())&#123; int index = queue.delMin(); System.out.print(index+&quot; &quot;); &#125; &#125; &#125; 平衡树2-3查找树 2-结点：含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点：含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 查找：要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。 向2-结点中插入新键：查找后未找到的节点是一个2-结点，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。 一棵完全平衡的2-3树具有以下性质：任意空链接到根结点的路径长度都是相等的。4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。 直接实现2-3树比较复杂，但是2-3查找树作为一种比较重要的概念和思路对于红黑树、B树和B+树非常重要。 红黑树 红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。 我们将树中的链接分为两种类型：红链接：将两个2-结点连接起来构成一个3-结点。黑链接：则是2-3树中的普通链接。 确切的说，我们将3-结点表示为由一条左斜的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。 红黑树是含有红黑链接并满足下列条件的二叉查找树：红链接均为左链接；没有任何一个结点同时和两条红链接相连；该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。 左旋：当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。前提：当前结点为h，它的右子结点为x。左旋过程：让x的左子结点变为h的右子结点：h.right=x.left;让h成为x的左子结点：x.left=h;让h的color属性变为x的color属性值：x.color=h.color;让h的color属性变为RED：h.color=true。 右旋：当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋。前提：当前结点为h，它的左子结点为x。右旋过程：让x的右子结点成为h的左子结点：h.left = x.right;让h成为x的右子结点：x.right=h;让x的color变为h的color属性值：x.color = h.color;让h的color为RED。 颜色反转：当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。 由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。 代码实现 public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; //根节点 private Node root; //记录树中元素的个数 private int N; //红色链接 private static final boolean RED = true; //黑色链接 private static final boolean BLACK = false; //结点类 private class Node &#123; //存储键 public Key key; //存储值 private Value value; //记录左子结点 public Node left; //记录右子结点 public Node right; //由其父结点指向它的链接的颜色 public boolean color; public Node(Key key, Value value, Node left, Node right, boolean color) &#123; this.key = key; this.value = value; this.left = left; this.right = right; this.color = color; &#125; &#125; //获取树中元素的个数 public int size() &#123; return N; &#125; /** * 判断当前节点的父指向链接是否为红色 * * @param x * @return */ private boolean isRed(Node x) &#123; if (x==null)&#123; return false; &#125; return x.color==RED; &#125; /** * 左旋转 * * @param h * @return */ private Node rotateLeft(Node h) &#123; //找到h结点的右子结点x Node x = h.right; //找到x结点的左子结点，让x结点的左子结点称为h结点的右子结点 h.right = x.left; //让h结点称为x结点的左子结点 x.left = h; //让x结点的color属性变为h结点的color属性 x.color = h.color; //让h结点的color属性变为RED h.color = RED; return x; &#125; /** * 右旋 * * @param h * @return */ private Node rotateRight(Node h) &#123; //找到h结点的左子结点 x Node x = h.left; //让x结点的右子结点成为h结点的左子结点 h.left = x.right; //让h结点成为x结点的右子结点 x.right = h; //让x结点的color属性变为h结点的color属性 x.color = h.color; //让h结点的color属性为RED h.color = RED; return x; &#125; /** * 颜色反转,相当于完成拆分4-节点 * * @param h */ private void flipColors(Node h) &#123; //当前结点变为红色 h.color = RED; //左子结点和右子结点变为黑色 h.left.color=BLACK; h.right.color = BLACK; &#125; /** * 在整个树上完成插入操作 * * @param key * @param val */ public void put(Key key, Value val) &#123; root = put(root,key,val); //根结点的颜色总是黑色 root.color = BLACK; &#125; /** * 在指定树中，完成插入操作,并返回添加元素后新的树 * * @param h * @param key * @param val */ private Node put(Node h, Key key, Value val) &#123; //判断h是否为空，如果为空则直接返回一个红色的结点就可以了 if (h == null)&#123; //数量+1 N++; return new Node(key,val,null,null,BLACK); &#125; //比较h结点的键和key的大小 int cmp = key.compareTo(h.key); if (cmp&lt;0)&#123; //继续往左 h.left = put(h.left,key,val); &#125;else if (cmp&gt;0)&#123; //继续往右 h.right = put(h.right,key,val); &#125;else&#123; //发生值的替换 h.value = val; &#125; //进行左旋:当当前结点h的左子结点为黑色，右子结点为红色，需要左旋 if (isRed(h.right) &amp;&amp; !isRed(h.left))&#123; h = rotateLeft(h); &#125; //进行右旋：当当前结点h的左子结点和左子结点的左子结点都为红色，需要右旋 if (isRed(h.left) &amp;&amp; isRed(h.left.left))&#123; rotateRight(h); &#125; //颜色反转：当前结点的左子结点和右子结点都为红色时，需要颜色反转 if (isRed(h.left) &amp;&amp; isRed(h.right))&#123; flipColors(h); &#125; return h; &#125; //根据key，从树中找出对应的值 public Value get(Key key) &#123; return get(root,key); &#125; //从指定的树x中，查找key对应的值 public Value get(Node x, Key key) &#123; if (x == null)&#123; return null; &#125; //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp&lt;0)&#123; return get(x.left,key); &#125;else if (cmp&gt;0)&#123; return get(x.right,key); &#125;else&#123; return x.value; &#125; &#125; &#125; 测试 public class RedBlackTreeTest &#123; public static void main(String[] args) &#123; //创建红黑树 RedBlackTree&lt;String, String&gt; tree = new RedBlackTree&lt;&gt;(); //往树中插入元素 tree.put(&quot;1&quot;,&quot;张三&quot;); tree.put(&quot;2&quot;,&quot;李四&quot;); tree.put(&quot;3&quot;,&quot;王五&quot;); //从树中获取元素 String r1 = tree.get(&quot;1&quot;); System.out.println(r1); String r2 = tree.get(&quot;2&quot;); System.out.println(r2); String r3 = tree.get(&quot;3&quot;); System.out.println(r3); &#125; &#125; B树和B+树B树 B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：每个结点最多有M-1个key，并且以升序排列；每个结点最多能有M个子结点；根结点至少有两个子结点。 在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。 在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。 B+树 B+树是对B树的一种变形树，它与B树的差异在于：非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。 B+ 树的优点在于：由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。 B树的优点在于：由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。 在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题，在很多数据库中，都是用到了B+树来提高查询的效率；在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这个索引就是B+树这种数据结构实现的。 并查集 并查集也是一种树型结构，跟二叉树、红黑树、B树等都不一样，这种树的要求比较简单：每个元素都唯一的对应一个结点；每一组数据中的多个元素都在同一颗树中；一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；元素在树中并没有子父级关系的硬性要求。 实现 初始情况下，并查集中的数据默认分为N个组；初始化数组eleAndGroup；把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i。 如果p和q已经在同一个分组中，则无需合并；如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可；分组数量-1。 public class UF &#123; //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //初始化并查集 public UF(int N)&#123; //初始化分组的数量,默认情况下，有N个分组 this.count = N; //初始化eleAndGroup数组 this.eleAndGroup = new int[N]; //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引 for (int i = 0; i &lt; eleAndGroup.length; i++) &#123; eleAndGroup[i] = i; &#125; &#125; //获取当前并查集中的数据有多少个分组 public int count()&#123; return count; &#125; //元素p所在分组的标识符 public int find(int p)&#123; return eleAndGroup[p]; &#125; //判断并查集中元素p和元素q是否在同一分组中 public boolean connected(int p,int q)&#123; return find(p) == find(q); &#125; //把p元素所在分组和q元素所在分组合并 public void union(int p,int q)&#123; //判断元素q和p是否已经在同一分组中，如果已经在同一分组中，则结束方法就可以了 if (connected(p,q))&#123; return; &#125; //找到p所在分组的标识符 int pGroup = find(p); //找到q所在分组的标识符 int qGroup = find(q); //合并组：让p所在组的所有元素的组标识符变为q所在分组的标识符 for (int i = 0; i &lt; eleAndGroup.length; i++) &#123; if (eleAndGroup[i]==pGroup)&#123; eleAndGroup[i] = qGroup; &#125; &#125; //分组个数-1 this.count--; &#125; &#125; 测试 public class UFTest &#123; public static void main(String[] args) &#123; //创建并查集对象 UF uf = new UF(5); System.out.println(&quot;默认情况下，并查集中有：&quot;+uf.count()+&quot;个分组&quot;); //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少 Scanner sc = new Scanner(System.in); while(true)&#123; System.out.println(&quot;请输入第一个要合并的元素：&quot;); int p = sc.nextInt(); System.out.println(&quot;请输入第二个要合并的元素：&quot;); int q = sc.nextInt(); //判断这两个元素是否已经在同一组了 if (uf.connected(p,q))&#123; System.out.println(p+&quot;元素和&quot;+q+&quot;元素已经在同一个组中了&quot;); continue; &#125; uf.union(p,q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); &#125; &#125; &#125; UF_Tree算法优化 我们仍然让eleAndGroup数组的索引作为某个结点的元素；eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点。 public class UF_Tree &#123; //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //初始化并查集 public UF_Tree(int N)&#123; //初始化分组的数量,默认情况下，有N个分组 this.count = N; //初始化eleAndGroup数组 this.eleAndGroup = new int[N]; //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引 for (int i = 0; i &lt; eleAndGroup.length; i++) &#123; eleAndGroup[i] = i; &#125; &#125; //获取当前并查集中的数据有多少个分组 public int count()&#123; return count; &#125; //判断并查集中元素p和元素q是否在同一分组中 public boolean connected(int p,int q)&#123; return find(p) == find(q); &#125; //元素p所在分组的标识符 public int find(int p)&#123; while(true)&#123; if (p == eleAndGroup[p])&#123; return p; &#125; p = eleAndGroup[p]; &#125; &#125; //把p元素所在分组和q元素所在分组合并 public void union(int p,int q)&#123; //找到p元素和q元素所在组对应的树的根结点 int pRoot = find(p); int qRoot = find(q); //如果p和q已经在同一分组，则不需要合并了 if (pRoot==qRoot)&#123; return; &#125; //让p所在的树的根结点的父结点为q所在树的根结点即可 eleAndGroup[pRoot] = qRoot; //组的数量-1 this.count--; &#125; &#125; 测试 public class UFTeeTest &#123; public static void main(String[] args) &#123; //创建并查集对象 UF_Tree uf = new UF_Tree(5); System.out.println(&quot;默认情况下，并查集中有：&quot;+uf.count()+&quot;个分组&quot;); //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少 Scanner sc = new Scanner(System.in); while(true)&#123; System.out.println(&quot;请输入第一个要合并的元素：&quot;); int p = sc.nextInt(); System.out.println(&quot;请输入第二个要合并的元素：&quot;); int q = sc.nextInt(); //判断这两个元素是否已经在同一组了 if (uf.connected(p,q))&#123; System.out.println(p+&quot;元素和&quot;+q+&quot;元素已经在同一个组中了&quot;); continue; &#125; uf.union(p,q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); &#125; &#125; &#125; 路径压缩优化 在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。 public class UF_Tree_Weighted &#123; //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //用来存储每一个根结点对应的树中保存的结点的个数 private int[] sz; //初始化并查集 public UF_Tree_Weighted(int N)&#123; //初始化分组的数量,默认情况下，有N个分组 this.count = N; //初始化eleAndGroup数组 this.eleAndGroup = new int[N]; //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引 for (int i = 0; i &lt; eleAndGroup.length; i++) &#123; eleAndGroup[i] = i; &#125; this.sz = new int[N]; //默认情况下，sz中每个索引处的值都是1 for (int i = 0; i &lt; sz.length; i++) &#123; sz[i] = 1; &#125; &#125; //获取当前并查集中的数据有多少个分组 public int count()&#123; return count; &#125; //判断并查集中元素p和元素q是否在同一分组中 public boolean connected(int p,int q)&#123; return find(p) == find(q); &#125; //元素p所在分组的标识符 public int find(int p)&#123; while(true)&#123; if (p == eleAndGroup[p])&#123; return p; &#125; p = eleAndGroup[p]; &#125; &#125; //把p元素所在分组和q元素所在分组合并 public void union(int p,int q)&#123; //找到p元素和q元素所在组对应的树的根结点 int pRoot = find(p); int qRoot = find(q); //如果p和q已经在同一分组，则不需要合并了 if (pRoot==qRoot)&#123; return; &#125; //判断proot对应的树大还是qroot对应的树大，最终需要把较小的树合并到较大的树中 if (sz[pRoot]&lt;sz[qRoot])&#123; eleAndGroup[pRoot] = qRoot; sz[qRoot]+=sz[pRoot]; &#125;else&#123; eleAndGroup[qRoot] = pRoot; sz[pRoot]+= sz[qRoot]; &#125; //组的数量-1 this.count--; &#125; &#125; 测试 public class UFTeeWeightedTest &#123; public static void main(String[] args) &#123; //创建并查集对象 UF_Tree_Weighted uf = new UF_Tree_Weighted(5); System.out.println(&quot;默认情况下，并查集中有：&quot;+uf.count()+&quot;个分组&quot;); //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少 Scanner sc = new Scanner(System.in); while(true)&#123; System.out.println(&quot;请输入第一个要合并的元素：&quot;); int p = sc.nextInt(); System.out.println(&quot;请输入第二个要合并的元素：&quot;); int q = sc.nextInt(); //判断这两个元素是否已经在同一组了 if (uf.connected(p,q))&#123; System.out.println(p+&quot;元素和&quot;+q+&quot;元素已经在同一个组中了&quot;); continue; &#125; uf.union(p,q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); &#125; &#125; &#125; 案例 public class Traffic_Project_Test &#123; public static void main(String[] args) throws Exception&#123; //构建一个缓冲读取流BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(Traffic_Project_Test.class.getClassLoader().getResourceAsStream(&quot;traffic_project.txt&quot;))); //读取第一行数据20 int totalNumber = Integer.parseInt(br.readLine()); //构建一个并查集对象 UF_Tree_Weighted uf = new UF_Tree_Weighted(totalNumber); //读取第二行数据7 int roadNumber = Integer.parseInt(br.readLine()); //循环读取7条道路 for (int i=1;i&lt;=roadNumber;i++)&#123; String line = br.readLine();//0 1 String[] str = line.split(&quot; &quot;); int p = Integer.parseInt(str[0]); int q = Integer.parseInt(str[1]); //调用并查集对象的union方法让两个城市相通 uf.union(p,q); &#125; //获取当前并查集中分组的数量-1就可以得到还需要修建的道路的数目 int roads = uf.count()-1; System.out.println(&quot;还需要修建&quot;+roads+&quot;条道路，才能实现畅通工程&quot;); &#125; &#125; 图概念 图是由一组顶点和一组能够将两个顶点相连的边组成的。按照连接两个顶点的边的不同，可以把图分为以下两种：无向图：边仅仅连接两个顶点，没有其他含义；有向图：边不仅连接两个顶点，并且具有方向。 相邻顶点：当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。 度：某个顶点的度就是依附于该顶点的边的个数。 子图：是一幅图的所有边的子集(包含这些边依附的顶点)组成的图。 路径：是由边顺序连接的一系列的顶点组成。 环：是一条至少含有一条边且终点和起点相同的路径。 连通图：如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图。 连通子图：一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图。 图的存储结构 只需要表示清楚以下两部分内容即可：图中所有的顶点；所有连接顶点的边。 常见的图的存储结构有两种：邻接矩阵和邻接表 邻接矩阵：使用一个 V*V 的二维数组int[V][V] adj,把索引的值看做是顶点；如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。邻接矩阵这种存储方式的空间复杂度是V^2的。 邻接表：使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点。 代码实现 public class Graph &#123; //顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Graph(int V)&#123; //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) &#123; adj[i] = new Queue&lt;Integer&gt;(); &#125; &#125; //获取顶点数目 public int V()&#123; return V; &#125; //获取边的数目 public int E()&#123; return E; &#125; //向图中添加一条边 v-w public void addEdge(int v, int w) &#123; //在无向图中，边是没有方向的，所以该边既可以说是从v到w的边，又可以说是从w到v的边，因此，需要让w出现在v的邻接表中，并且还要让v出现在w的邻接表中 adj[v].enqueue(w); adj[w].enqueue(v); //边的数量+1 E++; &#125; //获取和顶点v相邻的所有顶点 public Queue&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; &#125; 图的搜索 深度优先搜索：在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。 public class DepthFirstSearch &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录有多少个顶点与s顶点相通 private int count; //构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相邻顶点 public DepthFirstSearch(Graph G,int s)&#123; //初始化marked数组 this.marked = new boolean[G.V()]; //初始化跟顶点s相通的顶点的数量 this.count=0; dfs(G,s); &#125; //使用深度优先搜索找出G图中v顶点的所有相通顶点 private void dfs(Graph G, int v)&#123; //把v顶点标识为已搜索 marked[v] = true; for (Integer w : G.adj(v)) &#123; //判断当前w顶点有没有被搜索过，如果没有被搜索过，则递归调用dfs方法进行深度搜索 if (!marked[w])&#123; dfs(G,w); &#125; &#125; //相通顶点数量+1 count++; &#125; //判断w顶点与s顶点是否相通 public boolean marked(int w)&#123; return marked[w]; &#125; //获取与顶点s相通的所有顶点的总数 public int count()&#123; return count; &#125; &#125; 测试深度优先搜索 public class DepthFirstSearchTest &#123; public static void main(String[] args) &#123; //准备Graph对象 Graph G = new Graph(13); G.addEdge(0,5); G.addEdge(0,1); G.addEdge(0,2); G.addEdge(0,6); G.addEdge(5,3); G.addEdge(5,4); G.addEdge(3,4); G.addEdge(4,6); G.addEdge(7,8); G.addEdge(9,11); G.addEdge(9,10); G.addEdge(9,12); G.addEdge(11,12); //准备深度优先搜索对象 DepthFirstSearch search = new DepthFirstSearch(G, 0); //测试与某个顶点相通的顶点数量 int count = search.count(); System.out.println(&quot;与起点0相通的顶点的数量为:&quot;+count); //测试某个顶点与起点是否相同 boolean marked1 = search.marked(5); System.out.println(&quot;顶点5和顶点0是否相通：&quot;+marked1); boolean marked2 = search.marked(7); System.out.println(&quot;顶点7和顶点0是否相通：&quot;+marked2); &#125; &#125; 广度优先搜索:在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。 实现代码 public class BreadthFirstSearch &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录有多少个顶点与s顶点相通 private int count; //用来存储待搜索邻接表的点 private Queue&lt;Integer&gt; waitSearch; //构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 public BreadthFirstSearch(Graph G, int s) &#123; this.marked = new boolean[G.V()]; this.count=0; this.waitSearch = new Queue&lt;Integer&gt;(); bfs(G,s); &#125; //使用广度优先搜索找出G图中v顶点的所有相邻顶点 private void bfs(Graph G, int v) &#123; //把当前顶点v标识为已搜索 marked[v] = true; //让顶点v进入队列，待搜索 waitSearch.enqueue(v); //通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索 while(!waitSearch.isEmpty())&#123; //弹出一个待搜索的顶点 Integer wait = waitSearch.dequeue(); //遍历wait顶点的邻接表 for (Integer w : G.adj(wait)) &#123; if (!marked[w])&#123; bfs(G,w); &#125; &#125; &#125; //让相通的顶点+1； count++; &#125; //判断w顶点与s顶点是否相通 public boolean marked(int w) &#123; return marked[w]; &#125; //获取与顶点s相通的所有顶点的总数 public int count() &#123; return count; &#125; &#125; 测试 public class BreadthFirstSearchTest &#123; public static void main(String[] args) &#123; //准备Graph对象 Graph G = new Graph(13); G.addEdge(0,5); G.addEdge(0,1); G.addEdge(0,2); G.addEdge(0,6); G.addEdge(5,3); G.addEdge(5,4); G.addEdge(3,4); G.addEdge(4,6); G.addEdge(7,8); G.addEdge(9,11); G.addEdge(9,10); G.addEdge(9,12); G.addEdge(11,12); //准备广度优先搜索对象 BreadthFirstSearch search = new BreadthFirstSearch(G, 0); //测试与某个顶点相通的顶点数量 int count = search.count(); System.out.println(&quot;与起点0相通的顶点的数量为:&quot;+count); //测试某个顶点与起点是否相同 boolean marked1 = search.marked(5); System.out.println(&quot;顶点5和顶点0是否相通：&quot;+marked1); boolean marked2 = search.marked(7); System.out.println(&quot;顶点7和顶点0是否相通：&quot;+marked2); &#125; &#125; 案例 public class Traffic_Project_Test2 &#123; public static void main(String[] args) throws Exception&#123; //构建一个缓冲读取流BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(Traffic_Project_Test2.class.getClassLoader().getResourceAsStream(&quot;traffic_project.txt&quot;))); //读取第一行数据20 int totalNumber = Integer.parseInt(br.readLine()); //构建一个Graph对象 Graph G = new Graph(totalNumber); //读取第二行数据7 int roadNumber = Integer.parseInt(br.readLine()); //循环读取有限次(7)，读取已经修建好的道路 for (int i = 1;i&lt;=roadNumber;i++)&#123; String road = br.readLine();//&quot;0 1&quot; String[] str = road.split(&quot; &quot;); int v = Integer.parseInt(str[0]); int w = Integer.parseInt(str[1]); //调用图的addEdge方法，把边添加到图中，表示已经修建好的道路 G.addEdge(v,w); &#125; //构建一个深度优先搜索对象，起点设置为顶点9 DepthFirstSearch search = new DepthFirstSearch(G, 9); //调用marked方法，判断8顶点和10顶点是否与起点9相通 System.out.println(&quot;顶点8和顶点9是否相通：&quot;+search.marked(8)); System.out.println(&quot;顶点10和顶点9是否相通：&quot;+search.marked(10)); &#125; &#125; 路径查找 public class DepthFirstPaths &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //起点 private int s; //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 private int[] edgeTo; //构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径 public DepthFirstPaths(Graph G, int s)&#123; //初始化marked数组 this.marked = new boolean[G.V()]; //初始化起点 this.s = s; //初始化edgeTo数组 this.edgeTo = new int[G.V()]; dfs(G,s); &#125; //使用深度优先搜索找出G图中v顶点的所有相邻顶点 private void dfs(Graph G, int v)&#123; //把v表示为已搜索 marked[v] = true; //遍历顶点v的邻接表，拿到每一个相邻的顶点，继续递归搜索 for (Integer w : G.adj(v)) &#123; //如果顶点w没有被搜索，则继续递归搜索 if (!marked[w])&#123; edgeTo[w] = v;//到达顶点w的路径上的最后一个顶点是v dfs(G,w); &#125; &#125; &#125; //判断w顶点与s顶点是否存在路径 public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //找出从起点s到顶点v的路径(就是该路径经过的顶点) public Stack&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v))&#123; return null; &#125; //创建栈对象，保存路径中的所有顶点 Stack&lt;Integer&gt; path = new Stack&lt;&gt;(); //通过循环，从顶点v开始，一直往前找，到找到起点为止 for (int x = v; x!=s;x = edgeTo[x])&#123; path.push(x); &#125; //把起点s放到栈中 path.push(s); return path; &#125; &#125; 测试 public class DepthFirstPathsTest &#123; public static void main(String[] args) throws Exception&#123; //构建缓冲读取流BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(DepthFirstPathsTest.class.getClassLoader().getResourceAsStream(&quot;road_find.txt&quot;))); //读取第一行数据6 int total = Integer.parseInt(br.readLine()); //根据第一行数据构建一副图Graph Graph G = new Graph(total); //读取第二行数据8 int edgeNumbers = Integer.parseInt(br.readLine()); //继续通过循环读取每一条边关联的两个顶点，调用addEdge方法，添加边 for (int i = 1;i&lt;=edgeNumbers;i++)&#123; String edge = br.readLine();//0 1 String[] str = edge.split(&quot; &quot;); int v = Integer.parseInt(str[0]); int w = Integer.parseInt(str[1]); G.addEdge(v,w); &#125; //构建路径查找对象，并设置起点为0 DepthFirstPaths paths = new DepthFirstPaths(G, 0); //调用 pathTo(4)，找到从起点0到终点4的路径，返回Stack Stack&lt;Integer&gt; path = paths.pathTo(4); StringBuilder sb = new StringBuilder(); //遍历栈对象 for (Integer v : path) &#123; sb.append(v+&quot;-&quot;); &#125; sb.deleteCharAt(sb.length()-1); System.out.println(sb); &#125; &#125; 有向图定义 有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。 出度：由某个顶点指出的边的个数称为该顶点的出度。 入度：指向某个顶点的边的个数称为该顶点的入度。 有向路径：由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。 有向环：一条至少含有一条边，且起点和终点相同的有向路径。 一副有向图中两个顶点v和w可能存在以下四种关系：没有边相连；存在从v到w的边v—&gt;w;存在从w到v的边w—&gt;v;既存在w到v的边，也存在v到w的边，即双向连接。 有向图实现 public class Digraph &#123; //顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Digraph(int V)&#123; //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) &#123; adj[i] = new Queue&lt;Integer&gt;(); &#125; &#125; //获取顶点数目 public int V()&#123; return V; &#125; //获取边的数目 public int E()&#123; return E; &#125; //向有向图中添加一条边 v-&gt;w public void addEdge(int v, int w) &#123; //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终，顶点v的邻接表中存储的相邻顶点的含义是： v-&gt;其他顶点 adj[v].enqueue(w); E++; &#125; //获取由v指出的边所连接的所有顶点 public Queue&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; //该图的反向图 private Digraph reverse()&#123; //创建有向图对象 Digraph r = new Digraph(V); for (int v = 0;v&lt;V;v++)&#123; //获取由该顶点v指出的所有边 for (Integer w : adj[v]) &#123;//原图中表示的是由顶点v-&gt;w的边 r.addEdge(w,v);//w-&gt;v &#125; &#125; return r; &#125; &#125; 拓扑排序-检测有向图中的环 拓扑排序：给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明确的表示出每个顶点的优先级。 如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。 onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环。 代码实现 public class DirectedCycle &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录图中是否有环 private boolean hasCycle; //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上 private boolean[] onStack; //创建一个检测环对象，检测图G中是否有环 public DirectedCycle(Digraph G)&#123; //初始化marked数组 this.marked = new boolean[G.V()]; //初始化hasCycle this.hasCycle = false; //初始化onStack数组 this.onStack = new boolean[G.V()]; //找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索 for (int v =0; v&lt;G.V();v++)&#123; //判断如果当前顶点还没有搜索过，则调用dfs进行搜索 if (!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; //基于深度优先搜索，检测图G中是否有环 private void dfs(Digraph G, int v)&#123; //把顶点v表示为已搜索 marked[v] = true; //把当前顶点进栈 onStack[v] = true; //进行深度搜索 for (Integer w : G.adj(v)) &#123; //判断如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索 if (!marked[w])&#123; dfs(G,w); &#125; //判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了 if (onStack[w])&#123; hasCycle = true; return; &#125; &#125; //把当前顶点出栈 onStack[v] = false; &#125; //判断当前有向图G中是否有环 public boolean hasCycle()&#123; return hasCycle; &#125; &#125; 拓扑排序-基于深度优先的顶点排序 栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该顶点放入到reversePost中，这样就可以实现顶点排序。 代码实现： public class DepthFirstOrder &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //使用栈，存储顶点序列 private Stack&lt;Integer&gt; reversePost; //创建一个检测环对象，检测图G中是否有环 public DepthFirstOrder(Digraph G)&#123; //初始化marked数组 this.marked = new boolean[G.V()]; //初始化reversePost栈 this.reversePost = new Stack&lt;Integer&gt;(); //遍历图中的每一个顶点，让每个顶点作为入口，完成一次深度优先搜索 for (int v = 0;v&lt;G.V();v++)&#123; if (!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; //基于深度优先搜索，把顶点排序 private void dfs(Digraph G, int v)&#123; //标记当前v已经被搜索 marked[v] = true; //通过循环深度搜索顶点v for (Integer w : G.adj(v)) &#123; //如果当前顶点w没有搜索，则递归调用dfs进行搜索 if (!marked[w])&#123; dfs(G,w); &#125; &#125; //让顶点v进栈 reversePost.push(v); &#125; //获取顶点线性序列 public Stack&lt;Integer&gt; reversePost()&#123; return reversePost; &#125; &#125; 拓扑排序实现 public class TopoLogical &#123; //顶点的拓扑排序 private Stack&lt;Integer&gt; order; //构造拓扑排序对象 public TopoLogical(Digraph G) &#123; //创建一个检测有向环的对象 DirectedCycle cycle = new DirectedCycle(G); //判断G图中有没有环，如果没有环，则进行顶点排序：创建一个顶点排序对象 if (!cycle.hasCycle())&#123; DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G); order = depthFirstOrder.reversePost(); &#125; &#125; //判断图G是否有环 private boolean isCycle()&#123; return order==null; &#125; //获取拓扑排序的所有顶点 public Stack&lt;Integer&gt; order()&#123; return order; &#125; &#125; 测试 public class TopoLogicalTest &#123; public static void main(String[] args) &#123; //准备有向图 Digraph digraph = new Digraph(6); digraph.addEdge(0,2); digraph.addEdge(0,3); digraph.addEdge(2,4); digraph.addEdge(3,4); digraph.addEdge(4,5); digraph.addEdge(1,3); //通过TopoLogical对象堆有向图中的顶点进行排序 TopoLogical topoLogical = new TopoLogical(digraph); //获取顶点的线性序列进行打印 Stack&lt;Integer&gt; order = topoLogical.order(); StringBuilder sb = new StringBuilder(); for (Integer w : order) &#123; sb.append(w+&quot;-&gt;&quot;); &#125; String str = sb.toString(); int index = str.lastIndexOf(&quot;-&gt;&quot;); str = str.substring(0,index); System.out.println(str); &#125; &#125; 加权无向图 加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用对象来描述一条边。 边的实现： public class Edge implements Comparable&lt;Edge&gt; &#123; private final int v;//顶点一 private final int w;//顶点二 private final double weight;//当前边的权重 //通过顶点v和w，以及权重weight值构造一个边对象 public Edge(int v, int w, double weight) &#123; this.v = v; this.w = w; this.weight = weight; &#125; //获取边的权重值 public double weight()&#123; return weight; &#125; //获取边上的一个点 public int either()&#123; return v; &#125; //获取边上除了顶点vertex外的另外一个顶点 public int other(int vertex)&#123; if (vertex==v)&#123; return w; &#125;else&#123; return v; &#125; &#125; @Override public int compareTo(Edge that) &#123; //使用一个遍历记录比较的结果 int cmp; if (this.weight()&gt;that.weight())&#123; //如果当前边的权重值大，则让cmp=1； cmp = 1; &#125;else if (this.weight()&lt;that.weight())&#123; //如果当前边的权重值小，则让cmp=-1； cmp=-1; &#125;else&#123; //如果当前边的权重值和that边的权重值一样大，则让cmp=0 cmp = 0; &#125; return cmp; &#125; &#125; 加权无向图的实现 public class EdgeWeightedGraph &#123; //顶点总数 private final int V; //边的总数 private int E; //邻接表 private Queue&lt;Edge&gt;[] adj; //创建一个含有V个顶点的空加权无向图 public EdgeWeightedGraph(int V) &#123; //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) &#123; adj[i] = new Queue&lt;Edge&gt;(); &#125; &#125; //获取图中顶点的数量 public int V() &#123; return V; &#125; //获取图中边的数量 public int E() &#123; return E; &#125; //向加权无向图中添加一条边e public void addEdge(Edge e) &#123; //需要让边e同时出现在e这个边的两个顶点的邻接表中 int v = e.either(); int w = e.other(v); adj[v].enqueue(e); adj[w].enqueue(e); //边的数量+1 E++; &#125; //获取和顶点v关联的所有边 public Queue&lt;Edge&gt; adj(int v) &#123; return adj[v]; &#125; //获取加权无向图的所有边 public Queue&lt;Edge&gt; edges() &#123; //创建一个队列对象，存储所有的边 Queue&lt;Edge&gt; allEdges = new Queue&lt;&gt;(); //遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边 //因为这是无向图，所以同一条边同时出现在了它关联的两个顶点的邻接表中，需要让一条边只记录一次； for(int v =0;v&lt;V;v++)&#123; //遍历v顶点的邻接表，找到每一条和v关联的边 for (Edge e : adj(v)) &#123; if (e.other(v)&lt;v)&#123; allEdges.enqueue(e); &#125; &#125; &#125; return allEdges; &#125; &#125; 最小生成树 图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边的权重之和)最小的生成树。 树的性质：用一条边接树中的任意两个顶点都会产生一个新的环；从树中删除任意一条边，将会得到两棵独立的树。 切分：将图的所有顶点按照某些规则分为两个非空且没有交集的集合。 横切边：连接两个属于不同集合的顶点的边称之为横切边。 切分定理：在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。注意:一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。 贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。 最小生成树Prim算法 Prim算法的切分规则：把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。实现： public class PrimMST &#123; //索引代表顶点，值表示当前顶点和最小生成树之间的最短边 private Edge[] edgeTo; //索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 private double[] distTo; //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false private boolean[] marked; //存放树中顶点与非树中顶点之间的有效横切边 private IndexMinPriorityQueue&lt;Double&gt; pq; //根据一副加权无向图，创建最小生成树计算对象 public PrimMST(EdgeWeightedGraph G) &#123; //初始化edgeTo this.edgeTo = new Edge[G.V()]; //初始化distTo this.distTo = new double[G.V()]; for (int i = 0; i &lt; distTo.length; i++) &#123; distTo[i] = Double.POSITIVE_INFINITY; &#125; //初始化marked this.marked = new boolean[G.V()]; //初始化pq pq = new IndexMinPriorityQueue&lt;Double&gt;(G.V()); //默认让顶点0进入到树中，但是树中只有一个顶点0，因此，0顶点默认没有和其他的顶点相连，所以让distTo对应位置处的值存储0.0 distTo[0] = 0.0; pq.insert(0,0.0); //遍历索引最小优先队列，拿到最小和N切边对应的顶点，把该顶点加入到最小生成树中 while (!pq.isEmpty())&#123; visit(G,pq.delMin()); &#125; &#125; //将顶点v添加到最小生成树中，并且更新数据 private void visit(EdgeWeightedGraph G, int v) &#123; //把顶点v添加到最小生成树中 marked[v] = true; //更新数据 for (Edge e : G.adj(v)) &#123; //获取e边的另外一个顶点(当前顶点是v) int w = e.other(v); //判断另外一个顶点是不是已经在树中，如果在树中，则不做任何处理，如果不再树中，更新数据 if (marked[w])&#123; continue; &#125; //判断边e的权重是否小于从w顶点到树中已经存在的最小边的权重； if (e.weight()&lt;distTo[w])&#123; //更新数据 edgeTo[w] = e; distTo[w] = e.weight(); if (pq.contains(w))&#123; pq.changeItem(w,e.weight()); &#125;else&#123; pq.insert(w,e.weight()); &#125; &#125; &#125; &#125; //获取最小生成树的所有边 public Queue&lt;Edge&gt; edges() &#123; //创建队列对象 Queue&lt;Edge&gt; allEdges = new Queue&lt;&gt;(); //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中 for (int i = 0; i &lt; edgeTo.length; i++) &#123; if (edgeTo[i]!=null)&#123; allEdges.enqueue(edgeTo[i]); &#125; &#125; return allEdges; &#125; &#125; 测试 public class PrimMSTTest &#123; public static void main(String[] args) throws Exception&#123; //准备一副加权无向图 BufferedReader br = new BufferedReader(new InputStreamReader(PrimMSTTest.class.getClassLoader().getResourceAsStream(&quot;min_create_tree_test.txt&quot;))); int total = Integer.parseInt(br.readLine()); EdgeWeightedGraph G = new EdgeWeightedGraph(total); int edgeNumbers = Integer.parseInt(br.readLine()); for (int e = 1;e&lt;=edgeNumbers;e++)&#123; String line = br.readLine();//4 5 0.35 String[] strs = line.split(&quot; &quot;); int v = Integer.parseInt(strs[0]); int w = Integer.parseInt(strs[1]); double weight = Double.parseDouble(strs[2]); //构建加权无向边 Edge edge = new Edge(v, w, weight); G.addEdge(edge); &#125; //创建一个PrimMST对象，计算加权无向图中的最小生成树 PrimMST primMST = new PrimMST(G); //获取最小生成树中的所有边 Queue&lt;Edge&gt; edges = primMST.edges(); //遍历打印所有的边 for (Edge e : edges) &#123; int v = e.either(); int w = e.other(v); double weight = e.weight(); System.out.println(v+&quot;-&quot;+w+&quot; :: &quot;+weight); &#125; &#125; &#125; 最小生成树kruskal算法 kruskal算法是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。 kruskal算法和prim算法的区别：Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。 取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。 kruskal算法实现: public class KruskalMST &#123; //保存最小生成树的所有边 private Queue&lt;Edge&gt; mst; //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 private UF_Tree_Weighted uf; //存储图中所有的边，使用最小优先队列，对边按照权重进行排序 private MinPriorityQueue&lt;Edge&gt; pq; //根据一副加权无向图，创建最小生成树计算对象 public KruskalMST(EdgeWeightedGraph G) &#123; //初始化mst this.mst = new Queue&lt;Edge&gt;(); //初始化uf this.uf = new UF_Tree_Weighted(G.V()); //初始化pq this.pq = new MinPriorityQueue&lt;&gt;(G.E()+1); //把图中所有的边存储到pq中 for (Edge e : G.edges()) &#123; pq.insert(e); &#125; //遍历pq队列，拿到最小权重的边，进行处理 while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1)&#123; //找到权重最小的边 Edge e = pq.delMin(); //找到该边的两个顶点 int v = e.either(); int w = e.other(v); //判断这两个顶点是否已经在同一颗树中，如果在同一颗树中，则不对该边做处理，如果不在一棵树中，则让这两个顶点属于的两棵树合并成一棵树 if (uf.connected(v,w))&#123; continue; &#125; uf.union(v,w); //让边e进入到mst队列中 mst.enqueue(e); &#125; &#125; //获取最小生成树的所有边 public Queue&lt;Edge&gt; edges() &#123; return mst; &#125; &#125; 测试 public class KruskalMSTTest &#123; public static void main(String[] args) throws Exception&#123; //准备一副加权无向图 BufferedReader br = new BufferedReader(new InputStreamReader(KruskalMSTTest.class.getClassLoader().getResourceAsStream(&quot;min_create_tree_test.txt&quot;))); int total = Integer.parseInt(br.readLine()); EdgeWeightedGraph G = new EdgeWeightedGraph(total); int edgeNumbers = Integer.parseInt(br.readLine()); for (int e = 1;e&lt;=edgeNumbers;e++)&#123; String line = br.readLine();//4 5 0.35 String[] strs = line.split(&quot; &quot;); int v = Integer.parseInt(strs[0]); int w = Integer.parseInt(strs[1]); double weight = Double.parseDouble(strs[2]); //构建加权无向边 Edge edge = new Edge(v, w, weight); G.addEdge(edge); &#125; //创建一个KruskalMST对象，计算加权无向图中的最小生成树 KruskalMST primMST = new KruskalMST(G); //获取最小生成树中的所有边 Queue&lt;Edge&gt; edges = primMST.edges(); //遍历打印所有的边 for (Edge e : edges) &#123; int v = e.either(); int w = e.other(v); double weight = e.weight(); System.out.println(v+&quot;-&quot;+w+&quot; :: &quot;+weight); &#125; &#125; &#125; 加权有向图 有向图边的表示： public class DirectedEdge &#123; private final int v;//起点 private final int w;//终点 private final double weight;//当前边的权重 //通过顶点v和w，以及权重weight值构造一个边对象 public DirectedEdge(int v, int w, double weight) &#123; this.v = v; this.w = w; this.weight = weight; &#125; //获取边的权重值 public double weight()&#123; return weight; &#125; //获取有向边的起点 public int from()&#123; return v; &#125; //获取有向边的终点 public int to()&#123; return w; &#125; &#125; 有向图的实现： public class EdgeWeightedDigraph &#123; //顶点总数 private final int V; //边的总数 private int E; //邻接表 private Queue&lt;DirectedEdge&gt;[] adj; //创建一个含有V个顶点的空加权有向图 public EdgeWeightedDigraph(int V) &#123; //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i++) &#123; adj[i] = new Queue&lt;DirectedEdge&gt;(); &#125; &#125; //获取图中顶点的数量 public int V() &#123; return V; &#125; //获取图中边的数量 public int E() &#123; return E; &#125; //向加权有向图中添加一条边e public void addEdge(DirectedEdge e) &#123; //边e是有方向的，所以只需要让e出现在起点的邻接表中即可 int v = e.from(); adj[v].enqueue(e); E++; &#125; //获取由顶点v指出的所有的边 public Queue&lt;DirectedEdge&gt; adj(int v) &#123; return adj[v]; &#125; //获取加权有向图的所有边 public Queue&lt;DirectedEdge&gt; edges() &#123; //遍历图中的每一个顶点，得到该顶点的邻接表，遍历得到每一条边，添加到队列中返回即可 Queue&lt;DirectedEdge&gt; allEdges = new Queue&lt;&gt;(); for (int v = 0;v&lt;V;v++)&#123; for (DirectedEdge edge : adj[v]) &#123; allEdges.enqueue(edge); &#125; &#125; return allEdges; &#125; &#125; 最短路径 最短路径定义及性质定义：在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。 最短路径树：给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。 边的松弛：放松边v-&gt;w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w。 顶点的松弛：顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。 Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边是有效横切边pq队列中的权重最小的边。 public class DijkstraSP &#123; //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边 private DirectedEdge[] edgeTo; //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 private double[] distTo; //存放树中顶点与非树中顶点之间的有效横切边 private IndexMinPriorityQueue&lt;Double&gt; pq; //根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象 public DijkstraSP(EdgeWeightedDigraph G, int s)&#123; //初始化edgeTo this.edgeTo = new DirectedEdge[G.V()]; //初始化distTo this.distTo = new double[G.V()]; for (int i = 0; i &lt; distTo.length; i++) &#123; distTo[i] = Double.POSITIVE_INFINITY; &#125; //初始化pq this.pq = new IndexMinPriorityQueue&lt;&gt;(G.V()); //找到图G中以顶点s为起点的最短路径树 //默认让顶点s进入到最短路径树中 distTo[s] = 0.0; pq.insert(s,0.0); //遍历pq while(!pq.isEmpty())&#123; relax(G,pq.delMin()); &#125; &#125; //松弛图G中的顶点v private void relax(EdgeWeightedDigraph G, int v)&#123; for (DirectedEdge edge : G.adj(v)) &#123; //获取到该边的终点w int w = edge.to(); //通过松弛技术，判断从起点s到顶点w的最短路径是否需要先从顶点s到顶点v，然后再由顶点v到顶点w if (distTo(v)+edge.weight()&lt;distTo(w))&#123; distTo[w] = distTo[v]+edge.weight(); edgeTo[w] = edge; //判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在，则直接添加 if (pq.contains(w))&#123; pq.changeItem(w,distTo(w)); &#125;else&#123; pq.insert(w,distTo(w)); &#125; &#125; &#125; &#125; //获取从顶点s到顶点v的最短路径的总权重 public double distTo(int v)&#123; return distTo[v]; &#125; //判断从顶点s到顶点v是否可达 public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; //查询从起点s到顶点v的最短路径中所有的边 public Queue&lt;DirectedEdge&gt; pathTo(int v)&#123; //判断从顶点s到顶点v是否可达，如果不可达，直接返回null if (!hasPathTo(v))&#123; return null; &#125; //创建队列对象 Queue&lt;DirectedEdge&gt; allEdges = new Queue&lt;&gt;(); while (true)&#123; DirectedEdge e = edgeTo[v]; if (e==null)&#123; break; &#125; allEdges.enqueue(e); v = e.from(); &#125; return allEdges; &#125; &#125; 测试 public class DijkstraSPTest &#123; public static void main(String[] args) throws Exception&#123; //创建一副加权有向图 BufferedReader br = new BufferedReader(new InputStreamReader(DijkstraSPTest.class.getClassLoader().getResourceAsStream(&quot;min_route_test.txt&quot;))); int total = Integer.parseInt(br.readLine()); EdgeWeightedDigraph G = new EdgeWeightedDigraph(total); int edgeNumbers = Integer.parseInt(br.readLine()); for(int i=1;i&lt;=edgeNumbers;i++)&#123; String line = br.readLine();//4 5 0.35 String[] strs = line.split(&quot; &quot;); int v = Integer.parseInt(strs[0]); int w = Integer.parseInt(strs[1]); double weight = Double.parseDouble(strs[2]); DirectedEdge e = new DirectedEdge(v, w, weight); G.addEdge(e); &#125; //创建DijkstraSP对象，查找最短路径树 DijkstraSP dijkstraSP = new DijkstraSP(G, 0); //查找最短路径,0-&gt;6的最短路径 Queue&lt;DirectedEdge&gt; edges = dijkstraSP.pathTo(6); //遍历打印 for (DirectedEdge edge : edges) &#123; System.out.println(edge.from()+&quot;-&gt;&quot;+edge.to()+&quot; ：： &quot;+edge.weight()); &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"Git","slug":"38.git","date":"2020-07-04T12:13:24.467Z","updated":"2021-08-30T14:45:24.040Z","comments":false,"path":"2020/07/04/38.git/","link":"","permalink":"http://yoursite.com/2020/07/04/38.git/","excerpt":"","text":"创建和回退 下载地址 https://git-scm.com/download git分为工作区、暂存区、版本库。 使用如下命令可以查看版本记录： git log //简短log git log --pretty=oneline git log --pretty=oneline --graph 查看我们的操作记录，查看版本号： git reflog 使用如下命令查看当前工作树的状态： git status 创建仓库执行命令： git init 使用如下两条命令可以创建一个版本： git add 文件名.格式 git commit –m &apos;版本提交说明1&apos; 撤销工作区修改可以使用(没使用add)： git checkout -- 文件名.格式 把暂存区的修改撤销掉，重新放回工作区(使用了add，没使用commit): git reset HEAD 文件名.格式 现在若想回到某一个版本，可以使用如下命令(使用了commit)： git reset --hard HEAD^ //或者回退1个/100个版本 git reset --hard HEAD~1 git reset --hard HEAD~100 假如我们现在又想回到回退前的版本，可以使用如下命令： git reset --hard 版本号 对比工作区和某个版本文件的不同： git diff HEAD -- 文件名.格式 对比两个版本间文件的不同： git diff HEAD HEAD^ -- 文件名.格式 删错了，可以直接使用(还在工作区，没使用add): git checkout –- 文件名.格式 确实要从版本库中删除文件: git rm 文件名.格式 git commit –m &apos;版本提交说明&apos; 分支管理 截止到目前只有一条时间线，在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交0的，所以，HEAD指向的就是当前分支。 查看当前有几个分支并且看到在哪个分支下工作： git branch 创建一个分支dev,并切换到其上进行工作: git checkout -b dev //只创建分支 git branch dev 切换回master分支： git checkout master 当前在master分支，把dev分支的工作成果合并到master分支上： git merge dev //情况一：Fast-forward,这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快 //情况二：冲突了，先处理冲突文件，在add、commit提交冲突文件。 //情况三：快速合并不能成功而且合并时没有冲突，这个时候会合并之后并做一次新的提交，ctrl+x 强制禁用fast-forward模式: git merge --no-ff -m &apos;版本提交说明&apos; dev 合并完成后，就可以放心地删除dev分支: git branch -d dev 想把当前分支“储藏”起来，切换到别的分支： git stash //切换回来后 //git stash list git stash pop //恢复工作现场 github 克隆项目 git clone ...ssh... 推送分支，就是把该分支上的所有本地提交推送到远程库: git push origin 分支名称 将本地分支跟踪服务器分支: git branch --set-upstream-to=origin/远程分支名称 本地分支名称 推送分支，就是把该分支上的所有本地提交推送到远程库: git push git push origin 分支名称 从远程分支上拉取代码： git pull orgin 分支名称 git三剑客配置 作用域： //local只对某个仓库有效 git config --local //global对当前用户所有仓库有效 git config --global //system对对系统所有登陆的用户有效 git config --system 显示config的配置-加--list git config --list --local git config --list --global git config --list --system 配置user信息 git config --global user.name &apos;your_name&apos; git config --global user.email &apos;your_email&apos;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android性能分析与优化","slug":"35.Android性能分析与优化","date":"2020-06-26T09:55:12.815Z","updated":"2021-03-26T14:41:25.925Z","comments":false,"path":"2020/06/26/35.Android性能分析与优化/","link":"","permalink":"http://yoursite.com/2020/06/26/35.Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/","excerpt":"","text":"1、启动优化1.1、启动类型 冷启动流程：用户点击 -&gt; IPC -&gt; Process.start创建进程 -&gt; ActivityThread(单独进程的入口) -&gt; bindApplication(创建Application) -&gt; LifeCycle(Activity) -&gt; ViewRootImpl界面绘制 冷启动之前会进行的操作：启动App，加载空白Window，创建进程。随后会创建Application，启动主线程，创建Activity，加载布局，布置屏幕，首帧绘制。主要对Application和Activity生命周期进行优化。 热启动：后台切换到前台。 温启动：只会重走Activity的生命周期。 1.2、启动时间 1、adb方式： adb shell am start -W 包名/包名.首屏Activity ThisTime:最后一个Activity启动耗时 TotalTime：所有Activity启动耗时 WaitTime：AMS启动Activity的总耗时 2、手动打点方式：启动时埋点，可以线上使用 开始时间Application @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); //开始计时 &#125; 结束计时 //Activity中 @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); //结束计时 &#125; //或者Adapter @Override public void onBindViewHolder(@NonNull final ViewHolder holder, int position) &#123; if (position == 0 &amp;&amp; !mHasRecorded) &#123; mHasRecorded = true; holder.layout.getViewTreeObserver() .addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; @Override public boolean onPreDraw() &#123; //结束计时 return true; &#125; &#125;); &#125; &#125; 1.3、工具 traceview:图形展示执行时间、调用栈；包含所有线程。缺点：运行变慢。 android.os.Debug.startMethodTracing();//也可以调用startMethodTracing(String traceName) 设置trace文件的文件名 android.os.Debug.stopMethodTracing();//放在结束调试的地方 生成文件在：Android/data/包名/files systrace：结合Android内核的数据，生成Html报告。轻量级，开销小。直接反应cpu利用率。 //b:大小，t:时间，o：生成文件名字 python systrace.py -b 32768 -t 5 -a 包名 -o html文件 sched gfx view wm am app //项目代码 TraceCompat.beginSection(mTask.getClass().getSimpleName()); TraceCompat.endSection(); cputime代码消耗cpu的时间（重要指标）；walltime：代码执行时间。 1.4、统计方法消耗时间 AOP：针对同一类问题统一处理。 AspectJ https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx classpath &apos;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&apos; apply plugin: &apos;android-aspectjx&apos; implementation &apos;org.aspectj:aspectjrt:1.8.+&apos; 例如PerformanceAop类 1.4、Theme小技巧 Theme切换：感觉上更快。 drawable下创建.xml &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;!-- The background color, preferably the same as your normal theme --&gt; &lt;item android:drawable=&quot;@android:color/white&quot;/&gt; &lt;!-- Your product logo - 144dp color version of your app icon --&gt; &lt;item&gt; &lt;bitmap android:src=&quot;@mipmap/splash&quot; android:gravity=&quot;fill&quot;/&gt; &lt;/item&gt; &lt;/layer-list&gt; styles中设置 &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/lanucher&lt;/item&gt; 首屏Activity引用 android:theme=&quot;@style/Theme.Splash&quot; Activity中 setTheme(R.style.AppTheme); //super.onCreate之前切换真正的style super.onCreate(savedInstanceState); 1.5、异步解决方案-启动器 异步优化：子线程分担主线程任务。 Application中的sdk初始化如果不需要再主线程中执行，那么就异步执行。CountDownLatch。 线程池创建线程数，根据手机cup private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); 启动器：充分利用cpu多核，自动梳理任务顺序 代码Task化，启动逻辑抽象为Task。根据任务依赖关系排序生成一个有向无环图。多线程按照排序后的优先级依次执行。 工具类：TaskDispatcher，例子：主线程Task：InitWeexTask；子线程Task：InitAMapTask；等待Task：InitJPushTask。 延迟初始化：在MainActivity的onFeedShow方法中调用DelayInitDispatcher利用addIdleHandler","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"HTTP和加密和HTTPS","slug":"34.HTTP和加密和HTTPS","date":"2020-06-13T04:40:23.631Z","updated":"2021-03-26T14:41:21.592Z","comments":false,"path":"2020/06/13/34.HTTP和加密和HTTPS/","link":"","permalink":"http://yoursite.com/2020/06/13/34.HTTP%E5%92%8C%E5%8A%A0%E5%AF%86%E5%92%8CHTTPS/","excerpt":"","text":"HTTP1.1、HTTP的概念 HTTP是一种网络传输协议，位于TCP/IP协议族的最顶层——应用层。Hypertext Transfer Protocol超文本传输协议，和 HTML (Hypertext Markup Language 超文本标记语言一起诞生，用于在网络上请求和传输HTML内容。 OSI的7层协议：从下到上分别是:7-应用层、6-表示层、5-会话层、4-传输层、3-网络层、2-数据链路层、1-物理层。 TCP三次握手（作用是建立连接）和四次挥手（作用是断开连接）——保证数据传输可靠性。 HTTP协议是一个超文本传输协议。HTTP协议是一个基于TCP传输协议传输数据的。HTTP协议规定了浏览器和Web服务器通信数据的格式。 1.2、URL URL的英文全拼是(Uniform Resoure Locator),表达的意思是统一资源定位符，通俗理解就是网络资源地址，也就是我们常说的网址。 URL三部分组成：协议类型、服务器地址(和端口号)、资源路径(Path)，查询参数部分（可选）。 协议类型://服务器地址[:端口号]路径 1.3、报文 通信是以报文的形式。 请求报文 请求行: method、path、Http version Headers：Host、Content-Type、Content-Length Body 响应报文 状态行: Http version、status code、status message Headers：Content-Type、cache-control、vary、etag、content-encoding Body 请求头和响应头详细参考网站 http://tools.jb51.net/table/http_header 一个HTTP请求报文可以由请求行、请求头、空行和请求体4个部分组成。 请求行是由三部分组成:请求方式、请求资源路径、HTTP协议版本。 GET方式的请求报文没有请求体，只有请求行、请求头、空行组成。 POST方式的请求报文可以有请求行、请求头、空行、请求体四部分组成，注意:POST方式可以允许没有请求体，但是这种格式很少见。 一个HTTP响应报文是由响应行、响应头、空行和响应体4个部分组成。 响应行是由三部分组成：HTTP协议版本、状态码、状态描述。 1.4、请求方法 GET：对服务器数据不进行修改、不发送Body。幂等（反复调用多次会得到相同的结果）。 @GET(&quot;/users/&#123;id&#125;&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender); POST：用于增加或修改资源、不幂等。 @FormUrlEncoded @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) String gender); PUT:仅用于修改资源、发送给服务器的内容写在Body里面、幂等。 @FormUrlEncoded @PUT(&quot;/users/&#123;id&#125;&quot;) Call&lt;User&gt; updateGender(@Path(&quot;id&quot;) String id, @Field(&quot;gender&quot;) String gender); DELETE：用于删除资源、不发送Body、幂等。 @DELETE(&quot;/users/&#123;id&#125;&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender); HEAD：和GET使用方法完全相同，唯一区别在于，返回的响应中没有Body。 1.5、HTTP状态码 1xx: Infomational (信息状态码) ，临时性消息，如：100 （继续发送）、101（正在切换协议） 2xx: Succeed(成功)，请求正常处理完毕,如 200 3xx: Redirection(重定向)，需要进行附加操作，一般是没有响应数据返回的，如 304（Not,modified）307 4xx: Client Error (客户端的错误)，服务器无法处理请求，如 404 5xx: Server Error (服务端的错误)，服务器处理请求出错，如 500 1.5、Content-Type 指定Body的类型。主要有四类： text/html：请求Web页面是返回响应的类型，Body中返回html文本。 x-www-form-urlencoded：Web页面纯文本表单的提交方式。 @FormUrlEncoded @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) String gender); multitype/form-data：Web页面含有二进制文件时的提交方式。 Content-Type: multipart/form-data; boundary=---- @Multipart @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;avatar&quot;) RequestBody avatar); RequestBody namePart = RequestBody.create(MediaType.parse(&quot;text/plain&quot;),nameStr); RequestBody avatarPart = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;),avatarFile); api.addUser(namePart, avatarPart); application/json,image/jpeg,application/zip…单项内容（文本或非文本都可以），用于Web Api的响应或者POST/PUT的请求。 @POST(&quot;/users&quot;) Call&lt;User&gt; addUser(@Body(&quot;user&quot;) User user); @POST(&quot;users/&#123;id&#125;/avatar&quot;) Call&lt;User&gt; updateAvatar(@Path(&quot;id&quot;) String id, @Body RequestBody avatar); RequestBody avatarBody = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;),avatarFile); api.updateAvatar(id, avatarBody) 1.6、Header HTTP消息的元数据 (meta data) User-Agent:用户代理，即是谁实际发送请求、接受响应的，例如收机浏览器、某款收机App。 Host：服务器主机地址 Content-Length：长度 Location：重定向的目标 URL Cookie/Set-Cookie：发送Cookie/设置Cookie Authorization：授权信息 Accept: 客户端能接受的数据类型。如 text/html Accept-Charset: 客户端接受的字符集。如 utf-8 Accept-Encoding: 客户端接受的压缩编码类型。如 gzip Content-Encoding：压缩类型。如 gzip 1.7、Range Accept-Range: bytes 响应报文中出现，表示服务器支持按字节来取范围数据 Range: bytes=&lt;start&gt;-&lt;end&gt; 请求报文中出现，表示要取哪段数据 Content-Range:&lt;start&gt;-&lt;end&gt;/total 响应报⽂中出现，表示发送的是哪段数据 作用：断点续传、多线程下载。 1.8、Cache Cache 和 Buffer 的区别 Cache-Control: no-cache、no-store、max-age Last-Modified If-Modified-Since Etag If-None-Match Cache-Control: private / public 2、加密2.1、对称加密 DES（56位密钥，密钥太短而逐渐被弃用）、AES（128位、192位、256位密钥，现在最流行）。 2.2、非对称加密 使用公钥对数据进行加密得到密文；使用私钥对数据进行解密得到原数据。 缺点：双方公钥都暴漏，可能会伪造数据。 如果用私钥对数据加密，使用公钥是可以解密得到原数据的。但是一般不要互换，签名和验证就是这样，传输数据包括原数据+签名数据。 签名一般先对原数据hash，再进行签名。 用非对称加密+签名来传输数据 -&gt; 密文 + 签名数据。 解决上面的缺点。 经典算法：RSA（可用于加密和签名）、DSA（仅用于签名，但速度更快）。 2.3、Base64 将二进制数据转换成由64个字符组成的字符串的编码算法。64个字符：a-z、A-Z、0-9、+、/。 作用：让原数据具有字符串所具有的特性，如可以放在URL中传输、可以保存到文本文件。 Base64的缺点：因为自身的原理（6位变8位），因此每次Base64编码之后，数据都会增大约1/3，所以会影响存储和传输性能。 Base64并不是加密。 Base58：比特币使用的编码方式，去掉了Base64中的数字0，字母大写O，字母大写I，和字母小写l，以及 “+” 和 “/“ 符号，用于比特币地址的表示。 URL encoding:在URL的字符串中，对一些不用于特殊用途的保留字符，使⽤百分号%为前缀进行单独编码，以避免出现解析错误。 2.4、序列化 把数据对象（一般是内存中的，例如 JVM 中的对象）转换成字节序列的过程。对象在程序内存里的存放形式是散乱的（存放在不同的内存区域、并且由引用进行连接），通过序列化可以把内存中的对象转换成一个字节序列，从而使用byte[]等形式进行本地存储或网络传输，在需要的时候重新组装（反序列化）来使用。 目的：让内存中的对象可以被储存和传输。 序列化是编码吗？不是。编码是把数据由一种数据格式转换成另一种数据格式；而序列化是把数据由内存中的对象（而不是某种具体的格式）转换成字节序列。 2.5、Hash 定义：把任意数据转换成指定大小范围（通常很小，例如256字节以内）的数据。 作用：相当于从数据中提出摘要信息，因此最主要用途是数字指纹。 经典算法：MD5、SHA1、SHA256 等。 Hash的实际用途：唯一性验证。 例如 Java 中的 hashCode() 方法。怎么重写hashCode方法？ 把 equals() 方法中的每个用于判断相等的变量都放进 hashCode() 中，一起生成一个尽量不会碰撞的整数即可。 为什么每次重写 equals() 方法都需要？因为要把新的判断条件放进hashCode()。 Hash的实际用途：数据完整性验证 从网络上下载文件后，通过比对文件的Hash值（例如 MD5、SHA1），可以确认下载的文件是否有损坏。 Hash 的实际用途：快速查找 HashMap Hash 的实际用途：隐私保护 当重要数据必须暴露的时候，可以选择暴露它的Hash值（例如 MD5），以保障原数据的安全。 例如网站登录时，可以只保存用户密码的 Hash 值，在每次登录验证时只需要将输入的密码的Hash值和数据库中保存的 Hash 值作比对就好，网站无需知道用户的密码。这样，当网站数据失窃时，用户不会因为密码被盗导致其他网站的安全也受到威胁。 Hash是单向过程，往往是不可逆的，无法进行逆向恢复操作，因此Hash不属于编码。 Hash是单向过程，无法进行逆向回复操作，因此Hash不属于加密。（MD5不是加密！） 3、HTTPS3.1、TCP/IP协议 具体分层： Application Layer应用层：HTTP、FTP、DNS。 Transport Layer传输层：TCP、UDP。 Internet Layer网络层：IP。 Link Layer数据链路层：以太网、Wi-Fi。 三次握手：客户端：「我要向你发送消息」；服务器：「好的。我要向你发送消息」；客户端：「好的」。 四次挥手：客户端：「我不再给你发送消息」；服务端：「好的」；服务端：「我不再给你发送消息」；客户端：「好的」。 为什么四次挥手而不是三次：因为在客户端停止向服务器发送消息时，也许服务器还有消息需要向客户端发送，因此在它对客户端的「Fin」（即「我不再给你发送消息」，这个词不必记住）消息进行回应时，不需要立即附加上「我也不再向你发送消息」。在稍后服务器的消息发送完毕之后，才需要向客户端发送通知。 长连接：因为移动网络并不在Internet中，而是在运营商的内网，并不具有真正的公网 IP，因此当某个 TCP连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。 长连接的实现方式：心跳。即在一定间隔时间内，使用 TCP 连接发送超短无意义消息来让网关不能将自己定义为「空闲连接」，从而防止网关将自己的连接关闭。 3.2、HTTPS 定义：HTTP在SSL（或 TLS）上工作。 简单说就是加密通信的HTTP。 工作原理：在客户端和服务器之间协商出一套对称密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。因为对称加密性能更好。 为什么不直接用非对称加密？非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响网络通信的性能。 HTTPS 连接建⽴的过程 客户端请求建立连接Client Hello 服务端Server Hello 服务器发送证书（非对称加密的公钥、签名等）- 信任建立 客户端发给服务器Pre-master Secret（非对称加密随机数） 客户端通知：将使用加密通信 客户端发送：Finished 服务器通知：将使用加密通信 服务器发送：Finished 客户端加密密钥（客户端发送消息）、服务端加密密钥（服务端发送消息）、客户端MAC Secret（验证身份）、服务端MAC Secret（验证身份）。 4、网络编程4.1、IP地址 IP地址的作用是标识网络中唯一的一台设备的。 IP地址的表现形式分为: IPv4和IPv6。IPv4是目前使用的ip地址；IPv6是未来使用的ip地址；IPv4是由点分十进制组成；IPv6是由冒号十六进制组成。 查看IP地址：Linux 和 mac OS 使用 ifconfig 这个命令;Windows 使用 ipconfig 这个命令。 检查网络：ping ping www.baidu.com 检查是否能上公网 ping 当前局域网的ip地址 检查是否在同一个局域网内 ping 127.0.0.1 检查本地网卡是否正常 4.2、端口和端口号 端口的作用就是给运行的应用程序提供传输数据的通道。好比房间的门，是数据传输必经之路。 每一个端口都会有一个对应的端口号，好比每个房间的门都有一个门牌号，想要找到端口通过端口号即可。 操作系统为了统一管理这么多端口，就对端口进行了编号，这就是端口号，端口号其实就是一个数字，好比我们现实生活中的门牌号,端口号有65536个。 端口号的作用是用来区分和管理不同端口的，通过端口号能找到唯一个的一个端口。 端口和端口号的关系：端口号可以标识唯一的一个端口。 端口号可以分为两类：知名端口号和动态端口号。 知名端口号的范围是0到1023。这些端口号一般固定分配给一些服务，比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。 动态端口号的范围是1024到65535。如果程序员开发的程序没有设置端口号，操作系统会在动态端口号这个范围内随机生成一个给开发的应用程序使用。当运行一个程序默认会有一个端口号，当这个程序退出时，所占用的这个端口号就会被释放。 4.3、TCP的介绍 通过 IP 地址能够找到对应的设备，然后再通过端口号找到对应的端口，再通过端口把数据传输给应用程序，这里要注意，数据不能随便发送，在发送之前还需要选择一个对应的传输协议，保证程序之间按照指定的传输规则进行数据的通信， 而这个传输协议就是TCP。 TCP的英文全拼(Transmission Control Protocol)简称传输控制协议，它是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP通信步骤:创建连接、传输数据、关闭连接。 TCP的特点： 面向连接：通信双方必须先建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。 可靠传输：TCP 采用发送应答机制、超时重传、错误校验、流量控制和阻塞管理。 4.4、socket的介绍 为了保证数据的完整性和可靠性我们使用tcp传输协议进行数据的传输，为了能够找到对应设备我们需要使用ip地址，为了区别某个端口的应用程序接收数据我们需要使用端口号，那么通信数据是如何完成传输的呢？使用socket来完成。 socket是进程之间通信一个工具，好比现实生活中的插座，所有的家用电器要想工作都是基于插座进行，进程之间想要进行网络通信需要基于这个 socket。 socket的作用：负责进程之间的网络数据传输，好比数据的搬运工。 只要跟网络相关的应用程序或者软件都使用到了socket。进程之间网络数据的传输可以通过socket来完成，socke 就是进程间网络数据通信的工具。 4.5、TCP网络应用程序开发流程 TCP网络应用程序开发分为:TCP客户端程序开发和TCP服务端程序开发。 主动发起建立连接请求的是客户端程序，等待接受连接请求的是服务端程序。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"C基础","slug":"39.C基础","date":"2020-03-21T06:18:40.244Z","updated":"2021-03-26T14:41:37.134Z","comments":false,"path":"2020/03/21/39.C基础/","link":"","permalink":"http://yoursite.com/2020/03/21/39.C%E5%9F%BA%E7%A1%80/","excerpt":"","text":"C语言概述 #include &lt;stdio.h&gt; int main(int argc, const char * argv[]) &#123; printf(&quot;Hello, World!\\n&quot;); return 0; &#125; return return代表函数执行完毕，返回return代表函数的终止 如果main定义的时候前面是int，那么return后面就需要写一个整数；如果main定义的时候前面是void，那么return后面什么也不需要写 在main函数中return 0代表程序执行成功，return -1代表程序执行失败 int main()和void main()在C语言中是一样的，但C++只接受int main这种定义方式 include #include的意思是头文件包含，#include &lt;stdio.h&gt;代表包含stdio.h这个头文件 使用C语言库函数需要提前包含库函数对应的头文件，如这里使用了printf()函数，需要包含stdio.h头文件 #include&lt; &gt; 与 #include &quot;&quot;的区别： &lt; &gt; 表示系统直接按系统指定的目录检索 &quot;&quot; 表示系统先在 &quot;&quot; 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索 C代码编译成可执行程序经过4步.c： 预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法（.i） 编译：检查语法，将预处理后文件编译生成汇编文件(.s) 汇编：将汇编文件生成目标文件(二进制文件)(.o) 链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去() 32个关键字 数据类型关键字（12个） char、short、int、long、float、double、unsigned、signed、struct、union、enum、void 控制语句关键字（12个） if、else、switch、case、default、for、do、while、break、continue、goto、return 存储类关键字（5个） auto、extern、register、static、constant 其他关键字（3个） sizeof、typedef、volatile 变量 声明变量不需要建立存储空间，如：extern int a;。定义变量需要建立存储空间，如：int b;。 #include &lt;stdio.h&gt; int main(int argc, const char* argv[]) &#123; &#123; //extern 关键字只做声明，不能做任何定义 //声明一个变量a，a在这里没有建立存储空间 extern int a; //a = 10; //err, 没有空间，就不可以赋值 int b = 10; //定义一个变量b，b的类型为int，b赋值为10 return 0; &#125; &#125; define、const #include &lt;stdio.h&gt; #define MAX 10 //声明了一个常量，名字叫MAX，值是10，常量的值一旦初始化不可改 int main() &#123; int a; //定义了一个变量，其类型为int，名字叫a const int b = 10; //定义一个const常量，名为叫b，值为10 //b = 11; //err,常量的值不能改变 //MAX = 100; //err,常量的值不能改变 a = MAX;//将abc的值设置为MAX的值 a = 123; printf(&quot;%d\\n&quot;, a); //打印变量a的值 return 0; &#125; 通过 #define 定义的常量,是根据值来匹配数据类型的。const修饰的常量是不安全，可以通过指针来修改。 进制 #include &lt;stdio.h&gt; int main() &#123; int a = 123; //十进制方式赋值 int b = 0123; //八进制方式赋值， 以数字0开头 int c = 0xABC; //十六进制方式赋值 //如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x printf(&quot;十进制：%d\\n&quot;, a); printf(&quot;八进制：%o\\n&quot;, b); //%o,为字母o,不是数字 printf(&quot;十六进制：%x\\n&quot;, c); return 0; &#125; sizeof sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节。sizeof的返回值为size_t。size_t类型在32位操作系统下是unsigned int，是一个无符号的整数。 #include &lt;stdio.h&gt; int main() &#123; int a; int b = sizeof(a);//sizeof得到指定值占用内存的大小，单位：字节 printf(&quot;b = %d\\n&quot;, b); size_t c = sizeof(a); printf(&quot;c = %u\\n&quot;, c);//用无符号数的方式输出c的值 return 0; &#125; int 打印格式 %hd 输出short类型 %d 输出int类型 %l 输出long类型 %ll 输出long long类型 %hu 输出unsigned short类型 %u 输出unsigned int类型 %lu 输出unsigned long类型 %llu 输出unsigned long long类型 代码 #include &lt;stdio.h&gt; int main() &#123; short a = 10; int b = 10; long c = 10l; //或者10L long long d = 10ll; //或者10LL printf(&quot;sizeof(a) = %u\\n&quot;, sizeof(a)); printf(&quot;sizeof(b) = %u\\n&quot;, sizeof(b)); printf(&quot;sizeof(c) = %u\\n&quot;, sizeof(c)); printf(&quot;sizeof(c) = %u\\n&quot;, sizeof(d)); printf(&quot;short a = %hd\\n&quot;, a); printf(&quot;int b = %d\\n&quot;, b); printf(&quot;long c = %ld\\n&quot;, c); printf(&quot;long long d = %lld\\n&quot;, d); unsigned short a2 = 20u; unsigned int b2 = 20u; unsigned long c2 = 20ul; unsigned long long d2 = 20ull; printf(&quot;unsigned short a = %hu\\n&quot;, a2); printf(&quot;unsigned int b = %u\\n&quot;, b2); printf(&quot;unsigned long c = %lu\\n&quot;, c2); printf(&quot;unsigned long long d = %llu\\n&quot;, d2); return 0; &#125; 有符号数是最高位为符号位，0代表正数，1代表负数。 #include &lt;stdio.h&gt; int main() &#123; signed int a = -1089474374; //定义有符号整型变量a printf(&quot;%X\\n&quot;, a); //结果为 BF0FF0BA //B F 0 F F 0 B A //1011 1111 0000 1111 1111 0000 1011 1010 return 0; &#125; 无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。无符号数，可以增大数的表达最大值。 #include &lt;stdio.h&gt; int main() &#123; unsigned int a = 3236958022; //定义无符号整型变量a printf(&quot;%X\\n&quot;, a); //结果为 C0F00F46 return 0; &#125; char 字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。 #include &lt;stdio.h&gt; int main() &#123; char ch = &apos;a&apos;; printf(&quot;sizeof(ch) = %u\\n&quot;, sizeof(ch)); printf(&quot;ch[%%c] = %c\\n&quot;, ch); //打印字符 printf(&quot;ch[%%d] = %d\\n&quot;, ch); //打印‘a’ ASCII的值 char A = &apos;A&apos;; char a = &apos;a&apos;; printf(&quot;a = %d\\n&quot;, a); //97 printf(&quot;A = %d\\n&quot;, A); //65 printf(&quot;A = %c\\n&quot;, &apos;a&apos; - 32); //小写a转大写A printf(&quot;a = %c\\n&quot;, &apos;A&apos; + 32); //大写A转小写a ch = &apos; &apos;; printf(&quot;空字符：%d\\n&quot;, ch); //空字符ASCII的值为32 printf(&quot;A = %c\\n&quot;, &apos;a&apos; - &apos; &apos;); //小写a转大写A printf(&quot;a = %c\\n&quot;, &apos;A&apos; + &apos; &apos;); //大写A转小写a return 0; &#125; float、double #include &lt;stdio.h&gt; int main() &#123; //传统方式赋值 float a = 3.14f; //或3.14F double b = 3.14; printf(&quot;a = %f\\n&quot;, a); printf(&quot;b = %lf\\n&quot;, b); //科学法赋值,e3相当于1000，e-3相当于0.001 a = 3.2e3f; //3.2*1000 = 32000，e可以写E printf(&quot;a1 = %f\\n&quot;, a); a = 100e-3f; //100*0.001 = 0.1 printf(&quot;a2 = %f\\n&quot;, a); a = 3.1415926f; printf(&quot;a3 = %f\\n&quot;, a); //结果为3.141593 return 0; &#125; 类型限定符 //extern:声明一个变量，extern声明的变量没有建立存储空间 extern int a; //const:定义一个常量，常量的值不能修改。 const int a = 10; //volatile 防止编译器优化代码 //register 定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。 字符串常量 字符串是内存中一段连续的char空间，以&#39;\\0&#39;(数字0)结尾。 每个字符串的结尾，编译器会自动的添加一个结束标志位&#39;\\0&#39;，即 &quot;a&quot; 包含两个字符&#39;a&#39;和&#39;\\0&#39;。 运算符 C语言的比较运算中，“真”用数字“1”来表示，“假”用数字“0”来表示。 -&gt; 对象指针-&gt;成员名 //成员选择（指针） &amp; &amp;变量名 //取地址运算符 三目运算符 #include &lt;stdio.h&gt; int main() &#123; int a = 10; int b = 20; int c; c = (a &gt; b ? a : b); printf(&quot;c = %d\\n&quot;, c); return 0; &#125; 冒泡排序 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; int main() &#123; int arr[10] = &#123; 7,4,2,3,5,8,9,6,1,10 &#125;; int len = sizeof(arr) / sizeof(arr[0]) - 1; //冒泡排序 从小到大 for (int i = 0; i &lt;= len; i++) &#123; for (int j = 0; j &lt; len - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d\\n&quot;, arr[i]); &#125; system(&quot;pause&quot;); return EXIT_SUCCESS; &#125; goto语句 无条件跳转，尽量少用。 #include &lt;stdio.h&gt; int main() &#123; goto End; //无条件跳转到End的标识 printf(&quot;aaaaaaaaa\\n&quot;); End: printf(&quot;bbbbbbbb\\n&quot;); return 0; &#125; 数组 数组就是在内存中连续的相同类型的变量空间。同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的。 #include &lt;stdio.h&gt; int main() &#123; int a[10];//定义了一个数组，名字叫a，有10个成员，每个成员都是int类型 //a[0]…… a[9]，没有a[10] //没有a这个变量，a是数组的名字，但不是变量名，它是常量 int i = 0; for (i = 0; i &lt; 10; i++) &#123; a[i] = i; //给数组赋值 &#125; //遍历数组，并输出每个成员的值 for (i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; printf(&quot;\\n&quot;); return 0; &#125; 一维数组的初始化 在定义数组的同时进行赋值，称为初始化。全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。 int a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;//定义一个数组，同时初始化所有成员变量 int a[10] = &#123; 1, 2, 3 &#125;;//初始化前三个成员，后面所有元素都设置为0 int a[10] = &#123; 0 &#125;;//所有的成员都设置为0 //[]中不定义元素个数，定义时必须初始化 int a[] = &#123; 1, 2, 3, 4, 5 &#125;;//定义了一个数组，有5个成员 数组名 数组名是一个地址的常量，代表数组中首元素的地址。 #include &lt;stdio.h&gt; int main() &#123; int a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;//定义一个数组，同时初始化所有成员变量 printf(&quot;a = %p\\n&quot;, a); printf(&quot;&amp;a[0] = %p\\n&quot;, &amp;a[0]);//相等的 int n = sizeof(a); //数组占用内存的大小，10个int类型，10 * 4 = 40 int n0 = sizeof(a[0]);//数组第0个元素占用内存大小，第0个元素为int，4 //遍历数组 int i = 0; for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; printf(&quot;\\n&quot;); return 0; &#125; 数组元素个数： int （size_t） unsigned int 个数 = sizeof(数组名)/sizeof(数组元素 | 数组数据类型) 数组地址 int a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;//定义一个数组，同时初始化所有成员变量 printf(&quot;a = %p\\n&quot;, a); printf(&quot;&amp;a[0] = %p\\n&quot;, &amp;a[0]); 一维数组的最值 #include &lt;stdio.h&gt; int main() &#123; int a[] = &#123; 1, -2, 3,-4, 5, -6, 7, -8, -9, 10 &#125;;//定义一个数组，同时初始化所有成员变量 int i = 0; int max = a[0]; for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; printf(&quot;数组中最大值为：%d\\n&quot;, max); return 0; &#125; 一维数组的逆置 #include &lt;stdio.h&gt; int main() &#123; int a[] = &#123; 1, -2, 3,-4, 5, -6, 7, -8, -9, 10 &#125;;//定义一个数组，同时初始化所有成员变量 int i = 0; int j = sizeof(a) / sizeof(a[0]) - 1; int tmp; while (i &lt; j) &#123; tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) &#123; printf(&quot;%d &quot;, a[i]);//10 -9 -8 7 -6 5 -4 3 -2 1 &#125; printf(&quot;\\n&quot;); return 0; &#125; 冒泡法排序 #include &lt;stdio.h&gt; int main() &#123; int a[] = &#123; 1, -2, 3,-4, 5, -6, 7, -8, -9, 10 &#125;;//定义一个数组，同时初始化所有成员变量 int i = 0; int j = 0; int n = sizeof(a) / sizeof(a[0]); int tmp; for (i = 0; i &lt; n - 1; i++) &#123; for (j = 0; j &lt; n - i - 1; j++)//内循环的目的是比较相邻的元素，把大的放到后面 &#123; if (a[j] &gt; a[j + 1]) &#123; tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; &#125; &#125; &#125; for (i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; printf(&quot;\\n&quot;); return 0; &#125; 二维数组 //常量表达式1表示第一维下标的长度，常量表达式2表示第二维下标的长度。 类型说明符 数组名[常量表达式1][常量表达式2] 在内存中并不存在二维数组，二维数组实际的硬件存储器是连续编址的，也就是说内存中只有一维数组，即放完一行之后顺次放入第二行，和一维数组存放方式是一样的。 实现 #include &lt;stdio.h&gt; int main() &#123; //定义了一个二维数组，名字叫a //由3个一维数组组成，这个一维数组是int [4] //这3个一维数组的数组名分别为a[0],a[1],a[2] int a[3][4]; //给数组每个元素赋值 int i = 0; int j = 0; int num = 0; for (i = 0; i &lt; 3; i++) &#123; for (j = 0; j &lt; 4; j++) &#123; a[i][j] = num++; &#125; &#125; //遍历数组，并输出每个成员的值 for (i = 0; i &lt; 3; i++) &#123; for (j = 0; j &lt; 4; j++) &#123; printf(&quot;%d, &quot;, a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0; &#125; 二维数组的初始化 //分段赋值 int a[3][4] = &#123;&#123; 1, 2, 3, 4 &#125;,&#123; 5, 6, 7, 8, &#125;,&#123; 9, 10, 11, 12 &#125;&#125;; //连续赋值 int a[3][4] = &#123; 1, 2, 3, 4 , 5, 6, 7, 8, 9, 10, 11, 12&#125;; //可以只给部分元素赋初值，未初始化则为0 int a[3][4] = &#123; 1, 2, 3, 4&#125;; //所有的成员都设置为0 int a[3][4] = &#123;0&#125;; //[]中不定义元素个数，定义时必须初始化 int a[][4] = &#123; 1, 2, 3, 4, 5, 6, 7, 8&#125;; 数组名 数组名是一个地址的常量，代表数组中首元素的地址。 #include &lt;stdio.h&gt; int main() &#123; //定义了一个二维数组，名字叫a。二维数组是本质上还是一维数组，此一维数组有3个元素。每个元素又是一个一维数组int[4] int a[3][4] = &#123; 1, 2, 3, 4 , 5, 6, 7, 8, 9, 10, 11, 12 &#125;; //数组名为数组首元素地址，二维数组的第0个元素为一维数组。第0个一维数组的数组名为a[0] printf(&quot;a = %p\\n&quot;, a); printf(&quot;a[0] = %p\\n&quot;, a[0]);//二者相等 //测二维数组所占内存空间，有3个一维数组，每个一维数组的空间为4*4。sizeof(a) = 3 * 4 * 4 = 48 printf(&quot;sizeof(a) = %d\\n&quot;, sizeof(a)); //测第0个元素所占内存空间，a[0]为第0个一维数组int[4]的数组名，4*4=16 printf(&quot;sizeof(a[0]) = %d\\n&quot;, sizeof(a[0])); //测第0行0列元素所占内存空间，第0行0列元素为一个int类型，4字节 printf(&quot;sizeof(a[0][0]) = %d\\n&quot;, sizeof(a[0][0])); //求二维数组行数，3 printf(&quot;i = %d\\n&quot;, sizeof(a) / sizeof(a[0])); // 求二维数组列数，4 printf(&quot;j = %d\\n&quot;, sizeof(a[0]) / sizeof(a[0][0])); //求二维数组行*列总数，12 printf(&quot;n = %d\\n&quot;, sizeof(a) / sizeof(a[0][0])); return 0; &#125; 字符数组与字符串 C语言中没有字符串这种数据类型，可以通过char的数组来替代；字符串一定是一个char的数组，但char的数组未必是字符串；数字0(和字符‘\\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。 #include &lt;stdio.h&gt; int main() &#123; char c1[] = &#123; &apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos; &#125;; //普通字符数组 printf(&quot;c1 = %s\\n&quot;, c1); //乱码，因为没有’\\0’结束符 //以‘\\0’(‘\\0’就是数字0)结尾的字符数组是字符串 char c2[] = &#123; &apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;\\0&apos; &#125;; printf(&quot;c2 = %s\\n&quot;, c2); //字符串处理以‘\\0’(数字0)作为结束符，后面的&apos;h&apos;, &apos;l&apos;, &apos;l&apos;, &apos;e&apos;, &apos;o&apos;不会输出 char c3[] = &#123; &apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;\\0&apos;, &apos;h&apos;, &apos;l&apos;, &apos;l&apos;, &apos;e&apos;, &apos;o&apos;, &apos;\\0&apos; &#125;; printf(&quot;c3 = %s\\n&quot;, c3); return 0; &#125; 字符串初始化 #include &lt;stdio.h&gt; // C语言没有字符串类型，通过字符数组模拟 // C语言字符串，以字符‘\\0’, 数字0 int main() &#123; //不指定长度, 没有0结束符，有多少个元素就有多长 char buf[] = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;; printf(&quot;buf = %s\\n&quot;, buf); //乱码 //指定长度，后面没有赋值的元素，自动补0 char buf2[100] = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;; printf(&quot;buf2 = %s\\n&quot;, buf2);//buf2 = abc //所有元素赋值为0 char buf3[100] = &#123; 0 &#125;; //char buf4[2] = &#123; &apos;1&apos;, &apos;2&apos;, &apos;3&apos; &#125;;//数组越界 char buf5[50] = &#123; &apos;1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;0&apos;, &apos;7&apos; &#125;; printf(&quot;buf5 = %s\\n&quot;, buf5);//buf5 = 1ab07 char buf6[50] = &#123; &apos;1&apos;, &apos;a&apos;, &apos;b&apos;, 0, &apos;7&apos; &#125;; printf(&quot;buf6 = %s\\n&quot;, buf6);// 1ab char buf7[50] = &#123; &apos;1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;\\0&apos;, &apos;7&apos; &#125;; printf(&quot;buf7 = %s\\n&quot;, buf7);// 1ab //使用字符串初始化，编译器自动在后面补0，常用 char buf8[] = &quot;agjdslgjlsdjg&quot;; //&apos;\\0&apos;后面最好不要连着数字，有可能几个数字连起来刚好是一个转义字符 //&apos;\\ddd&apos;八进制字义字符，&apos;\\xdd&apos;十六进制转移字符 // \\012相当于\\n char str[] = &quot;\\012abc&quot;; printf(&quot;str == %s\\n&quot;, str); return 0; &#125; 字符串追加拼接 #include &lt;stdio.h&gt; int main() &#123; char str1[] = &quot;abcdef&quot;; char str2[] = &quot;123456&quot;; char dst[100]; int i = 0; while (str1[i] != 0) &#123; dst[i] = str1[i]; i++; &#125; int j = 0; while (str2[j] != 0) &#123; dst[i + j] = str2[j]; j++; &#125; dst[i + j] = 0; //字符串结束符 printf(&quot;dst = %s\\n&quot;, dst); return 0; &#125; 随机数 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int main() &#123; time_t tm = time(NULL);//得到系统时间 srand((unsigned int)tm);//随机种子只需要设置一次即可 int r = rand(); printf(&quot;r = %d\\n&quot;, r); return 0; &#125; strlen() #include &lt;string.h&gt;计算指定指定字符串的长度，不包含字符串结束符‘\\0’。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char str[] = &quot;abcdefg&quot;; int n = strlen(str); printf(&quot;n = %d\\n&quot;, n); return 0; &#125; strcpy_s include &lt;string.h&gt; char *strcpy_s(char *dest, const char *src); 功能：把src所指向的字符串复制到dest所指向的空间中，’\\0’也会拷贝过去。返回值：成功：返回dest字符串的首地址；失败：NULL。 注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char dest[20] = &quot;123456789&quot;; char src[] = &quot;hello world&quot;; strcpy_s(dest, src); printf(&quot;%s\\n&quot;, dest); return 0; &#125; strncpy_s #include &lt;string.h&gt; char *strncpy_s(char *dest, const char *src, size_t n);把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含’\\0’。返回值：成功：返回dest字符串的首地址;失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char dest[20]; char src[] = &quot;hello world&quot;; strncpy_s(dest, src, 5); printf(&quot;%s\\n&quot;, dest); dest[5] = &apos;\\0&apos;; printf(&quot;%s\\n&quot;, dest); return 0; &#125; strcat_s #include &lt;string.h&gt; char *strcat_s(char *dest, const char *src);将src字符串连接到dest的尾部，‘\\0’也会追加过去。返回值：成功：返回dest字符串的首地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char str[20] = &quot;123&quot;; char src[] = &quot;hello world&quot;; strcat_s(str, src); printf(&quot;%s\\n&quot;, str); return 0; &#125; strncat_s #include &lt;string.h&gt; char *strncat(char *dest, const char *src, size_t n);将src字符串前n个字符连接到dest的尾部，‘\\0’也会追加过去。返回值：成功：返回dest字符串的首地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char str[20] = &quot;123&quot;; char src[] = &quot;hello world&quot;; strncat_s(str, src,5); printf(&quot;%s\\n&quot;, str); return 0; &#125; strcmp和strncmp 比较 s1 和 s2 的大小，比较的是字符ASCII码大小。返回值：相等：0; 大于：&gt;0; 小于：&lt;0。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello mike&quot;; if (strcmp(str1, str2) == 0) &#123; printf(&quot;str1==str2\\n&quot;); &#125; else if (strcmp(str1, str2) &gt; 0) &#123; printf(&quot;str1&gt;str2\\n&quot;); &#125; else &#123; printf(&quot;str1&lt;str2\\n&quot;); &#125; return 0; &#125; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello mike&quot;; if (strncmp(str1, str2, 5) == 0) &#123; printf(&quot;str1==str2\\n&quot;); &#125; else if (strncmp(str1, str2, 5) &gt; 0) &#123; printf(&quot;str1&gt;str2\\n&quot;); &#125; else &#123; printf(&quot;str1&lt;str2\\n&quot;); &#125; return 0; &#125; sprintf_s #include &lt;stdio.h&gt; int main() &#123; char dst[100] = &#123; 0 &#125;; int a = 10; char src[] = &quot;hello world&quot;; printf(&quot;a = %d, src = %s&quot;, a, src); printf(&quot;\\n&quot;); int len = sprintf_s(dst, &quot;a = %d, src = %s&quot;, a, src); printf(&quot;dst = \\&quot; %s\\&quot;\\n&quot;, dst);// dst = &quot; a = 10, src = hello world&quot; printf(&quot;len = %d\\n&quot;, len);//25 return 0; &#125; strchr #include &lt;string.h&gt; char *strchr(const char *s, int c);在字符串s中查找字母c出现的位置。返回值：成功：返回第一次出现的c地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char src[] = &quot;ddda123abcd&quot;; char* p = strchr(src, &apos;a&apos;); printf(&quot;p = %s\\n&quot;, p); return 0; &#125; strstr #include &lt;string.h&gt; char *strstr(const char *haystack, const char *needle);在字符串haystack中查找字符串needle出现的位置。返回值：成功：返回第一次出现的needle地址；失败：NULL。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char src[] = &quot;ddddabcd123abcd333abcd&quot;; char* p = strstr(src, &quot;abcd&quot;); printf(&quot;p = %s\\n&quot;, p);//p = abcd123abcd333abcd return 0; &#125; strstr #include &lt;stdlib.h&gt; int atoi(const char *nptr);atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(‘\\0’)才结束转换，并将结果返回返回值。返回值：成功转换后整数 类似的函数有：atof()：把一个小数形式的字符串转化为一个浮点数。atol()：将一个字符串转化为long类型。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; char str1[] = &quot;-10&quot;; int num1 = atoi(str1); printf(&quot;num1 = %d\\n&quot;, num1);//num1 = -10 char str2[] = &quot;0.123&quot;; double num2 = atof(str2); printf(&quot;num2 = %lf\\n&quot;, num2);//num2 = 0.123000 return 0; &#125; 函数函数的定义 函数定义的一般形式： 返回类型 函数名(形式参数列表) &#123; 数据定义部分; 执行语句部分; &#125; 如果没有形参，圆括号内容为空，或写一个void关键字。 函数的形参和实参 形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参也不能使用。单向传递，只由实参传给形参，而不能由形参传回来给实参。在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放。实参单元与形参单元是不同的单元。调用结束后，形参单元被释放，函数调用结束返回主调函数后则不能再使用该形参变量。实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调函数中实参的值。 实参可以是常量、变量或表达式。 函数的声明 函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数作声明。 所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行。注意：一个函数只能被定义一次，但可以声明多次。 #include &lt;stdio.h&gt; int max(int x, int y); // 函数的声明，分号不能省略 // int max(int, int); // 另一种方式 int main() &#123; int a = 10, b = 25, num_max = 0; num_max = max(a, b); // 函数的调用 printf(&quot;num_max = %d\\n&quot;, num_max); return 0; &#125; // 函数的定义 int max(int x, int y) &#123; return x &gt; y ? x : y; &#125; exit 在main函数中调用exit和return结果是一样的，但在子函数中调用return只是代表子函数终止了，在子函数中调用exit，那么程序终止。 分文件编程 max.h文件 extern int max(int a, int b); max.c文件 int max(int x, int y) &#123; return x &gt; y ? x : y; &#125; main.c文件 #include &lt;stdio.h&gt; #include &quot;max.h&quot; int main() &#123; int a = 10, b = 25, num_max = 0; num_max = max(a, b); // 函数的调用 printf(&quot;num_max = %d\\n&quot;, num_max); return 0; &#125; 防止头文件重复包含 方法一： #ifndef __SOMEFILE_H__ #define __SOMEFILE_H__ // 声明语句 #endif 方法二： #pragma once // 声明语句 指针int i 定义整形变量 int *p 定义一个指向int的指针变量 int a[10] 定义一个有10个元素的数组，每个元素类型为int int *p[10] 定义一个有10个元素的数组，每个元素类型为int* int func() 定义一个函数，返回值为int型 int *func() 定义一个函数，返回值为int *型 int **p 定义一个指向int的指针的指针，二级指针 内存地址和指针 将内存抽象成一个很大的一维字符数组。编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）。这个内存编号我们称之为内存地址。 内存中的每一个数据都会分配相应的地址：char:占一个字节分配一个地址；int: 占四个字节分配四个地址。 内存区的每一个字节都有一个编号，这就是“地址”。 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号) 指针的实质就是内存“地址”。指针就是地址，地址就是指针。指针是内存单元的编号，指针变量是存放地址的变量。 指针也是一种数据类型，指针变量也是一种变量。指针变量指向谁，就把谁的地址赋值给指针变量。“*”操作符操作的是指针变量指向的内存空间。 #include &lt;stdio.h&gt; int main() &#123; int a = 0; char b = 100; printf(&quot;%p, %p\\n&quot;, &amp;a, &amp;b); //打印a, b的地址 //int *代表是一种数据类型，int*指针类型，p才是变量名 //定义了一个指针类型的变量，可以指向一个int类型变量的地址 int* p; p = &amp;a;//将a的地址赋值给变量p，p也是一个变量，值是一个内存地址编号 printf(&quot;%d\\n&quot;, *p);//p指向了a的地址，*p就是a的值 char* p1 = &amp;b; printf(&quot;%c\\n&quot;, *p1);//*p1指向了b的地址，*p1就是b的值 return 0; &#125; 通过指针间接修改变量的值 #include &lt;stdio.h&gt; int main() &#123; int a = 0; int b = 11; int* p = &amp;a; *p = 100; printf(&quot;a = %d, *p = %d\\n&quot;, a, *p);//a = 100, *p = 100 p = &amp;b; *p = 22; printf(&quot;b = %d, *p = %d\\n&quot;, b, *p);//b = 22, *p = 22 return 0; &#125; 指针大小 使用sizeof()测量指针的大小，得到的总是：4或8。sizeof()测的是指针变量指向存储地址的大小。 在32位平台，所有的指针（地址）都是32位(4字节)。在64位平台，所有的指针（地址）都是64位(8字节)。 野指针和空指针 指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。 int a = 100; int* p; p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义 p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义 *p = 1000; //操作野指针指向未知区域，内存出问题，err 但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。NULL是一个值为0的宏常量： int *p = NULL; 万能指针 void *指针可以指向任意变量的内存空间： void* p = NULL; int a = 10; p = (void*)&amp;a; //指向变量时，最好转换为void * //使用指针变量指向的内存时，转换为int * *((int*)p) = 11; printf(&quot;a = %d\\n&quot;, a);//11 const修饰的指针变量 指针常量和常量的指针 #include &lt;stdio.h&gt; int main() &#123; int a = 100; int b = 200; //指向常量的指针 //修饰*，指针指向内存区域不能修改，指针指向可以变 const int* p1 = &amp;a; //等价于int const *p1 = &amp;a; //*p1 = 111; //err p1 = &amp;b; //ok //指针常量 //修饰p2，指针指向不能变，指针指向的内存可以修改 int* const p2 = &amp;a; //p2 = &amp;b; //err *p2 = 222; //ok return 0; &#125; 指针和数组 数组名字是数组的首元素地址，但它是一个常量： int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; printf(&quot;a = %p\\n&quot;, a);//a = 0000002A5F6FFB48 printf(&quot;&amp;a[0] = %p\\n&quot;, &amp;a[0]);//&amp;a[0] = 0000002A5F6FFB48 //a = 10; //err, 数组名只是常量，不能修改 指针操作数组元素 #include &lt;stdio.h&gt; int main() &#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int i = 0; int n = sizeof(a) / sizeof(a[0]); for (i = 0; i &lt; n; i++) &#123; //printf(&quot;%d, &quot;, a[i]); printf(&quot;%d, &quot;, *(a + i));//1, 2, 3, 4, 5, 6, 7, 8, 9, &#125; printf(&quot;\\n&quot;); int* p = a; //定义一个指针变量保存a的地址 for (i = 0; i &lt; n; i++) &#123; p[i] = 2 * i; &#125; for (i = 0; i &lt; n; i++) &#123; printf(&quot;%d, &quot;, *(p + i));//0, 2, 4, 6, 8, 10, 12, 14, 16, &#125; printf(&quot;\\n&quot;); return 0; &#125; 指针加法运算:指针计算不是简单的整数相加，如果是一个int *，+1的结果是增加一个int的大小;如果是一个char *，+1的结果是增加一个char大小。 int a; int* p = &amp;a; printf(&quot;%d\\n&quot;, p);//896988804 p += 2;//移动了2个int printf(&quot;%d\\n&quot;, p);//896988812 char b = 0; char* p1 = &amp;b; printf(&quot;%d\\n&quot;, p1);//896988812 p1 += 2;//移动了2个char printf(&quot;%d\\n&quot;, p1);//896988812 return 0; 通过改变指针指向操作数组元素： #include &lt;stdio.h&gt; int main() &#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int i = 0; int n = sizeof(a) / sizeof(a[0]); int *p = a; for (i = 0; i &lt; n; i++) &#123; printf(&quot;%d, &quot;, *p); p++; &#125; printf(&quot;\\n&quot;);//1, 2, 3, 4, 5, 6, 7, 8, 9, return 0; &#125; 指针减法运算 int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int* p2 = &amp;a[2]; //第2个元素地址 int* p1 = &amp;a[1]; //第1个元素地址 printf(&quot;p1 = %p, p2 = %p\\n&quot;, p1, p2); int n1 = p2 - p1; //n1 = 1 int n2 = (int)p2 - (int)p1; //n2 = 4 printf(&quot;n1 = %d, n2 = %d\\n&quot;, n1, n2); 指针数组，它是数组，数组的每个元素都是指针类型。 //指针数组 int* p[3]; int a = 1; int b = 2; int c = 3; int i = 0; p[0] = &amp;a; p[1] = &amp;b; p[2] = &amp;c; for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++) &#123; printf(&quot;%d, &quot;, *(p[i]));//1, 2, 3, &#125; printf(&quot;\\n&quot;); 多级指针 C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。二级指针就是指向一个一级指针变量地址的指针。 int a = 10; int* p = &amp;a; //一级指针 *p = 100; //*p就是a int** q = &amp;p; //*q就是p //**q就是a int*** t = &amp;q; //*t就是q //**t就是p //***t就是a 指针和函数函数形参改变实参的值 #include &lt;stdio.h&gt; void swap1(int x, int y) &#123; int tmp; tmp = x; x = y; y = tmp; printf(&quot;x = %d, y = %d\\n&quot;, x, y);//x = 5, y = 3 &#125; void swap2(int* x, int* y) &#123; int tmp; tmp = *x; *x = *y; *y = tmp; &#125; int main() &#123; int a = 3; int b = 5; swap1(a, b); //值传递 printf(&quot;a = %d, b = %d\\n&quot;, a, b);//a = 3, b = 5 a = 3; b = 5; swap2(&amp;a, &amp;b); //地址传递 printf(&quot;a2 = %d, b2 = %d\\n&quot;, a, b);//a2 = 5, b2 = 3 return 0; &#125; 数组名做函数参数 数组名做函数参数，函数的形参会退化为指针。 //void printArrary(int a[10], int n) //void printArrary(int a[], int n) void printArrary(int* a, int n) &#123; int i = 0; for (i = 0; i &lt; n; i++) &#123; printf(&quot;%d, &quot;, a[i]);//1, 2, 3, 4, 5, 6, 7, 8, 9, &#125; printf(&quot;\\n&quot;); &#125; int main() &#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int n = sizeof(a) / sizeof(a[0]); //数组名做函数参数 printArrary(a, n); return 0; &#125; 指针做为函数的返回值 #include &lt;stdio.h&gt; int a = 10; int* getA() &#123; return &amp;a; &#125; int main() &#123; *(getA()) = 111; printf(&quot;a = %d\\n&quot;, a);//a = 111 return 0; &#125; 指针和字符串 char str[] = &quot;hello world&quot;; char* p = str; *p = &apos;m&apos;; p++; *p = &apos;i&apos;; printf(&quot;%s\\n&quot;, str);//millo world p = &quot;mike jiang&quot;; printf(&quot;%s\\n&quot;, p);//mike jiang char* q = &quot;test&quot;; printf(&quot;%s\\n&quot;, q);//test 字符指针做函数参数 #include &lt;stdio.h&gt; void mystrcat(char* dest, const char* src) &#123; int len1 = 0; int len2 = 0; while (dest[len1]) &#123; len1++; &#125; while (src[len2]) &#123; len2++; &#125; int i; for (i = 0; i &lt; len2; i++) &#123; dest[len1 + i] = src[i]; &#125; &#125; int main() &#123; char dst[100] = &quot;hello mike&quot;; char src[] = &quot;123456&quot;; mystrcat(dst, src); printf(&quot;dst = %s\\n&quot;, dst);//dst = hello mike123456 return 0; &#125; const修饰的指针，变量从左往右看，跳过类型，看修饰哪个字符，如果是*， 说明指针指向的内存不能改变，如果是指针变量，说明指针的指向不能改变，指针的值不能修改。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) &#123; //const修饰一个变量为只读 const int a = 10; //a = 100; //err //指针变量， 指针指向的内存， 2个不同概念 char buf[] = &quot;aklgjdlsgjlkds&quot;; //从左往右看，跳过类型，看修饰哪个字符 //如果是*， 说明指针指向的内存不能改变 //如果是指针变量，说明指针的指向不能改变，指针的值不能修改 const char* p = buf; // 等价于上面 char const *p1 = buf; //p[1] = &apos;2&apos;; //err p = &quot;agdlsjaglkdsajgl&quot;; //ok char* const p2 = buf; p2[1] = &apos;3&apos;; //p2 = &quot;salkjgldsjaglk&quot;; //err //p3为只读，指向不能变，指向的内存也不能变 const char* const p3 = buf; return 0; &#125; 查找”abcd”个数-while #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) &#123; char* p = &quot;11abcd111122abcd333abcd3322abcd3333322qqq&quot;; int n = 0; while ((p = strstr(p, &quot;abcd&quot;)) != NULL) &#123; //能进来，肯定有匹配的子串 //重新设置起点位置 p = p + strlen(&quot;abcd&quot;); n++; if (*p == 0) //如果到结束符 &#123; break; &#125; &#125; printf(&quot;n = %d\\n&quot;, n); return 0; &#125; 查找”abcd”个数-do-while #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) &#123; char* p = &quot;11abcd111122abcd333abcd3322abcd3333322qqq&quot;; int n = 0; do &#123; p = strstr(p, &quot;abcd&quot;); if (p != NULL) &#123; n++; //累计个数 //重新设置查找的起点 p = p + strlen(&quot;abcd&quot;); &#125; else //如果没有匹配的字符串，跳出循环 &#123; break; &#125; &#125; while (*p != 0); //如果没有到结尾 printf(&quot;n = %d\\n&quot;, n); return 0; &#125; 求非空字符串元素的个数： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; int fun(char* p, int* n) &#123; if (p == NULL || n == NULL) &#123; return -1; &#125; int begin = 0; int end = strlen(p) - 1; //从左边开始 //如果当前字符为空，而且没有结束 while (p[begin] == &apos; &apos; &amp;&amp; p[begin] != 0) &#123; begin++; //位置从右移动一位 &#125; //从右往左移动 while (p[end] == &apos; &apos; &amp;&amp; end &gt; 0) &#123; end--; //往左移动 &#125; if (end == 0) &#123; return -2; &#125; //非空元素个数 *n = end - begin + 1; return 0; &#125; int main(void) &#123; char* p = &quot; abcddsgadsgefg &quot;; int ret = 0; int n = 0; ret = fun(p, &amp;n); if (ret != 0) &#123; return ret; &#125; printf(&quot;非空字符串元素个数：%d\\n&quot;, n);//非空字符串元素个数：14 return 0; &#125; 字符串反转模型(逆置): #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int inverse(char* p) &#123; if (p == NULL) &#123; return -1; &#125; char* str = p; int begin = 0; int end = strlen(str) - 1; char tmp; while (begin &lt; end) &#123; //交换元素 tmp = str[begin]; str[begin] = str[end]; str[end] = tmp; begin++; //往右移动位置 end--; //往左移动位置 &#125; return 0; &#125; int main(void) &#123; //char *str = &quot;abcdefg&quot;; //文件常量区，内容不允许修改 char str[] = &quot;abcdef&quot;; int ret = inverse(str); if (ret != 0) &#123; return ret; &#125; printf(&quot;str ========== %s\\n&quot;, str);//str ========== fedcba return 0; &#125; 内存管理 类型 作用域 生命周期 存储位置 auto变量 一对&#123;&#125;内 当前函数 栈区 static局部变量 一对&#123;&#125;内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对&#123;&#125;内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 C代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。 只有c语言将数组放在栈区。 malloc() #include &lt;stdlib.h&gt; void *malloc(size_t size); 功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。参数：size：需要分配内存大小(单位：字节)。返回值：成功：分配空间的起始地址，失败：NULL。 free #include &lt;stdlib.h&gt; void free(void *ptr); 功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。参数：ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。返回值：无。 结构体 定义结构体变量的方式：先声明结构体类型再定义变量名；在声明类型的同时定义变量；直接定义结构体类型变量（无类型名）。 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; //先定义类型，再定义变量（常用） struct stu s1 = &#123; &quot;mike&quot;, 18 &#125;; //定义类型同时定义变量 struct stu2 &#123; char name[50]; int age; &#125;s2 = &#123; &quot;lily&quot;, 22 &#125;; struct &#123; char name[50]; int age; &#125;s3 = &#123; &quot;yuri&quot;, 25 &#125;; 结构体成员的使用 #include&lt;stdio.h&gt; #include&lt;string.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; int main() &#123; struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, &quot;abc&quot;); s1.age = 18; printf(&quot;s1.name = %s, s1.age = %d\\n&quot;, s1.name, s1.age); //如果是指针变量，通过-&gt;操作结构体成员 strcpy((&amp;s1)-&gt;name, &quot;test&quot;); (&amp;s1)-&gt;age = 22; printf(&quot;(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\\n&quot;, (&amp;s1)-&gt;name, (&amp;s1)-&gt;age); return 0; &#125; 结构体数组 #include &lt;stdio.h&gt; //统计学生成绩 struct stu &#123; int num; char name[20]; char sex; float score; &#125;; int main() &#123; //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = &#123; &#123; 101, &quot;Li ping&quot;, &apos;M&apos;, 45 &#125;, &#123; 102, &quot;Zhang ping&quot;, &apos;M&apos;, 62.5 &#125;, &#123; 103, &quot;He fang&quot;, &apos;F&apos;, 92.5 &#125;, &#123; 104, &quot;Cheng ling&quot;, &apos;F&apos;, 87 &#125;, &#123; 105, &quot;Wang ming&quot;, &apos;M&apos;, 58 &#125; &#125;; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i &lt; 5; i++) &#123; s += boy[i].score; //计算总分 if (boy[i].score &lt; 60) &#123; c += 1; //统计不及格人的分数 &#125; &#125; printf(&quot;s=%f\\n&quot;, s);//打印总分数 s=345.000000 ave = s / 5; //计算平均分数 printf(&quot;average=%f\\ncount=%d\\n\\n&quot;, ave, c); //打印平均分与不及格人数 average=69.000000 count=2 for (i = 0; i &lt; 5; i++) &#123; printf(&quot; name=%s, score=%f\\n&quot;, boy[i].name, boy[i].score); // printf(&quot; name=%s, score=%f\\n&quot;, (boy+i)-&gt;name, (boy+i)-&gt;score); &#125; return 0; &#125; 结构体套结构体 #include &lt;stdio.h&gt; struct person &#123; char name[20]; char sex; &#125;; struct stu &#123; int id; struct person info; &#125;; int main() &#123; struct stu s[2] = &#123; 1, &quot;lily&quot;, &apos;F&apos;, 2, &quot;yuri&quot;, &apos;M&apos; &#125;; int i = 0; for (i = 0; i &lt; 2; i++) &#123; printf(&quot;id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n&quot;, s[i].id, s[i].info.name, s[i].info.sex); &#125; return 0; &#125; 结构体赋值 #include&lt;stdio.h&gt; #include&lt;string.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; int main() &#123; struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, &quot;abc&quot;); s1.age = 18; printf(&quot;s1.name = %s, s1.age = %d\\n&quot;, s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(&amp;s2, &amp;s1, sizeof(s1)); printf(&quot;s2.name = %s, s2.age = %d\\n&quot;, s2.name, s2.age); return 0; &#125; 指向普通结构体变量的指针 #include&lt;stdio.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; int main() &#123; struct stu s1 = &#123; &quot;lily&quot;, 18 &#125;; //如果是指针变量，通过-&gt;操作结构体成员 struct stu* p = &amp;s1; printf(&quot;p-&gt;name = %s, p-&gt;age=%d\\n&quot;, p-&gt;name, p-&gt;age);//p-&gt;name = lily, p-&gt;age=18 printf(&quot;(*p).name = %s, (*p).age=%d\\n&quot;, (*p).name, (*p).age);//(*p).name = lily, (*p).age=18 return 0; &#125; 堆区结构体变量 #include&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; int main() &#123; struct stu* p = NULL; p = (struct stu*)malloc(sizeof(struct stu)); //如果是指针变量，通过-&gt;操作结构体成员 strcpy(p-&gt;name, &quot;test&quot;); p-&gt;age = 22; printf(&quot;p-&gt;name = %s, p-&gt;age=%d\\n&quot;, p-&gt;name, p-&gt;age); printf(&quot;(*p).name = %s, (*p).age=%d\\n&quot;, (*p).name, (*p).age); free(p); p = NULL; return 0; &#125; 结构体套一级指针 #include&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; //结构体类型的定义 struct stu &#123; char* name; //一级指针 int age; &#125;; int main() &#123; struct stu* p = NULL; p = (struct stu*)malloc(sizeof(struct stu)); p-&gt;name = malloc(strlen(&quot;test&quot;) + 1); strcpy(p-&gt;name, &quot;test&quot;); p-&gt;age = 22; printf(&quot;p-&gt;name = %s, p-&gt;age=%d\\n&quot;, p-&gt;name, p-&gt;age); printf(&quot;(*p).name = %s, (*p).age=%d\\n&quot;, (*p).name, (*p).age); if (p-&gt;name != NULL) &#123; free(p-&gt;name); p-&gt;name = NULL; &#125; if (p != NULL) &#123; free(p); p = NULL; &#125; return 0; &#125; 结构体普通变量做函数参数 #include&lt;stdio.h&gt; #include &lt;string.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; //函数参数为结构体普通变量 void set_stu(struct stu tmp) &#123; strcpy(tmp.name, &quot;mike&quot;); tmp.age = 18; printf(&quot;tmp.name = %s, tmp.age = %d\\n&quot;, tmp.name, tmp.age); &#125; int main() &#123; struct stu s = &#123; 0 &#125;; set_stu(s); //值传递 printf(&quot;s.name = %s, s.age = %d\\n&quot;, s.name, s.age); return 0; &#125; 结构体指针变量做函数参数 #include&lt;stdio.h&gt; #include &lt;string.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; //函数参数为结构体指针变量 void set_stu_pro(struct stu *tmp) &#123; strcpy(tmp-&gt;name, &quot;mike&quot;); tmp-&gt;age = 18; &#125; int main() &#123; struct stu s = &#123; 0 &#125;; set_stu_pro(&amp;s); //地址传递 printf(&quot;s.name = %s, s.age = %d\\n&quot;, s.name, s.age); return 0; &#125; 结构体数组名做函数参数 #include&lt;stdio.h&gt; //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; //void set_stu_pro(struct stu tmp[100], int n) //void set_stu_pro(struct stu tmp[], int n) void set_stu_pro(struct stu *tmp, int n) &#123; int i = 0; for (i = 0; i &lt; n; i++) &#123; sprintf(tmp-&gt;name, &quot;name%d%d%d&quot;, i, i, i); tmp-&gt;age = 20 + i; tmp++; &#125; &#125; int main() &#123; struct stu s[3] = &#123; 0 &#125;; int i = 0; int n = sizeof(s) / sizeof(s[0]); set_stu_pro(s, n); //数组名传递 for (i = 0; i &lt; n; i++) &#123; printf(&quot;%s, %d\\n&quot;, s[i].name, s[i].age); &#125; return 0; &#125; const修饰结构体指针形参变量 //结构体类型的定义 struct stu &#123; char name[50]; int age; &#125;; void fun1(struct stu* const p) &#123; //p = NULL; //err p-&gt;age = 10; //ok &#125; //void fun2(struct stu const* p) void fun2(const struct stu* p) &#123; p = NULL; //ok //p-&gt;age = 10; //err &#125; void fun3(const struct stu* const p) &#123; //p = NULL; //err //p-&gt;age = 10; //err &#125; 共用体(联合体) 联合union是一个能在同一个存储空间存储不同类型数据的类型；联合体所占的内存长度等于其最长成员的长度，也有叫做共用体； 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用； 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖； 共用体变量的地址和它的各成员的地址都是同一地址。 #include &lt;stdio.h&gt; //共用体也叫联合体 union Test &#123; unsigned char a; unsigned int b; unsigned short c; &#125;; int main() &#123; //定义共用体变量 union Test tmp; //1、所有成员的首地址是一样的 printf(&quot;%p, %p, %p\\n&quot;, &amp;(tmp.a), &amp;(tmp.b), &amp;(tmp.c));//0000003825CFF6B4, 0000003825CFF6B4, 0000003825CFF6B4 //2、共用体大小为最大成员类型的大小 printf(&quot;%lu\\n&quot;, sizeof(union Test));//4 //3、一个成员赋值，会影响另外的成员 //左边是高位，右边是低位 //低位放低地址，高位放高地址 tmp.b = 0x44332211; printf(&quot;%x\\n&quot;, tmp.a); //11 printf(&quot;%x\\n&quot;, tmp.c); //2211 tmp.a = 0x00; printf(&quot;short: %x\\n&quot;, tmp.c); //2200 printf(&quot;int: %x\\n&quot;, tmp.b); //44332200 return 0; &#125; 枚举 枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 enum 枚举名 &#123; 枚举值表 &#125;; 在枚举值表中应列出所有可用值，也称为枚举元素。枚举值是常量，不能在程序中用赋值语句再对它赋值。枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …。 #include &lt;stdio.h&gt; enum weekday &#123; sun = 2, mon, tue, wed, thu, fri, sat &#125;; enum bool &#123; flase, true &#125;; int main() &#123; enum weekday a, b, c; a = sun; b = mon; c = tue; printf(&quot;%d,%d,%d\\n&quot;, a, b, c);//2,3,4 enum bool flag; flag = true; if (flag == 1) &#123; printf(&quot;flag为真\\n&quot;);//flag为真 &#125; return 0; &#125; typedef 为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值。#define发生在预处理，typedef发生在编译阶段。 #include &lt;stdio.h&gt; typedef int INT; typedef char BYTE; typedef BYTE T_BYTE; typedef unsigned char UBYTE; typedef struct type &#123; UBYTE a; INT b; T_BYTE c; &#125;TYPE, * PTYPE; int main() &#123; TYPE t; t.a = 254; t.b = 10; t.c = &apos;c&apos;; PTYPE p = &amp;t; printf(&quot;%u, %d, %c\\n&quot;, p-&gt;a, p-&gt;b, p-&gt;c);//254, 10, c return 0; &#125;","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"JNI入门","slug":"33.JNI入门","date":"2020-03-07T03:21:44.564Z","updated":"2021-03-26T14:41:17.451Z","comments":false,"path":"2020/03/07/33.JNI入门/","link":"","permalink":"http://yoursite.com/2020/03/07/33.JNI%E5%85%A5%E9%97%A8/","excerpt":"","text":"介绍JNI含义:java native interface JNI好处: 1、JNI可以扩展java虚拟机的能力，让java代码可以调用驱动 2、C/C++的效率要高，通过jni把耗时操作方法C/C++可以提高java运行效率 3、java代码编译成的.class文件安全性较差, 可以通过jni把重要的业务逻辑放到c/c++去实现,c/c++反编译比较困难,安全性较高. C基本语法1、C的基本数据类型java基本数据类型:boolean(1个字节),byte(1),char(2),short(2),int(4),long(8),float(4),double(8) C的基本数据类型:char(1个字节), int(4), float(4), double(8), long(4), short(2), signed, unsigned, void signed:有符号数,可以表示负数;unsigned:无符号数,不可以表示负数。signed和unsigned只能用来修饰整形变量char、short、int、long。 C没有boolean和byte，C用0和非0表示false和true。 2、占位符和字符串占位符： %d - int %ld – long int %lld - long long %hd – short %c - char %f - float %lf – double %u – 无符号数 %x – 十六进制输出 int 或者long int 或者short int %o - 八进制输出 %s – 字符串 占位符不要乱用,要选择正确的对应类型,否则可能会损失精度。 C没有String类型,C的字符串实际就是字符数组。C字符串两种定义方式： //注意&apos;\\0&apos;字符串结束符, []只能再变量名之后 char str[] = &#123;&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;r&apos;,&apos;t&apos;,&apos;\\0&apos;&#125;; //这种定义方式不用写结束符,可以表示汉字 char str[] = &quot;你好&quot;; C字符串不检查下标越界,使用时要注意。 C的控制台输入 scanf(&quot;占位符&quot;, &amp;地址);//&amp; 取地址符 3、内存地址的概念声明一个变量,就会立即为这个变量申请内存,一定会有一个对应的内存地址；没有地址的内存是无法使用的；内存的每一个字节都有一个对应的地址；内存地址用一个16进制数来表示；32位操作系统最大可以支持4G内存。 4、指针int i = 123; //一般计算机中用16进制数来表示一个内存地址 printf(&quot;%#x\\n&quot;,&amp;i); //int* int类型的指针变量 pointer指针 指针变量只能用来保存内存地址 //用取地址符&amp;i 把变量i的地址取出来 用指针变量pointer 保存了起来 //此时我们可以说 指针pointer指向了 i的地址 int* pointer = &amp;i; printf(&quot;pointer的值 = %#x\\n&quot;,pointer); printf(&quot;*pointer的值%d\\n&quot;,*pointer); *pointer = 456; printf(&quot;i的值是%d\\n&quot;,i); system(&quot;pause&quot;); 未赋值的指针称为野指针。 5、指针交换两个数的值所有传递其实本质都是值传递，引用传递本质是把地址传递过去，引用传递其实也是传递一个值，但是这个值是一个内存地址。 void swap(int* p, int* p2)&#123; int temp = *p; *p = *p2; *p2 = temp; &#125; 6、数组和指针的关系数组占用的内存空间是连续的 数组变量保存的地址，是第0个元素地址，也就是首地址。&amp;array和&amp;array[0]值一样。 *(p + 1):指针位移一个单位，一个单位是多少个字节，取决于指针的类型。 7、指针的长度不管变量的类型是什么，它的内存地址的长度一定是相同的；类型不同只决定变量占用的内存空间不同；32位环境下，内存地址长度都是4个字节，64位环境下，内存地址长度都是8个字节。 8、多级指针二级指针变量只能保存一级指针变量的地址，有几个*就是几级指针 int i = 123; //int类型一级指针 int* p = &amp;i; //int 类型 二级指针 二级指针只能保存一级指针的地址 int** p2 = &amp;p; //int 类型 三级指针 三级指针只能保存二级指针的地址 int*** p3 = &amp;p2; //通过p3 取出 i的值 printf(&quot;***p3 = %d\\n&quot;, ***p3); 9、堆、栈、静态内存、动态内存栈内存:系统自动分配，系统自动销毁，连续的内存区域，向低地址扩展，大小固定，栈上分配的内存称为静态内存。 静态内存分配：子函数执行完，子函数中的所有局部变量都会被销毁，内存释放，但内存地址不可能被销毁，只是地址上的值没了。 堆内存：程序员手动分配（java：new，c：malloc），空间不连续，大小取决于系统的虚拟内存，C程序员手动回收free，java自动回收，堆上分配的内存称为动态内存。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; main()&#123; printf(&quot;请输入班级的人数:&quot;); int count; scanf(&quot;%d&quot;,&amp;count); //申请一块堆内存 int* pointer = malloc(sizeof(int)*count); int i; for(i = 0;i&lt;count;i++)&#123; printf(&quot;请输入第%d个学生的学号:&quot;,i+1); scanf(&quot;%d&quot;, pointer+i); &#125; for(i = 0;i&lt;count;i++)&#123; printf(&quot;第%d个学生的学号是:%d\\n&quot;,i+1,*(pointer+i)); &#125; printf(&quot;请输入插班生的人数:&quot;); //声明一个变量increment用来保存 插班生的人数 int increment; //接受用户的输入 scanf(&quot;%d&quot;,&amp;increment); //重新申请一块足够大的内存 //如果 malloc申请到的内存后面还有足够的空间 realloc会在malloc申请的内存空间后继续申请足够大的内存空间 //如果 malloc申请到的内存后面没有足够的空间 realloc会找到一块足够大的堆内存 并且把 malloc申请到的内存中的值复制过来 pointer = realloc(pointer,sizeof(int)*(count+increment)); for(i = count;i&lt;count+increment;i++)&#123; printf(&quot;请输入第%d个学生的学号:&quot;,i+1); scanf(&quot;%d&quot;, pointer+i); &#125; for(i = count;i&lt;count+increment;i++)&#123; printf(&quot;第%d个学生的学号是:%d\\n&quot;,i+1,*(pointer+i)); &#125; system(&quot;pause&quot;); &#125; 10、结构体结构体的大小大于等于结构体中每一变量的占字节数的和;结构体的大小是最大的那个变量所占字节数的整数倍。 c结构体类似java的class。struct来声明c的结构体。C结构体中不能定义函数，可以定义函数指针 。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void study()&#123; printf(&quot;good good study!\\n&quot;); &#125; typedef struct Student&#123; int age; //8 int score; // 4 char sex; //1 void(*studypointer)(); &#125; stud; main()&#123; stud stu = &#123;18,100,&apos;f&apos;&#125;; stu.studypointer = &amp;study; stu.studypointer(); struct Student* stuPointer = &amp;stu; printf(&quot;*stuPointer.age = %d\\n&quot;,(*stuPointer).age); (*stuPointer).sex =&apos;m&apos;; printf(&quot;stu.sex = %c\\n&quot;,stu.sex); printf(&quot;stuPointer-&gt;age = %d&quot;,stuPointer-&gt;age); //printf(&quot;stu.age = %hd\\n&quot;,stu.age); //printf(&quot;stu.score = %d\\n&quot;,stu.score); //printf(&quot;stu.sex = %c\\n&quot;,stu.sex); // printf(&quot;结构体student占%d个字节\\n&quot;,sizeof(stu)); system(&quot;pause&quot;); &#125; 11、联合体union长度等于联合体中定义的变量当中最长的那个,联合体只能保存一个变量的值,联合体共用同一块内存 c++c++开发jni代码时 env不再是结构体Jninativeinterface的二级指针。_JNIEnv是C++的结构体，C++的结构体可以定义函数。env是JNIEnv的一级指针,也就是结构体_JNIEnv的一级指针。env-&gt;来调用结构体里的函数。 am命令am命令:在adb shell里可以通过am命令进行一些操作如启动activity Service 启动浏览器等等。 #include &lt;jni.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;android/log.h&gt; #define LOG_TAG &quot;System.out&quot; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) int ppid; JNIEXPORT void JNICALL Java_com__cfork_demo_MainActivity_cfork (JNIEnv * env, jobject obj)&#123; int pid = fork(); //fork成功的分叉出一个子进程 会返回当前进程的id 但是只能在主进程中fork成功 //在子进程中运行fork 会返回0 但是不能再分叉出新的进程 //fork的返回值可能三种 &gt;0 == 0 &lt;0 FILE* file; if(pid&gt;0)&#123; LOGD(&quot;pid = %d&quot;,pid); &#125;else if(pid == 0)&#123; //拿到父进程的进程编号 LOGD(&quot;pid == 0&quot;); while(1)&#123; ppid = getppid(); //如果父进程的进程编号为1 说明父进程被杀死了 if(ppid == 1)&#123; LOGD(&quot;ppid =%d&quot;,ppid); file = fopen(&quot;/data/data/com.cfork.demo&quot;,&quot;r&quot;); if(file == NULL)&#123; //打开网页 调用am命令 execlp(&quot;am&quot;, &quot;am&quot;, &quot;start&quot;, &quot;--user&quot;,&quot;0&quot;,&quot;-a&quot;, &quot;android.intent.action.VIEW&quot;, &quot;-d&quot;, &quot;http://www.baidu.com&quot;, (char *) NULL); &#125;else&#123; execlp(&quot;am&quot;, &quot;am&quot;, &quot;start&quot;, &quot;--user&quot;,&quot;0&quot;, &quot;-n&quot; , &quot;com.cfork.demo/com.cfork.demo.MainActivity&quot;,(char *) NULL); &#125; break; &#125; LOGD(&quot;sub process is running&quot;); sleep(2); &#125; &#125;else&#123; LOGD(&quot;pid&lt;0 &quot;); &#125; &#125; JNIc本地函数命名规则:Java_包名_类名_本地方法名。 参数jobject thiz：调用本地函数的java对象，在这个例子中，就是MainActivity的实例。 参数JNIEnv* env：是结构体JNINativeInterface的二级指针。JNIEnv是结构体JNINativeInterface的一级指针，操作一级指针用(*env)-&gt;。JNINativeInterface结构体中定义了大量的函数指针，这些函数指针在jni开发中很常用。 C代码 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;jni.h&gt; jstring Java_com_vcredit_cdemo_MainActivity_stringFromJNI(JNIEnv* env,jobject thiz)&#123; char* cstr = &quot;hello from c!&quot;; return (*env)-&gt;NewStringUTF(env,cstr); &#125; C++代码 #include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_com_vcredit_cdemo_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); &#125; java传参数给cJava给C传递int，String和int[]，并且返回: #include &lt;jni.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //传递数字，并返回数字 JNIEXPORT jint JNICALL Java_com_vcredit_cdemo_MainActivity_intFromJNI(JNIEnv *env, jobject thiz, jint a, jint b) &#123; return a + b; &#125; char *_JString2CStr(JNIEnv *env, jstring jstr) &#123; char *rtn = NULL; jclass clsstring = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); jstring strencode = (*env)-&gt;NewStringUTF(env, &quot;GB2312&quot;); jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) (*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte(&quot;GB2312&quot;); jsize alen = (*env)-&gt;GetArrayLength(env, barr); jbyte *ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); if (alen &gt; 0) &#123; rtn = (char *) malloc(alen + 1); //&quot;\\0&quot; memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); return rtn; &#125; //传递字符串，并返回字符串 JNIEXPORT jstring JNICALL Java_com_vcredit_cdemo_MainActivity_stringChange(JNIEnv *env, jobject thiz, jstring string) &#123; char *cstr = _JString2CStr(env, string); int length = strlen(cstr); int i; for (i = 0; i &lt; length; i++) &#123; *(cstr + i) += 1; &#125; return (*env)-&gt;NewStringUTF(env, cstr); &#125; //传递int数组，并返回数组 JNIEXPORT jintArray JNICALL Java_com_vcredit_cdemo_MainActivity_arrIncrease(JNIEnv *env, jobject thiz, jintArray jArray) &#123; jsize length = (*env)-&gt;GetArrayLength(env, jArray); jint *arrayPointer = (*env)-&gt;GetIntArrayElements(env, jArray, NULL); int i; for (i = 0; i &lt; length; i++) &#123; *(arrayPointer + i) += 10; &#125; (*env)-&gt;SetIntArrayRegion(env, jArray, 0, length, arrayPointer); return jArray; &#125; 在C中打印log#include &lt;android/log.h&gt; #define LOG_TAG &quot;System.out&quot; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__) //使用 LOGD(&quot;length = %d&quot;,length); c调用JavaC调用Java空参方法 JNIEXPORT void JNICALL Java_com_vcredit_cdemo_MainActivity_callbackvoidmethod(JNIEnv* env, jobject thiz) &#123; jclass claz = (*env)-&gt;FindClass(env, &quot;com/vcredit/cdemo/MainActivity&quot;); jmethodID methodID = (*env)-&gt;GetMethodID(env, claz, &quot;helloFromJava&quot;, &quot;()V&quot;); (*env)-&gt;CallVoidMethod(env, thiz, methodID); &#125; public void helloFromJava() &#123; Log.d(&quot;-----rrrrr&quot;, &quot;hello from java&quot;); &#125; 注意FindClass路径用/。 C调用Java有Int参数方法并返回 JNIEXPORT void JNICALL Java_com_vcredit_cdemo_MainActivity_callbackintmethod(JNIEnv *env, jobject thiz) &#123; jclass claz = (*env)-&gt;FindClass(env, &quot;com/vcredit/cdemo/MainActivity&quot;); jmethodID methodID = (*env)-&gt;GetMethodID(env, claz, &quot;add&quot;, &quot;(II)I&quot;); int result = (*env)-&gt;CallIntMethod(env, thiz, methodID, 6, 6); LOGD(&quot;result = %d&quot;, result); &#125; public int add(int x, int y) &#123; return x + y; &#125; C调用Java有String参数方法 JNIEXPORT void JNICALL Java_com_vcredit_cdemo_MainActivity_callbackStringmethod(JNIEnv *env, jobject thiz) &#123; jclass claz = (*env)-&gt;FindClass(env, &quot;com/vcredit/cdemo/MainActivity&quot;); jmethodID methodID = (*env)-&gt;GetMethodID(env, claz, &quot;printString&quot;, &quot;(Ljava/lang/String;)V&quot;); jstring result = (*env)-&gt;NewStringUTF(env, &quot;hello from c&quot;); (*env)-&gt;CallVoidMethod(env, thiz, methodID, result); &#125; public void printString(String s) &#123; Log.d(&quot;-----rrrrr&quot;, s); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"http://yoursite.com/tags/JNI/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android自定义控件入门与实战-读书笔记","slug":"32.Android自定义控件入门与实战","date":"2020-01-04T11:48:26.998Z","updated":"2021-03-26T14:41:13.947Z","comments":false,"path":"2020/01/04/32.Android自定义控件入门与实战/","link":"","permalink":"http://yoursite.com/2020/01/04/32.Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"第1章、绘图基础1.1、基本图形绘制1.1.1、概述在 Android中，Paint类就是画笔，而Canvas类就是纸，在这里叫作画布。 1.1.2、画笔的基本设置Paint paint.setAntiAlias(true); //打开抗锯齿功能 paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Paint.Style.FILL); //设置填充样式 paint.setStrokeWidth(50); //设置画笔宽度 ARGB A 代表透明度（Alpha） R 代表红色值（Red） G 代表绿色值（Green） B 代表蓝色值（Blue） 设置填充样式，对于文字和几何图形都有效: Paint.Style.FILL//仅填充内部。 Paint.Style.FILL_AND_STROKE//填充内部和描边。 Paint.Style.STROKE//仅描边。 FILL_AND_STROKE比FILL多了一个描边的宽度。 1.1.3、Canvas使用基础demo地址 com.vcredit.doview.chapter1.DrawShapeView 1、画布背景设置canvas.drawColor(int color) canvas.drawARGB(int a, int r, int g, int b) canvas.drawRGB(int r, int g, int b) //透明度Alpha的值取255 2、画直线void drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 直线的粗细是与setStrokeWidth有直接关系的。所以，paint.setStrokeWidth在Style起作用时，用于设置描边宽度；在Style不起作用时，用于设置画笔宽度。 3、多条直线void drawLines(float[] pts, Paint paint) void drawLines(float[] pts, int offset, int count, Paint paint) pts：点的集合。两个元素形成一个点，每两个点形成一条直线。 offset：pts集合中跳过的元素个数。 count：pts集合中参与绘制的元素个数。 float[] pts = &#123;10,10,100,100,200,200,400,400&#125;; canvas.drawLines(pts,2,4,paint); 表示点(100,100)和(200,200)这两个点的连线。 4、点void drawPoint(float x, float y, Paint paint) 点的大小只与setStrokeWidth(width)有关，而与setStyle无关。 5、多个点void drawPoints(float[] pts, Paint paint) void drawPoints(float[] pts, int offset, int count, Paint paint) 这几个参数的含义与多条直线中的参数含义相同。 6、矩形工具类RectF和RectRectF与Rect中的方法、成员变量完全一样，都是根据4个点构造出一个矩形结构，唯一不同的是：RectF是用来保存float类型数值的矩形结构的；而Rect是用来保存int类型数值的矩形结构的。 //RectF 的构造函数有如下4个，但最常用的还是第二个，即根据 4 个点构造出一个矩形。 RectF() RectF(float left, float top, float right, float bottom) RectF(RectF r) RectF(Rect r) //Rect的构造函数有如下3个。 Rect() Rect(int left, int top, int right, int bottom) Rect(Rect r) 一般而言，要构造一个矩形结构，可以通过以下两种方法来实现。 //方法一：直接构造 Rect rect = new Rect(10,10,100,100); //方法二：间接构造 Rect rect = new Rect(); rect.set(10,10,100,100); 7、矩形矩形的绘制方法 void drawRect(float left, float top, float right, float bottom, Paint paint) void drawRect(RectF rect, Paint paint) void drawRect(Rect r, Paint paint) 8、圆角矩形void drawRoundRect(RectF rect, float rx, float ry, Paint paint) rect：要绘制的矩形；rx：生成圆角的椭圆的X轴半径；ry：生成圆角的椭圆的Y轴半径。 drawRoundRect()函数不能针对每个角设置对应的椭圆，而只能统一设置4个角对应的椭圆。 9、圆形void drawCircle(float cx, float cy, float radius, Paint paint) 参数是圆心和半径 10、椭圆void drawOval(RectF oval, Paint paint) 椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，以矩形的宽为椭圆的Y轴。 11、弧void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter,Paint paint) 弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧也是根据矩形来生成的。 oval：生成椭圆的矩形。startAngle：弧开始的角度，以 X 轴正方向为 0°。sweepAngle：弧持续的角度,顺时针方向为正值。 useCenter：是否有弧的两边。为true时，表示带有两边；为false时，只有一条弧。 1.1.4、Rect与RectF1、是否包含点、矩形//判断是否包含某个点，如果在，则返回true；如果不在，则返回false。 boolean contains(int x, int y) //rect.contains(mX, mY) //判断是否包含某个矩形 Boolean contains(int left, int top, int right, int bottom) boolean contains(Rect r) postInvalidate()和 nvalidate()函数都是用来重绘控件的，区别是invalidate()函数一定要在主线程中执行，否则就会报错；而postInvalidate()可以在任何线程中执行。因为在 postInvalidate()函数中就是利用handler给主线程发送刷新界面的消息来实现的，所以它可以在任何线程中执行而不会出错。postInvalidate()界面刷新速度可能没有直接调用invalidate()函数那么快。 2、判断两个矩形是否相交//这是Rect类的一个静态方法，如果相交则返回true，否则返回false。 static boolean intersects(Rect a, Rect b) //还可以使用 Rect 类中自带的方法来判断当前 Rect 对象与其他矩形是否相交。 boolean intersects(int left, int top, int right, int bottom) //判断相交并返回结果 //不仅会返回是否相交的结果，而且会把相交部分的矩形赋给当前Rect对象。如果两个矩形不相交，则当前Rect对象的值不变。 boolean intersect(int left, int top, int right, int bottom) boolean intersect(Rect r) 3、合并合并两个矩形的意思就是将两个矩形合并成一个矩形，即无论这两个矩形是否相交，取两个矩形最小左上角点作为结果矩形的左上角点，取两个矩形最大右下角点作为结果矩形的右下角点。如果要合并的两个矩形有一方为空，则将有值的一方作为最终结果。 public void union(int left, int top, int right, int bottom) public void union(Rect r) 合并矩形与某个点：先判断当前矩形与目标合并点的关系，如果不相交，则根据目标点(x,y)的位置，将目标点设置为当前矩形的左上角点或者右下角点。如果当前矩形是一个空矩形，则最后的结果矩形为([0,0],[x,y])，即结果矩形的左上角点为[0,0]，右下角点为[x,y]。 public void union(int x, int y) 1.1.5、Color 当需要重绘时就会调用onDraw()函数，所以在 onDraw()函数中创建的变量会一直被重复创建，这样会引起频繁的程序GC（回收内存），进而引起程序卡顿。所以一定要记住，在onDraw()函数中不能创建变量！一般在自定义控件的构造函数中创建变量，即在初始化时一次性创建。 1.2、路径1.2.1、概述Path类就代表路径。在Canvas中绘制路径的方法 void drawPath(Path path, Paint paint) 1.2.2、直线路径//(x1,y1)是直线的起始点 void moveTo(float x1, float y1) //(x2,y2)是直线的终点，又是下一次绘制直线路径的起始点； lineTo()函数可以一直使用。 void lineTo(float x2, float y2) //首尾点连接起来，形成闭环 void close() 1.2.3、弧线路径//弧线是从椭圆上截取的一部分 void arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) //oval：生成椭圆的矩形。 //startAngle：弧开始的角度，以 X 轴正方向为 0°。sweepAngle：弧持续的角度。 //forceMoveTo 的含义是是否强制将弧的起始点作为绘制起始位置。 1.2.4、addXXX系列函数addXXX系列函数可以让我们直接往Path中添加一些曲线，而不必考虑连贯性。 添加矩形路径void addRect(float left, float top, float right, float bottom,Path.Direction dir) void addRect(RectF rect, Path.Direction dir) Path.Direction 参数有两个值。Path.Direction.CCW：是指创建逆时针方向的矩形路径。Path.Direction.CW：指创建顺时针方向的矩形路径。 添加圆角矩形路径void addRoundRect(RectF rect, float[] radii, Path.Direction dir) void addRoundRect(RectF rect, float rx, float ry, Path.Direction dir) float[] radii：必须传入8个数值，分4组，第一组对应第一个角（左上角）的用来生成圆角的椭圆的横轴半径和纵轴半径。在第二个构造函数中，只能构建统一的圆角大小，rx：生成圆角的椭圆的横轴半径，ry：生成圆角的椭圆的纵轴半径。 添加圆形路径void addCircle(float x, float y, float radius, Path.Direction dir) x和y：圆心坐标；radius：圆半径。 添加椭圆路径void addOval(RectF oval, Path.Direction dir) 添加弧形路径void addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) void addArc(RectF oval, float startAngle, float sweepAngle) oval：生成椭圆的矩形;startAngle：弧开始的角度;sweepAngel：弧持续的角度。 1.2.5、填充模式Path的填充模式是指填充Path的哪部分。 //Path.FillType 表示 Path 的填充模式，它有 4 个枚举值。 FillType.WINDING：默认值，当两个图形相交时，取相交部分显示。 FillType.EVEN_ODD：取 path 所在并不相交的区域。 FillType.INVERSE_WINDING：取 path 的外部区域。 FillType.INVERSE_EVEN_ODD：取 path 的外部和相交区域。 在利用画笔填充图形时，填充的肯定是图形内部，而 path.setFillType()函数就是用来界定哪里算Path内部的算法，进而让Paint填充这部分图像。 1.2.6、重置路径系统提供了两个重置路径的方法: void reset() void rewind() 共同点是都会清空内部所保存的所有路径。 区别:rewind()函数不会清除内存，但会清除FillType；而reset()函数则会清除内存，但不会清除FillType。 1.2.7、蜘蛛网状图示例1.3、文字1.3.1、Paint设置Paint与文字相关的设置: //普通设置 paint.setStrokeWidth(5); //设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能 paint.setStyle(Paint.Style.FILL); //绘图样式，对于文字和几何图形都有效 paint.setTextAlign(Align.CENTER); //设置文字对齐方式，取值为Align.CENTER、Align.LEFT 或 Align.RIGHT paint.setTextSize(12); //设置文字大小 //样式设置 paint.setFakeBoldText(true); //设置是否为粗体文字 paint.setUnderlineText(true); //设置下画线 paint.setTextSkewX((float) -0.25); //字体水平倾斜度，默认为0，普通斜体字设为-0.25，负数代表向右倾斜 paint.setStrikeThruText(true); //设置带有删除线效果 //其他设置 paint.setTextScaleX(2); //水平方向拉伸，高度不变，表示拉伸倍数，默认为1表示不拉伸 1.3.2、Canvas绘制文本//setTextAlign的显示与x、y的设置有关系 canvas.drawText(String text,Float x,Float y,Paint paint); 1、普通绘制//参数(x,y)就是起始点坐标 void drawText(String text, float x, float y, Paint paint) //start：表示起始绘制字符所在字符串中的索引。 //end：表示结束绘制字符所在字符串中的索引。x,y：起始点坐标。 void drawText(CharSequence text, int start, int end, float x, float y, Paint paint) void drawText(String text, int start, int end, float x, float y, Paint paint) //绘制char类型的数组所组成的字符串。其他参数的含义如下。index：指定起始绘制字符的位置。 //count：指定从起始绘制字符开始绘制几个字符。x,y：起始点坐标。 void drawText(char[] text, int index, int count, float x, float y, Paint paint) 举例 canvas.drawText(&quot;床前明月光&quot;,2,4, 10,100, paint);//明月 2、逐个指定文字位置指定每个要绘制的文字的具体位置 void drawPosText(String text, float[] pos, Paint paint) void drawPosText(char[] text, int index, int count, float[] pos, Paint paint) index：第一个要绘制的文字的索引。count：要绘制的文字的个数。pos：要绘制的每个文字的具体位置，两个点确定一个文字的位置。 3、沿路径绘制void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint) void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset,float vOffset, Paint paint) hOffset：与路径起始点的水平偏移量。vOffset：与路径中心的垂直偏移量。 1.3.3、设置字体样式在Paint中有一个函数是专门用来设置字体样式的。使用这个函数的前提是必须构造Typeface类的一个参数。 Typeface setTypeface(Typeface typeface) 设置字体样式 Typeface defaultFromStyle(int style) //参数int style的取值如下。 Typeface.NORMAL：正常字体。 Typeface.BOLD：粗体。 Typeface.ITALIC：斜体。 Typeface.BOLD_ITALIC：粗斜体。 举例，设置粗斜体样式: Typeface typeface = Typeface.defaultFromStyle(Typeface.BOLD_ITALIC); paint.setTypeface(typeface); 1.4、RegionRegion译为“区域”，区域是一块任意形状的封闭图形。 1.4.1、构造Region直接构造public Region(Region region) //复制一个 Region 的范围 public Region(Rect r) //创建一个矩形区域 public Region(int left, int top, int right, int bottom) //创建一个矩形区域 间接构造间接构造主要是通过空构造函数与set系列函数相结合来实现的。 //Region的空构造函数： public Region() //set 系列函数： public void setEmpty() //置空 public boolean set(Region region)//利用新的区域替换原来的区域 public boolean set(Rect r) public boolean set(int left, int top, int right, int bottom) public boolean setPath(Path path, Region clip)//根据路径的区域与某区域的交集构造出新的区域 无论调用set系列函数的Region是不是有区域值，当调用set系列函数后，原来的区域值就会被替换成set系列函数里的区域值。 利用setPath可以设置不规则区域 1.4.2、枚举区域——RegionIterator类//构造函数：根据区域构建对应的矩形集。 RegionIterator(Region region) //获取下一个矩形，将结果保存在参数 Rect r 中。 boolean next(Rect r) Canvas中没有直接绘制Region的函数，想要绘制一个区域，就只能通过RegionIterator类构造矩形集来逼近显示区域。 private void drawRegion(Canvas canvas,Region rgn,Paint paint)&#123; RegionIterator iter = new RegionIterator(rgn); Rect r = new Rect(); while (iter.next(r)) &#123; canvas.drawRect(r, paint); &#125; &#125; 1.4.3、区域相交Region不是用来绘图的，Region最重要的功能在区域的相交操作中。 union()函数boolean union(Rect r) 该函数用于与指定矩形取并集，即将Rect所指定的矩形加入当前区域中。举例： Region region = new Region(10,10,200,100); region.union(new Rect(10,10,50,300)); 区域操作方法一： 相交操作，并将结果赋给当前的Region对象。如果计算成功，则返回true；否则返回false。 boolean op(Rect r, Op op) boolean op(int left, int top, int right, int bottom, Op op) boolean op(Region region, Op op) Op参数值有如下6个： public enum Op &#123; DIFFERENCE(0), //最终区域为region1区域，但是不包括与region2相交的区域 INTERSECT(1), // 最终区域为region1与region2 相交的区域 UNION(2), //最终区域为region1与region2组合在一起的区域 XOR(3), //最终区域为region1和region2区域，但是不包括相交的区域 REVERSE_DIFFERENCE(4),//最终区域为region2区域，但是不包括与region1相交的区域 REPLACE(5); //最终区域为region2的区域 &#125; 方法二：传入两个 Region 对象进行区域操作 boolean op(Rect rect, Region region, Op op) boolean op(Region region1, Region region2, Region.Op op) 1.4.4、其他函数几个判断 //该函数用于判断该区域是否为空 public boolean isEmpty(); //该函数用于判断该区域是否是一个矩阵。 public boolean isRect(); //该函数用于判断该区域是否是多个矩阵的组合。 public boolean isComplex(); getBound系列函数 //这两个函数用于返回能够包裹当前路径的最小矩形。 public Rect getBounds() public boolean getBounds(Rect r) //这两个函数用于返回当前矩形所对应的 Path 对象。 public Path getBoundaryPath() public boolean getBoundaryPath(Path path) 是否包含 //该函数用于判断该区域是否包含某个点。 public boolean contains(int x, int y) //这两个函数用于判断该区域是否包含某个矩形。 public boolean quickContains(Rect r) public boolean quickContains(int left, int top, int right,int bottom) 是否相交 //这两个函数用于判断该区域是否没有和指定矩形相交。 public boolean quickReject(Rect r) public boolean quickReject(int left, int top, int right, int bottom); //该函数用于判断该区域是否没有和指定区域相交。 public boolean quickReject(Region rgn); 平移变换 //该函数用于将Region对象向X轴平移dx距离，向Y轴平移dy距离，并将结果赋给当前的Region对象。X轴向右是正方向，Y轴向下是正方向。 public void translate(int dx, int dy) //与上一个函数不同的是，该函数将结果赋给dst对象，而当前Region对象的值保持不变。 public void translate(int dx, int dy, Region dst) 1.5、Canvas（画布）除了在Canvas上绘图以外，还可以对画布进行变换及裁剪等操作。 1.5.1、Canvas变换平移（Translate）右是X轴正方向，向下是Y轴正方向。 void translate(float dx, float dy) 举例 canvas.translate(100, 100); Rect rect = new Rect(0,0,400,220); canvas.drawRect(rect, paint); 屏幕显示与Canvas的关系每次调用drawXXX系列函数来绘图时，都会产生一个全新的Canvas透明图层。调用平移、旋转等函数对Canvas进行了操作，不会对之前已经draw的产生影响。 旋转（Rotate）//旋转的中心点是原点(0,0) void rotate(float degrees) //指定旋转的中心点坐标(px,py) void rotate(float degrees, float px, float py) 缩放（Scale）//sx是小数表示缩小，sx是整数表示放大 public void scale(float sx, float sy) //px,py表示缩放中心位置 public void scale(float sx, float sy, float px, float py) 扭曲（Skew）//sx为X轴方向倾斜角度的正切值，比如在X轴方向上倾斜60°，tan60=1.732 void skew(float sx, float sy) 举例 canvas.skew(1.732f,0);//X 轴倾斜 60°， Y 轴不变 裁剪画布（clip系列函数）一旦Canvas被裁剪，就不能恢复。在使用clip系列函数时，需要禁用硬件加速功能，setLayerType(LAYER_TYPE_SOFTWARE,null)。 clip 系列函数如下： boolean clipPath(Path path) boolean clipPath(Path path, Region.Op op) boolean clipRect(Rect rect, Region.Op op) boolean clipRect(RectF rect, Region.Op op) boolean clipRect(int left, int top, int right, int bottom) boolean clipRect(float left, float top, float right, float bottom) boolean clipRect(RectF rect) boolean clipRect(float left, float top, float right, float bottom, Region.Op op) boolean clipRect(Rect rect) boolean clipRegion(Region region) boolean clipRegion(Region region, Region.Op op) 1.5.2、画布的保存与恢复save()和restore()函数每次调用save()函数，都会先保存当前画布的状态，然后将其放入特定的栈中。每次调用restore()函数，都会把栈中顶层的画布状态取出来，并按照这个状态恢复当前的画布，然后在这个画布上作画。 restoreToCount(int saveCount)函数在利用save()函数保存画布时，会有一个int类型的返回值。该返回值是当前所保存的画布所在栈的索引。restoreToCount()函数就是一直出栈，直到指定索引的画布出栈为止，即将指定索引的画布作为当前画布。 public void restoreToCount(int saveCount); 1.5.3、圆形头像示例1.5.4、裁剪动画示例1.6、控件的使用方法1.6.1、控件概述1.6.2、通过XML引入控件通过XML引入控件，所调用的构造函数： public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; 1.6.3、动态添加控件LinearLayout rootView = (LinearLayout)findViewById(R.id.root); CustomView customView = new CustomView(this); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams (LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); rootView.addView(customView,layoutParams); LayoutParams的作用就是设置控件的宽和高，对应的是XML中的layout_width和layout_height属性。 LayoutParams有三个构造函数: //指定具体的宽和高:LayoutParams.MATCH_PARENT或者具体值 public LayoutParams(int width, int height) //从AttributeSet中提取出宽高等属性值 public LayoutParams(Context c, AttributeSet attrs) //复制一份LayoutParams public LayoutParams(LayoutParams source) LinearLayout、FrameLayout、RelativeLayout都有各自的LayoutParams。 addRuleRelativeLayout.LayoutParams的addRule()函数：第一个参数是指RelativeLayout的布局属性，第二个参数是指相对于哪个控件ID来布局。 RelativeLayout rootView = (RelativeLayout) findViewById(R.id.root); CustomView customView = new CustomView(this); RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT); layoutParams.addRule(RelativeLayout.RIGHT_OF,R.id.text); rootView.addView(customView, layoutParams); 设置marginLinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 20, 30, 40); imageView.setLayoutParams(lp); 设置layout_weight（方法一）构造函数 public LayoutParams(int width, int height, float weight) 示例： TextView tv_like = new TextView(this); LinearLayout.LayoutParams LP_LIKE_MW = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f); tv_like.setText(&quot;赞(8)&quot;); tv_like.setTextSize(16); layout_sub_Lin.addView(tv_like, LP_LIKE_MW); 设置layout_weight（方法二）LinearLayout rootView = (LinearLayout) findViewById(R.id.root); CustomView customView = new CustomView(this); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); layoutParams.weight = 1.0f; rootView.addView(customView, layoutParams); 设置layout_gravityLinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.FILL_PARENT); params.gravity = Gravity.TOP; params.gravity的取值有Gravity.TOP、Gravity.BOTTOM、Gravity.LEFT、Gravity.RIGHT、Gravity.CENTER_VERTICAL、Gravity.CENTER_HORIZONTAL等这些属性值可|（或）运算符合并。 设置android:gravity分别给Button和rootView设置 Button button = new Button(this); button.setGravity(Gravity.TOP); button.setText(&quot;btn&quot;); rootView.addView(button, layoutParams); rootView.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL); addViewpublic void addView(View child, int index) 在指定位置添加一个View控件，index的取值有-1、0和正数。当取值为-1时，表示在末尾添加一个View控件，此时的效果就与addView(View child)相同；当取值为0时，表示在容器顶端添加一个View控件；当取值为正数时，表示在对应的索引位置插入一个View控件。 第2章、视图动画两种类型的动画：View Animation（视图动画）和Property Animation（属性动画）。其中，View Animation包括Tween Animation（补间动画）和Frame Animation（逐帧动画）;Property Animation包括ValueAnimator和ObjectAnimator。 2.1、视图动画标签2.1.1、概述alpha(渐变透)、scale(缩放)、translate(位置移动)、rotate(旋转)set(动画集)。 配置XML动画文件//首先加载动画 Animation animation = AnimationUtils.loadAnimation(Activity.this,R.a aim.scaleanim); //然后利用View的startAnimation()函数开始动画 tv.startAnimation(animation); 2.1.2、scale标签&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;700&quot; android:fillBefore=&quot;true&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.2&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:toXScale=&quot;0.4&quot; android:toYScale=&quot;0.6&quot; /&gt; android:fromXScale：动画起始时，控件在X轴方向上相对自身的缩放比例，浮点值，比如1.0 代表自身无变化，0.5代表缩小1倍，2.0代表放大1倍。 android:toXScale：动画结束时，控件在X轴方向上相对自身的缩放比例，浮点值。 android:fromYScale和android:toYScale类似。 android:pivotX：缩放起始点X轴坐标，可以是数值、百分数、百分数p三种样式，如50、50%、50%p。如果是数值，则表示在当前视图本身View的左上角，即原点处加上50px，作为缩放起始点X轴坐标；如果是50%，则表示在当前控件的左上角加上自己宽度的50%作为缩放起始点X轴坐标；如果是50%p，则表示在当前控件的左上角加上父控件宽度的50%作为缩放起始点X轴坐标。 android:pivotY：与android:pivotX一样用法。 Animation继承属性android:duration：用于设置完成一次动画的持续时间，以毫秒为单位。 android:fillAfter：如果设置为true，则控件动画结束时，将保持动画结束时的状态。 android:fillBefore：如果设置为true，则控件动画结束时，将还原到初始化状态。 android:fillEnabled：与android:fillBefore效果相同。 android:repeatCount：用于指定动画的重复次数，当取值为infinite时，表示无限循环。 android:repeatMode：用于设定重复的类型，有reverse和restart两个值。其中，reverse表示倒序回放：restart表示重放，并且必须与repeatCount一起使用才能看到效果。 android:interpolator：用于设定插值器，其实就是指定的动画效果，比如弹跳效果等。 2.1.3、alpha标签透明度动画效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:fillBefore=&quot;true&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot;&gt; &lt;/alpha&gt; android:fromAlpha:开始时的透明度,android:toAlpha:结束时的透明度。0.0表示全透明，1.0表示完全不透明。 2.1.4、rotate标签旋转动画效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:fillAfter=&quot;true&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;100%&quot; android:pivotY=&quot;100%&quot; android:toDegrees=&quot;-650&quot;&gt; &lt;/rotate&gt; android:fromDegrees：动画开始旋转时的角度位置；android:toDegrees：动画结束时旋转到的角度位置。正值代表顺时针方向的度数，负值代表逆时针方向的度数。 android:pivotX：旋转中心点X轴坐标；android:pivotY：旋转中心点Y轴坐标。没有指定android:pivotX与android:pivotY属性，旋转中心点是默认的控件坐标原点，即控件左上角位置。 2.1.5、translate标签位置移动动画效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;-80&quot; android:toYDelta=&quot;-80&quot;&gt; &lt;/translate&gt; android:fromXDelta：起始点X轴坐标，android:fromYDelta：起始点Y轴坐标，android:toXDelta：终点X轴坐标，android:toYDelta：终点Y轴坐标。可以是数值、百分数、百分数p三种样式。 2.1.6、set标签定义动画集。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt; &lt;scale android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.4&quot; android:toYScale=&quot;1.4&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot; /&gt; &lt;/set&gt; 在set标签中设直repeateCount属性是无效的，必须对每个动画单独设直才有作用。 2.2、视图动画的代码实现2.2.1、概述setDuration(long) setFillAfter(boolean) setFillBefore(boolean) setFillEnabled(boolean) setRepeatCount(int) setRepeatMode(int) setlnterpolator(lnterpolator) setRepeatMode(int）取值为Animation.RESTART或者Animation.REVERSE;setRepeatCount(int）用于设置循环次数，当设置为Animation.INFINITE时，表示无限循环。 2.2.2、ScaleAnimationScaleAnimation(float fromX , float toX, float fromY , float toY) ScaleAnimation(float fromX , float toX , float fromY , float toY , float pivotX, float pivotY) ScaleAnimation(float fromX , float toX , float fromY , float toY, intpivotXType,float pivotXVal ue , int pivotYType , float pivotYValue) pivotXType的取值有三个：Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF和Animation.RELATIVE_TO_PARENT。对应的是android:pivotX中的三种取值样式:数值、百分数、百分数p。 ScaleAnimation scaleAnim = new ScaleAnimation(O.Of , 1.4f, O.Of, 1.4f, Animation.RELATIVE_TO_SELF , 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnim.setDuration(700); tv.startAnimation(scaleAnim); 2.2.3、AlphaAnimationAlphaAnimation(Context context , AttributeSet attrs) AlphaAnimation(float fromAlpha , float toAlpha) 示例 AlphaAnimation alphaAnim = new AlphaAnimation(1.Of, 0.1f); alphaAnim.setDuration(3000); alphaAnim.setFillBefore(true); tv.startAnimation(alphaAnim); 2.2.4、RotateAnimationRotateAnimation(Context context , AttributeSet attrs) RotateAnimation(float fromDegrees , float toDegrees) RotateAnimation(float fromDegrees , float toDegrees , float pivotX,float pivotY) RotateAnimation (float fromDegrees , float toDegrees , int pivotXType , float pivotXValue , int pivotYType , float pivotYValue) 示例 RotateAnimation rotateAnim = new RotateAnimation(0 , -650, Animation.RELATIVE_TO_SELF, O.5f , Animation.RELATIVE_TO_SELF , 0.5f); rotateAnim.setDuration(3000); rotateAnim.setFillAfter(true); tv.startAnimation(rotateAnim); 2.2.5、TranslateAnimationTranslateAnimation(Context context , AttributeSet attrs) TranslateAnimation(float fromXDelta ,float toXDelta, float fromYDelta, float toYDelta) TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue , int fromYType , float fromYValue , int toYType , float toYValue) 示例 TranslateAnimation translateAnim = new TranslateAnimation(Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80); translateAnim.setDuration(2000); translateAnim.setFillBefore(true); tv.startAnimation(translateAnim); 2.2.6、AnimationSet构造函数 AnimationSet(Context context, AttributeSet attrs) AnimationSet(boolean shareinterpolator) shareinterpolator当取值为true，在AnimationSet类中定义一个插值器（Interpolator）其下面的所有动画共用该插值器；当取值为false，则表示其下面的动画定义各自的插值器。 增加动画的函数为： public void addAnimation(Animation a) 示例 Animation alpha_Anim = new AlphaAnimation(1.0f, 0.1f); Animation scale_Anim = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); Animation rotate_Anim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); AnimationSet setAnim = new AnimationSet(true); setAnim.addAnimation(alpha_Anim); setAnim.addAnimation(scale_Anim); setAnim.addAnimation(rotate_Anim); setAnim.setDuration(3000); setAnim.setFillAfter(true); tv.startAnimation(setAnim); 2.2.7、Animation//取消动画 void cancel() //将控件重置到动画开始前状态 void reset() //设置动画监昕 void setAnimationListener(Animation.AnimationListener listener) 监听： scaleAnim.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); 2.3、插值器初探Interpolator只是一个接口，通过实现这个接口就可以自定义动画的变化速率。 使用： //xml中 android:interpolator=”@android:anim/accelerate_interpolator” //代码 alphaAnim.setinterpolator(new LinearInterpolator()); 2.3.1、AccelerateDeceleratelnterpolator加速减速插值器，表示在开始与结束的地方速率改变比较慢，在中间的时候加速。效果是先加速后减速。 2.3.2、Acceleratelnterpolator动画开始的地方速率改变比较慢，然后开始加速。动画一直是加速的。 2.3.3、Deceleratelntelnterpolator动画开始的一瞬间加速到最大值，然后逐渐变慢。 2.3.4、Linearlnterpolator动画的速率始终保持恒定。 2.3.5、Bouncelnterpolator弹跳插值器，模拟了控件自由落地后回弹的效果。 2.3.6、Anticipatelnterpolator动画开始后，会先往动画反方向移动一段距离，再应用动画。 Anticipatelnterpolator还有一个构造函数： public Anticipateinterpolator(float tension) 参数tension对应的XML属性为android:tension，表示张力值，默认值为2，值越大，初始的偏移量越大，而且速度越快。 2.3.7、Overshootlnterpolator结束偏移插值器，表示在动画结束时，沿动画方向继续运动一段距离后再结束动画。 Overshootlnterpolator也有另一个构造函数： public Overshootinterpolator(float tension） 参数tension对应的XML属性为android:tension，表示张力值，默认值为2，值越大，结束时的偏移量越大，而且速度越快。 2.3.8、AnticipateOvershootlnterpolatorAnticipateOvershootlnterpolator是Anticipatelnterpolator与Overshootlnterpolator的合体，即在动画开始时向前偏移一段距离，在动画结束时向后偏移一段距离。 AnticipateOvershootlnterpolator也有其他的构造函数 public AnticipateOvershootlnterpolator(float tension) public AnticipateOvershootlnterpolator(float tension, float extraTension) tension默认值为2，extraTension默认值为1.5。 2.3.9、Cyclelnterpolator循环插值器，表示动画循环播放特定的次数，速率沿正弦曲线改变。 Cyclelnterpolator的构造函数如下： public Cycleinterpolator(float cycles) 参数cycles表示循环次数。 2.4、动画示例2.4.1、镜头由远及近效果2.4.2、加载框效果2.4.3、扫描动画效果用Animation.setStartOffset(int time）来延迟各个动画的开始时间。 2.5、逐帧动画Frame Animation 2.5.1、XML实现1、概述XML文件放置在／res下的drawable目录中： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing1&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing2&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing3&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing4&quot; android:duration=&quot;60&quot; /&gt; &lt;item android:drawable=&quot;@drawable/list_icon_gif_playing5&quot; android:duration=&quot;60&quot; /&gt; &lt;/animation-list&gt; android:oneshot如果定义为true，那么此动画只会执行1次;如果定义为false，则一直循环。 然后给ImageView设置动画资源。可以通过android:src实现，也可以通过android:background实现。 android:background=&quot;@drawable/playing_ani&quot; //或者 android:src=&quot;@drawable/playing_ani&quot; 最后代码中开始动画 AnimationDrawable anim = (AnimationDrawable) image.getDrawable(); anim.start(); 当我们通过android:src＝””设置动画资源时，对应的取出方式是image.getDrawable()如果我们通过android:background=””设置动画资源，那么对应的取出方式就是image.getBackground()。 2、音乐播放示例3、AnimationDrawable类AnimationDrawable有下面几个常用函数 void start()//开始播放逐帧动画 void stop()//停止播放逐帧动画 int getDuration(int index）//得到指定index的帧的持续时间 Drawable getFrame(int index）//得到指定index的帧所对应的Drawable对象 int getNumberOfFrames()//得到当前AnimationDrawable的所有帧数量 boolean isRunning() //判断当前AnimationDrawable是否正在播放 void setOneShot(boolean oneShot）//设置AnimationDrawable是否执行一次，true表示执行一次，false表示循环播放 boolean isOneShot() //判断当前AnimationDrawable是否执行一次，true表示执行一次，返回false表示循环播放。 void addFrame(Drawable frame,int duration）//为AnimationDrawable添加1帧，并设置持续时间。 2.5.2、代码实现&lt;ImageView android:id=&quot;@+id/frame_iv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 代码 AnimationDrawable anim = new AnimationDrawable(); for (int i = 1; i &lt;= 14; i++) &#123; int id = getResources().getIdentifier(&quot;list_icon_gif_playing&quot; + i,&quot;drawable&quot;, getPackageName()); Drawable drawable = getResources().getDrawable(id); anim.addFrame(drawable, 60); &#125; anim.setOneShot(false); image.setBackgroundDrawable(anim); anim.start(); getldentifier()函数的完整声明如下： int getldentifier(String name, String defType, String defPackage) //获得string getResources().getldentifier(”name”,”string”, packdgeName); //获得array中的数组： getResources().getidentifier(”name”,”array”, packdgeName); 第3章、属性动画3.1、ValueAnimator的基本使用3.1.1、概述View Animation中的动画类命名都是XXXXAnimation，而Property Animation中的动画类命名都是XXXXAnimator。 视图动画仅能对指定的控件做动画，而属性动画是通过改变控件的某一属性值来做动画的。 3.1.2、ValueAnimator的简单使用ValueAnimator不会对控件执行任何操作，我们可以给它设定从哪个值运动到哪个值，通过监听这些值的渐变过程来自己操作控件。 //创建实例 ValueAnimator animator = ValueAnimator.ofInt(0, 400); animator.setDuration(1000); //添加监昕事件 animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (Integer)animation.getAnimatedValue() ; Log.d(&quot;qijian&quot;,&quot;curValue:&quot; + curValue); &#125; &#125;); //开启动画 animator.start(); 改变控件位置 view.layout(); 3.1.3、常用函数public static ValueAnimator ofint (int... values) public static ValueAnimator ofFloat(float... values) //设置动画时长，单位是毫秒 ValueAnimator setDuration(long duration) //获取 ValueAnimator 在运动时当前运动点的值 Object getAnimatedValue() //开始动画 void start() //设置循环次数，设置为ValueAnimator.INFINITE表示无限循环 void setRepeatCount(int value) //设置循环模式有ValueAnimator.RESTART和ValueAnimator.REVERSE void setRepeatMode(int value) //取消动画 void cancel() 重复次数为INFINITE的动画，当Activity结束的时候，必须调用cancel()函数取消动画，否则动画将无限循环，从而导致View无法释放，进一步导致整个Activity无法释放，最终引起内存泄漏。 //监听动画过程中值的实时变化,添加方法为:public void addUpdateListener(AnimatorUpdateListener listener) public static interface AnimatorUpdateListener &#123; void onAnimationUpdate(ValueAnimator animation); &#125; //听动画变化时的4个状态,添加方法为:public void addListener(AnimatorListener listener) public static interface AnimatorListener &#123; void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); &#125; 移除监听 void removeUpdateListener(AnimatorUpdateListener listener); void removeAllUpdateListeners(); void removeListener(AnimatorListener listener); void removeAllListeners(); 其他不常用函数 //延时多久开始，单位是毫秒 public void setStartDelay(long startDelay) //完全克隆一个ValueAnimator实例，包括它所有的设置以及所有对监听器代码的处理 public void Animatorclone() 3.1.4、弹跳加载申效果示例通过setTop(int top）函数将控件移动到当前位置。这里需要说明的是，getTop和setTop函数所得到的和设置的坐标都是相对父控件的坐标位置。 3.2、自定义插值器与Evaluator对于Animator而言，不仅可以设置插值器，还可以设置Evaluator。 3.2.1、自定义插值器系统插值器实现的接口： public interface TimeInterpolator &#123; float getInterpolation(float input); &#125; 参数input:取值范围是0～1，表示当前动画的进度，只与时间有关，取0时表示动画刚开始，取1时表示动画结束。 返回值：表示当前实际想要显示的进度。取值可以超过1，也可以小于0。超过1表示己经超过目标值，小于0表示小于开始位置。 自定义插值器，只需实现Timelnterpolator接口就可以了。 3.2.2、Evaluator流程：oflnt(0,400）定义动画数值区间 -&gt; 插值器(返面当前数值进度，如0.2) -&gt; Evaluator(根据数值进度计算当前值) -&gt; 监听器退回(在AnimatorUpdatelistener中返回)。 Evaluator用于将从插值器返回的数值进度转换成对应的数值。 public class IntEvaluator Implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction , Integer startValue , Integer endValue) &#123; int startint = startValue; return (int) (startint + fraction * (endValue - startint)); &#125; &#125; fraction参数就是插值器中的返回值，表示当前动画的数值进度，以小数表示。startValue和endValue分别对应oflnt(int start,int end）函数中start和end的数值。返回值就是在AnimatorUpdateListener监听器中通过animation.getAnimatedValue()函数得到的数值。 使用 animator.setEvaluator(new IntEvaluator()); 所以既可以通过重写插值器改变数值进度来改变数值位置，也可以通过改变Evaluator中数值进度所对应的具体数值来改变数值位置。 ArgbEvaluator除 IntEvaluator 和 FloatEvaluator 外，还有一个名为 ArgbEvaluator，它是用来实现颜色值过渡转换的。 ValueAnimator animator = ValueAnimator.ofInt(0xffffff00,0xff0000ff); animator.setEvaluator(new ArgbEvaluator()); animator.setDuration(3000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (Integer) animation.getAnimatedValue(); tv.setBackgroundColor(curValue); &#125; &#125;); animator.start(); 3.3、ValueAnimator进阶ofObjectpublic static ValueAnimator ofObject(TypeEvaluator evaluator, Object ...values) TextView中的字母从A变化到Z实例3.3.2、示例：抛物动画3.4、ObjectAnimator3.4.1、概述ObjectAnimator是派生自ValueAnimator的，所以ValueAnimator中所能使用的函数在ObjectAnimator中都可以正常使用。 public static ObjectAnimator ofFloat(Object target,String propertyName,float ...values) 在View中，有关动画共有下面几组set函数。 // 1. 透明 度： alpha public void setAlpha(float alpha) // 2. 旋转度数 ： rotation 、 rotationX 、 rotationY public void setRotation(float rotation) public void setRotationX(float rotationX) public void setRotationY(float rotationY) // 3. 平移 ： translationX 、 translationY public void setTranslationX(float translationX) public void setTranslationY(float translationY) // 4. 缩放 ： scaleX 、 scaleY public void setScaleX(float scaleX) public void setScaleY(float scaleY) 3.4.2、ObjectAnimator动画原理ofFloat(tv, &quot;scaleY&quot;,0,3,1）(定义动画对象及区间） —&gt; 插值器(返面当前数值进度，如0.2) -&gt; Evaluator(根据数值进度计算当前值) -&gt; 调用set函数(根据属性拼装set函数并反射调用，并将当前值作为参数传入)。 ObjectAnimator 只负责把动画过程中的数值传到对应属性的set函数中就结束了。 3.4.3、自定义ObjectAnimator属性抛物动画例子 3.4.4、何时需要实现对应属性的get函数当动画只有一个过渡值时，系统才会调用对应属性的get函数来得到动画的初始值。当不存在get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。 3.4.5、常用函数//设置动画时长，单位是毫秒 ValueAnimator setDuration(long duration) //获取 ValueAnimator 在运动时，当前运动点的值 Object getAnimatedValue () ; //开始动画 void start () //设置循环次数，设置为 INFINITE 表示无限循环 void setRepeatCount(int value) //设置循环模式，value 取值有 RESTART 和 REVERSE void setRepeatMode （Int value) //取消动画 void cancel() //监听动画变化时的实时值 //添加方法为 public void addUpdateListener(AnimatorUpdateListener listener public static interface AnimatorUpdateListener &#123; void onAnimatorUpdate(ValueAnimator animation); ) //监听器二 ： 监听动画变化时的 4 种状态 //添加方法为 public void addListener(AnimatorListener listener) public static interface AnimatorListener &#123; void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); &#125; //设置插值器 public void setInterpolator(Timeinterpolator value) //设置 Evaluator public void setEvaluator(TypeEvaluator value) 3.5、组合动画AnimatorSet3.5.1、playSequentially与playTogetherplaySequentially：动画依次播放，playTogether：所有动画一起开始。 playTogether和playSequentially函数在开始动画时，只是把每个控件的动画激活，至于每个控件自身的动画是否延时、是否无限循环，只与控件自身的动画设定有关，与playTogether和 playSequentially函数无关，它们只负责到时间后激活动画。 playSequentially函数只有在上一个控件做完动画以后，才会激活下一个控件的动画。如果上一个控件的动画是无限循环的，那么下一个控件就别再指望能做动画了。 3.5.2、AnimatorSet.Builde//表示要播放哪个动画 public Builder play (Animator anim) //和前面的动画一起执行 public Builder with(Animator anim) //先执行这个动画，再执行前面的动画 public Builder before (Animator aηim) //在执行前面的动画后才执行该动画 public Builder after(Animator anim) //延迟 n 毫秒之后执行动画 public Builder after(long delay) 3.5.3、AnimatorSet监昕器public void addListener(AnimatorListener listener); 3.5.4、常用函数//设置单次动画时长 public AnimatorSet setDuration(long duration); //设置插值器 public void setinterpolator(Timeinterpolator interpolator) //设置 ObjectAnimator 动画目标控件 public void setTarget(Object target) 在AnimatorSet中设置以后，会覆盖单个ObjectAnimator中的设置。 //设置延时开始动画时长 public void setStartDelay(long startDelay) 不会覆盖单个动画的延时，而且仅针对性地延长AnimatorSet的激活时间。 3.5.5、示例：路径动画代码 https://github.com/AdamRight/TeaTool/blob/master/app/src/main/java/com/tea/teatool/pathMenu/PathMenuActivity.java 3.6、Animator动画的XML实现在 XML 中与 Animator 对应的有三个标签: &lt;animator/＞:对应ValueAnimator &lt;objectAnimator/＞ 对应ObjectAnimator &lt;set/＞对应 AnimatorSet ValueAnimator valueAnimator = (ValueAnimator)Animatorinflater.loadAnimator(MyActivity.this , R.animator.animator); valueAnimator.start(); ObjectAnimator animator = (ObjectAnimator) Animatorinflater.loadAnimator(MyActivity.this , R.animator.object_animator); animator.setTarget(mTvl); animator.start(); 第4章属性动画进阶4.1、PropertyValuesHolder与Keyframe通过ofPropertyValu巳sHolder函数来创建实例。 4.1.1、PropertyValuesHolderofFloat PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;Rotation&quot;, 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f); PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0.1f, 1f, 0.1f, 1f); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, alphaHolder); animator.setDuration(3000); animator.start(); ofObject public static PropertyValuesHolder ofObject (String propertyName ,TypeEvaluator evaluator, Object . .. values ) 4.1.2、Keyframe关键帧：解决控制动画速率的问题。 public static Keyframe ofFloat(float fraction , float value) fraction：表示当前的显示进度，即在插值器中getlnterpolation函数的返回值。 value：表示动画当前所在的数值位置。 设置插值器： public void setinterpolator(Timeinterpolator interpolator) 使用ofObject函数来制作动画的时候，必须设置Evaluator，因为系统根本无法知道动画的中间值Object真正是什么类型的。 4.1.3 PropertyValuesHolde其他函数4.1.4、电话晌铃效果示例借助Keyframe，不需要使用AnimatorSet，也能实现多个动画同时播放。 4.2、ViewPropertyAnimator4.2.1、概述4.2.2、常用函数tv.animate().scaleX(2).scaleY(2).setListener(new Animator.AnimatorListener() &#123; public void onAnimationStart(Animator animation ) &#123;&#125; public void onAnimationEnd (Animator animation ) &#123;&#125; public void onAnimationCancel(Animator animation) &#123;&#125; public void onAnimationRepeat(Animator animation) &#123;&#125; &#125;); 4.3、为ViewGroup内的组件添加动画4.3.1、animatelayoutChanges属性android:animateLayoutChanges＝”true/false”，所有派生自ViewGroup类的控件都具有此属性。动画不能自定义。 4.3.2、LayoutTransition第一步，创建实例。 LayoutTransition transitioner = new LayoutTransition(); 第二步创建动画并进行设置。 ObjectAnimator animOut = ObjectAnimator.ofFloat(null,”rotation”, Of,90f, Of); transitioner.setAnimator(LayoutTransition.DISAPPEARING , animOut); 第三步将LayoutTransition设置到ViewGroup中。 linearLayout.setLayoutTransition(transitioner); 其中,transitionType表示当前应用动画的对象范围，取值如下: APPEARING：元素在容器中出现时所定义的动画。 DISAPPEARING：元素在容器中消失时所定义的动画。 CHANGE_APPEARING:由于容器中要显现一个新的元素，其他需要变化的元素所应用的动画。 CHANGE_DISAPPEARING：当容器中某个元素消失时，其他需要变化的元素所应用的动画。 4.3.3、其他函数4.4、开源动画库NineOldAndroids第5章动画进阶5.1、利用PathMeasure实现路径动画5.1.1、初始化方式一： PathMeasure pathMeasure = new PathMeasure() ; setPath (Path path , boolean forceClosed); 方式二： PathMeasure(Path path , boolean forceClosed); boolean forceClosed表示Path最终是否需要闭合，如果为true，则不管关联的Path是否是闭合的，都会被闭合。对绑定的Path不会产生任何影响，PathMeasure的计算就会包含最后一段闭合的路径，与原来的Path不同。 5.1.2、简单函数使用//获取计算的路径长度 PathMeasure.getLength() //判断测量Path时是否计算闭合 public boolean isClosed() //函数得到的曲线的顺序与Path中添加的顺序相同。getLength等函数针对的都是当前的曲线，而不是整个Path。 PathMeasure.nextContour() 5.1.3、getSegment函数//截取整个Path中的某个片段，将截取后的 Path 保存到参数 dst 中。 boolean getSegrneηt(float startD ,float stopD, Path dst, boolean startWithMoveTo) startD、stopD：开始截取位置距离 Path 起始点的长度；结束截取位置距离 Path 起始点的长度。 Path dst：截取的Path将会被添加到dst中。注意是添加，而不是替换。 boolean startWithMoveTo：起始点是否使用 moveTo。 5.1.4、getPosTan函数//用于得到路径上某一长度的位置以及该位置的正切值 boolean getPosTan(float distance , float[] pos , float[] tan) float distance：距离Path起始点的长度。float[] pos：该点的坐标值。pos[O]表示x坐标，pos[1］表示y坐标。float[] tan：该点的正切值。 箭头加载动画示例 5.1.5、getMatrix函数//用于得到路径上某一长度的位置以及该位置的正切值的矩阵 boolean getMatrix(float distance , Matrix matrix , int flags) 5.1.6、支付宝支付成功动画示例5.2、SVG动画5.2.1、概述SVG 的全称是Scalable Vector Graphics（可缩放矢量图形〉。矢量图相对应的是位图，Bitmap就是位图。 对于5.0以下的机型，可以通过引入 com.android.support:appcompat-v7:23.4.0及以上版本进行支持。 5.2.2、vector标签与图像显示vector标签指定的是画布大小，path标签则指定的是路径内容。 Android工程中使用SVG图像。 5.2.3、动态Vector5.2.4、输入搜索动画示例第6章Paint基本使用6.1、硬件加速GPU的英文全称为Graphic Processing Unit，中文翻译为“图形处理器”。GPU是专门为处理图形任务而产生的芯片。在GPU加速时，实际上是使用OpenGL的相关函数来完成绘制的。 Android提供了不同的禁用方法，分Application、Activity、Window、View4个层级。 在AndroidManifest.xml文件中为application标签添加如下属性，即可为整个应用程序开启/关闭硬件加速。 &lt;application android:hardwareAccelerated=”true”...&gt; 在activity标签下开启或关闭硬件加速: &lt;activity android:hardwareAccelerated=”false” /&gt; 在Window层级上使用如下代码开启硬件加速(在Window层级上不支持关闭硬件加速: getWiηdow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 在View层级上使用如下代码关闭硬件加速（在View层级上不支持开启硬件加速） setLayerType(View.LAYER_TYPE_SOFTWARE,null&#125;; 或者使用android:layerType＝&quot;software&quot;来关闭硬件加速。 6.2、文字6.2.1、概述基线就是四线格中的第三条线。 public void drawText (String text , float x , float y , Paint paint) y代表的是基线的位置,而不是左上角。x代表所要绘制的文字所在矩形的相对位置。 Align的取值为 Paint.Align.LEFT、Paint.Align.CENTER、Paint.Align.RIGHT Paint :: setTextAlign(Align align); 6.2.2、绘图四线搭与FontMetricsascent：系统推荐的，在绘制单个字符时，字符应当的最高高度所在线。 descent：系统推荐的，在绘制单个字符肘，宇符应当的最低高度所在线。 top：可绘制的最高高度所在线。 bottom：可绘制的最低高度所在线。 ascent变量的值是负数。descent变量的值必然是正数。 ascent线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.ascent descent线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.descent top线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.top bottom线的y坐标 ＝ baseline线的y坐标 ＋ fontMetric.bottom 获取 FontMetrics 对象 Paint paint = new Paint(); Paint.FontMetrics fm = paint.getFontMetrics();//Float类型 Paint.FontMetricsint fmint = paint.getFontMetricsint();//Int类型 6.2.3、常用函数字符串所占区域的高度、宽度和最小矩形。 高度：bottom线所在位置的y坐标减去top线所在位置的y坐标 Paint.FontMetricsint fm = paint.getFontMetricsint(); int top = baseLineY + fm.top; int bottom = baseLineY + fm.bottom; //所占区域的高度 int height = bottom - top; 宽度: int width = paint.measureText(String text); 最小矩形 //以（0, 0）点所在位置为基线,text要测量最小矩形的字符串,start 要测量起始字符在字符串中的索引, //end 所要测量的字符的长度,bounds接收测量结果 public void getTextBounds(String text, int start, int end, Rect bounds); 矩形实际位置的坐标如下 Rect minRect = new Rect(); paint.getTextBounds(text , 0 , text. length(), minRect); //最小矩形，实际top线的位置 int minTop =bounds.top + baselineY; //最小矩形，实际 bottom 线的位置 int minBottom = bounds.bottom + baselineY; 6.2.4、定点写字示例当给定中间线位置以后，baseline线的位置为： baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom 6.3、Paint常用函数6.3.1、基本设置函数reset() setColor(int color) setARGB(int a, int r, int g, int b) setAlpha(int a) //Paint.Style.FILL、Paint.Style.FILL_AND_STROE、Paint.Style.STROKE setStyle(Paint.Style style) setStrokeWidth(float width) setAntiAlias(boolean aa) setStrokeMiter(float miter) //ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect。 setPathEffect(PathEffect effect) //Paint.Cap.ROUND 、Paint.Cap.SQUARE、Paint.Cap.BUTT setStrokeCap(Paint.Cap cap) //Paiηt.Join.MITER、Paiηt.Join.ROUND、Paiηt.Join.BEVEL setStrokeJoin (Paiηt.Join join) setDither(boolean dither) 6.3.2、字体相关函数setTextSize(float textSize) setFakeBoldText(boolean fakeBoldText) setUnderlineText(boolean underlineText) setTextAlign（Paint.Align align) setTextScaleX(float scaleX) setTextSkewX(float skewX) setTypeface(Typeface typeface) setSubpixelText(boolean subpixelText) 第7章绘图进阶7.1、贝济埃曲线7.1.1、概述一阶贝济埃曲线，可以理解为在由起始点和终点形成的这条直线上匀速移动的点。 二阶贝济埃曲线的移动轨迹是建立在两条一阶贝济埃曲线的中间点的基础上的。 所谓几阶贝济埃曲线，全部是由一条条一阶贝济埃曲线搭起来的。 7.1.2、贝济埃曲线之quadTo//二阶贝济埃曲线 public void quadTo(float xl , float yl, fl oat x2 , float y2) public void rQuadTo(float dxl, float dyl , float dx2, float dy2) //三阶贝济埃曲线 public void cubicTo (float xl , float yl , float x2 , float y2 , float x3 , float y3) public void rCubicTo(float xl , float yl, float x2 , float y2 , float x3 , float y3 ) 起始点是通过Path.moveTo(x,y）函数来指定的，而如果我们连续调用quadTo（）函数， 那么前一个quadTo（）函数的终点就是下一个quadTo（）函数的起始。 传统捕捉手势轨迹示例 7.1.3、贝济埃曲线之rQuadToquadTo()函数定义一个绝对坐标： path.moveTo(300,400) path.quadTo(500,300,500,500) 与利用rQuadTo()函数定义相对坐标是等价的： path.moveTo(300,400) path.rQuadTo(200,-100,200,100) 7.1.4、波浪效果示例7.2、setShadowLayer与阴影效果7.2.1、setShadowlayer()构造函数public void setShadowLayer(float radius, float dx , float dy , int color) float radius：模糊半径，radius越大越模糊、越小越清晰。如果radius设置为0则阴影消失不见。float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移。float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移。int color：绘制阴影的画笔颜色，阴影的颜色（对图片阴影无效）。 setShadowLayer()函数使用的是高斯模糊算法。高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的RGB值并且平均，这个平均值就是模糊处理过的像素。如果对图片中的所有像素都这么处理，那么处理完成的图片就会变得模糊。其中，所取周围像素的半径就是模糊半径。所以，模糊半径越大，所得平均像素与原始像素相差就越大，也就越模糊。 7.2.2、清除阴影setShadowLayer函数的radius参数值设为0， 或者用专门的清除阴影的函数： public void clearShadowLayer() 7.2.3、给文字添加阴影示例7.3、BlurMaskFilter发光效果与图片阴影public MaskFilter setMaskFilter(MaskFilter maskfilter) public BlurMaskFilter&#123;float radius ,Blur style) 7.3.2、给图片添加纯色阴影public Bitmap extractAlpha(); extractAlpha会新建一幅仅具有Alpha值的空白图像，而且这幅图像的颜色是在使用canvas.drawBitmap函数绘制时由传入的画笔颜色指定的。 7.4、Shader与BitmapShader7.4.1、Shader概述通过给Shader指定对应的图像、渐变色等来填充图形的。 public Shader setShader (Shader shader) 7.4.2、BitmapShader的基本用法public BitmapShader(Bitmap bitmap, TileMode tileX , TileMode tileY) bitmap用来指定图案，tileX用来指定当X轴超出单张图片大小时所使用的重复策略，tileY用来指定当Y轴超出单张图片大小时所使用的重复策略。 TileMode的取值： TileMode.CLAMP：用边缘色彩来填充多余空间。 TileMode.REPEAT：重复原图像来填充多余空间。 TileMode.MIRROR：重复使用镜像模式的 图像来填充多余空间。 先填充Y轴，然后填充X轴。 7.4.3、望远镜效果示例7.4.4、生成不规则头像示例7.5、Shader之LinearGradient7.5.1、概述public LinearGradient(float xO , float yO , float xl , float yl , int colorO , int colorl , TileMode tile) public LinearGradient (float xO , fl 。atyO, floatxl ,floatyl,intcolors[], float positions[] , TileMode tile) 7.5.2、闪光文字效果示例7.6、Shader之RadialGradient7.6.1、双色渐变RadialGradient(float centerX , float centerY , float radius , int centerColor ,int edgeColor, Shader.TileMode tileMode) 7.6.2、多色渐变RadialGradient(float centerX , float centerY , float radius, int[] colors , float[] stops, Shader.TileMode tileMode) 第8章混合模式8.1、混合模式之AvoidXfermode8.1.1、混合模式概述Xfermode的子类有AvoidXfermode、PixelXorXfermode和PorterDuffXfermode。 在使用Xfermode时，为了保险起见，需要做两件事： 禁用硬件加速： setLayerType(View.LAYER_TYPE_SOFTWARE, null); 使用离屏绘制: 需要把绘制的核心代码放在canvas.save和canvas.restore函数之间 //新建图层 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(),null ,Canvas.ALL_SAVE_FLAG); //核心绘制代码 //.... //还原图层 canvas.restoreToCount(layerid); 8.1.2、AvoidXfermodepublic AvoidXfermode (int opColor, int tolerance ,Mode mode) 8.1.3、AvoidXfermode绘制原理8.1.4、AvoidXfermode之Mode.AVOID8.2、混合模式之PorterDuffXfermode8.2.1、PorterDuffXfermode概述public PorterDuffXfermode(PorterDuff .Mode mode) 在Xfermode设置前画出的图像叫作目标图像，即给谁应用Xfermode；在Xfermode设置后画出 的图像叫作源图像，即拿什么应用Xfermode。 8.2.2、颜色叠加相关模式8.3、PorterDuffXfermode之源图像模式刮刮卡效果示例 8.4、目标图像模式与真他模式区域波纹示例","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"ConstraintLayout布局详解","slug":"31.ConstraintLayout布局","date":"2019-12-23T13:44:16.294Z","updated":"2021-03-26T14:41:10.261Z","comments":false,"path":"2019/12/23/31.ConstraintLayout布局/","link":"","permalink":"http://yoursite.com/2019/12/23/31.ConstraintLayout%E5%B8%83%E5%B1%80/","excerpt":"","text":"ConstraintLayout代码：https://github.com/AdamRight/Android2021Code/blob/master/app/src/main/java/com/android/code/constraintlayout/ConstraintLayoutActivity.kt 相对位置 下面是ConstraintLayout确定位置的属性： layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf ＃ 与left\\right相似 layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf 尺寸约束0dp ConstraintLayout 中不支持 MATCH_PARENT 这个值，如果需要实现跟MATCH_PARENT同样的效果，可以使用0dp来代替，其表示MATCH_CONSTRAINT,即适应约束。其跟MATCH_PARENT还是有区别的。 android:layout_width=&quot;0dp&quot; 权重weight 通过设置以下两个属性： app:layout_constraintHorizontal_weight //水平权重 app:layout_constraintVertical_weight //竖直权重 比如 &lt;View android:background=&quot;@color/black&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;50dp&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/view2&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;View android:background=&quot;@color/purple_200&quot; android:id=&quot;@+id/view2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;50dp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; app:layout_constraintStart_toEndOf=&quot;@+id/view1&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 文字基准线对齐Baseline # 底部对齐 layout_constraintBaseline_toBaselineOf 主要用于和文字底部对齐样式，app:layout_constraintBaseline_toBaselineOf主要和 app:layout_constraintBottom_toBottomOf做区分。 &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;80dp&quot; android:background=&quot;@color/design_default_color_primary_variant&quot; android:text=&quot;99&quot; android:textSize=&quot;128sp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;%&quot; android:textSize=&quot;26sp&quot; app:layout_constraintBaseline_toBaselineOf=&quot;@+id/textView1&quot; app:layout_constraintStart_toEndOf=&quot;@+id/textView1&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;%&quot; android:textSize=&quot;26sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/textView1&quot; app:layout_constraintStart_toEndOf=&quot;@+id/textView1&quot; /&gt; 圆形定位-角度布局Circl 三个属性确定位置：以谁为圆心，半径，角度： app:layout_constraintCircleAngle app:layout_constraintCircleRadius app:layout_constraintCircle 约束限制constrained app:layout_constrainedWidth=&quot;true&quot; app:layout_constrainedHeight=&quot;true&quot; 一般控制TextView的宽度不超过限定的距离。 &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:background=&quot;@color/design_default_color_error&quot; android:text=&quot;长文本长文本长文本长文本长文本文本长文本长文本&quot; android:textColor=&quot;@android:color/white&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/sun&quot; app:layout_constraintStart_toStartOf=&quot;@+id/sun&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/sun&quot; /&gt; 位置偏向bias 如果想让view的位置偏向某一侧,其值同样也是0到1之间： layout_constraintHorizontal_bias //水平偏向 layout_constraintVertical_bias //竖直偏向 bias可以和constrained一起使用： &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:background=&quot;@color/design_default_color_error&quot; android:text=&quot;长文本长文本长文本长文本长文本文本长文本长文本&quot; android:textColor=&quot;@android:color/white&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/sun&quot; app:layout_constraintHorizontal_bias=&quot;0.508&quot; app:layout_constraintStart_toStartOf=&quot;@+id/sun&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/sun&quot; /&gt; goneMargin 当某个控件A存在时，下面的控件B距离A需要一个margin_top=20dp。 当A消失时(gone掉了)，此时margin_top=0dp。layout_goneMarginTop就有用了。 &lt;TextView android:id=&quot;@+id/textview&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimary&quot; android:text=&quot;长文本长文本&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;28sp&quot; android:visibility=&quot;gone&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;ImageView app:layout_goneMarginStart=&quot;46dp&quot; android:id=&quot;@+id/avatar&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:src=&quot;@mipmap/ic_launcher_round&quot; app:layout_constraintStart_toEndOf=&quot;@id/textview&quot; app:layout_constraintTop_toTopOf=&quot;@id/textview&quot; /&gt; 约束链chain 设置链样式的属性是： app:layout_constraintVertical_chainStyle=&quot;spread|spread_inside|packed&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread|spread_inside|packed&quot; 默认是spread（扩散），packed意思是打包在一起，spread_inside（内部扩散）。使用时候，给第一个控件view添加chainStyle即可。 宽高比DimensionRatio 默认的都是宽：搞，然后根据另外一条边和比例算出。需要将宽或者高中的的至少一个设置为0dp（即MATCH_CONSTRAINT），即要适应约束条件。然后通过layout_constraintDimensionRatio属性设置一个比率即可。这个比率可以是一个浮点数，表示宽度和高度之间的比率；也可以是“宽度：高度”形式的比率。 &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:text=&quot;-------------------宽高比2：1-------------------&quot; app:layout_constraintDimensionRatio=&quot;2:1&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; 如果宽和高都设置为0dp（MATCH_CONSTRAINT），那么layout_constraintDimensionRatio的值需要先加一个W,或H,来表示约束宽度或高度。如下： &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintDimensionRatio=&quot;H,16:9&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; 这里例子是说，首先宽度将满足自适应的约束，然后将按照16：9的比例设置高度。 百分比宽高percent 要使用百分比，宽或高同样要设置为0dp（MATCH_CONSTRAINT）。 然后设置以下属性即可： app:layout_constraintWidth_default=&quot;percent&quot; //设置宽为百分比 app:layout_constraintWidth_percent=&quot;0.3&quot; //0到1之间的值 或 app:layout_constraintHeight_default=&quot;percent&quot; //设置高为百分比 app:layout_constraintHeight_percent=&quot;0.3&quot; //0到1之间的值 例子 &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;宽50%&quot; app:layout_constraintWidth_default=&quot;percent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintWidth_percent=&quot;0.5&quot;/&gt; layout_constraintWidth_default 设置为 percent 即采用百分比的方式布局，然后设置 layout_constraintWidth_percent 的属性值，来改变水平方向的百分比。 控件统一Group 通过constraint_referenced_ids使用引用的方式来避免布局嵌套。可以为一组控件统一设置 setVisibility，只有设置可见度的功能，不能设置点击事件。 &lt;androidx.constraintlayout.widget.Group android:id=&quot;@+id/group&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:constraint_referenced_ids=&quot;view,view1,view7,view8&quot; /&gt; 控件统一Layer 和Group类似，通过引用的方式来避免布局嵌套，可以为一组控件统一设置旋转/缩放/位移。 &lt;androidx.constraintlayout.helper.widget.Layer android:id=&quot;@+id/layer&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:constraint_referenced_ids=&quot;view,view1,view7,view8&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt; 控件统一Flow Flow统一控制控件的排列方向orientation和方式flow_wrapMode。flow_wrapMode的属性有chain、aligned、none(默认)。 &lt;androidx.constraintlayout.helper.widget.Flow android:id=&quot;@+id/flow&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;16dp&quot; android:background=&quot;@color/colorAccent&quot; android:orientation=&quot;horizontal&quot; app:flow_wrapMode=&quot;chain&quot; app:flow_verticalGap=&quot;16dp&quot; app:flow_horizontalGap=&quot;16dp&quot; app:constraint_referenced_ids=&quot;view1,view2,view3,view4,view5,view6&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 辅助线Guideline Guideline主要的属性有： //水平或垂直引导线 android:orientation=&quot;horizontal|vertical&quot; //如果是水平引导线，则距离布局顶部30dp，如果是垂直引导线，则距离布局左边30dp app:layout_constraintGuide_begin=&quot;30dp&quot; //如果是水平引导线，则距离布局底部30dp，如果是垂直引导线，则距离布局右边30dp app:layout_constraintGuide_end=&quot;30dp&quot; //如果是水平引导线，则距离布局顶部为整个布局高度的50%，如果是垂直引导线，则距离布局左边文这个布局宽度的50% app:layout_constraintGuide_percent=&quot;0.5&quot; 辅助线Barrier 通过设置一组控件的某个方向的屏障，来避免布局嵌套。比如view1和view2谁的宽度长，就以谁的宽度为基准，设置垂直的辅助线。 &lt;androidx.constraintlayout.widget.Barrier android:id=&quot;@+id/barrier&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:barrierDirection=&quot;end&quot; app:constraint_referenced_ids=&quot;view1,view2&quot; /&gt; 自定义ConstraintHelper 通过继承ConstraintHelper类，自定义统一操作的控件组。 代码：https://github.com/AdamRight/Android2021Code/blob/master/app/src/main/java/com/android/code/constraintlayout/CircularRevealHelper.kt 占位符Placeholder Placeholder通过setContentId来将指定控件放到占位符的位置。 代码：activity_circular_reveal.xml ConstraintSet 使用ConstraintSet对象来动态修改布局。防止布局中有不存在的 id 控件报错，需要设置 isForceId = false。 布局扁平化更加容易做过渡动画，在布局修改之前加上 TransitionManager 来自动完成过渡动画。 2、MotionLayout2.1、介绍 MotionLayout是ConstraintLayout的子类。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://yoursite.com/tags/ConstraintLayout/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"adb命令","slug":"30.adb命令","date":"2019-11-29T14:22:57.855Z","updated":"2021-03-26T14:41:06.462Z","comments":false,"path":"2019/11/29/30.adb命令/","link":"","permalink":"http://yoursite.com/2019/11/29/30.adb%E5%91%BD%E4%BB%A4/","excerpt":"","text":"monkey测试 adb shell monkey -p 包名 -v 次数 启动adb、关闭adb adb start-server adb kill-server 获取手机的系统版本 adb shell getprop ro.build.version.release 清除apk的数据和缓存 adb shell pm clear 包名 安装和卸载apk adb install 文件路径 adb uninstall 包名 电脑和手机文件互传 adb push C:\\Users\\win\\Desktop\\xx.png /sdcard adb pull /sdcard/xx.png C:\\Users\\win\\Desktop 查看保存app错误日志 adb logcat *:E | grep &quot;包名&quot; &gt; 电脑路径 //mac adb logcat *:E | find &quot;包名&quot; &gt; 电脑路径 //win 获取当前app包名和当前页面名(⼿机打开对应app) adb shell dumpsys window windows | grep mFocusedApp //mac adb shell dumpsys window windows | findstr mFocusedApp //win log获取app的包名和activity名称 adb logcat | grep START //mac adb logcat | findstr START //win 然后点击app 关闭app后,获取app启动时间 关闭app adb shell am start -W 包名/启动名 adb shell am start -W com.xxx.xxx/.LaunchActivity //TotalTime： app⾃身启动时间,WaitTime： 系统启动应⽤时间 Appium 官⽹： www.appium.io, Appium是由nodejs的express框架写的Http Server,Appium使⽤WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"adb","slug":"adb","permalink":"http://yoursite.com/tags/adb/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Gradle构建详解","slug":"29.Gradle构建详解","date":"2019-07-13T08:08:14.650Z","updated":"2021-03-26T14:41:01.350Z","comments":false,"path":"2019/07/13/29.Gradle构建详解/","link":"","permalink":"http://yoursite.com/2019/07/13/29.Gradle%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1、介绍和环境搭建DSL(domain specific language)：领域特定语言，解决特定问题，包括Groovy，xml等等。 Groovy是一种基于JVM的敏捷开发语言，可以使用java所用的库。 Groovy官网 http://groovy-lang.org/ 下载最新稳定版本(the latest stable version of Groovy)-2.5.8版本。 检查环境变量配置 groovy -version 在Android studio中Tools - Groovy Console直接编写Groovy语言。 println &quot;hello groovy&quot; 2、语法2.1、基础语法groovy变量的类型都是对象类型，没有基本类型，因为基本类型都会装箱成对象类型。 变量的定义包括强类型定义和弱类型def定义。 def x = 10 println x.class //class java.lang.Integer 字符串除了String还有GString，GString的常用三种定义方式 def s1 = &apos;a single \\&apos;a\\&apos; String&apos; println s1 //a single &apos;a&apos; String def s2 = &apos;&apos;&apos;\\ line one line two line three &apos;&apos;&apos; println s2 //line one //line two //line three def s3 = &quot;a common String&quot; def say = &quot;this is $&#123;s3&#125;&quot; //花括号可扩展任意的表达式 println say //this is a common String println say.class //class org.codehaus.groovy.runtime.GStringImpl 新增常用操作符 def str = &quot;groovy&quot; //println str.center(9,&apos;a&apos;) //agroovyaa //println str.padLeft(9,&apos;a&apos;) //aaagroovy //println str.padRight(9,&apos;a&apos;) //groovyaaa def str2 = &apos;Hello&apos; println str &gt; str2 //true println str[0] //g println str[0..1] //gr def str3 = &apos;gro&apos; println str.minus(str3) //ovy println str - str3 //ovy //println str.reverse() //yvoorg println str.capitalize() //Groovy println str.isNumber() //false 逻辑控制: switch def x = 1.23 def result switch (x)&#123; case &quot;str&quot;: result = &apos;str&apos; break case [4,6,7,&apos;inlist&apos;]: //list result = &apos;list&apos; break case 12..30: //范围 result = &apos;range&apos; break case Integer: result = &apos;Integer&apos; break case BigDecimal: result = &apos;BigDecimal&apos; break default:result = &apos;default&apos; &#125; println result //BigDecimal for范围 def sum = 0 for (i in 0..9)&#123; sum += i &#125; println sum //45 list循环 def sum = 0 for (i in [1,2,3,4,5,6,7,8,9])&#123; sum += i &#125; println sum //45 map循环 def sum = 0 for (i in [&apos;wang&apos;:1,&apos;zhang&apos;:2,&apos;li&apos;:3])&#123; sum += i.value &#125; println sum //6 2.2、闭包类似于方法 def clouser = &#123; println &quot;Hello groovy&quot;&#125; clouser.call() //调用方式一，Hello groovy clouser() //调用方式二，Hello groovy 有参数的闭包-&gt;前的是参数,也可以有多个参数 def clouser = &#123;String name -&gt; println &quot;$&#123;name&#125; Hello groovy&quot;&#125; clouser.call(&quot;this is&quot;) //调用方式一，this is Hello groovy clouser(&quot;this is&quot;) //调用方式二，this is Hello groovy 隐式的it参数,不需要定义参数 def clouser = &#123;println &quot;Hello $&#123;it&#125;&quot;&#125; clouser(&quot;groovy&quot;) //Hello groovy 返回值 def clouser = &#123;String name -&gt; return &quot;Hello $&#123;name&#125;&quot;&#125; println clouser(&quot;groovy&quot;) //Hello groovy 基本类型和闭包结合使用 int x = cal(5) println x //num的阶乘 int fab(int number) &#123; int result = 1 1.upto(number, &#123; num -&gt; result *= num &#125;) return result &#125; int fab2(int number) &#123; int result = 1 number.downto(1) &#123; num -&gt; result *= num &#125; return result &#125; //累加 int cal(int number) &#123; int result = 0 number.times &#123; num -&gt; result += num &#125; return result &#125; 字符串和闭包结合使用 String str = &apos;2 and 3 is 5&apos; //each遍历 str.each &#123; // String temp -&gt; println temp.multiply(2) String temp -&gt; println temp &#125; //find查找符合条件的第一个,findAll查找所有符合条件的放到集合 println str.find&#123; String s -&gt; s.isNumber() &#125; def list = str.findAll&#123; String s -&gt; s.isNumber() &#125; println list.toListString() //[2, 3, 5] def result = str.any &#123; String s -&gt; s.isNumber() //有一项是数字就返回true &#125; println result //true println str.every &#123; //false String s -&gt; s.isNumber() //每一项都是数字就返回true &#125; def list2 = str.collect&#123; it.toUpperCase() &#125; println list2.toListString() //[2, , A, N, D, , 3, , I, S, , 5] 闭包进阶 变量：this、owner、delegate def scriptClouser = &#123; println &quot;this:&quot; + this //代表闭包定义处的类 println &quot;owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;delegate:&quot; + delegate //代表任意对象，默认与owner一致 &#125; scriptClouser.call() class Person&#123;//内部类 def classClouser = &#123; println &quot;classClouser this:&quot; + this //代表闭包定义处的类 println &quot;classClouser owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;classClouser delegate:&quot; + delegate //代表任意对象，默认与owner一致 &#125; def say()&#123; def classClouser = &#123; println &quot;method classClouser this:&quot; + this //代表闭包定义处的类 println &quot;method classClouser owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;method classClouser delegate:&quot; + delegate //代表任意对象，默认与owner一致 &#125; classClouser.call() &#125; &#125; Person person = new Person() person.classClouser.call() person.say() def nextClouser = &#123; def innerClouser = &#123; println &quot;innerClouser this:&quot; + this //代表闭包定义处的类 println &quot;innerClouser owner:&quot; + owner //代表闭包定义处的类或者对象 println &quot;innerClouser delegate:&quot; + delegate //代表任意对象，默认与owner一致 &#125; innerClouser.delegate = person //修改delegate innerClouser.call() &#125; nextClouser.call() 闭包委托策略 class Student &#123; String name def pretty = &#123; &quot;My name is $&#123;name&#125;&quot; &#125; String toSting()&#123; pretty.call() &#125; &#125; class Teacher &#123; String name &#125; def stu = new Student(name: &apos;Sarash&apos;) def tea = new Teacher(name: &apos;Qndroid&apos;) stu.pretty.delegate = tea stu.pretty.resolveStrategy = Closure.DELEGATE_FIRST//delegate优先 println stu.toSting() //My name is Qndroid 2.3、列表list数组和列表定义方式 def array = [1, 2, 3, 4, 5, 6] as int[] int[] array2 = [1, 2, 3, 4, 5, 6] def list = [1, 2, 3, 4, 5, 6] 主要介绍特有的 //排序 def sortList = [1, -4, 5, -6, 2, 3] //Collections.sort(sortList) //println sortList //[-6, -4, 1, 2, 3, 5] sortList.sort() println sortList //[-6, -4, 1, 2, 3, 5] //自定义排序 //Comparator mc = &#123; a, b -&gt; // a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 //&#125; //Collections.sort(sortList, mc) //println sortList //[1, 2, 3, -4, 5, -6] sortList.sort &#123; a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 &#125; println sortList //[1, 2, 3, -4, 5, -6] //字符串排序 def sortStringList = [&apos;123&apos;, &apos;a&apos;, &apos;groovy&apos;] sortStringList.sort &#123; it -&gt; return it.size() &#125; println sortStringList //[a, 123, groovy] //查找 def findList = [-3, 8, -8, 12, 4, 7] int result = findList.find &#123; return it % 2 == 0 &#125; println result //8 def result2 = findList.findAll &#123; return it % 2 == 0 &#125; println result2.toListString() //[8, -8, 12, 4] def result3 = findList.any &#123; return it % 2 != 0 &#125; println result3 //true def result4 = findList.every &#123; return it % 2 != 0 &#125; println result4 //false println findList.min() //-8 println findList.max() //12 def num = findList.count &#123; return it % 2 == 0 &#125; //符合条件的个数 println num //4 2.4、映射map定义和基本操作 def colors = [red: &apos;ff0000&apos;, green: &apos;00ff00&apos;, blue: &apos;0000ff&apos;] println colors.getClass() //class java.util.LinkedHashMap //索引 println colors[&apos;red&apos;] //ff0000 println colors.red //ff0000 //添加 colors.yellow = &apos;ffff00&apos; println colors.toMapString() //[red:ff0000, green:00ff00, blue:0000ff, yellow:ffff00] 其他操作 def students = [ 1: [number: &apos;0001&apos;, name: &apos;zhang&apos;, score: 55, sex: &apos;male&apos;], 2: [number: &apos;0002&apos;, name: &apos;li&apos;, score: 62, sex: &apos;female&apos;], 3: [number: &apos;0003&apos;, name: &apos;wang&apos;, score: 63, sex: &apos;female&apos;], 4: [number: &apos;0004&apos;, name: &apos;zhao&apos;, score: 66, sex: &apos;male&apos;] ] //遍历 students.each &#123; def student -&gt; println student.key + &quot;:&quot; + student.value &#125; //带索引 students.eachWithIndex &#123; def student, int index -&gt; println index + &apos;::&apos; + student.key + &quot;:&quot; + student.value &#125; //直接遍历 students.each &#123; key, value -&gt; println key + &quot;:&quot; + value &#125; students.eachWithIndex &#123; key, value, index -&gt; println index + &apos;:::&apos; + key + &quot;:&quot; + value &#125; //查找 def entry = students.find &#123; def student -&gt; return student.value.score &gt;= 60 &#125; println entry //2=&#123;number=0002, name=li, score=62, sex=female&#125; def entry2 = students.findAll &#123; def student -&gt; return student.value.score &gt;= 60 &#125; println entry2 //计数 def count = students.count &#123; def student -&gt; return student.value.score &gt;= 60 &amp;&amp; student.value.sex == &apos;male&apos; &#125; println count //1 //查找并筛选 def names = students.findAll &#123; def student -&gt; return student.value.score &gt;= 60 &#125;.collect &#123; return it.value.name &#125; println names //[li, wang, zhao] //分组 def group = students.groupBy &#123; def student -&gt; return student.value.score &gt;= 60 ? &apos;及格&apos; : &apos;不及格&apos; &#125; println group.toMapString() //排序 def sort = students.sort&#123; def stu1 ,def stu2-&gt; Number num1 = stu1.value.score Number num2 = stu2.value.score return num1 == num2 ? 0 : num1 &lt; num2 ? -1 : 1 &#125; println sort.toMapString() 2.5、范围range定义和使用 def range = 1..10 println range[0] //1 println range.contains(10) //true println range.from //1 println range.to //10 //遍历 range.each &#123; println it &#125; //switch中使用 def result = getGrade(75) println result def getGrade(Number number)&#123; def result switch (number)&#123; case 0..&lt;60: result = &apos;不及格&apos; break case 60..&lt;70: result = &apos;及格&apos; break case 70..&lt;80: result = &apos;良好&apos; break case 80..100: result = &apos;优秀&apos; break &#125; return result &#125; 2.6、面向对象类、方法、接口 //groovy中默认都是public类型 class Person implements Action&#123; String name Integer age def increasseAge(Integer years) &#123; this.age += years &#125; @Override void eat() &#123;&#125; @Override void drink() &#123;&#125; @Override void play() &#123;&#125; &#125; def person = new Person(name: &quot;zhang&quot;, age: 26) println &quot;name:$&#123;person.name&#125;,age:$&#123;person.age&#125;&quot;//name:zhang,age:26 person.increasseAge(10) println &quot;name:$&#123;person.name&#125;,age:$&#123;person.age&#125;&quot;//name:zhang,age:36 interface Action&#123; void eat() void drink() void play() &#125; trait DefaultAction&#123; abstract void eat() void play()&#123; println &apos;i can play&apos; &#125; &#125; 元编程 class Person &#123; String name Integer age def increasseAge(Integer years) &#123; this.age += years &#125; //一个方法找不到时候，用它代替 def invokeMethod(String name, Object args) &#123; return &quot;invokeMethod: $&#123;name&#125;,$&#123;args&#125;&quot; &#125; //优先级高于invokeMethod def methodMissing(String name, Object args) &#123; return &quot;methodMissing: $&#123;name&#125;,$&#123;args&#125;&quot; &#125; &#125; def person = new Person(name: &apos;zhang&apos;, age: 26) println person.cry() //为类动态添加属性 Person.metaClass.sex = &apos;male&apos; def person1 = new Person(name: &apos;zhang&apos;, age: 26) println person1.sex //male //为类动态添加方法 Person.metaClass.sexUpperCase = &#123; -&gt; sex.toUpperCase() &#125; def personn2 = new Person(name: &apos;zhang&apos;, age: 26) println personn2.sexUpperCase() //MALE //添加静态方法 Person.metaClass.static.createPerson = &#123; String name, int age -&gt; new Person(name: name, age: age) &#125; def personn3 = Person.createPerson(&apos;li&apos;, 18) println personn3.name + personn3.age //li18 一次注入，应用程序其他方法都可以使用 ExpandoMetaClass.enableGlobally() 3、高级用法3.1、json文件处理转换成json import groovy.json.JsonOutput import groovy.json.JsonSlurper class Person &#123; String name Integer age &#125; //转换成Json def list = [new Person(name: &apos;zhang&apos;, age: 26), new Person(name: &apos;li&apos;, age: 22)] def json = JsonOutput.toJson(list) println JsonOutput.prettyPrint(json) //转成实体对象 def jsonSlpuer = new JsonSlurper() jsonSlpuer.parseText() get请求 import groovy.json.JsonSlurper def response = getNetworkData(&quot;http://httpbin.org/get?id=123&quot;) println response.args.id def getNetworkData(String url)&#123; def connection = new URL(url).openConnection() connection.setRequestMethod(&apos;GET&apos;) connection.connect() def response = connection.content.text def jsonSlurper = new JsonSlurper() return jsonSlurper.parseText(response) &#125; 3.2、xml读取和生成解析xml格式数据，创建xml格式数据，都不再详解 3.3、文件操作读取文件 def file = new File(&quot;目标文件&quot;) //方式一 file.eachLine &#123; line -&gt; println line &#125; //方式二 def text = file.getText() println text //方式三 def result = file.readLines() println result //方式四,读取部分内容 def reader = file.withReader &#123; reader -&gt; char[] buffer = new char[100] reader.read(buffer) return buffer &#125; println reader 拷贝文件 def copy(String sourcePath, String destationPath) &#123; try &#123; def desFile = new File(destationPath) if (!desFile.exists()) &#123; desFile.createNewFile() &#125; new File(sourcePath).withReader &#123; reader -&gt; def lines = reader.readLines() desFile.withWriter &#123; writer -&gt; lines.each &#123; line -&gt; writer.append(line + &quot;\\r\\n&quot;) &#125; &#125; &#125; return true &#125; catch (Exception e) &#123; &#125; &#125; 对象的读写 def saveObject(Object object, String path) &#123; try &#123; def desFile = new File(path) if (!desFile.exists()) &#123; desFile.createNewFile() &#125; desFile.withObjectOutputStream &#123; out -&gt; out.writeObject(object) &#125; return true &#125; catch (Exception e) &#123; &#125; return false &#125; def readObject(String path) &#123; def obj = null try &#123; def file = new File(path) if (file == null || !file.exists()) return null file.withObjectInputStream &#123; input -&gt; obj = input.readObject() &#125; &#125; catch (Exception e) &#123; &#125; return obj &#125; 4、Gradle介绍Gradle用于构建应用程序，使用Groovy核心语法。 在Terminal中执行 gradlew clean //win gradlew build //win ./gradlew clean //mac ./gradlew build //mac gradle的生命周期 initialization初始化阶段：根据settings.gradle解析整个工程中所有的Project，构建所有的Project对应的project对象。 Configuration配置阶段：解析所有的projects对象中的task，构建好所有的task的拓扑图 Excution执行阶段：执行具体的task及其依赖task 生命周期监听 //配置阶段开始前的监听回调 this.beforeEvaluate &#123; println &apos;------配置阶段开始------&apos; &#125; //配置阶段完成以后的监听回调 this.afterEvaluate &#123; println &apos;------配置阶段完成------&apos; &#125; //gradle执行完毕后的回调监听 this.gradle.buildFinished &#123; println &apos;------gradle执行完毕------&apos; &#125; //等同beforeEvaluate this.gradle.beforeProject &#123;&#125; //等同afterEvaluate this.gradle.afterProject &#123;&#125; 5、Project查看Project的个数 gradlew projects ./gradlew projects //mac 5.1、Project相关API在最外层的根的build.gradle中 this.getProjects() def getProjects()&#123; //只输全部projects this.getAllprojects().eachWithIndex &#123; Project project, int index -&gt; if (index ==0)&#123; println &quot;this is Root project:$&#123;project.name&#125;&quot; &#125; else &#123; println &quot;this is project:$&#123;project.name&#125;&quot; &#125; &#125; //只输出子projects this.getSubprojects().eachWithIndex &#123; Project project, int index -&gt; println &quot;this is project:$&#123;project.name&#125;&quot; &#125; //只输出根projects println &quot;this is Root project:&quot; + this.getRootProject().name &#125; 在module的build.gradle中 //只输出父projects println &quot;this is parent project:&quot; + this.getParent().name 根project中可以配置module的配置 //根project配置module为app的配置 project(&apos;app&apos;) &#123; Project project -&gt; println project.name //app apply plugin: &apos;com.android.application&apos; group &apos;com.tea&apos; version &apos;1.0.0-release&apos; dependencies &#123;&#125; android &#123;&#125; &#125; 配置当前节点工程和subproject的所有project //配置当前节点工程和subproject的所有project allprojects &#123; group &apos;com.tea&apos; version &apos;1.0.0-release&apos; &#125; println project(&apos;app&apos;).group 不包括当前节点工程，只包括他的subproject //不包括当前节点工程，只包括他的subproject subprojects &#123; Project project -&gt; if (project.plugins.hasPlugin(&apos;com.android.library&apos;)) &#123; apply from: &apos;../publistTOMaven.gradle&apos; &#125; &#125; 5.2、属性相关API定义扩展属性 ext&#123;&#125; 所以提供扩展属性定义方式: 方式一： 可以在根build中定义 ext &#123; compileSdkVersion = 28 cardview = &apos;com.android.support:cardview-v7:28.0.0&apos; &#125; 然后在需要用的build中引用 compileSdkVersion this.rootProject.compileSdkVersion implementation this.cardview 方式二： 和根build同级定义common.gradle ext &#123; android = [compileSdkVersion: 28, buildToolsVersion: &apos;26.0.0&apos;, applicationId : &apos;com.tea&apos;, minSdkVersion : 16, targetSdkVersion : 26, versionCode : 1, versionName : &apos;1.0.0&apos;, multiDexEnabled : true] signConfigs = [&apos;storeFile&apos; : &apos;tea.jks&apos;, &apos;storePassword&apos;: &apos;tea123456&apos;, &apos;keyAlias&apos; : &apos;android&apos;, &apos;keyPassword&apos; : &apos;tea123456&apos;] java = [&apos;javaVersion&apos;: JavaVersion.VERSION_1_8] dependence = [&apos;libCardview&apos; : &apos;com.android.support:cardview-v7:28.0.0&apos;, &apos;libAppcompat&apos;: &apos;com.android.support:appcompat-v7:28.0.0&apos;] &#125; 在根build中引入 apply from: this.file(&apos;common.gradle&apos;) 在需要的build中使用 compileSdkVersion rootProject.ext.android.compileSdkVersion implementation rootProject.ext.dependence.libCardview 方式三： 在gradle.properties中定义key:value形式 mCompileSdkVersion = 28 build中使用，默认都是字符串，需要转换 compileSdkVersion mCompileSdkVersion.toInteger() 5.3、file相关API文件路径获取 println getRootDir().absolutePath println getBuildDir().absolutePath println getProjectDir().absolutePath 文件定位 apply from: this.file(&apos;common.gradle&apos;) println getContent(&apos;common.gradle&apos;) def getContent(String path)&#123; try &#123; //路径是相对于当前project查找 def file = file(path) return file.text &#125;catch (GradleException e)&#123; println &quot;not found&quot; &#125; return null &#125; 文件拷贝,在app的build中拷贝文件或者文件夹 copy &#123; from file(&apos;build/outputs/apk/&apos;) into getRootProject().getBuildDir().path + &apos;/apk/&apos; exclude &#123;&#125;//补拷贝的文件 rename &#123;&#125;//重命名 &#125; 文件树 fileTree(&apos;src/main/assets/&apos;)&#123;FileTree fileTree -&gt; fileTree.visit &#123;FileTreeElement element -&gt; println element.file.name copy &#123; from element.file into getRootProject().getBuildDir().path + &apos;/test/&apos; &#125; &#125; &#125; 5.4、依赖相关API依赖 buildscript &#123; //配置工程的仓库地址 repositories &#123; &#125; //配置工程的gradle插件依赖地址，app中的是项目的第三库依赖 dependencies &#123; &#125; &#125; 依赖冲突常用解决办法 compile (&apos;rootProject.ext.dependence.libAutoScrollViewPager&apos;) &#123; exclude module: &apos;support-v4&apos;//排除依赖 exclude group: &apos;com.android.support&apos; transitive false//禁止传递依赖 &#125; provided只在编译起作用，占位编译。 5.5、外部命令API调用系统指令，执行./gradlew apkcopy task(name: &apos;apkcopy&apos;) &#123; doLast &#123; def srcPath = this.buildDir.path + &apos;/outputs/apk&apos; def destPath = &apos;./target/apk&apos; def command = &quot;mv -f $&#123;srcPath&#125; $&#123;destPath&#125;&quot; exec &#123; try &#123; executable &apos;bash&apos; args &apos;-c&apos;, command println &apos;this command exec success&apos; &#125;catch(GradleException e)&#123; println &apos;this command exec error&apos; &#125; &#125; &#125; &#125; 调用脚本 task stopTomcat(type:Exec) &#123; //dir workingDir &apos;../tomcat/bin&apos; //windows commandLine &apos;cmd&apos;, &apos;/c&apos;, &apos;stop.bat&apos; //linux commandLine &apos;./stop.sh&apos; &#125; 6、task两种定义方式task helloTask (group: &apos;com.tea&apos;,description: &apos;study&apos;)&#123; println &apos;---------helloTask&apos; &#125; this.tasks.create(name : &apos;helloTask2&apos;)&#123; setGroup(&apos;com.tea&apos;) setDescription(&apos;study&apos;) println &apos;---------helloTask2&apos; &#125; doFirst和doLasttask helloTask (group: &apos;com.tea&apos;,description: &apos;study&apos;)&#123; println &apos;---------helloTask&apos; doFirst &#123; println &apos;---------helloTask---doFirst&apos; &#125; &#125; helloTask.doFirst&#123; println &apos;---------helloTask---doFirst2&apos;//比闭包的先执行 &#125; 统计Build时长def startTime,endTime this.afterEvaluate &#123;Project project -&gt; def preBuildTask = project.tasks.getByName(&apos;preBuild&apos;) preBuildTask.doFirst &#123; startTime = System.currentTimeMillis() println &quot;==============:&quot; + startTime &#125; def buildTask = project.tasks.getByName(&apos;build&apos;) buildTask.doLast &#123; endTime = System.currentTimeMillis() println &quot;==============:&quot; + endTime println &quot;==============:&quot; + (endTime - startTime) &#125; &#125; 依赖task taskX &#123; doLast &#123; println &quot;taskX&quot; &#125; &#125; task taskY &#123; doLast &#123; println &quot;taskY&quot; &#125; &#125; //动态依赖 task taskZ &#123; dependsOn this.tasks.findAll &#123; task -&gt; println task.name return task.name.startsWith(&apos;taskX&apos;) &#125; doLast &#123; println &quot;taskZ&quot; &#125; &#125; //静态依赖 task taskZ(dependsOn: [taskX, taskY]) &#123; dependsOn this.tasks.findAll &#123; task -&gt; return task.name.startsWith(&apos;lib&apos;) &#125; doLast &#123; println &quot;taskZ&quot; &#125; &#125; //或者 taskZ.dependsOn(taskX, taskY) 输入输出task writeTask&#123; //输入 inputs.property(&quot;key&quot;,&quot;value&quot;) def data = inputs.getProperties() //输出 outputs.file 文件 File file = outputs.getFiles().getSingleFile() &#125; 执行顺序指定mustRunAfter 7、其他模块7.1、SourceSet修改资源路径 sourceSets &#123; main&#123; jniLibs.srcDirs = [&apos;libs&apos;]//修改so库文件位置 &#125; &#125; 给res分模块分包 sourceSets &#123; main&#123; res.srcDirs = [&apos;src/main/res&apos;, &apos;src/main/res-ad&apos;, &apos;src/main/res-tea&apos;] &#125; &#125; 7.2、自定义plugin main下的java替换成groovy，新建.groovy类： class GradleStudyPlugin implements Plugin&lt;Project&gt;&#123; @Override void apply (Project project)&#123; project.extensions.create(&apos;comTea&apos;,xxx（groovy类）) &#125; &#125; 自定义task的类 class xxxxx extend DefaultTask&#123; @TaskAction void doAction()&#123; //执行于gradle执行阶段的代码 &#125; &#125; main/resources/META-INF.gradle/包名.properties: implementation-class=包名.类名 build.gradle为： apply plugin: &apos;groovy&apos; sourceSets &#123; main&#123; groovy &#123; srcDir &apos;src/main/groovy&apos; &#125; resources &#123; srcDir &apos;src/main/resources&apos; &#125; &#125; &#125; 引用和传参 apply plugin: &apos;包名&apos; comTea&#123; //传参 &#125; 7.3、修改apk名字app的build中 this.afterEvaluate &#123; this.android.applicationVariants.all &#123; variant -&gt; def output = variant.outputs.first() def apkName = &quot;app-$&#123;variant.baseName&#125;&quot; + &quot;-$&#123;variant.versionName&#125;.apk&quot; output.outputFile = new File(output.outputFile.parent,apkName) println &quot;------------------&quot; &#125; &#125; 8、Jenkinsjava -jar jenkins.war Android实战应用buildTypes和productFlavors 和main同级别，同包名，创建文件，区别使用debug还是release。可以用来实现类似gradle调用java类。 implementation implementation：不会传递依赖；compile / api：会传递依赖；api 是 compile 的替代品。当依赖被传递时，二级依赖的改动会导致0级项目重新编译；当依赖不传递时，二级依赖的改动不会导致 0 级项目重新编译。 plugin android&#123;&#125;的内容就是对apply plugin: &#39;com.android.application&#39;的配置。 参考上述7.2、自定义plugin。 新建Module-Java Library-buildSrc模块 创建目录\\buildSrc\\src\\main\\resources\\META-INF\\gradle-plugins，创建文件xxx.properties implementation-class=com.plugin.demo.PluginDemo 目录buildSrc\\src\\main\\groovy\\com\\plugin\\demo创建文件PluginDemo.groovy import com.android.build.gradle.BaseExtension import org.gradle.api.Plugin import org.gradle.api.Project public class PluginDemo implements Plugin&lt;Project&gt; &#123; @Override public void apply(Project project) &#123; def extension = project.extensions.create(&apos;yyyy&apos;, ExtensionDemo) project.afterEvaluate &#123; println &quot;Hello $&#123;extension.name&#125;!&quot;//Hello zzzzz &#125; //def transform = new TransformDemo() //def baseExtension = project.extensions.getByType(BaseExtension) //baseExtension.registerTransform(transform) &#125; &#125; 创建文件ExtensionDemo.groovy public class ExtensionDemo &#123; def name = &quot;Author&quot;; &#125; 在app的build中使用plugin apply plugin: &apos;xxx&apos; yyyy &#123; name &apos;zzzzz&apos; &#125; 关于 buildSrc 目录：这是 gradle 的一个特殊目录，这个目录的 build.gradle 会自动被执行，即使不配配置进settings.gradle。buildSrc 的执行早于任何一个 project，也早于 settings.gradle。它是一个独立的存在。 buildSrc 所配置出来的 Plugin 会被自动添加到编译过程中的每一个 project 的 classpath，因此它们才可以直接使用 apply plugin: &#39;xxx&#39;的方式来便捷应用这些 plugin。 settings.gradle 中如果配置了 ‘:buildSrc’ ，buildSrc 目录就会被当做是子 Project ，因此会被执行两遍。所以在 settings.gradle 里面应该删掉 :buildSrc 的配置。 Transform Transform是由 Android 提供的，在项目构建过程中把编译后的文件（jar文件和 class文件）添加自定义的中间处理过程的工具。下面代码只是把编译完的内容原封不动搬运到目标位置，没有实际用处。要修改字节码，需要引入其他工具，例如 javassist。 新建TransformDemo.groovy import com.android.build.api.transform.Format import com.android.build.api.transform.QualifiedContent import com.android.build.api.transform.Transform import com.android.build.api.transform.TransformException import com.android.build.api.transform.TransformInvocation import com.android.build.gradle.internal.pipeline.TransformManager import com.android.utils.FileUtils; public class TransformDemo extends Transform &#123; @Override String getName() &#123; return &quot;hencoderTransform&quot; &#125; @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; @Override Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.SCOPE_FULL_PROJECT &#125; @Override boolean isIncremental() &#123; return false &#125; @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; def inputs = transformInvocation.inputs def outputProvider = transformInvocation.outputProvider inputs.each &#123; it.jarInputs.each &#123; File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.JAR) FileUtils.copyFile(it.file, dest) &#125; it.directoryInputs.each &#123; File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.DIRECTORY) FileUtils.copyDirectory(it.file, dest) &#125; &#125; &#125; &#125; buildSrc-build中改为： repositories &#123; google() jcenter() &#125; dependencies &#123; implementation &apos;com.android.tools.build:gradle:3.2.1&apos; &#125; PluginDemo.groovy中添加代码 def transform = new TransformDemo() def baseExtension = project.extensions.getByType(BaseExtension) baseExtension.registerTransform(transform) 修改app-build中的plugin放在android{}之后。 示例：https://github.com/liangzhitao/consuming-collector","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/tags/gradle/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"手写实现EventBus","slug":"28.手写实现EventBus","date":"2019-07-07T07:07:51.613Z","updated":"2021-03-26T14:40:57.619Z","comments":false,"path":"2019/07/07/28.手写实现EventBus/","link":"","permalink":"http://yoursite.com/2019/07/07/28.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0EventBus/","excerpt":"","text":"使用github地址： https://github.com/greenrobot/EventBus 引入 implementation &apos;org.greenrobot:eventbus:3.0.0&apos; 订阅和接收 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125; @Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true) public void onStringEvent(String event) &#123; Log.d(&quot;接收者&quot;, &quot;event----:&quot; + event); &#125; 发布事件 EventBus.getDefault().post(&quot;我来发布消息&quot;); 发布粘性事件 EventBus.getDefault().postSticky(&quot;我来发布消息&quot;); ThreadMode总共四个枚举项： MAIN //UI主线程 BACKGROUND //后台线程 POSTING //和发布者处在同一个线程 ASYNC //异步线程 终止事件往下传递： //优先级高的订阅者可以终止事件往下传递 EventBus.getDefault().cancelEventDelivery(event); 混淆 -keepattributes *Annotation* -keepclassmembers class * &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;; &#125; -keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125; -keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable); &#125; 源码分析第一步register第一步：EventBus.getDefault().register(this);其中getDefault()获取单例，看EventBus中register()方法： public void register(Object subscriber) &#123; //首先获得class对象 Class&lt;?&gt; subscriberClass = subscriber.getClass(); //通过findSubscriberMethods来找到订阅者订阅了哪些事件，返回一个SubscriberMethod对象的List。 //SubscriberMethod里包含了：这个对象的方法method、响应订阅的线程ThreadMode、方法参数类型eventType、订阅的优先级 priority、是否接收粘性sticky的boolean值。 //其实就是解析这个类上的所有带@Subscriber注解的方法的属性。 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; // 订阅，第二步分析 subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 看SubscriberMethodFinder类中findSubscriberMethods(Class&lt;?&gt; subscriberClass)方法： List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; // 先从缓存里面读取，订阅者的Class List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; // ignoreGeneratedIndex属性表示是否忽略注解器生成的MyEventBusIndex。 // 支持编译时注解的方式，需要引入eventbus的apt，ignoreGeneratedIndex的默认值为false，可以通过EventBusBuilder来设置它的值 if (ignoreGeneratedIndex) &#123; // 利用反射来获取订阅类中所有订阅方法信息 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; // 从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 会走到SubscriberMethodFinder类中findUsingInfo(Class&lt;?&gt; subscriberClass)方法： private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; // FindState涉及到享元设计模式 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //默认是空，除非用了编译时注解 findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //走到这里，通过反射去找 findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass(); &#125; // 释放 findState 享元模式 return getMethodsAndRelease(findState); &#125; 走到SubscriberMethodFinder类中findUsingReflectionInSingleClass(FindState findState)方法： //找方法的核心代码 private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // 通过反射来获取订阅类的所有方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; //for循环所有方法 for (Method method : methods) &#123; // 获取方法访问修饰符 int modifiers = method.getModifiers(); //找到所有声明为public的方法 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //获取参数的的Class Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //只允许包含一个参数 if (parameterTypes.length == 1) &#123; //Subscribe注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //获取事件的Class ，也就是方法参数的Class Class&lt;?&gt; eventType = parameterTypes[0]; // 检测添加 if (findState.checkAdd(method, eventType)) &#123; //获取ThreadMode ThreadMode threadMode = subscribeAnnotation.threadMode(); // 往集合里面添加 SubscriberMethod ，解析方法注解所有的属性 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; 第一步总结：register()方法中调用findSubscriberMethods()，去解析注册者对象的所有方法，找出public方法，并且带有@Subscribe注解、并且参数只有一个，的方法，然后通过Annotation解析所有细节参数threadMode(线程)、priority(优先级)、sticky(是否粘性)、method(方法名)、eventType(方法参数类型)，把这些参数封装成一个SubscriberMethod对象，添加到集合返回。 第二步registerEventBus中register()方法调用了subscribe(subscriber, subscriberMethod);其中subscriber就是register(this)中的this，subscriberMethod就是第一步中的集合遍历的元素对象。 EventBus中subscribe(Object subscriber, SubscriberMethod subscriberMethod)方法: private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; // 获取方法参数的class Class&lt;?&gt; eventType = subscriberMethod.eventType; // 创建一个 Subscription，subscribe方法的参数传给了Subscription Subscription newSubscription = new Subscription(subscriber, subscriberMethod); // 获取订阅了此事件类的所有订阅者信息列表,下面有分析subscriptionsByEventType CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; // 线程安全的 ArrayList subscriptions = new CopyOnWriteArrayList&lt;&gt;(); // 添加 subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; // 是否包含，如果包含再次添加抛异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; // 处理优先级priority int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; // 通过 subscriber 获取 List&lt;Class&lt;?&gt;&gt;，下面有分析typesBySubscriber List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; // 将此事件类加入 订阅者事件类列表中 subscribedEvents.add(eventType); // 处理粘性事件 if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 查看subscriptionsByEventType，是EventBus的一个Map成员变量，可以根据EventType查找订阅事件 // key 是注解方法参数的class(eventType)，value 存放的是Subscription的线程安全的集合列表 //Subscription 包含两个属性，一个是subscriber 订阅者（this），一个是SubscriberMethod注解方法的所有属性参数值（SubscriberMethod） private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; 查看typesBySubscriber，是EventBus的一个Map成员变量，根据我们的订阅对象找到EventType。 // key 是所有的订阅者(this)，value 是所有订阅者里面方法的参数的class的集合 private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; 粘性事件stickyEvents:是ConcurrentHashMap集合,粘性事件的缓存。 第二步总结：register()方法中调用subscribe方法，解析所有SubscriberMethod的eventType，然后按照要求解析成Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType和Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber。 第三步post查看EventBus中post方法： public void post(Object event) &#123; // currentPostingThreadState是一个 ThreadLocal，他的特点是获取当前线程一份独有的变量数据，不受其他线程影响。 PostingThreadState postingState = currentPostingThreadState.get(); // postingState 就是获取到的线程独有的变量数据 List&lt;Object&gt; eventQueue = postingState.eventQueue; // 把post的事件添加到事件队列 eventQueue.add(event); // 如果没有处在事件发布状态，那么开始发送事件并一直保持发布状态 if (!postingState.isPosting) &#123; //是否是主线程 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); //isPosting = true postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; //走到这里，下面有分析 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125; &#125;; 查看EventBus中postSingleEvent方法： //参数event是post的对象 private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; //得到事件的Class Class&lt;?&gt; eventClass = event.getClass(); //是否找到订阅者 boolean subscriptionFound = false; //如果支持事件继承，默认为支持 if (eventInheritance) &#123; //查找 eventClass 的所有父类和接口 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); // 依次向 eventClass 的父类或接口的订阅方法发送事件 // 只要有一个事件发送成功，返回 true ，那么 subscriptionFound 就为 true，下面有分析 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; // 发送事件 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; // 如果没有订阅者 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; 查看EventBus中postSingleEventForEventType方法： //event是post的对象，eventClass是post的对象的class private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; // subscriptionsByEventType是第二步中的map，得到Subscription集合List subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; // 遍历subscriptions for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; // 发送事件，下面分析 postToSubscription(subscription, event, postingState.isMainThread); // 是否被取消了 aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; // 如果被取消，则跳出循环 if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 查看EventBus中postToSubscription方法： private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; // 根据不同的线程模式执行对应 switch (subscription.subscriberMethod.threadMode) &#123; // 和发送事件处于同一个线程 case POSTING: invokeSubscriber(subscription, event); break; // 主线程 case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; // 子线程，如果发布事件的线程是主线程，那么调用线程池中的子线程来执行订阅方法；否则直接执行； case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; // 异步线程：无论发布事件执行在主线程还是子线程，都利用一个异步线程来执行订阅方法 case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125; &#125; 第三步总结：post()方法中去遍历了subscriptionsByEventType，找到符合的方法,调用方法的method.invoke()执行。 第四步unregisterunregister就是移除。查看EventBus中unregister方法： public synchronized void unregister(Object subscriber) &#123; // 获取订阅对象的所有订阅事件类列表,第二步中的map List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; // 将订阅者的订阅信息移除，下面分析 unsubscribeByEventType(subscriber, eventType); &#125; // 将订阅者从列表中移除 typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); &#125; &#125; 查看EventBus中unsubscribeByEventType方法： private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; // 获取事件类的所有订阅信息列表，将订阅信息从订阅信息集合中移除，同时将订阅信息中的active属性置为FALSE,第二步中的map List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; // 将订阅信息激活状态置为FALSE subscription.active = false; // 将订阅信息从集合中移除 subscriptions.remove(i); i--; size--; &#125; &#125; &#125; &#125; 手写实现https://github.com/AdamRight/TeaTool/blob/master/app/src/main/java/com/tea/teatool/teaeventbus","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RecyclerView","slug":"27.RecyclerView","date":"2019-07-01T14:22:32.257Z","updated":"2021-03-26T14:40:53.881Z","comments":false,"path":"2019/07/01/27.RecyclerView/","link":"","permalink":"http://yoursite.com/2019/07/01/27.RecyclerView/","excerpt":"","text":"1、基本使用和封装布局、点击、分割线、多类型条目使用。 1.1、基本使用点我跳转 1.2、基本封装点我跳转 1.3、多类型条目点我跳转 1.4、添加头部和底部点我跳转 2、分割线2.1、条目相关设置分割线类中的getItemOffsets方法中 //获取条目View在RecyclerView中的第几个位置：0、1、2、3... int currentPosition = ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewLayoutPosition(); //获取条目的总个数 int itemCount = parent.getAdapter().getItemCount(); //GridLayoutManager时候，获取列数 RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; int spanCount = gridLayoutManager.getSpanCount(); &#125; 其他实例化View的3种方式View.inflate(mContext, mLayoutId, null); LayoutInflater.from(mContext).inflate(mLayoutId, parent); LayoutInflater.from(mContext).inflate(mLayoutId, parent, false);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"手写实现Butterknife","slug":"26.手写实现Butterknife","date":"2019-06-29T04:21:42.594Z","updated":"2021-03-26T14:40:49.752Z","comments":false,"path":"2019/06/29/26.手写实现Butterknife/","link":"","permalink":"http://yoursite.com/2019/06/29/26.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Butterknife/","excerpt":"","text":"介绍Butterknife源码地址 https://github.com/JakeWharton/butterknife 引入 implementation &apos;com.jakewharton:butterknife:8.5.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.5.1&apos; 主要是解决掉findViewById、setOnclick 、资源的注入等。反射造成大量的临时文件，造成gc，影响性能。而Butterknife采用编译时注解，即用APT mirror生成代码。 ButterKnife的工作原理: 声明的注解的生命周期为CLASS。继承AbstractProcessor类，再调用AbstractProcessor的process方法。 编译的时候扫描注解，调用javapoet库，生成java代码。 调用ButterKnife.bind(this);方法的时候，将ID与对应的上下文绑定在一起。 思路发现编译后生成类名_ViewBinding，那么我们手动实现Butterknife，先写下伪代码： 新建类名_ViewBinding： public class ButterknifeActivity_ViewBinding &#123; private ButterknifeActivity target; @UiThread public ButterknifeActivity_ViewBinding(ButterknifeActivity target) &#123; this.target = target; target.textView = target.findViewById(R.id.tv); &#125; @CallSuper public void unbind() &#123; ButterknifeActivity target = this.target; if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;); this.target = null; target.textView = null; &#125; &#125; 在Activity中不需要再findViewById： public class ButterknifeActivity extends AppCompatActivity &#123; public TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_butterknife); ButterknifeActivity_ViewBinding viewBinding = new ButterknifeActivity_ViewBinding(this); textView.setText(&quot;我是伪代码&quot;); &#125; &#125; 所以，我们的思路就是用APT实现伪代码，就实现了手写Butterknife。 实现前奏新建Module-Library Android Library:butterknife Java Library:butterknife-annotations(运行时的注解)和butterknife-compiler(编译，生成代码) 配置 app的build中引入 implementation project(&apos;:butterknife-annotations&apos;) implementation project(&apos;:butterknife&apos;) annotationProcessor project(&apos;:butterknife-compiler&apos;) butterknife-compiler中引入 implementation &apos;com.google.auto.service:auto-service:1.0-rc3&apos;//注解 implementation &apos;com.squareup:javapoet:1.8.0&apos;//生成代码文件 implementation project(&apos;:butterknife-annotations&apos;)//依赖butterknife-annotations 注解处理器是（Annotation Processor）是javac的一个工具，用来在编译时扫描和编译和处理注解（Annotation）。在编译时把标记了注解的类，变量等作为输入内容，经过注解处理器处理，生成想要生成的java代码。处理器都是继承于AbstractProcessor。 APT(Annotation Processing Tool)是一种处理注解的工具,它对源代码文件进行检测找出其中的Annotation，根据注解自动生成代码。 注解处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 @AutoService(Processor.class) public class ButterKnifeProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; //先进init &#125; //用来指定支持的 SourceVersion @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; //用来指定支持的 AnnotationTypes @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123; types.add(annotation.getCanonicalName()); &#125; return types; &#125; //绑定哪些注解 private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindView.class); return annotations; &#125; //编译时候执行,核心方法，有注解就都会进来这个方法，可以扫描，处理注解等，并且可以生成java代码。 @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; return false; &#125; &#125; APT流程：编译开始 → 拿到元素(添加指定的注解元素) → 处理分解元素以及注解信息 → 通过JAVAPOET拼装生成Java文件 → 交给编译器。 AbstractProcessor中的init方法中的参数ProcessingEnvironment public interface ProcessingEnvironment &#123; Map&lt;String, String&gt; getOptions(); Messager getMessager(); Filer getFiler(); Elements getElementUtils(); Types getTypeUtils(); SourceVersion getSourceVersion(); Locale getLocale(); &#125; ProcessingEnvironment提供了一些工具类，Filer用于创建文件，Elements获取所有源文件元素，Types获取源代码类型信息。 反射唯一使用反射的地方： 不在class中写入 Class_ViewBinding viewBinding = new Class_ViewBinding(this); 而是通过 ButterKnife.bind(this)//中对Class_ViewBinding进行有参构造反射 实现生成的类在/build/generated/source/apt/base/包名/ClassName_ViewBinding类。 代码 https://github.com/AdamRight/TeaTool/tree/master/app/src/main/java/com/tea/teatool/teabutterknife https://github.com/AdamRight/TeaTool","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"handler源码分析及手写handler","slug":"24.handler源码分析及手写handler","date":"2019-06-11T13:20:32.691Z","updated":"2021-03-26T14:40:45.513Z","comments":false,"path":"2019/06/11/24.handler源码分析及手写handler/","link":"","permalink":"http://yoursite.com/2019/06/11/24.handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%89%8B%E5%86%99handler/","excerpt":"","text":"小实例private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); System.out.println(msg.what); &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; //进行耗时操作后 Message message = Message.obtain(); message.what = 1; mHandler.sendMessage(message); &#125; &#125;).start(); &#125; 在子线程中，进行耗时操作，执行完操作后，发送消息，通知主线程更新UI。 子线程中创建handler如果在子线程中创建handler： new Thread()&#123; @Override public void run() &#123; Handler handler = new Handler(); &#125; &#125;.start(); 代码运行报错： java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare() 可以修改为： new Thread()&#123; @Override public void run() &#123; Looper.prepare(); Handler handler = new Handler(); Looper.loop(); &#125; &#125;.start(); 在主线程中不需要，究其原因，在ActivityThread的main()方法中： ... Looper.prepareMainLooper();//准备循环 ... Looper.loop();//循环 .... 其中prepareMainLooper()方法会调用prepare(false)方法。 源码流程分析分析源码的思路,就是小实例中,从子线程调用mHandler.sendMessage(message);到主线程更新数据执行handleMessage(Message msg)方法的流程。 第一步sendMessage到MessageQueue:Handler.sendMessage → Handler.sendMessageDelayed → Handler.sendMessageAtTime → MessageQueue.enqueueMessage。 Handler中sendMessageAtTime()方法 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; //其中mQueue是消息队列，从Looper中获取的 MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; //调用enqueueMessage方法 return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //注意此处的msg.target就是当前的Handler，Looper中的loop会使用。 msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); &#125; 可以看到sendMessageAtTime()方法的作用很简单，就是调用MessageQueue的enqueueMessage()方法，往消息队列中添加一个消息。 知识扩展：在子线程中通过Handler的post()方式或send()方式发送消息，最终都是调用了sendMessageAtTime()方法。子线程中调用Activity中的runOnUiThread()中更新UI，其实也是发送消息通知主线程更新UI，最终也会调用sendMessageAtTime()方法。 MessageQueue中enqueueMessage()方法 boolean enqueueMessage(Message msg, long when) &#123; // 每一个Message必须有一个target if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; //正在退出时，回收msg，加入到消息池 if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的（即第一个msg）,则进入该该分支. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; //将消息按时间顺序插入到MessageQueue。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; MessageQueue是按照Message触发时间(when)的先后顺序排列的，队头的消息是最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。MessageQueue消息队列采用链表存储Message,因为链表是增加删除快，数组是查询快 第一步总结：Handler.sendMessage是把Message加入了消息队列(MessageQueue)中，消息队列采用的是链表存储方式，按照when也就是时间排序。 第二步我们知道主线程中，已经创建了Looper，在Loop方法中消息循环调用了Handler.handleMessage。 初始化Looper无参情况下，默认调用prepare(true);表示的是这个Looper可以退出，而对于false的情况则表示当前Looper不可以退出。 Looper中 public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 调用sThreadLocal.set，在ThreadLocal中 public void set(T value) &#123; Thread t = Thread.currentThread(); //从线程中获取ThreadLocalMap ，一个线程中只有一个ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 一个线程中只有一个ThreadLocalMap，一个线程中只能创建一个Looper，ThreadLocalMap中把ThreadLocal为key，Looper为value，存储起来。其中ThreadLocal是线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。 开启Looperpublic static void loop() &#123; //获取线程中TLS存储的Looper对象 final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; //获取Looper对象中的消息队列 final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //进入loop的主循环方法，死循环 for (;;) &#123; Message msg = queue.next(); //可能会阻塞,因为next()方法可能会无限循环 if (msg == null) &#123; //消息为空，则退出循环 // No message indicates that the message queue is quitting. return; &#125; try &#123; //重点地方,获取msg的目标Handler，然后通过handler去执行Message这个时候就调用了handleMessage方法 msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; // 回收消息 msg.recycleUnchecked(); &#125; &#125; loop()进入循环模式，直到消息为空时退出循环:读取MessageQueue的下一条Message；把Message分发给相应的target。 当next()取出下一条消息时，队列中已经没有消息时，next()会无限循环，产生阻塞。等待MessageQueue中加入消息，然后重新唤醒。 Handler创建创建Handler public Handler() &#123; this(null, false); &#125; public Handler(Callback callback, boolean async) &#123; //必须先执行Looper.prepare()，才能获取Looper对象，否则为null. mLooper = Looper.myLooper(); //从当前线程的TLS中获取Looper对象 if (mLooper == null) &#123; throw new RuntimeException(&quot;&quot;); &#125; mQueue = mLooper.mQueue; //消息队列，来自Looper对象 mCallback = callback; //回调方法 mAsynchronous = async; //设置消息是否为异步处理方式 &#125; 对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行了Looper.prepare()方法，那么便可以获取有效的Looper对象。 Handler分发消息在Looper.loop()方法中，获取到下一条消息后，执行msg.target.dispatchMessage(msg)，来分发消息到目标Handler对象。 public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; //当Message存在回调方法，回调msg.callback.run()方法； handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //当Handler存在Callback成员变量时，回调方法handleMessage()； if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //Handler自身的回调方法handleMessage() handleMessage(msg); &#125; &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; public void handleMessage(Message msg) &#123; &#125; 第三步获取消息：当发送了消息后，在MessageQueue维护了消息队列，然后在Looper中通过loop()方法，不断地获取消息。上面对loop()方法进行了介绍，其中最重要的是调用了queue.next()方法,通过该方法来提取下一条信息。下面我们来看一下next()方法的具体流程。 MessageQueue中 Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; //当消息循环已经退出，则直接返回 return null; &#125; int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1 int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; //当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，为空则退出循环。 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; //当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一条消息，并返回 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; //设置消息的使用状态，即flags |= FLAG_IN_USE msg.markInUse(); return msg; //成功地获取MessageQueue中的下一条即将要执行的消息 &#125; &#125; else &#123; //没有消息 nextPollTimeoutMillis = -1; &#125; //消息正在退出，返回null if (mQuitting) &#123; dispose(); return null; &#125; ............................... &#125; &#125; nativePollOnce是阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。可以看出next()方法根据消息的触发时间，获取下一条需要执行的消息,队列中消息为空时，则会进行阻塞操作。 总结消息机制主要包含部分： Message：需要传递的消息，可以传递数据； MessageQueue：消息队列，但是它的内部实现并不是用的队列，实际上是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)； Handler：主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)； Looper：不断循环执行(Looper.loop)，从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。 在主线程中,默认已经调用了Looper.preper()方法,调用该方法的目的是在Looper中创建MessageQueue成员变量并把Looper对象绑定到当前线程中。当调用Handler的sendMessage()方法的时候就将Message对象添加到了Looper创建的MessageQueue队列中，同时给Message指定了target对象，其实这个target对象就是Handler对象。主线程默认执行了Looper.looper()方法,该方法从Looper的成员变量MessageQueue中取出Message，然后调用Message的target对象的handleMessage()方法。这样就完成了整个消息机制。 每个线程中只能存在一个Looper，Looper是保存在ThreadLocal中的。主线程（UI线程）已经创建了一个Looper，所以在主线程中不需要再创建Looper，但是在其他线程中需要创建Looper。每个线程中可以有多个Handler，即一个Looper可以处理来自多个Handler的消息。 Looper中维护一个MessageQueue，来维护消息队列。MessageQueue有一组待处理的Message,消息队列中的Message可以来自不同的Handler。 思考在Activity中使用Handler的时候如何去除警告信息将Handler类声明为static，同时在Handler类中使用弱引用去引用Context对象。 static class MyHandler extends Handler &#123; private SoftReference&lt;Context&gt; srf; public MyHandler(Context context) &#123; srf = new SoftReference&lt;Context&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; Toast.makeText(srf.get(), msg.toString(), Toast.LENGTH_SHORT).show(); &#125; &#125; Android中为什么主线程不会因为Looper.loop()里的死循环卡死主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。 真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。 ActivityThread实际上并非线程，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，该人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。 主线程的死循环一直运行是不是特别消耗CPU资源呢？其实不然，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施： 在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。 比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法。 手写handler实现实现代码github","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自定义View","slug":"22.自定义View","date":"2019-05-15T12:55:41.469Z","updated":"2021-03-26T14:40:41.941Z","comments":false,"path":"2019/05/15/22.自定义View/","link":"","permalink":"http://yoursite.com/2019/05/15/22.%E8%87%AA%E5%AE%9A%E4%B9%89View/","excerpt":"","text":"构造函数一个参数(Context context)的构造函数会在代码里面new的时候调用， 两个参数(Context context, AttributeSet attrs)的构造函数在布局layout中使用(调用)， 三个参数(Context context, AttributeSet attrs, int defStyleAttr)的构造函数在布局layout中使用(调用)，但是会有style。 public MyView(Context context) &#123; this(context, null); &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; xml布局通过LayoutInflate，解析的时候，实例化View是通过反射，显示加载到我们Activity。 measure布局的宽高都是由这个方法指定，需要测量，获取宽高的模式。 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取宽高的模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); //获取宽高的值 int widthSize = MeasureSpec.getSize(widthMeasureSpec);// 获取后面30位 int heightSize = MeasureSpec.getSize(heightMeasureSpec); &#125; MeasureSpec：32位的二进制数字，前两位代表mode(测量模式)，后面30位才是他们的实际宽高的数值（size）。 三种模式： MeasureSpec.UNSPECIFIED：二进制00，默认值，父控件没有给子view任何限制，子View可以设置为任意大小。 MeasureSpec.EXACTLY：二进制01，表示父控件已经确切的指定了子View的大小。比如100dp、match_parent、fill_parent。 MeasureSpec.AT_MOST：二进制10，表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。wrap_content。 一般情况，wrap_content，即MeasureSpec.AT_MOST才需要重新计算。onMeasure方法最终调用setMeasuredDimension确定宽高值。 layoutdraw用于绘制 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //canvas可以画文本、画弧、画圆等等 &#125; ViewGroup不会触发onDraw方法解决办法： 方式一：把onDraw方法替换为dispatchDraw；方式二：设置透明的背景setBackgroundColor(Color.TRANSPARENT);;方式三：设置setWillNotDraw(false); 主要三个方法onDraw绘制自己；dispatchDraw绘制孩子；绘制背景 // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); Pathvoid moveTo (float x1, float y1):直线的开始点；即将直线路径的绘制点定在（x1,y1）的位置； void lineTo (float x2, float y2)：直线的结束点，又是下一次绘制直线路径的开始点；lineTo（）可以一直用； void close ():如果连续画了几条直线，但没有形成闭环，调用Close()会将路径首尾点连接起来，形成闭环； Paint相关属性setAntiAlias(true);//抗锯齿功能 setColor(Color.RED);//设置画笔颜色 //Style.FILL:填充内部;Style.FILL_AND_STROKE填充内部和描边;Style.STROKE仅描边 setStyle(Style.FILL);//设置填充样式 setStrokeWidth(30);//设置画笔宽度 //参数：radius:阴影的倾斜度;dx:水平位移;dy:垂直位移 setShadowLayer(float radius, float dx, float dy, int color)//添加阴影 //设置线冒样式，Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeCap(Paint.Cap cap) setAlpha(int a) //设置画笔透明度 reset() //重置画笔 和文字相关//相对位置 paint.setTextAlign(Paint.Align.LEFT);//Paint.Align.LEFT、Paint.Align.CENTER、Paint.Align.RIGHT setTextSize(float textSize) //设置文字大小 setFakeBoldText(boolean fakeBoldText) //设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) //设置带有删除线效果 setUnderlineText(boolean underlineText) //设置下划线 setTextSkewX(float skewX) //设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 draw图形画点//参数：float X：点的X坐标； float Y：点的Y坐标 drawPoint (float x, float y, Paint paint) 多个点//参数：pts:点的合集｛x1,y1,x2,y2,x3,y3,……｝; offset:集合中跳过的数值个数， //注意不是点的个数,一个点是两个数值; count:参与绘制的数值的个数。 drawPoints (float[] pts, Paint paint) drawPoints (float[] pts, int offset, int count, Paint paint) 画直线//参数：startX:开始点X坐标; startY:开始点Y坐标; stopX:结束点X坐标; stopY:结束点Y坐标 drawLine (float startX, float startY, float stopX, float stopY, Paint paint) 多条直线//参数：pts是点的集合，每两个点形成一条直线，pts的组织方式为｛x1,y1,x2,y2,x3,y3,……｝ drawLines (float[] pts, Paint paint) drawLines (float[] pts, int offset, int count, Paint paint) 矩形工具类RectF和Rect//根据四个点构造出一个矩形； RectF(float left, float top, float right, float bottom) Rect(int left, int top, int right, int bottom) 画矩形drawRect (float left, float top, float right, float bottom, Paint paint) drawRect (RectF rect, Paint paint) drawRect (Rect r, Paint paint) 画圆角矩形//参数：rx:生成圆角的椭圆的X轴半径； ry:生成圆角的椭圆的Y轴半径 drawRoundRect (RectF rect, float rx, float ry, Paint paint) 画圆形//参数：cx：圆心点X轴坐标 ; cy：圆心点Y轴坐标; radius：圆的半径 drawCircle (float cx, float cy, float radius, Paint paint) 画椭圆//椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，矩形的宽为椭圆的Y轴，建立的椭圆图形 drawOval (RectF oval, Paint paint) 画弧弧当然也是根据矩形来生成的 //参数：oval:生成椭圆的矩形; startAngle：弧开始的角度，X轴正方向为0度,顺时针为正; //sweepAngle：弧持续的角度,顺时针; useCenter:是否有弧的两边，True，有两边，False，只有一条弧。 drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 画三角if (mPath == null) &#123; // 画路径 mPath = new Path(); mPath.moveTo(getWidth() / 2, 0); mPath.lineTo(0, (float) ((getWidth()/2)*Math.sqrt(3))); mPath.lineTo(getWidth(), (float) ((getWidth()/2)*Math.sqrt(3))); mPath.close();// 把路径闭合 &#125; canvas.drawPath(mPath, mPaint); 画图片canvas.drawBitmap(bitmap, x, y, paint); drawText画文字//text:要绘制的文字; x：绘制原点x坐标; y：基线y坐标; paint:用来做画的画笔 drawText(String text, float x, float y, Paint paint) 从上往下依次为：top、ascent、baseLine、descent、bottom。 Paint paint = new Paint(); Paint.FontMetrics fm = paint.getFontMetrics(); Paint.FontMetricsInt fmInt = paint.getFontMetricsInt(); FontMetricsInt和FontMetrics完全相同，只是得到的值的类型不一样而已，FontMetricsInt中的四个成员变量的值都是Int类型，而FontMetrics得到的四个成员变量的值则都是float类型的。 获取基线 Paint.FontMetricsInt fontMetrics = paint.getFontMetricsInt(); int dy = (fontMetrics.bottom - fontMetrics.top) / 2 - fontMetrics.bottom; int baseLine = getHeight() / 2 + dy; 获取文字宽度 int width = paint.measureText(String text); onTouch处理跟用户交互，手指触摸，事件分发事件拦截等等。 @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 手指按下 break; case MotionEvent.ACTION_MOVE: // 手指移动 break; case MotionEvent.ACTION_UP: // 手指抬起 break; &#125; return super.onTouchEvent(event); &#125; 可以通过event.getX()获取相对于当前控件的位置,event.getRawX()获取距离屏幕的x位置。 自定义属性在res/values下面新建attrs.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;!--name 自定义View的名字MyView--&gt; &lt;declare-styleable name=&quot;MyView&quot;&gt; &lt;!-- name属性名称 format格式: string 文字、color 颜色、dimension 宽高 字体大小、 integer 数字、reference 资源（drawable）--&gt; &lt;attr name=&quot;myText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;myTextColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;myTextSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;myMaxLength&quot; format=&quot;integer&quot;/&gt; &lt;attr name=&quot;myBackground&quot; format=&quot;reference|color&quot;/&gt; &lt;!-- 枚举 --&gt; &lt;attr name=&quot;myInputType&quot;&gt; &lt;enum name=&quot;number&quot; value=&quot;1&quot;/&gt; &lt;enum name=&quot;text&quot; value=&quot;2&quot;/&gt; &lt;enum name=&quot;password&quot; value=&quot;3&quot;/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 在布局中使用，声明命名空间，然后在自己的自定义View中使用 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &lt;com.view.MyView app:myText=&quot;jt&quot; app:myTextColor=&quot;@color/colorAccent&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 在自定义View中获取属性 //获取自定义属性 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); mText = array.getString(R.styleable.MyView_myText); mTextColor = array.getColor(R.styleable.MyView_myTextColor, mTextColor); mTextSize = array.getDimensionPixelSize(R.styleable.MyView_myTextSize, mTextSize); //回收 array.recycle(); 系统有的自定义属性，我们是不能重新定义。 其他方法onFinishInflatesetContentView布局解析完毕之后会执行这个方法。而View的绘制流程是在Activity的onResume()之后才调用的。 requestDisallowInterceptTouchEvent改变的其实就是mGroupFlags的值 //事件分发 //dispatchTouchEvent-&gt;onInterceptTouchEvent-&gt;onTouchEvent @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; //请求所有父控件及祖宗控件不要拦截事件 getParent().requestDisallowInterceptTouchEvent(true); return super.dispatchTouchEvent(ev); &#125; canChildScrollUpSwipeRefreshLayout中方法，判断是否滚动到了最顶部。 public boolean canChildScrollUp() &#123; if (mChildScrollUpCallback != null) &#123; return mChildScrollUpCallback.canChildScrollUp(this, mTarget); &#125; if (android.os.Build.VERSION.SDK_INT &lt; 14) &#123; if (mTarget instanceof AbsListView) &#123; final AbsListView absListView = (AbsListView) mTarget; return absListView.getChildCount() &gt; 0 &amp;&amp; (absListView.getFirstVisiblePosition() &gt; 0 || absListView.getChildAt(0) .getTop() &lt; absListView.getPaddingTop()); &#125; else &#123; return ViewCompat.canScrollVertically(mTarget, -1) || mTarget.getScrollY() &gt; 0; &#125; &#125; else &#123; return ViewCompat.canScrollVertically(mTarget, -1); &#125; &#125; GestureDetector快速滑动，手势处理。 在ScrollView中嵌入ListView在ScrollView添加一个ListView会导致listview控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。 ListView,ScrollView在测量子布局的时候会用UNSPECIFIED,需要重写listview中的onMeasure。 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 解决显示不全的问题 heightMeasureSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE&gt;&gt; 2,MeasureSpec.AT_MOST); //heightMeasureSpec：32位的值，30位 是 Integer.MAX_VALUE，2位是MeasureSpec.AT_MOST super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; invalidate源码分析invlidate()一路向上，不断调用invalidateChild(this, damage)，调到最外层ViewRootImpl。最外层调用draw()、dispatchDraw(),一路往下画,最终画到当前调用invaldate的View的onDraw()方法。invlidate() 牵连着整个layout布局中的View。 ViewRootImpl中的重要方法 performTraversals()、performMeasure()、performLayout()、performDraw() 为什么不能在子线程中更新UIViewRootImpl中checkThread()方法用来检测线程。 if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125; mThread在构造函数中初始化的主线程mainThread View的绘制流程setContentView创建DecorView，把我们的布局加载到了DecorView。 Activity的启动流程 performLaunchActivity -&gt; Activity.onCreate()handleResumeActivity() -&gt; performResumeActivity() -&gt; Activity的onResume()方法 -&gt; wm.addView(decor, l); 才开始把我们的 DecorView 加载到 WindowManager, -&gt; View的绘制流程在这个时候才开始 measure() layout() draw() addView wm.addView(decor, l); -&gt; WindowManangerImpl.addView()-&gt; root.setView(view, wparams, panelParentView); -&gt; requestLayout() -&gt; scheduleTraversals()-&gt; doTraversal() -&gt; performTraversals() onmeasure:测量是从外往里递归 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; onMeasure(widthMeasureSpec, heightMeasureSpec); 测量开始 -&gt; measureVertical(int widthMeasureSpec, int heightMeasureSpec)-&gt; measureChildWithMargins childWidthMeasureSpec,childHeightMeasureSpec测量模式是通过getChildMeasureSpec计算。调用setMeasuredDimension()这个时候我们布局才真正指定宽度和高度，mMeasuredWidth和mMeasuredHeight才开始有值。 layout:摆放子布局for循环所有子View, 前提不是GONE，调用child.layout() performLayout ：View -&gt; layout() -&gt; onLayout() draw performDraw() : View -&gt; draw() -&gt; drawBackground();//画背景 onDraw(canvas);// 画自己 ViewGroup 默认情况下不会调用 dispatchDraw(canvas);// 画子View 不断的循环调用子View的 draw() 流程小结： 第一步performMeasure()：用于指定和测量layout中所有控件的宽高，对于ViewGroup,先去测量里面的子孩子，根据子孩子的宽高再来计算和指定自己的宽高，对于View,它的宽高是由自己和父布局决定的。 第二步performLayout(): 用于摆放子布局,for循环所有子View,用child.layout()摆放ChildView。 第三步performDraw(): 用于绘制自己还有子View,对于ViewGroup首先绘制自己的背景,for循环绘制子View调用子View的draw()方法, 对于View绘制自己的背景，绘制自己显示的内容（TextView）。 细节: View的绘制流程是在onResume() 之后才开始，如果要获取View的高度，前提肯定需要调用测量方法，测量完毕之后才能获取宽高。 addView、setVisibility、等，会调用requestLayout()重新走一遍View的绘制流程。 View的Touch事件分发自定义view @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(&quot;TAG&quot;,&quot;onTouchEvent -&gt; &quot;+event.getAction()); return super.onTouchEvent(event); &#125; 添加listener view.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.e(&quot;TAG&quot;, &quot;onTouch -&gt; &quot; + event.getAction()); return false; &#125; &#125;); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.e(&quot;TAG&quot;, &quot;onClick&quot;); &#125; &#125;); 现象： OnTouchListener返回false时： OnTouchListener.DOWN -&gt; onTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; onTouchEvent.MOVE -&gt; OnTouchListener.UP-&gt; onTouchEvent.UP-&gt; OnClickListener OnTouchListener返回true时： OnTouchListener.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchListener.UP OnTouchListener没有，onTouchEvent返回true时： onTouchEvent.DOWN -&gt; onTouchEvent.MOVE -&gt; onTouchEvent.UP 自定义view中添加dispatchTouchEvent时候，如果不写super，就什么都不走了： @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; //super.dispatchTouchEvent(event); return true; &#125; dispatchTouchEvent事件分发ListenerInfo li = mListenerInfo; ListenerInfo: 存放了关于View的所有Listener信息，如：OnTouchListener、OnClickListener。 boolean result = false; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED //是否是enable &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;//如果onTouch是false，result=false；如果是true，result=true result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123;//如果result=false就会执行onTouchEvent，如果result=true就不会执行onTouchEvent result = true; &#125; return result; 在View的onTouchEvent中的case MotionEvent.ACTION_UP:里面调用了performClick()添加了点击事件li.mOnClickListener.onClick(this)。 onTouchEvent方法ViewGroup的事件分发自定义View和上面view一样，自定义ViewGroup： @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;TAG&quot;, &quot;ViewGroup dispatchTouchEvent -&gt; &quot; + ev.getAction()); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.e(&quot;TAG&quot;, &quot;ViewGroup onInterceptTouchEvent -&gt; &quot; + ev.getAction()); return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(&quot;TAG&quot;, &quot;ViewGroup onTouchEvent -&gt; &quot; + event.getAction()); return super.onTouchEvent(event); &#125; 自定义ViewGroup包裹自定义View，点击View时候： DOWN -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; MOVE -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; Up -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; View.onclick 去掉自定义View的onClick： ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View onTouchEvent -&gt; ViewGroup.onTouchEvent 自定义View的onTouchEvent()方法里面返回true时： DOWN -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; MOVE -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent -&gt; Up -&gt; ViewGroup.dispatchTouchEvent -&gt; ViewGroup onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEvent 自定义ViewGroup的onInterceptTouchEvent()返回true时： ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; ViewGroup.onTouchEvent dispatchTouchEventonInterceptTouchEventonInterceptTouchEvent()默认情况下返回false。 onTouchEvent如果子View没有一个地方返回true,只会进来一次只会响应DOWN事件,代表不需要消费该事件,如果你想响应MOVE,UP必须找个地方ture。 对于ViewGroup,如果想拦截子View的Touch事件,可以覆写onInterceptTouchEvent返回true,执行该ViewGroup的onTouchEvent方法;如果子View没有消费Touch事件,也会调用该ViewGroup的onTouchEvent方法。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"线程和线程池","slug":"21.线程和线程池","date":"2019-05-13T14:17:03.835Z","updated":"2021-03-26T14:40:38.285Z","comments":false,"path":"2019/05/13/21.线程和线程池/","link":"","permalink":"http://yoursite.com/2019/05/13/21.%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"创建线程两种方法： 继承Thread类 实现Runnable接口 共同点：都要用start()开启线程 创建子线程方式1： Thread thread = new Thread() &#123; @Override public void run() &#123; //super.run(); System.out.println(&quot;Thread started!&quot;); &#125; &#125;; thread.start(); start调用了native方法。 或者 class MyThread1 extends Thread&#123; @Override public void run() &#123; super.run(); System.out.println(&quot;MyThread1:&quot;+Thread.currentThread().getName()); &#125; &#125; new MyThread1().start();//创建并启动线程 创建子线程方式2： Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Thread with Runnable started!&quot;); &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); 或者 class MyThread2 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;MyThread2:&quot;+Thread.currentThread().getName()); &#125; &#125; new Thread(new MyThread2()).start();//创建并启动线程 //或者 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;MyThread3:&quot;+Thread.currentThread().getName()); &#125; &#125;).start(); ThreadFactory ThreadFactory factory = new ThreadFactory() &#123; AtomicInteger count = new AtomicInteger(0); @Override public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;Thread-&quot; + count.incrementAndGet()); &#125; &#125;; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; started!&quot;); &#125; &#125;; Thread thread = factory.newThread(runnable); thread.start(); Thread thread1 = factory.newThread(runnable); thread1.start(); Executors Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Thread with Runnable started!&quot;); &#125; &#125;; Executor executor = Executors.newCachedThreadPool(); executor.execute(runnable); executor.execute(runnable); executor.execute(runnable); 除了newCachedThreadPool还有newSingleThreadExecutor单线程池、newFixedThreadPool指定固定线程数的线程池。 ExecutorService executor = Executors.newFixedThreadPool(20); for (Bitmap bitmap : bitmaps) &#123; executor.execute(bitmapProcessor(bitmap)); &#125; executor.shutdown(); synchronized synchronized 的本质:保证方法内部或代码块内部资源（数据）的互斥访问。即同一时间、由同一个Monitor监视的代码，最多只能有一个线程在访问。 synchronized定义在方法上，Monitor默认指定的是这个类；方法中使用synchronized(this),Monitor指定的也是这个类；如果想更换Monitor，就要把this换成其他对象。即多个线程，访问同一个类的多个方法，就要处理Monitor是不是同一个。 如果线程1正在访问count方法，那么线程2无法访问到minus方法，因为两个方法是同一个Monitor： private synchronized void count(int newValue) &#123; x = newValue; y = newValue; &#125; private void minus(int delta) &#123; synchronized (this) &#123; x -= delta; y -= delta; &#125; &#125; 如果线程1正在访问count方法，线程2可以访问到minus方法，因为两个方法不是同一个Monitor，是两个Monitor： private final Object monitor1 = new Object(); private synchronized void count(int newValue) &#123; x = newValue; y = newValue; &#125; private void minus(int delta) &#123; synchronized (monitor1) &#123; x -= delta; y -= delta; &#125; &#125; 保证线程之间对监视资源的数据同步。即，任何线程在获取到 Monitor 后的第一时间，会先将共享内存中的数据复制到自己的缓存中；任何线程在释放 Monitor 的第一时间，会先将缓存中的数据复制到共享内存中。 volatile 保证加了 volatile 关键字的字段的操作具有原子性和同步性，其中原子性相当于实现了针对单一字段的线程间互斥访问。因此 volatile 可以看做是简化版的 synchronized。 volatile 只对基本类型 (byte、char、short、int、long、float、double、boolean) 的赋值操作和对象的引用赋值操作有效。 原子性是cup执行的最小单位。 atomic java.util.concurrent.atomic 包： 下面有 AtomicInteger AtomicBoolean 等类，作用和 volatile 基本一致，可以看做是通用版的 volatile。 AtomicInteger atomicInteger = new AtomicInteger(0); ... atomicInteger.getAndIncrement(); lock 同样是「加锁」机制。但使用方法更灵活，同时也更麻烦一些。 Lock lock = new ReentrantLock(); ... lock.lock(); try &#123; x++; &#125; finally &#123; lock.unlock(); &#125; 一般并不会只是使用Lock，而是会使用更复杂的锁ReentrantReadWriteLock： public class ReadWriteLockDemo &#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); Lock readLock = lock.readLock(); Lock writeLock = lock.writeLock(); private int x = 0; private void count() &#123; writeLock.lock(); try &#123; x++; &#125; finally &#123; writeLock.unlock(); &#125; &#125; private void print(int time) &#123; readLock.lock(); try &#123; for (int i = 0; i &lt; time; i++) &#123; System.out.print(x + &quot; &quot;); &#125; System.out.println(); &#125; finally &#123; readLock.unlock(); &#125; &#125; public void runTest() &#123; new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1_000_000; i++) &#123; count(); &#125; System.out.println(&quot;final x from 1: &quot; + x); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; print(1); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; print(2); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; print(3); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; print(4); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; print(5); &#125; &#125;.start(); &#125; &#125; wait在未达到目标时 wait();用 while 循环检查;设置完成后 notifyAll();wait() 和 notify() / notifyAll() 都需要放在同步代码块里。 public class WaitDemo &#123; private String sharedString; private synchronized void initString() &#123; sharedString = &quot;kkk&quot;; notifyAll(); &#125; private synchronized void printString() &#123; while (sharedString == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;String: &quot; + sharedString); &#125; public void runTest() &#123; final Thread thread1 = new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; printString(); &#125; &#125;; thread1.start(); Thread thread2 = new Thread() &#123; @Override public void run() &#123; Thread.yield(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; initString(); &#125; &#125;; thread2.start(); &#125; &#125; 其他Service：后台任务的活动空间。适用场景：音乐播放器等。IntentService：执行单个任务后自动关闭的 Service。 如果在界面组件里创建 Executor 或者 HandlerThread，记得要在关闭的时候（例如Activity.onDestroy() ）关闭 Executor 和 HandlerThread。 @Override protected void onDestroy() &#123; super.onDestroy(); executor.shutdown(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); handlerThread.quit(); // 这个其实就是停⽌ Looper 的循环 &#125; 线程池ThreadPoolExecutor构造方法参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：线程基本大小 maximumPoolSize：线程池最大所能容纳线程大小 keepAliveTime：线程活动保持时间 workQueue：阻塞队列 threadFactory创建线程的工厂 handler：饱和策略 手动创建线程池仿照AsyncTask源码，写个线程池。缓存队列Runnable，加入到线程队列中去执行。 public class ThreadPoolDemo &#123; static ThreadPoolExecutor threadPoolExecutor; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;&gt;(128); static &#123; threadPoolExecutor = new ThreadPoolExecutor( 4,// 核心线程数，就是线程池里面的核心线程数量 10, // 最大线程数，线程池中的最大线程数 60,// 线程存活的时间，没事干的时候的空闲存活时间，超过这个时间线程就会被销毁 TimeUnit.SECONDS,// 线程存活时间的单位 sPoolWorkQueue,// 线程队列 new ThreadFactory() &#123;//线程创建工厂，如果线程池需要创建线程就会调用newThread 来创建 @Override public Thread newThread(@NonNull Runnable r) &#123; // Thread thread = new Thread(r,&quot;自己线程的名字&quot;); // thread.setDaemon(false); // 不是守护线程 return new Thread(r); &#125; &#125;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;下载图片显示完毕&quot;+Thread.currentThread().getName()); &#125; &#125;; // 加入线程队列，寻找合适的时机去执行 threadPoolExecutor.execute(runnable); &#125; &#125; &#125; 输出结果： Runnable缓存队列大于WorkQueue线程队列就可能会报错。 workQueue的参数BlockingQueue: 先进先出的一个队列 FIFO（rxjava，AsyncTask） SynchronousQueue: 线程安全的队列，它里面是没有固定的缓存的（OKHttp所使用的） PriorityBlockingQueue: 无序的可以根据优先级进行排序，指定的对象要实现Comparable作比较 有限队列SynchronousQueue和ArrayBlockingQueue；无限队列LinkedBloackingQueue。 PriorityBlockingQueue示例 public class Request implements Runnable,Comparable&lt;Request&gt;&#123; @Override public void run() &#123; System.out.println(&quot;run&quot;); &#125; @Override public int compareTo(@NonNull Request o) &#123; return 0; &#125; &#125; public class ThreadPoolTest &#123; static ThreadPoolExecutor threadPoolExecutor; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new PriorityBlockingQueue&lt;Runnable&gt;(4); static &#123; threadPoolExecutor = new ThreadPoolExecutor( 4,// 核心线程数，就是线程池里面的核心线程数量 10, // 最大线程数，线程池中的最大线程数 60,// 线程存活的时间，没事干的时候的空闲存活时间，超过这个时间线程就会被销毁 TimeUnit.SECONDS,// 线程存活时间的单位 sPoolWorkQueue,// 线程队列 new ThreadFactory() &#123;// 线程创建工厂，如果线程池需要创建线程就会调用 newThread 来创建 @Override public Thread newThread(@NonNull Runnable r) &#123; return new Thread(r); &#125; &#125;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; Request request = new Request(); // 加入线程队列，寻找合适的时机去执行 threadPoolExecutor.execute(request); &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"学习Node","slug":"17.学习node","date":"2019-04-26T12:25:02.383Z","updated":"2021-03-26T14:40:34.351Z","comments":false,"path":"2019/04/26/17.学习node/","link":"","permalink":"http://yoursite.com/2019/04/26/17.%E5%AD%A6%E4%B9%A0node/","excerpt":"","text":"起步官网： https://nodejs.org/en/ 检查安装版本 node --version Node.js既不是语言，也不是框架，它是一个平台。Node.js 中的 JavaScript没有 BOM、DOM，提供了一些服务器级别的 API：文件操作的能力、http 服务的能力。 helloworld.js var f = &apos;hello nodejs&apos; console.log(f) 然后执行 node .../helloworld.js require 是一个方法,它的作用就是用来加载模块的。在 Node 中，模块有三种：具名的核心模块，例如 fs、http；用户自己编写的文件模块；第三方模块。 读和写文件浏览器中的 JavaScript 是没有文件操作的能力的，但是 Node 中的JavaScript 具有文件操作的能力。fs 是 file-system 的简写，就是文件系统的意思，fs.readFile 就是用来读取文件的。 node执行下面的js文件： var fs = require(&apos;fs&apos;) // 第一个参数就是要读取的文件路径,第二个参数是一个回调函数 fs.readFile(&apos;./data/hello.txt&apos;, function (error, data) &#123; if (error) &#123; console.log(&apos;读取文件失败了&apos;) &#125; else &#123; console.log(data.toString()) &#125; &#125;) 写文件： var fs = require(&apos;fs&apos;) fs.writeFile(&apos;./data/你好.md&apos;, &apos;我是Node.js&apos;, function (error) &#123; if (error) &#123; console.log(&apos;写入失败&apos;) &#125; else &#123; console.log(&apos;写入成功了&apos;) &#125; &#125;) http服务简单的http服务 var http = require(&apos;http&apos;) //使用 http.createServer() 方法创建一个 Web 服务器 var server = http.createServer() //当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数 server.on(&apos;request&apos;, function () &#123; console.log(&apos;收到客户端的请求了&apos;) &#125;) //绑定端口号，启动服务器 server.listen(3000, function () &#123; console.log(&apos;服务器启动成功了，可以通过 http://你的ip/ 来进行访问&apos;) &#125;) 处理请求,request请求事件处理函数，需要接收两个参数：Request 请求对象,请求对象可以用来获取客户端的一些请求信息，例如请求路径;Response 响应对象,响应对象可以用来给客户端发送响应消息。 var http = require(&apos;http&apos;) var server = http.createServer() server.on(&apos;request&apos;, function (request, response) &#123; console.log(&apos;收到客户端的请求了，请求路径是：&apos; + request.url) // response 对象有一个方法：write 可以用来给客户端发送响应数据,write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待 response.write(&apos;hello&apos;) response.write(&apos; nodejs&apos;) response.end() &#125;) server.listen(3000, function () &#123; console.log(&apos;服务器启动成功了，可以通过 http://你的ip:3000/ 来进行访问&apos;) &#125;) 根据不同请求路径返回不同数据： var http = require(&apos;http&apos;) var server = http.createServer() server.on(&apos;request&apos;, function (req, res) &#123; console.log(&apos;收到请求了，请求路径是：&apos; + req.url) console.log(&apos;请求我的客户端的地址是：&apos;, req.socket.remoteAddress, req.socket.remotePort) var url = req.url if (url === &apos;/&apos;) &#123; res.end(&apos;index page&apos;) &#125; else if (url === &apos;/login&apos;) &#123; res.end(&apos;login page&apos;) &#125; else if (url === &apos;/products&apos;) &#123; var products = [&#123; name: &apos;苹果 X&apos;, price: 8888 &#125;, &#123; name: &apos;菠萝 X&apos;, price: 5000 &#125;, &#123; name: &apos;小辣椒 X&apos;, price: 1999 &#125; ] res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) // 响应内容只能是二进制数据或者字符串、 数字、 对象、数组、布尔值 res.end(JSON.stringify(products)) &#125; else &#123; res.end(&apos;404 Not Found.&apos;) &#125; &#125;) server.listen(3000, function () &#123; console.log(&apos;服务器启动成功，可以访问了。。。&apos;) &#125;) 在服务端默认发送的数据，其实是 utf8 编码的内容，中文操作系统默认是 gbk。在 http 协议中，Content-Type 就是用来告知对方我给你发送的数据内容是什么类型 // text/plain 就是普通文本 res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) // 如果你发送的是 html 格式的字符串，则也要告诉浏览器我给你发送是 text/html 格式的内容 res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) // 图片就不需要指定编码了，因为我们常说的编码一般指的是：字符编码 res.setHeader(&apos;Content-Type&apos;, &apos;image/jpeg&apos;) 模板引擎读取文件目录 var fs = require(&apos;fs&apos;) fs.readdir(&apos;D:/Movie/www&apos;, function (err, files) &#123; if (err) &#123; return console.log(&apos;目录不存在&apos;) &#125; console.log(files) &#125;) art-template不仅可以在浏览器使用，也可以在 node 中使用。 https://github.com/aui/art-template https://aui.github.io/art-template/ 安装：该命令在哪执行就会把包下载到哪里,下载到 node_modules 目录中。 npm install art-template 注意：在浏览器中需要引用 lib/template-web.js 文件 浏览器中使用art-template: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;浏览器中使用art-template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/template&quot; id=&quot;tpl&quot;&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;大家好，我叫：&#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;我今年 &#123;&#123; age &#125;&#125; 岁了&lt;/p&gt; &lt;h1&gt;我来自 &#123;&#123; province &#125;&#125;&lt;/h1&gt; &lt;p&gt;我喜欢：&#123;&#123;each hobbies&#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;/script&gt; &lt;script&gt; var ret = template(&apos;tpl&apos;, &#123; name: &apos;Jack&apos;, age: 18, province: &apos;北京市&apos;, hobbies: [ &apos;写代码&apos;, &apos;唱歌&apos;, &apos;打游戏&apos; ] &#125;) console.log(ret) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在 Node 中使用 art-template 模板引擎。在需要使用的文件模块中加载 art-template，只需要使用 require 方法加载就可以了：require(&#39;art-template&#39;) node执行js var template = require(&apos;art-template&apos;) var fs = require(&apos;fs&apos;) fs.readFile(&apos;./tpl.html&apos;, function (err, data) &#123; if (err) &#123; return console.log(&apos;读取文件失败了&apos;) &#125; var ret = template.render(data.toString(), &#123; name: &apos;Jack&apos;, age: 18, province: &apos;北京市&apos;, hobbies: [ &apos;写代码&apos;, &apos;唱歌&apos;, &apos;打游戏&apos; ], title: &apos;个人信息&apos; &#125;) console.log(ret) &#125;) tpl.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;大家好，我叫：&#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;我今年 &#123;&#123; age &#125;&#125; 岁了&lt;/p&gt; &lt;h1&gt;我来自 &#123;&#123; province &#125;&#125;&lt;/h1&gt; &lt;p&gt;我喜欢：&#123;&#123;each hobbies&#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt; &lt;script&gt; var foo = &apos;&#123;&#123; title &#125;&#125;&apos; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 留言板小案例 npm官网 https://www.npmjs.com/ 常用命令行工具 //查看版本 npm --version //升级npm npm install --global npm //跳过向导，快速生成 npm init -y //只下载 npm install 包名 //下载并且保存依赖项(package.json文件中的dependencies选项) npm install --save //只删除，如果有依赖项依然保存 npm uninstall 包名 //依赖也删除 npm uninstall --save 包名 //帮助 npm help 解决翻墙： 首先安装淘宝cnpm（可以再任意目录执行，–global表示安装到全局） npm install --global cnpm 接下来用cnpm替换npm。 如果不想安装npm又想使用淘宝镜像： npm install jquery --registry=https://registry.npm.taobao.org 加入配置文件中： npm config set registry https://registry.npm.taobao.org //查看配置成功 npm config list","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"设计模式","slug":"16.设计模式","date":"2019-04-24T12:22:35.621Z","updated":"2021-03-26T14:40:30.502Z","comments":false,"path":"2019/04/24/16.设计模式/","link":"","permalink":"http://yoursite.com/2019/04/24/16.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式 单例模式：保证整个程序只有一个实例。 套路：1、构造函数私有，防止在外部new对象；2、内部必须提供一个静态的方法，让外部调用。 饿汉模式 public class SingletonEHan &#123; private SingletonEHan() &#123; &#125; private static SingletonEHan singletonEHan = new SingletonEHan(); public static SingletonEHan getInstance() &#123; return singletonEHan; &#125; // SingletonEHan instance= SingletonEHan.getInstance(); &#125; 优点：比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。 缺点：由于在类加载的时候就实例化了，也就是说可能我没有用到这个实例，但是它也会加载，会造成内存的浪费(但是这个浪费可以忽略)。 懒汉模式，四种方式 public class SingletonLanHan &#123; private SingletonLanHan() &#123; &#125; /** * 单例模式的懒汉式[线程不安全，不可用] */ private static SingletonLanHan singletonLanHan; public static SingletonLanHan getInstance() &#123; if (singletonLanHan == null) &#123; //多线程并发，这里线程是不安全的,可能得到两个不同的实例 singletonLanHan = new SingletonLanHan(); &#125; return singletonLanHan; &#125; /** * 懒汉式线程安全的:加锁，[线程安全，效率低不推荐使用] * 缺点：效率太低，每个线程在想获得类的实例时候，执行getSingletonLanHanTwo()方法都要进行同步。 */ private static SingletonLanHan singletonLanHanTwo; public static synchronized SingletonLanHan getSingletonLanHanTwo() &#123; if (singletonLanHanTwo == null) &#123; singletonLanHanTwo = new SingletonLanHan(); &#125; return singletonLanHanTwo; &#125; /** * 单例模式懒汉式[线程不安全，不可用] * 虽然加了锁，new Singleton()跳出这个锁时，另一个已经进入if语句的线程同样会实例化另外一个Singleton对象。 * */ private static SingletonLanHan singletonLanHanThree = null; public static SingletonLanHan getSingletonLanHanThree() &#123; if (singletonLanHanThree == null) &#123; synchronized (SingletonLanHan.class) &#123;// 线程不安全 singletonLanHanThree = new SingletonLanHan(); &#125; &#125; return singletonLanHanThree; &#125; /** * 懒汉式双重校验 * 缺点:不推荐用，下面解释 */ private static SingletonLanHan singletonLanHanFour; public static SingletonLanHan getSingletonLanHanFour() &#123; if (singletonLanHanFour == null) &#123;//只执行一次锁，所以效率高一些 synchronized (SingletonLanHan.class) &#123; if (singletonLanHanFour == null) &#123; singletonLanHanFour = new SingletonLanHan(); &#125; &#125; &#125; return singletonLanHanFour; &#125; &#125; 1、开辟一块内存空间，2、初始化对象，3、给变量赋值，指向内存地址。在java中2和3的顺序不一定，也可能先3再2。用volatile保证123的顺序执行，防止重排序。 volatile[同步锁DCL] public class SingletonLanHan &#123; private SingletonLanHan() &#123; &#125; //volatile解决了gvm指令重排序优化 private static volatile SingletonLanHan singletonLanHanFour; public static SingletonLanHan getSingletonLanHanFour() &#123; if (singletonLanHanFour == null) &#123; synchronized (SingletonLanHan.class) &#123; if (singletonLanHanFour == null) &#123; singletonLanHanFour = new SingletonLanHan(); &#125; &#125; &#125; return singletonLanHanFour; &#125; &#125; volatile关键字作用:防止重排序,线程可见性。 线程可见性:某一个线程改了公用对象(变量)，短时间内另一个线程可能是不可见的，因为每一个线程都有自己的缓存区(线程工作区)。 举例：可以看加不加volatile的区别： public class VolatileTest &#123; public static void main(String[] args) &#123; ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true)&#123; if(td.isFlag())&#123; System.out.println(&quot;主线程flag:&quot; + td.isFlag()); break; &#125; &#125; &#125; &#125; class ThreadDemo implements Runnable &#123; private volatile boolean flag = false; @Override public void run() &#123; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; &#125; flag = true; System.out.println(&quot;其他线程flag=&quot; + isFlag()); &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; &#125; 静态内部类 /** * 内部类[推荐用] * 在饿汉式方式是只要Singleton类被装载就会实例化, * 内部类是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类 * 优点：避免了线程不安全，延迟加载，效率高。 */ public class SingletonIn &#123; private SingletonIn() &#123; &#125; private static class SingletonInHodler &#123; private static final SingletonIn singletonIn = new SingletonIn(); &#125; public static SingletonIn getSingletonIn() &#123; return SingletonInHodler.singletonIn; &#125; &#125; 枚举 /** * 枚举[推荐使用] * SingletonEnum.instance * 这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。 * 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 */ public enum SingletonEnum &#123; instance; private SingletonEnum() &#123; &#125; public void whateverMethod() &#123; &#125; // SingletonEnum.instance.method(); &#125; 容器管理 SystemServiceRegistry.getSystemService系统的服务就是用的这种 public class Singleton &#123; private static Map&lt;String,Object&gt; mSingleMap = new HashMap&lt;&gt;(); static &#123; mSingleMap.put(&quot;activity_manager&quot;,new Singleton()); &#125; private Singleton() &#123; &#125; public static Object getService(String serviceName)&#123; return mSingleMap.get(serviceName); &#125; &#125; 补充复习static static关键字的特点：随着类的加载而加载，随着类的消失而消失；优先于对象存在；被类的所有对象共享。 静态变量存储于方法区的静态区；成员变量存储于堆内存。 静态代码块：在类中方法外出现，并加上static修饰；用于给类进行初始化(全局初始化)，在类加载的时候就执行，并且只执行一次。main主方法所在的类中的静态代码块优先于主方法执行。 class Student &#123; static &#123; System.out.println(&quot;Student 静态代码块&quot;); &#125; &#123; System.out.println(&quot;Student 构造代码块&quot;); &#125; public Student() &#123; System.out.println(&quot;Student 构造方法&quot;); &#125; &#125; class Demo2_Student &#123; static &#123; System.out.println(&quot;Demo2_Student静态代码块&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;我是main方法&quot;); Student s1 = new Student(); Student s2 = new Student(); &#125; &#125; 输出结果： Demo2_Student静态代码块 我是main方法 Student 静态代码块 Student 构造代码块 Student 构造方法 Student 构造代码块 Student 构造方法 工厂模式简单工厂模式 简单工厂模式：提供专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。客户端只知道传入工厂类的参数，不需要关心具体的实现。它不属于GoF23种设计模式，但在软件开发中应用也较为频繁。 实例 Bitmap bitmap = BitmapFatory.deresources(res,id); 简单工厂场景 使用简单工厂模式设计一个可以创建圆形、方形和三角形的绘图工具。 //抽象类 public interface IPain &#123; void draw(); &#125; //具体产品类 class Triangle implements IPain &#123; @Override public void draw() &#123; System.out.println(&quot;画出三角形&quot;); &#125; &#125; class Square implements IPain &#123; @Override public void draw() &#123; System.out.println(&quot;画出正方形&quot;); &#125; &#125; class Circle implements IPain &#123; @Override public void draw() &#123; System.out.println(&quot;画出圆形&quot;); &#125; &#125; //工厂类 public class PainFactory &#123; //静态工厂方法 public static IPain create(int type)&#123; switch (type) &#123; case 1: return new Triangle(); case 2: return new Square(); case 3: return new Circle(); default: return new Circle(); &#125; &#125; &#125; //客户端 public class Client &#123; public static void main(String[] args) &#123; //通过静态工厂方法创建产品 IPain mPain = PainFactory.create(2); mPain.draw(); &#125; &#125; 在简单工厂模式包含如下几个角色： 工厂类，负责实现创建所有产品实例，在工厂类中提供了静态方法，可以被外界直接调用，返回抽象产品类Product。 Product抽象产品角色，它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，所有创建的具体产品对象都是其子类对象。 具体产品角色，都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象。 工厂方法模式 简单工厂Factory Method Pattern，模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类。 工厂方法模式中，不再提供一个统一的工厂类，而是针对不同的产品提供不同的工厂。提供一个抽象工厂接口来声明抽象工厂方法，其子类来具体实现工厂方法，创建具体的产品对象。即把对象的实现延迟到子类完成。 实例： //List:Factory抽象工厂，ArrayList:具体的工厂Factory //Iterator:抽象产品Product，ArrayListIterator:具体的产品 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.iterator(); 工厂方法场景 玩具工厂生产动物玩具，发出不同叫声。 //抽象产品-玩具 interface IToy &#123; void makeNoise(String string); &#125; //具体产品 class DogToy implements IToy &#123; public void makeNoise(String string) &#123; System.out.println(string + &quot;汪汪汪的叫。&quot; ); &#125; &#125; //具体产品 class CatToy implements IToy &#123; public void makeNoise(String string) &#123; System.out.println(string + &quot;喵喵喵的叫。&quot;); &#125; &#125; //抽象工厂 abstract class IToyFactory &#123; abstract IToy createToy(); &#125; //具体工厂 class DogFactory extends IToyFactory &#123; public IToy createToy() &#123; return new DogToy(); &#125; &#125; //具体工厂 class CatFactory extends IToyFactory &#123; public IToy createToy() &#123; return new CatToy(); &#125; &#125; //客户端 class Client &#123; public static void main(String args[]) &#123; IToyFactory factory = new CatFactory(); IToy toy = factory.createToy(); toy.makeNoise(&quot;我是cat。&quot;); //factory.createToy().makeNoise(&quot;我是cat。&quot;); &#125; &#125; 工厂方法模式的几个角色： Product抽象产品角色和具体产品角色，和简单工厂模式类似，不再累述。 Factory（抽象工厂）：是工厂方法模式的核心，在抽象工厂类中，声明了抽象工厂方法，用于返回一个产品。可以是接口，也可以是抽象类或者具体类。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 抽象工厂模式 抽象工厂模式Abstract Factory Pattern 待更新 建造者模式介绍 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。 简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件。 角色 在建造者模式中包含如下几个角色： Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 Director（指挥者）：负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。 客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 建造者模式与抽象工厂模式有点相似，但是建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品。 场景 实例：生产机器人，包含机器人服装，脸型，机器人功能 //产品,包含很多组件 class RobotProduct &#123; private String type; //机器人功能 private String face; //脸型 private String costume; //服装 public void setType(String type) &#123; this.type = type; &#125; public void setFace(String face) &#123; this.face = face; &#125; public void setCostume(String costume) &#123; this.costume = costume; &#125; public String getType() &#123; return (this.type); &#125; public String getFace() &#123; return (this.face); &#125; public String getCostume() &#123; return (this.costume); &#125; &#125; //抽象建造者 abstract class RobotBuilder &#123; protected RobotProduct robot = new RobotProduct(); public abstract void buildType(); public abstract void buildFace(); public abstract void buildCostume(); //工厂方法，返回一个完整机器人 public RobotProduct createRobot() &#123; return robot; &#125; &#125; //具体建造者 class ManBuilder extends RobotBuilder &#123; public void buildType() &#123; robot.setType(&quot;男仆&quot;); &#125; public void buildFace() &#123; robot.setFace(&quot;英俊&quot;); &#125; public void buildCostume() &#123; robot.setCostume(&quot;西服&quot;); &#125; &#125; //具体建造者 class WomanBuilder extends RobotBuilder &#123; public void buildType() &#123; robot.setType(&quot;女仆&quot;); &#125; public void buildFace() &#123; robot.setFace(&quot;漂亮&quot;); &#125; public void buildCostume() &#123; robot.setCostume(&quot;短裙&quot;); &#125; &#125; //指挥者类定义了construct()方法，该方法拥有一个抽象建造者类型的参数，在该方法内部实现了机器人的逐步构建 class RobotController &#123; //逐步构建复杂产品对象 public RobotProduct construct(RobotBuilder ab) &#123; RobotProduct robot; ab.buildType(); ab.buildFace(); ab.buildCostume(); robot = ab.createRobot(); return robot; &#125; &#125; class Client &#123; public static void main(String args[]) &#123; RobotBuilder ab = new WomanBuilder(); RobotController ac = new RobotController(); RobotProduct robot = ac.construct(ab); //通过指挥者创建完整的建造者对象 System.out.println(robot.getType() + &quot;的外观：&quot;); System.out.println(&quot;面容：&quot; + robot.getFace()); System.out.println(&quot;服装：&quot; + robot.getCostume()); &#125; &#125; 变形 建造者模式的变形，也是在源码和开源项目中长用的，比如：AlertDialog //产品,包含很多组件 class RobotProduct &#123; private String type; //机器人功能 private String face; //脸型 private String costume; //服装 public void apply(RobotBuilder.RobotParmas parmas) &#123; type = parmas.type; face = parmas.face; costume = parmas.costume; &#125; @Override public String toString() &#123; return type + &quot;的外观：&quot; + &quot;面容：&quot; + face + &quot;服装：&quot; + costume; &#125; &#125; //具体建造者 class RobotBuilder &#123; private RobotBuilder.RobotParmas parmas; public RobotBuilder() &#123; this.parmas = new RobotBuilder.RobotParmas(); &#125; public RobotBuilder makeType(String type) &#123; parmas.type = type; return this; &#125; public RobotBuilder makeFace(String face) &#123; parmas.face = face; return this; &#125; public RobotBuilder makeCostume(String costume) &#123; parmas.costume = costume; return this; &#125; //真正构建 public RobotProduct build() &#123; RobotProduct produc = new RobotProduct(); produc.apply(parmas); return produc; &#125; class RobotParmas &#123; public String type; //机器人功能 public String face; //脸型 public String costume; //服装 &#125; &#125; class Client &#123; public static void main(String args[]) &#123; RobotProduct product = new RobotBuilder().makeType(&quot;女仆&quot;).makeFace(&quot;俊俏&quot;).makeCostume(&quot;护士装&quot;).build(); System.out.println(product.toString()); &#125; &#125; 责任链模式介绍 职责链模式(Chain of Responsibility Pattern，职责链模式)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。职责链模式结构的核心在于引入了一个抽象处理者。 重点：上一个处理对象必须含有下一个处理对象的引用，形成一个单向链表。 角色 Handler（抽象处理者）：定义一个处理请求的抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。 ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。 场景 安卓实例，比如，事件分发机制。在View、ViewGroup、Activity中都有机会处理OnTouchEvent请求。 例子：主任、副董事长、董事长有不同的审批金额的权利，当超过自己额度审批范围，就像上级提交。 class Client &#123; public static void main(String[] args) &#123; ApproverHander little, middle, high; little = new Director(&quot;张三&quot;); middle = new VicePresident(&quot;李四&quot;); high = new President(&quot;王五&quot;); //创建职责链 little.setSuccessor(middle); middle.setSuccessor(high); //创建采购单 PurchaseRequest pr1 = new PurchaseRequest(45000); little.processRequest(pr1); PurchaseRequest pr2 = new PurchaseRequest(60000); little.processRequest(pr2); PurchaseRequest pr3 = new PurchaseRequest(160000); little.processRequest(pr3); &#125; &#125; //采购单：请求类 class PurchaseRequest &#123; private double amount; //采购金额 public PurchaseRequest(double amount) &#123; this.amount = amount; &#125; public void setAmount(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return this.amount; &#125; &#125; //审批者类：抽象处理者 abstract class ApproverHander &#123; protected ApproverHander hander; //定义后继对象 protected String name; //审批者姓名 public ApproverHander(String name) &#123; this.name = name; &#125; //设置后继者 public void setSuccessor(ApproverHander hander) &#123; this.hander = hander; &#125; //抽象请求处理方法 public abstract void processRequest(PurchaseRequest request); &#125; //主任类：具体处理者 class Director extends ApproverHander &#123; public Director(String name) &#123; super(name); &#125; //具体请求处理方法 public void processRequest(PurchaseRequest request) &#123; if (request.getAmount() &lt; 50000) &#123; System.out.println(&quot;主任&quot; + this.name + &quot;审批金额：&quot; + request.getAmount()); //处理请求 &#125; else &#123; this.hander.processRequest(request); //转发请求 &#125; &#125; &#125; //副董事长类：具体处理者 class VicePresident extends ApproverHander &#123; public VicePresident(String name) &#123; super(name); &#125; //具体请求处理方法 public void processRequest(PurchaseRequest request) &#123; if (request.getAmount() &lt; 100000) &#123; System.out.println(&quot;副董事长&quot; + this.name + &quot;审批金额：&quot; + request.getAmount()); //处理请求 &#125; else &#123; this.hander.processRequest(request); //转发请求 &#125; &#125; &#125; //董事长类：具体处理者 class President extends ApproverHander &#123; public President(String name) &#123; super(name); &#125; //具体请求处理方法 public void processRequest(PurchaseRequest request) &#123; System.out.println(&quot;董事长&quot; + this.name + &quot;审批金额：&quot; + request.getAmount()); //处理请求 &#125; &#125; 和观察者模式区别 受众数量不同。观察者广播链式可以 1:N 的方式广播，而责任链则要求是的 1:1 的传递，必然有一个且只有一个类完成请求的处理; 请求内容不同。观察者广播链中的信息可以在传播中改变，但是责任链中的请求是不可改变的; 处理逻辑不通。观察者广播链主要用于触发联动动作，而责任链则是对一个类型的请求按照既定的规 则进行处理。 装饰模式介绍 装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。 角色 Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 装饰设计模式一般情况都是把类对象作为构造参数传递。在不使用的继承的方式下，采用装饰设计模式可以扩展一个对象的功能，可以使一个对象变得越来越强大。 场景 例子：在铺了地板的毛坯房上进行装饰： public class Client &#123; public static void main(String args[]) &#123; Home home, homeTake; //使用抽象构件定义 home = new Floor(); //定义具体构件 homeTake = new TakeHomeDecorator(home); //定义装饰后的构件 homeTake.display(); &#125; &#125; //抽象界面构件类 abstract class Home &#123; public abstract void display(); &#125; //具体构件类 class Floor extends Home &#123; public void display() &#123; System.out.println(&quot;毛坯房铺了地板&quot;); &#125; &#125; //抽象装饰类 class HomeDecorator extends Home &#123; private Home component; //维持对抽象构件类型对象的引用 public HomeDecorator(Home component)&#123;//注入抽象构件类型的对象 this.component = component; &#125; public void display() &#123; component.display(); &#125; &#125; //具体装饰类 class TakeHomeDecorator extends HomeDecorator &#123; public TakeHomeDecorator(Home component) &#123; super(component); &#125; public void display() &#123; super.display(); this.setFurniture(); &#125; public void setFurniture() &#123; System.out.println(&quot;搬进去很多家具&quot;); &#125; &#125; 安卓实例 ListView中的HeaderViewListAdapter，添加头部和底部。 ContextWrapper。 模板方法模式介绍 模板方法模式(Template Method Pattern)：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 其核心是抽象类和其中的模板方法的设计。父类一般都是流程和通用部分的封装，子类一般都是具体的功能和逻辑。 钩子：用来控制父类的流程,比如:插件化开发hook启动流程。 场景 模版和钩子,比如吃饭:点餐、吃东西、充卡、买单,充卡可以自由选择 public class Client &#123; public static void main(String[] args) &#123; PeopleEat h1 = new PeopleEat(); h1.setMoney(true); h1.havaEat(); &#125; &#125; abstract class EatModel &#123; //钩子方法，默认会充钱 protected boolean isAdd()&#123; return true; &#125; protected abstract void orderFood(); protected abstract void eatMeal(); protected abstract void addMoney(); protected abstract void payBill(); final public void havaEat() &#123; this.orderFood(); this.eatMeal(); if(this.isAdd())&#123; this.addMoney(); &#125; this.payBill(); &#125; &#125; class PeopleEat extends EatModel &#123; private boolean addMoneyFlag = true; @Override protected void addMoney() &#123; System.out.println(&quot;充值200元...&quot;); &#125; @Override protected void payBill() &#123; System.out.println(&quot;买单离开...&quot;); &#125; @Override protected void orderFood() &#123; System.out.println(&quot;点了烤肉...&quot;); &#125; @Override protected void eatMeal() &#123; System.out.println(&quot;开始烤肉啦...&quot;); &#125; @Override protected boolean isAdd() &#123; return this.addMoneyFlag; &#125; public void setMoney(boolean isAdd)&#123; this.addMoneyFlag = isAdd; &#125; &#125; 安卓实例 Activity的生命周期采用了模板方法模式：首先都是继承自Activity，而且所有要自己定义写的Activity的生命周期的流程都是一样的，每个Activity可以设置不同的界面，可以实现自己的具体交互逻辑。 AsyncTask 开发中BaseActivity 策略设计模式介绍 策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。 策略模式的主要目的是将算法的定义与使用分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。 角色 Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。 Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。 ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。 场景 景区门票，原始票价，学生票价，老人票价 public class Client &#123; public static void main(String[] args)&#123; ParkTicket pt = new ParkTicket(); double originalPrice = 100; pt.setPrice(originalPrice); System.out.println(&quot;原始价为：&quot; + originalPrice); Discount discount = new StudentDiscount(); pt.setDiscount(discount); //注入折扣对象 System.out.println(&quot;折后价为：&quot; + pt.getPrice()); &#125; &#125; //环境类:公园票价 class ParkTicket &#123; private double price; private Discount discount; //维持一个对抽象折扣类的引用 public void setPrice(double price) &#123; this.price = price; &#125; //注入一个折扣类对象 public void setDiscount(Discount discount) &#123; this.discount = discount; &#125; public double getPrice() &#123; //调用折扣类的折扣价计算方法 return discount.calculate(this.price); &#125; &#125; //抽象策略类：折扣类 interface Discount &#123; public double calculate(double price); &#125; //具体策略类：学生票折扣类 class StudentDiscount implements Discount &#123; public double calculate(double price) &#123; System.out.println(&quot;学生票：&quot;); return price * 0.8; &#125; &#125; //具体策略类：老人票折扣类 class OldManDiscount implements Discount &#123; public double calculate(double price) &#123; System.out.println(&quot;老人票：&quot;); return price - 10; &#125; &#125; 策略模式定义了一系列算法，并将每一个算法封装起来，而且是他们之间可以相互切换。 安卓实例 第三方的：Glide的缓存策略，ImageLoader的生成图片文件的命名策略，timber日志打印工具的策略，OKhttp部分 源码里面：属性动画setInterpolator差值器；RecyclerView:setLayoutManager可以是ListView样式或者是GirdView样式等等。 观察者模式场景 观察者是汽车，根据被观察者红路灯，作出反应。 public class Client &#123; public static void main(String[] args)&#123; //观察者 Observer bigCar = new BigCar(); Observer smallCar = new SmallCar(); //被观察者 TrafficLight trafficLight = new TrafficLight(); //关联 trafficLight.addObserver(bigCar); trafficLight.addObserver(smallCar); //目标有变化，看看观察者怎么办 trafficLight.havaRed(); trafficLight.havaGreen(); &#125; &#125; //被观察者 interface Observable &#123; //增加一个观察者 void addObserver(Observer observer); //删除一个观察者 void deleteObserver(Observer observer); //通知观察者 void notifyObservers(String context); &#125; //观察者 interface Observer &#123; //一发现􏰀人有动静，自己也要行动起来 void update(String context); &#125; //被观察者 class TrafficLight implements Observable &#123; //存放所有的观察者 private ArrayList&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); //增加观察者 public void addObserver(Observer observer) &#123; this.observerList.add(observer); &#125; //删除观察者 public void deleteObserver(Observer observer) &#123; this.observerList.remove(observer); &#125; //通知所有的观察者 public void notifyObservers(String context) &#123; for (Observer observer : observerList) &#123; observer.update(context); &#125; &#125; public void havaRed() &#123; System.out.println(&quot;红灯...&quot;); //通知所有的观察者 this.notifyObservers(&quot;红灯停车啦&quot;); &#125; public void havaGreen() &#123; System.out.println(&quot;绿灯...&quot;); this.notifyObservers(&quot;绿灯开车啦&quot;); &#125; &#125; //观察者 class BigCar implements Observer &#123; public void update(String str) &#123; System.out.println(str); this.makeCar(str); &#125; private void makeCar(String reportContext) &#123; System.out.println(&quot;我是大汽车---&gt;&quot; + reportContext); &#125; &#125; //观察者 class SmallCar implements Observer &#123; public void update(String str) &#123; System.out.println(str); this.makeCar(str); &#125; private void makeCar(String reportContext) &#123; System.out.println(&quot;我是小汽车---&gt;&quot; + reportContext); &#125; &#125; 推拉模式 推拉模式：上面是推模式，即被观察者变化的时候，推送给观察者。拉模式，即被观察者变化的时候，观察者主动查看下被观察者。可以分开使用，也可以结合使用。 原生API 继承原生API实现 import java.util.Observable; import java.util.Observer; public class Client &#123; public static void main(String[] args)&#123; //观察者 Observer bigCar = new BigCar(); Observer smallCar = new SmallCar(); //被观察者 TrafficLight trafficLight = new TrafficLight(); //关联 trafficLight.addObserver(bigCar); trafficLight.addObserver(smallCar); //目标有变化，看看观察者怎么办 trafficLight.havaRed(); trafficLight.havaGreen(); &#125; &#125; //被观察者 class TrafficLight extends Observable &#123; public void havaRed() &#123; System.out.println(&quot;红灯...&quot;); super.setChanged(); super.notifyObservers(&quot;红灯停车啦&quot;); &#125; public void havaGreen() &#123; System.out.println(&quot;绿灯...&quot;); super.setChanged(); super.notifyObservers(&quot;绿灯开车啦&quot;); &#125; &#125; //观察者 class BigCar implements Observer &#123; private void makeCar(String reportContext) &#123; System.out.println(&quot;我是大汽车---&gt;&quot; + reportContext); &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(arg.toString()); this.makeCar(arg.toString()); &#125; &#125; //观察者 class SmallCar implements Observer &#123; private void makeCar(String reportContext) &#123; System.out.println(&quot;我是小汽车---&gt;&quot; + reportContext); &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(arg.toString()); this.makeCar(arg.toString()); &#125; &#125; 安卓实例 ListView的Adapter的setDataChange方法。给Adapter注册一个mDataSetObserver。 mAdapter.registerDataSetObserver(mDataSetObserver); 代理模式静态代理 目标接口、代理对象、被代理的对象。 /** * 银行办理业务 - 目标接口（业务） */ public interface IBank &#123; /*** 申请办卡*/ public void applyBank(); /*** 挂失*/ public void lostBank(); &#125; /** * 银行办理业务 - 代理对象 - 银行的业务员 */ public class BankWorker implements IBank&#123; private IBank bank; /** * 持有被代理的对象 * @param bank */ public BankWorker(IBank bank)&#123; this.bank = bank; &#125; @Override public void applyBank() &#123; System.out.println(&quot;开始受理&quot;); bank.applyBank(); System.out.println(&quot;操作完毕&quot;); &#125; @Override public void lostBank() &#123; System.out.println(&quot;开始受理&quot;); bank.lostBank(); System.out.println(&quot;操作完毕&quot;); &#125; &#125; /** * 银行办理业务 - 被代理的对象 - 我们 */ public class Man implements IBank &#123; private String name; public Man(String name) &#123; this.name = name; &#125; /** * 自己的一些操作 */ @Override public void applyBank() &#123; System.out.println(name + &quot; 申请办卡&quot;); &#125; @Override public void lostBank() &#123; System.out.println(name + &quot; 申请挂失&quot;); &#125; &#125; public class Client &#123; public static void main(String[] args)&#123; Man man = new Man(&quot;张三&quot;); BankWorker bankWorker = new BankWorker(man); bankWorker.applyBank(); &#125; &#125; 动态代理 形式 Proxy.newProxyInstance( IBank.class.getClassLoader(),//ClassLoader new Class&lt;?&gt;[]&#123;IBank.class&#125;,//目标接口 null//InvocationHandler-关键 ); 代码 /** * 银行办理业务 - 动态代理 - InvocationHandler */ public class BankInvocationHandler implements InvocationHandler&#123; /** * 被代理的对象 */ private Object mObject; public BankInvocationHandler(Object object)&#123; this.mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 执行方法 ，目标接口调用的方法都会来到这里面 // System.out.println(&quot;methodName = &quot;+method.getName()); System.out.println(&quot;开始受理&quot;); // System.out.println(&quot;params = &quot;+args.toString()); // 调用被代理对象的方法,这里其实调用的就是 man 里面的 applyBank 方法 Object voidObject = method.invoke(mObject,args); System.out.println(&quot;操作完毕&quot;); return voidObject; &#125; &#125; public class Client &#123; public static void main(String[] args) &#123; Man man = new Man(&quot;张三&quot;); IBank bank = // 返回的是 IBank 的一个实例对象，这个对象是由 Java 给我们创建的 ,调用的是 jni (IBank) Proxy.newProxyInstance( IBank.class.getClassLoader(), // ClassLoader new Class&lt;?&gt;[]&#123;IBank.class&#125;, // 目标接口 new BankInvocationHandler(man) // InvocationHandler (这个类是关键) ); // 当调用这个方法的时候会来到 BankInvocationHandler 的 invoke 方法 bank.applyBank(); bank.lostBank(); bank.extraBank(); &#125; &#125; /** * 银行办理业务 - 目标接口（业务） */ public interface IBank &#123; /** * 申请办卡 */ public void applyBank(); /** * 挂失 */ public void lostBank(); /** * 额外业务 */ public void extraBank(); &#125; /** * 银行办理业务 - 被代理的对象 - 我们 */ public class Man implements IBank &#123; private String name; public Man(String name)&#123; this.name = name; &#125; /** * 自己的一些操作 */ @Override public void applyBank() &#123; System.out.println(name + &quot; 申请办卡&quot;); &#125; @Override public void lostBank() &#123; System.out.println(name + &quot; 申请挂失&quot;); &#125; @Override public void extraBank() &#123; System.out.println(name + &quot; 额外业务&quot;); &#125; &#125; 开发用到的地方 Android 插件化架构之绕过 AndroidManifest 检测（动态代理） Android 数据库实现数据的懒加载（静态代理） Android MVP 架构设计（静态代理和动态代理） Android Xutils 实现 View 事件注入（动态代理） Android Retrofit 的 create 创建接口对象 （动态代理） Android Framework 层的 AMS Android Framework 层的 Binder 驱动 Retrofit的create public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; // 验证当前类是否是接口 Utils.validateServiceInterface(service); //有需要的话做方法缓存？ if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; // 动态代理设计模式 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; //如果调用的方法是Object的 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; // //默认进不来这个if ，平台判断 android java8 ios if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 重点*具体执行细节 // method:就是我们调用的具体的方法(例如：login方法) 去解析方法属性和参数属性吧？ ServiceMethod serviceMethod = loadServiceMethod(method); // 解析完成之后，调用OKHttp框架执行请求 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // 这个最终是 ExecutorCallAdapterFactory 里面的 CallAdapter 所以最终返回的是 ExecutorCallbackCall return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 自己实现create的思路 public &lt;T&gt; T create(Class&lt;T&gt; clazz)&#123; // 动态代理 return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class&lt;?&gt;[]&#123;clazz&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.e(&quot;TAG&quot;,method.getName()); // 如果要实现 Retrofit 一样的代码应该怎么办？ // 1. 解析方法的所有注解 比如 POST GET FormUrlEncoded 等等 // 2. 解析参数的所有注解 比如 FieldMap Part PartMap 等等 // 3. 封装成 Call 对象 // 4.返回的 Call 对象 return &quot;返回&quot;; &#125; &#125;); &#125; 通过Retrofit.create(class)方法创建出Service interface的实例，从而使得Service中配置的方法变得可用，这是Retrofit代码结构的核心。 Retrofit.create(class)方法内部，使用Proxy.newProxyInstance()方法创建Service实例。create方法会为参数中的interface创建一个对象，这个对象实现了interface中的每一个方法，并且每个方法的实现都是类似的：调用对象实例内部的一个InvocationHandler成员变量的invoke()方法，并把自己的方法信息传递进去。实质上就是动态代理：interface中的方法全部由一个另外设定的InvocationHandler对象来进行代理操作。并且，这些方法的具体实现是在运行时生成interface实例时才确定的，而不是在编译时。 invoke()方法中创建interface实例，有三行关键代码： 1、ServiceMethod的创建： ServiceMethod&lt;Object, Object&gt; serviceMethod = （ServiceMethod&lt;Object, Object&gt;）loadServiceMethod(method); 这行代码负责读取interface中原方法的信息，包括返回值、方法注解、参数类型、参数注解，并将这些信息做初步分支。 2、OkHttpCall的创建 OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCall是retrofit2.Call的子类。这行代码负责将ServiceMethod封装进retrofit2.Call对象，这个对象可以在需要的时候，例如enqueue()方法被调用的时候，利用ServiceMethod中包含的信息来创建一个okhttp3.Call对象，并调用这个okhttp3.Call对象来进行网络请求的发起，然后对结果进行预处理，如类型转换。 3、adapt()方法 return serviceMethod.callAdapter.adapt(okHttpCall); 这个方法会使用ServiceMethod中的callAdapter对象来把okHttpCall对象进行转换,生成一个新的retrofit2.Call对象，在这个新的Call对象中，后台线程发起的请求，会在相应返回后，从主线程中调用回调方法，实现线程的自动切换。 另外这个方法不止可以生成新的retrofit2.Call对象，也可以生成别的类型对象，例如RaJava的Obervable，来让Retrofit可以和RaJava结合使用。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"反射、注解、泛型","slug":"15.反射、注解、泛型","date":"2019-04-17T12:37:27.932Z","updated":"2021-03-26T14:40:26.400Z","comments":false,"path":"2019/04/17/15.反射、注解、泛型/","link":"","permalink":"http://yoursite.com/2019/04/17/15.%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"反射.java文件，通过编译，生成.class文件，再通过类加载器，加载到jdk内存中并且生成字节码对象class。 所有的反射功能都是基于我们字节码（class），一个类的class在内存中只有一份，而且class其实也是一个对象Class。 获取class对象的三种方式方式一： 通过Object继承来的方法(getClass)获取对象对应的字节码文件对象 Person p = new Person();//创建Peron对象 Class clazz = p.getClass();//1 方式二：每一个类型都具备一个class静态属性，通过该属性即可获取该类的字节码文件对象。 Class clazz = Person.class; 方式三：必须类全名,使用最多。 Class clazz = Class.forName(&quot;cn.bean.Person&quot;);//必须类全名 通过构造函数，获取对象默认构造函数 public class Person &#123; public Person() &#123; System.out.println(&quot;无参构造---&quot;); &#125; &#125; try&#123; Class clazz = Person.class; Person person = (Person)clazz.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 有参公共构造函数 public class Person &#123; private String name; public Person(String name) &#123; this.name = name; System.out.println(&quot;有参构造---&quot; + name); &#125; &#125; try&#123; Class clazz = Person.class; Constructor constructor = clazz.getConstructor(String.class); Person person = (Person)constructor.newInstance(&quot;张三&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 无参私有构造 public class Person &#123; private Person() &#123; System.out.println(&quot;无参私有构造---&quot; ); &#125; &#125; try&#123; Class clazz = Person.class; Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); Person person = (Person)constructor.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 有参私有构造 public class Person &#123; private String name; private Person(String name) &#123; this.name = name; System.out.println(&quot;有参私有构造---&quot; + name); &#125; &#125; try&#123; Class clazz = Person.class; Constructor constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); Person person = (Person)constructor.newInstance(&quot;张三&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 获取属性public class Person &#123; private String name = &quot;李四&quot;; public int age = 18; &#125; try &#123; Class clazz = Person.class; Person person = (Person) clazz.newInstance(); Field field = clazz.getField(&quot;age&quot;); int age = (int) field.get(person); Field fieldDeclared = clazz.getDeclaredField(&quot;name&quot;); fieldDeclared.setAccessible(true); String name = (String) fieldDeclared.get(person); System.out.println(name + &quot;----&quot; + age); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 方法调用获取，私有有参方法和公有无参方法 public class Person &#123; private String name = &quot;李四&quot;; public String getName() &#123; System.out.println(&quot;get:&quot; + name); return name; &#125; private void setName(String name) &#123; this.name = name; System.out.println(&quot;set:&quot; + name); &#125; &#125; try&#123; Class clazz = Person.class; Person person = (Person)clazz.newInstance(); Method methodDeclared = clazz.getDeclaredMethod(&quot;setName&quot;, String.class); methodDeclared.setAccessible(true); methodDeclared.invoke(person,&quot;张三&quot;); Method method = clazz.getMethod(&quot;getName&quot;); method.invoke(person); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 实例：调用静态属性Class clazz = Class.forName(&quot;android.app.ActivityThread&quot;); Field sCurrentActivityThreadField = clazz.getDeclaredField(&quot;sCurrentActivityThread&quot;); sCurrentActivityThreadField.setAccessible(true); //sCurrentActivityThread是静态的，可以传null Object sCurrentActivityThread = sCurrentActivityThreadField.get(null); 注解注解和反射没有什么必然联系。注解只是一个标识（标记），没有具体的功能逻辑代码。注解作用:给jvm看的，给机器看的。注解优点：开发效率高，成本低。注解缺点：耦合性大，并且不利于后期维护。 jdk5提供的注解@Override：告知编译器此方法是覆盖父类的 @Deprecated：标注过时 @SuppressWarnings：压制警告 编写一个注解关键字：@interface。属性：返回值 名称() 。 注意：如果属性的名字是value，并且注解的属性值有一个,那么在使用注解时可以省略value。 注解属性类型只能是以下几种:基本类型、String、枚举类型、注解类型、Class类型、以上类型的一维数组类型。 元注解：代表修饰注解的注解。作用：限制定义的注解的特性。 @Retention//代表注解什么时候起作用 SOURCE: 注解在源码级别可见，编程阶段 CLASS：注解在字节码文件级别可见，编译时（打包的时候） RUNTIME：注解在整个运行阶段都可见 @Target //代表注解修饰的范围：类上使用，方法上使用，字段上使用 FIELD:字段上可用此注解 METHOD:方法上可以用此注解 TYPE:类/接口上可以使用此注解 例如 @Target(ElementType.FIELD) @Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;) 注解例子 @Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface Anno &#123; int age() default 28; String[] value(); &#125; @Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface Anno2 &#123; String value(); &#125; @Anno2(&quot;张三&quot;) public class Test&#123; @Anno(value = &#123; &quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;,age = 18) public void test()&#123; &#125; &#125; default作用是设置默认值,如果设置了default,注解时候可以不传。 butterknife 用了反射没有？ 一个地方用了Class.fromName().newInstance();（new 对象的时候）。 补充@Target注解的作用目标 @Target(ElementType.TYPE) //接口、类、枚举、注解 @Target(ElementType.FIELD) //字段、枚举的常量 @Target(ElementType.METHOD) //方法 @Target(ElementType.PARAMETER) //方法参数 @Target(ElementType.CONSTRUCTOR) //构造函数 @Target(ElementType.LOCAL_VARIABLE)//局部变量 @Target(ElementType.ANNOTATION_TYPE)//注解 @Target(ElementType.PACKAGE) ///包 反射加注解实现要想解析使用了注解的类，那么该注解的Retention必须设置成Runtime。关于注解解析的实质：从注解中解析出属性值。字节码对象存在于获得注解相关的方法。 运行时注解，仿xutil获取Id（编译时注解-ButterKnife注解）: @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface ViewById &#123; int value(); &#125; public class ViewUtils &#123; public static void inject(Activity activity) &#123; // 1.获取所有的属性 Field[] fields = activity.getClass().getDeclaredFields(); // 2.过滤关于 ViewById 属性 for (Field field : fields) &#123; ViewById viewById = field.getAnnotation(ViewById.class); if(viewById != null)&#123; // 3.findViewById View view = activity.findViewById(viewById.value()); // 4.反射注入 field.setAccessible(true); try &#123; //activity 属性所在类，view 代表的是属性的值 field.set(activity,view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; @ViewById(R.id.tv) private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ViewUtils.inject(this); tv.setText(&quot;ViewById&quot;); &#125; 泛型泛型的好处：将运行时期的ClassCastException，转移到了编译时期变成了编译失败;避免了类型强转的麻烦。 缺点：泛型不能用于显性地引用运行时类型的操作之中，例如转型，instanceof和new操作。 多泛型 class MorePoint&lt;T,U,A,B,C&gt;&#123; &#125; 任意一个大写字母都可以。他们的意义是完全相同的，但为了提高可读性，大家还是用有意义的字母比较好，一般来讲，在不同的情境下使用的字母意义如下： E — Element，常用在java Collection里，如：List&lt;E&gt;,Iterator&lt;E&gt;,Set&lt;E&gt; K,V — Key，Value，代表Map的键值对 N — Number，数字 T — Type，类型，如String，Integer等等 类泛型在任何地方出现的，代表的是统一类型。创建对象时，确定泛型的类型 class ArrayList&lt;T&gt; &#123; public boolean add(T e) &#123; return false; &#125; public T get(int index) &#123; return null; &#125; &#125; 方法泛型定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;泛型类型 变量名&#125; 例如，API中的ArrayList集合中的方法： //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组 public &lt;T&gt; T[] toArray(T[] a)&#123; &#125; //使用格式：调用方法时，确定泛型的类型 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); String[] arr = new String[100]; String[] result = list.toArray(arr); 方法泛型最好与类的泛型一致,如果不一致,需要在方法上声明该泛型静态方法必须声明自己的泛型 泛型的接口//带有泛型的接口 public interface List &lt;E&gt;&#123; abstract boolean add(E e); &#125; //一种实现类,先实现接口,不理会泛型 public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123; &#125; //另一种实现类,实现接口的同时,也指定了数据类型 public class XXX implements List&lt;String&gt;&#123; &#125; 泛型的通配匹配所有的数据类型:&lt;?&gt;。 泛型的上限和下限// 上限，限制的是父类,接收BaseActivity和它的子类 public void startActivity(Class&lt;? extends BaseActivity&gt; clazz) &#123; Intent intent = new Intent(this,clazz); startActivity(intent); &#125; //下限，限制的是子类,接收BaseActivity和它的父类 public void startActivity1(Class&lt;? super BaseActivity&gt; clazz) &#123; Intent intent = new Intent(this,clazz); startActivity(intent); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"win下Fiddler和mac下charles抓包","slug":"14.win下Fiddler和mac下charles抓包","date":"2019-04-12T11:59:42.748Z","updated":"2021-03-26T14:40:22.242Z","comments":false,"path":"2019/04/12/14.win下Fiddler和mac下charles抓包/","link":"","permalink":"http://yoursite.com/2019/04/12/14.win%E4%B8%8BFiddler%E5%92%8Cmac%E4%B8%8Bcharles%E6%8A%93%E5%8C%85/","excerpt":"","text":"前戏准备：win下的Fiddler，mac下的charles，安卓手机。 手机：打开手机WIFI高级设置，代理服务器类型改为”手动”，代理服务器地址填入PC的IP地址，填入代理服务器端口值，一般默认为8888。 ip：方式一：win通过ipconfig，mac通过ifconfig，快速查询电脑ip。 方式二：顶部菜单：Fiddler右上角;charles中Help → Local IP Address。 FiddlerFiddler官网 https://www.telerik.com/fiddler 端口号设置 过滤设置 查看请求和返回数据 模拟请求 注意4中为请求头，5中为请求体。 抓取https手机自带浏览器输入ip:端口号下载证书 修改请求或返回参数 步骤：1设置修改返回数据，2去掉勾勾，3修改返回数据，4打上勾勾，5输入go回车。 charlescharles官网，30天试用 https://www.charlesproxy.com/ 端口号设置 通过菜单栏：proxy → Proxy Settings，进行查看当前或者修改当前代理端口，并且保证Enable transparent HTTP proxying被勾选。 过滤设置 菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择Include栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。 查看请求和返回数据 Structure视图模式下，所有的请求是以域名进行分类显示的;Sequence视图模式下，会将所有的网络请求都按照访问的时间从上到下进行排序。 抓取https在Mac上安装CA证书:通过顶部菜单选择：Help → SSL Proxying → Install Charles Root Certificate，来安装CA证书。 安卓手机安装Charles证书:在Charles菜单栏里点击Help — SSL Proxying — Save Charles Root Certificate，生成后缀名是.cer的文件，然后传到手机安装。 最后:双击对应证书，打开简介全部信任。 如果还是不行:设置匹配规则，菜单栏 - proxy - ssl proxy settings，重启 模拟限流网络 Proxy → Throttle Setting，勾选Enable Throttling然后在1中选择我们需要网络环境。开启限速之后，2处的小乌龟图标也会高亮，点击小乌龟，就可以关闭限速模式。 重发请求,模拟请求 在网络请求上，右键选择Repeat，即可对这个链接重新发送一遍。右键选择Compose，就可以对这个请求进行编辑。 对网络请求的任意修改后,点击Execute即可将修改后的数据直接发送出去;点击Revert就恢复到最初的数据了。 修改请求响应数据Map适合将所有的A请求，重定向到，B地址请求(Map Remote)或者本地文件(Map Local)。 设置Map Remote或者Map Local可以在，顶部菜单中选择Tools或者请求链接上右键。请求链接上，点击右键save，可以保存请求或者响应的数据文件。 Rewrite功能适合对所有网络请求做一些简单的正则匹配后，对匹配的内容进行替换。 顶部菜单栏中，选择Tools → Rewrite。图中将所有响应体中“查询新闻列表成功”替换成了“我成功啦”。1处可以添加url。 Breakpoints类似于调试的断点。每次触发 Breakpoint 都会断住两次，一次是 request、一次是 response,可以分别对请求和响应的数据进行修改。点击2处execute继续执行。 请求链接上点击右键，然后选择Breakpoints:接下来的相同url会被断点。或者点击1处的六边形，有颜色就开始对接下来的请求依次断点，直至终止。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"http://yoursite.com/tags/Fiddler/"},{"name":"charles","slug":"charles","permalink":"http://yoursite.com/tags/charles/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Vue学习笔记","slug":"13.Vue学习笔记","date":"2019-04-03T13:47:38.218Z","updated":"2021-09-04T07:56:42.741Z","comments":false,"path":"2019/04/03/13.Vue学习笔记/","link":"","permalink":"http://yoursite.com/2019/04/03/13.Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"介绍 Vue.js是一套构建用户界面的框架，只关注视图层。可以减少不必要的DOM操作，提高渲染效率。 打包工具：WebPack和Gulp。 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑。 框架：一套完整的技术解决方案，对项目侵入性较大；库（插件）：提供某一小功能，侵入性小。 mvvm MVVM是前端视图层的概念，主要关注于视图层分离，把前端的视图层分为三部分，Model(数据)、View(每个页面的HTML结构)、ViewModel(调度者，数据双向绑定，可以理解为View和Model的通信桥梁)。 引入 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; 实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Vue 实例所控制的这个元素区域，就是我们的V --&gt; &lt;div id=&quot;vue_det&quot;&gt; &lt;h1&gt;url : &#123;&#123;url&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;details()&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者 var vm = new Vue(&#123; // 表示new 的这个 Vue 实例，要控制页面上的哪个区域 el: &apos;#vue_det&apos;, // 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的 data: &#123; url: &quot;http://www.baidu.com&quot; &#125;, methods: &#123; details: function() &#123; return this.url + &quot; - 百度一下&quot;; &#125; &#125; &#125;) document.write(vm.url) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 文本插值使用双大括号: &#123;&#123; &#125;&#125; Vue调试谷歌应用商店搜索Vue.js devtools 教程https://cn.vuejs.org/v2/guide/ https://github.com/pagekit/vue-resource http://cubic-bezier.com/#.17,.67,.83,.67 指令 指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到 DOM 上。 v-cloak解决插值表达式闪烁问题，只替换占位符。 v-textv-text默认没有闪烁问题，替换内容时会把整个元素替换。 v-html用于输出html格式的，也会替换全部内容。 v-bind绑定属性的指令，用于监听DOM事件。v-bind:可以省略为:。变量加常量的效果可以实现。 v-on事件绑定机制。v-on:可以省略为@。 代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt; &lt;!-- v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 --&gt; &lt;h4 v-text=&quot;msg&quot;&gt;==================&lt;/h4&gt; &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt; &lt;div v-text=&quot;msg2&quot;&gt;&lt;/div&gt; &lt;div v-html=&quot;msg2&quot;&gt;1212112&lt;/div&gt; &lt;!-- v-bind: 是 Vue中，提供的用于绑定属性的指令 --&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot;&gt; &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt; &lt;!-- v-bind 中，可以写合法的JS表达式 --&gt; &lt;!-- Vue 中提供了 v-on: 事件绑定机制 --&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;show&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos;, msg2: &apos;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&apos;, mytitle: &apos;这是一个自己定义的title&apos; &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert(&apos;Hello&apos;) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例之跑马灯 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 导入Vue包 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;浪起来&quot; @click=&quot;lang&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;低调&quot; @click=&quot;stop&quot;&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示 我们 new 出来的 VM 实例对象 var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;猥琐发育，别浪~~！&apos;, intervalId: null // 在data上定义 定时器Id &#125;, methods: &#123; lang() &#123; if (this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.substring(0, 1) // 获取到 后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start &#125;, 400) // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 &#125;, stop() &#123; // 停止定时器 clearInterval(this.intervalId) // 每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-model 双向数据绑定，唯一的一个。v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定。 v-model可以实现表单元素和Model中数据双向绑定。 注意:只能用到在input、select、text、checkbox、radio等表单元素中。根据表单上的值，自动更新绑定的元素的值。 v-model实现简单计算器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-model=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;/&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;/&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; n1:0, n2:0, result:0, opt:&quot;+&quot; &#125;, methods:&#123; calc:function()&#123; /*switch (this.opt)&#123; case &quot;+&quot;: this.result = parseInt(this.n1)+parseInt(this.n2) break; case &quot;-&quot;: this.result = parseInt(this.n1)-parseInt(this.n2) break; case &quot;*&quot;: this.result = parseInt(this.n1)*parseInt(this.n2) break; case &quot;/&quot;: this.result = parseInt(this.n1)/parseInt(this.n2) break; &#125;*/ var codeStr =&quot;parseInt(this.n1)&quot;+ this.opt + &quot;parseInt(this.n2)&quot; this.result = eval(codeStr) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-for v-for 指令需要以site in sites形式的特殊语法， sites是源数据数组并且site是数组元素迭代的别名。 循环普通数组；循环对象数组；循环对象，包含key，value，和索引；迭代数字，从1开始。 &lt;div id=&quot;app&quot;&gt; &lt;!--循环普通数组--&gt; &lt;p v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;p v-for=&quot;(item,i) in list&quot;&gt;索引值是&#123;&#123;i&#125;&#125;，每一项是&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;!--循环对象数组--&gt; &lt;p v-for=&quot;item in list2&quot;&gt;&#123;&#123;item.id&#125;&#125;和&#123;&#123;item.name&#125;&#125;&lt;/p&gt; &lt;p v-for=&quot;(item,i) in list2&quot;&gt;索引值是&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;!--循环对象--&gt; &lt;p v-for=&quot;val in user&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/p&gt; &lt;p v-for=&quot;(val,key) in user&quot;&gt;&#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;&lt;/p&gt; &lt;p v-for=&quot;(val,key,i) in user&quot;&gt;&#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;----&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;!--迭代数字--&gt; &lt;p v-for=&quot;count in 10&quot;&gt;这是第&#123;&#123;count&#125;&#125;次&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; list:[1,2,3,4,5,6], list2:[ &#123;id:1,name:&quot;a&quot;&#125;, &#123;id:2,name:&quot;b&quot;&#125;, &#123;id:3,name:&quot;c&quot;&#125;, &#123;id:4,name:&quot;d&quot;&#125; ], user:&#123; id:1, name:&quot;张三&quot;, sex:&quot;男&quot; &#125; &#125; &#125;) &lt;/script&gt; 注意：在2.2.0+的版本里，当在组件中使用v-for时，key是必须的。key属性只能使用number或者string，必须使用v-bind属性绑定的形式，指定key的值。 &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;/p&gt; v-if和v-show 根据表达式的值来决定是否插入元素。 v-if每次都会重新删除或者创建元素，切换消耗性能；v-show只是切换了元素display:none样式，较高的初始渲染消耗。 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;flag=!flag&quot; value=&quot;toggle&quot;/&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是v-if控制&lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是v-show控制&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; flag:true &#125; &#125;) &lt;/script&gt; v-else-if和v-else的使用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B &lt;/div&gt; &lt;div v-else&gt; Not A/B &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; type: &apos;C&apos; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 事件修饰符 修饰符是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 .stop阻止事件冒泡 .prevent阻止默认事件 .capture捕获事件 .self只当事件在该元素本身触发时，触发回调。只会阻止自己身上冒泡行为的触发，并不会真正阻止冒泡行为。 .once事件只触发一次 代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .inner&#123; height: 150px; background-color: darkcyan; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;div1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;百度&lt;/a&gt; &lt;div class=&quot;inner&quot; @click.capture=&quot;div1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;div1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;百度&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; div1:function()&#123; console.log(&quot;div1click&quot;) &#125;, btn:function()&#123; console.log(&quot;btnclick&quot;) &#125;, linkClick:function()&#123; console.log(&quot;btnclick&quot;) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 样式class样式 格式： &lt;div id=&quot;app&quot;&gt; &lt;!--直接绑定--&gt; &lt;h1 v-bind:class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,&apos;类名3&apos;]&quot;&gt;&lt;/h1&gt; &lt;!--直接绑定，简写--&gt; &lt;h1 :class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,&apos;类名3&apos;]&quot;&gt;&lt;/h1&gt; &lt;!--三元运算--&gt; &lt;h1 :class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,flag?&apos;类名3&apos;:&apos;&apos;]&quot;&gt;&lt;/h1&gt; &lt;!--嵌套对象--&gt; &lt;h1 :class=&quot;[&apos;类名1&apos;,&apos;类名2&apos;,&#123;&apos;类名3&apos;:flag&#125;]&quot;&gt;&lt;/h1&gt; &lt;!--使用对象--&gt; &lt;h1 :class=&quot;&#123;类名1:true,类名2:true,类名3:true&#125;&quot;&gt;&lt;/h1&gt; &lt;!--抽取对象--&gt; &lt;h1 :class=&quot;classObj&quot;&gt;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; flag: true, classObj:&#123;类名1:true,类名2:true,类名3:true&#125; &#125; &#125;) &lt;/script&gt; 代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;h1 class=&quot;red thin&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用 v-bind 做数据绑定 --&gt; &lt;!-- &lt;h1 :class=&quot;[&apos;thin&apos;, &apos;italic&apos;]&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;!-- &lt;h1 :class=&quot;[&apos;thin&apos;, &apos;italic&apos;, flag?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用 对象来代替三元表达式，提高代码的可读性 --&gt; &lt;!-- &lt;h1 :class=&quot;[&apos;thin&apos;, &apos;italic&apos;, &#123;&apos;active&apos;:flag&#125; ]&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名，由于 对象的属性可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt; &lt;h1 :class=&quot;classObj&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 内联样式 &lt;div id=&quot;app&quot;&gt; &lt;!--直接绑定--&gt; &lt;h1 :style=&quot;&#123;color:&apos;red&apos;,&apos;font-weight&apos;:200&#125;&quot;&gt;哈哈哈&lt;/h1&gt; &lt;!--data--&gt; &lt;h1 :style=&quot;styleObj1&quot;&gt;哈哈哈&lt;/h1&gt; &lt;!--多个data--&gt; &lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;哈哈哈&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; styleObj1 : &#123;color:&apos;red&apos;,&apos;font-weight&apos;:200&#125;, styleObj2 : &#123;&apos;font-style&apos;:&apos;italic&apos;&#125;, &#125; &#125;) &lt;/script&gt; 过滤器 Vue允许你自定义过滤器，被用作一些常见的文本格式化。过滤器可以用在两个地方：双括号插值和v-bind表达式，过滤器应该被添加在js表达式的尾部，由管道符(|)提示。 过滤器中function第一个参数已经被规定死了：永远是管道符前面传递过来的数据。 全局过滤器和私有过滤器： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message | data1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; message | data2(\"嘻嘻\")&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; message | data1 | data3&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; message | data4 &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; //方式一：全局过滤器 Vue.filter(&apos;data1&apos;,function(value)&#123; return value+&quot;嘻嘻&quot; &#125;) //方式二：可以多个参数 Vue.filter(&apos;data2&apos;,function(value,arg1)&#123; return value+arg1 &#125;) //方式三：可以多次调用 Vue.filter(&apos;data3&apos;,function(value)&#123; return value+&quot;哈哈&quot; &#125;) new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;哈哈哈&apos; &#125;, //方式四：私有过滤器 filters: &#123; data4: function (value) &#123; return value+&quot;嘻嘻&quot; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=&#39;&#39;) 或 String.prototype.padEnd(maxLength, fillString=&#39;&#39;)来填充字符串。 自定义键盘修饰符 Vue.config.keyCodes.f2 = 113 自定义指令 和js相关的最好在inserted中执行；和样式相关的，一般在bind中执行。 Vue.directive: Vue.directive(&apos;focus&apos;, &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) 全局指令和私有指令。自定义指令下的钩子函数。 https://cn.vuejs.org/v2/guide/custom-directive.html 私有指令： var vm2 = new Vue(&#123; el: &apos;#app&apos;, data: &#123; &#125;, methods: &#123;&#125;, filters: &#123; // 定义私有过滤器 过滤器有两个 条件 【过滤器名称 和 处理函数】 &#125;, directives: &#123; // 自定义私有指令 &#125; &#125;) 简写方式： directives: &#123; // 自定义私有指令 &apos;fontsize&apos;: function (el, binding) &#123; // 注意：这个 function 等同于 把 代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + &apos;px&apos; &#125; &#125; vue实例的生命周期 生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。生命周期钩子 = 生命周期函数 = 生命周期事件。 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性。 created：实例已经在内存中创建好，此时data和methods已经创建好，此时还没有开始编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数：当data改变时候才会执行 beforeUpdate：状态更新之前执行此函数， 此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 代码： // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;ok&apos; &#125;, methods: &#123; show() &#123; console.log(&apos;执行了show方法&apos;) &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created() &#123; // 这是遇到的第二个生命周期函数 // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, beforeMount() &#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 // console.log(document.getElementById(&apos;h3&apos;).innerText)//&#123;&#123;msg&#125;&#125; // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 // console.log(document.getElementById(&apos;h3&apos;).innerText) // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate() &#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 /* console.log(&apos;界面上元素的内容：&apos; + document.getElementById(&apos;h3&apos;).innerText) console.log(&apos;data 中的 msg 数据是：&apos; + this.msg) */ // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated() &#123; console.log(&apos;界面上元素的内容：&apos; + document.getElementById(&apos;h3&apos;).innerText) console.log(&apos;data 中的 msg 数据是：&apos; + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125; &#125;); 页面初始化可以在created中请求网络。 vue-resource实现网络请求 https://github.com/pagekit/vue-resource 直接在页面中，通过script标签，引入vue-resource的脚本文件,注意：引用的先后顺序是：先引用Vue的脚本文件，再引用vue-resource的脚本文件； &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-resource@1.5.1&quot;&gt;&lt;/script&gt; 发送get请求： getInfo() &#123; // get 方式获取数据 this.$http.get(&apos;url&apos;).then(res =&gt; &#123; console.log(res.body); &#125;) &#125; 发送post请求： postInfo() &#123; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: &apos;zs&apos; &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;); &#125; 发送JSONP请求获取数据： jsonpInfo() &#123; // JSONP形式从服务器获取数据 this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;); &#125; JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程：- 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 除了vue-resource之外，axios也可以实现数据请求。 全局配置 // 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则 不会启用根路径做拼接； Vue.http.options.root = &apos;http://vue.studyit.io/&apos;; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; 练习-品牌案例 需要bootstra样式 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/bootstrap-3.3.7.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body form-inline&quot;&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; class=&quot;btn btn-primary&quot; @click=&quot;add()&quot;&gt; &lt;label&gt; 搜索名称关键字： &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;keywords&quot; id=&quot;search&quot; v-focus v-color=&quot;&apos;green&apos;&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;item in search(keywords)&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td v-text=&quot;item.name&quot;&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime | dateFormat() &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&apos;dateFormat&apos;, function (dateStr, pattern = &quot;&quot;) &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 // 使用 Vue.directive() 定义全局的指令 v-focus // 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 // 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(&apos;focus&apos;, &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) // 自定义一个 设置字体颜色的 指令 Vue.directive(&apos;color&apos;, &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = &apos;red&apos; // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; id: &apos;&apos;, name: &apos;&apos;, keywords: &apos;&apos;, // 搜索的关键字 list: [ &#123; id: 1, name: &apos;奔驰&apos;, ctime: new Date() &#125;, &#123; id: 2, name: &apos;宝马&apos;, ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; // 添加的方法 var car = &#123; id: this.id, name: this.name, ctime: new Date() &#125; this.list.push(car) this.id = this.name = &apos;&apos; &#125;, del(id) &#123; // 根据Id删除数据 var index = this.list.findIndex(item =&gt; &#123; if (item.id == id) &#123; return true; &#125; &#125;) this.list.splice(index, 1) &#125;, search(keywords) &#123; // 根据关键字，进行数据的搜索 /* var newList = [] this.list.forEach(item =&gt; &#123; if (item.name.indexOf(keywords) != -1) &#123; newList.push(item) &#125; &#125;) return newList */ // 注意： forEach some filter findIndex 这些都属于数组的新方法， // 都会对数组中的每一项，进行遍历，执行相关的操作； return this.list.filter(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes(&apos;要包含的字符串&apos;) // 如果包含，则返回 true ，否则返回 false // contain if (item.name.includes(keywords)) &#123; return item &#125; &#125;) // return newList &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的动画 https://cn.vuejs.org/v2/guide/transitions.html 使用Vue官方提供的transition元素，把需要被动画控制的元素，包裹起来。v-enter和v-leave-to：是一个时间点，是进入之前，元素的起始状态，此时还没有开始进入。v-enter-active：入场动画的时间段。v-leave-active：离场动画的时间段。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to&#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active&#123; transition: all 0.8s ease; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;我是h3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag:false &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 自定义v-前缀 给transition加个name属性 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .my-enter, .my-leave-to&#123; opacity: 0; transform: translateX(150px); &#125; .my-enter-active, .my-leave-active&#123; transition: all 0.8s ease; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;transition name=&quot;my&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;我是h3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag:false &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用第三方animate.css类库实现动画官网 https://daneden.github.io/animate.css/ 举个栗子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/animate.css@3.5.2/animate.min.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :duration=&quot;&#123; enter: 200, leave: 400&#125;&quot;&gt; &lt;h3 v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;我是h3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag:false &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 动画钩子https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90 动画钩子函数的第一个参数：el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象。可以认为，el是通过document.getElementById(‘’) 方式获取到的原生JS DOM对象。 beforeEnter 表示动画入场之前，此时，动画尚未开始，可以在beforeEnter中，设置元素开始动画之前的起始样式 enter表示动画开始之后的样式，这里可以设置小球完成动画之后的，结束状态 el.offsetWidth没有实际的作用，但是，如果不写，出不来动画效果 done，起始就是afterEnter这个函数，也就是说：done是afterEnter函数的引用 动画完成之后，会调用afterEnter 举个例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;购物车&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag:false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.transform = &quot;translate(0, 0)&quot; &#125;, enter: function (el, done) &#123; el.offsetWidth el.style.transform = &quot;translate(150px, 450px)&quot; el.style.transition = &apos;all 1s ease&apos; done() &#125;, afterEnter: function (el) &#123; this.flag = !this.flag &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-for的列表过渡在实现列表过渡的时候，如果需要过渡的元素，是通过v-for循环渲染出来的，不能使用transition包裹，需要使用transitionGroup。如果要为 v-for循环创建的元素设置动画，必须为每一个元素设置 :key 属性。给transition-group添加appear属性，实现页面刚展示出来时候，入场时候的效果。通过为transition-group元素，设置tag属性，指定transition-group渲染为指定的元素，如果不指定tag属性，默认渲染为span标签。 &lt;transition-group&gt;组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的v-move特性，它会在元素的改变定位的过程中应用。v-move和v-leave-active结合使用，能够让列表的过渡更加平缓柔和。 举个例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; .v-move &#123; transition: all 0.6s ease; &#125; .v-leave-active &#123; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; id: &apos;&apos;, name: &apos;&apos;, list: [ &#123;id: 1, name: &apos;Tom&apos;&#125;, &#123;id: 2, name: &apos;Jim&apos;&#125;, &#123;id: 3, name: &apos;Lucy&apos;&#125; ] &#125;, methods: &#123; add: function () &#123; this.list.push(&#123;id: this.id, name: this.name&#125;) this.id = this.name = &apos;&apos; &#125;, del: function (i) &#123; this.list.splice(i, 1) &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件 组件：以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可。 组件化：是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 模块化：是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一。 全局组件定义的三种方式 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;my-com1&gt;&lt;/my-com1&gt; &lt;mycom1&gt;&lt;/mycom1&gt; &lt;mycom2&gt;&lt;/mycom2&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;mycom4&gt;&lt;/mycom4&gt; &lt;/div&gt; &lt;!-- 在被控制的 #app 外面,使用template元素,定义组件的HTML模板结构 --&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;h4&gt;好用,不错!&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //方式一： //1.1 使用 Vue.extend 来创建全局的Vue组件 var com1 = Vue.extend(&#123; template: &apos;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&apos; // 通过 template 属性，指定了组件要展示的HTML结构 &#125;) // 1.2 使用 Vue.component(&apos;组件的名称&apos;, 创建出来的组件模板对象) Vue.component(&apos;myCom1&apos;, com1) // 如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 链接； // 如果不使用驼峰,则直接拿名称来使用即可; Vue.component(&apos;mycom1&apos;, com1) // Vue.component 第一个参数:组件的名称,将来在引用组件的时候,就是一个 标签形式 来引入 它的；第二个参数: Vue.extend 创建的组件 Vue.component(&apos;mycom2&apos;, Vue.extend(&#123; template: &apos;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&apos; &#125;)) //方式二： // 注意:不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素 Vue.component(&apos;mycom3&apos;, &#123; template: &apos;&lt;div&gt;&lt;h3&gt;这是直接使用 Vue.component 创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;&apos; &#125;) // 方式三： Vue.component(&apos;mycom4&apos;, &#123; template: &apos;#tmpl&apos; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意:不论是哪种方式创建出来的组件,组件的template属性指向的模板内容,必须有且只能有唯一的一个根元素。 私有组件定义 通过components定义私有组件： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;template id=&quot;tmpl2&quot;&gt; &lt;h3&gt;这是私有组件&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, components: &#123; // 定义实例内部私有组件的 login: &#123; //方式一： // template: &apos;&lt;h3&gt;这是私有组件&lt;/h3&gt;&apos;, //方式二： template: &apos;#tmpl2&apos; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件中的data和methods 组件可以有自己的data数据，实例中的data可以为一个对象,但是组件中的data必须是一个方法，这个方法内部,还必须返回一个对象才行。组件中 的data数据,使用方式,和实例中的data使用方式完全一样。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;+1&quot; @click=&quot;increment&quot;&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component(&apos;counter&apos;, &#123; template: &apos;#tmpl&apos;, data: function () &#123; // return dataObj return &#123; count: 0 &#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件切换 v-if方式切换： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=true&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt;&lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;login&apos;, &#123; template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; &#125;) Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag: false &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用component元素实现：component是一个占位符,:is属性可以用来指定要展示的组件的名称 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&apos;login&apos;, &#123; template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; &#125;) Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; comName: &apos;login&apos; // 当前 component 中的 :is 绑定的组件的名称 &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件切换动画 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/animate.css@3.5.2/animate.min.css&quot;/&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;!-- 通过 mode 属性,设置组件切换时候的模式 --&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&apos;login&apos;, &#123; template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; &#125;) Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; comName: &apos;login&apos; // 当前 component 中的 :is 绑定的组件的名称 &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父组件向子组件传值 组件中，默认无法访问到父组件中的data上的数据和methods中的方法。父组件可以在引用子组件的时候，通过属性绑定v-bind:的形式, 把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用。组件中的所有props中的数据，都是通过父组件传递给子组件的。 注意：props中的数据，都是只读的，无法重新赋值。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;com1 v-bind:parentmsg=&quot;msg&quot;&gt;&lt;/com1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;这是父组件中的数据&apos; &#125;, components: &#123; com1: &#123; template: &apos;&lt;h1 @click=&quot;change&quot;&gt;这是子组件 --- &#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;&apos;, props: [&apos;parentmsg&apos;]// 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父组件向子组件传方法父组件向子组件传递方法，使用的是事件绑定机制：v-on, 当我们自定义了一个事件属性之后，那么子组件就能够通过某些方式，来调用传递进去的 这个方法了。子组件通过$emit调用父组件方法。 子组件调用父组件的方法，并传值： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;子组件按钮-触发父组件传递过来的方法&quot; @click=&quot;myclick&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var com2 = &#123; template: &apos;#tmpl&apos;, data() &#123; return &#123; sonmsg: &#123; name: &apos;子组件data&apos;, age: 16 &#125; &#125; &#125;, methods: &#123; myclick() &#123; this.$emit(&apos;func&apos;, this.sonmsg) &#125; &#125; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123; this.datamsgFormSon = data console.log(this.datamsgFormSon) &#125; &#125;, components: &#123; com2 &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件案例-评论功能实现存放在localStorage中。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;cmt-box @func=&quot;loadComments&quot;&gt;&lt;/cmt-box&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;span class=&quot;badge&quot;&gt;评论人： &#123;&#123; item.user &#125;&#125;&lt;/span&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;发表评论&quot; class=&quot;btn btn-primary&quot; @click=&quot;postComment&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = &#123; data() &#123; return &#123; user: &apos;&apos;, content: &apos;&apos; &#125; &#125;, template: &apos;#tmpl&apos;, methods: &#123; postComment() &#123; var comment = &#123; id: Date.now(), user: this.user, content: this.content &#125; // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) list.unshift(comment) // 重新保存最新的 评论数据 localStorage.setItem(&apos;cmts&apos;, JSON.stringify(list)) this.user = this.content = &apos;&apos; this.$emit(&apos;func&apos;) &#125; &#125; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; list: [] &#125;, created()&#123; this.loadComments() &#125;, methods: &#123; loadComments() &#123; // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) this.list = list &#125; &#125;, components: &#123; &apos;cmt-box&apos;: commentBox &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过refs获取元素和组件&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素&quot; @click=&quot;getElement&quot; ref=&quot;mybtn&quot;&gt; &lt;h3 ref=&quot;myh3&quot;&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;login ref=&quot;mylogin&quot;&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;, data() &#123; return &#123; msg: &apos;son msg&apos; &#125; &#125;, methods: &#123; show() &#123; console.log(&apos;调用了子组件的方法&apos;) &#125; &#125; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123; getElement() &#123; console.log(this.$refs.myh3.innerText) console.log(this.$refs.mylogin.msg) this.$refs.mylogin.show() &#125; &#125;, components: &#123; login &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 路由后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由。 网站介绍 https://router.vuejs.org/zh/ 基本使用router-view是vue-router提供的元素，专门用来当作占位符的，匹配到的组件，就会展示到router-view中去。 routes:路由匹配规则，每个路由规则，都是一个对象，有两个必须的属性： 属性1是path，表示监听哪个路由链接地址；属性2是component，表示，如果路由是前面匹配到的path，则展示component属性对应的那个组件。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; &#125; var register = &#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125; var routerObj = new VueRouter(&#123; routes: [ &#123;path: &apos;/login&apos;, component: login&#125;, &#123;path: &apos;/register&apos;, component: register&#125; ] &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; router-link&lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 重定向routes: [ // 路由匹配规则 &#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ] 选中路由高亮方式一：router-link标签中，默认情况 &lt;style&gt; .router-link-active&#123; color: red; font-weight: 800; font-style: italic; font-size: 18px; text-decoration: underline; &#125; &lt;/style&gt; 方式二：修改router-link-active为myactive，然后再定义样式 var routerObj = new VueRouter(&#123; linkActiveClass: &apos;myactive&apos; &#125;) 路由传参方式一：query方式传递参数 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;h1&gt;登录组件 --- &#123;&#123; $route.query.id &#125;&#125; --- &#123;&#123; $route.query.name &#125;&#125;&lt;/h1&gt;&apos;, created()&#123; // 组件的生命周期钩子函数 console.log(this.$route.query.id) &#125; &#125; var register = &#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125; var routerObj = new VueRouter(&#123; routes: [ &#123;path: &apos;/login&apos;, component: login&#125; ] &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方式二：params方式传递参数 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login/10/zs&quot;&gt;登录&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;h1&gt;登录组件 --- &#123;&#123; $route.params.id &#125;&#125; --- &#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;&apos;, created()&#123; // 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125; &#125; var register = &#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125; var routerObj = new VueRouter(&#123; routes: [ &#123;path: &apos;/login/:id/:name&apos;, component: login&#125; ] &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 路由嵌套使用children属性，实现子路由。同时，子路由的path前面，不要带/，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var account = &#123; template: &apos;#tmpl&apos; &#125; var login = &#123; template: &apos;&lt;h3&gt;登录&lt;/h3&gt;&apos; &#125; var register = &#123; template: &apos;&lt;h3&gt;注册&lt;/h3&gt;&apos; &#125; var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/account&apos;, component: account, children: [ &#123; path: &apos;login&apos;, component: login &#125;, &#123; path: &apos;register&apos;, component: register &#125; ] &#125; ] &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 命名视图实现经典布局&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; .header &#123; background-color: orange; height: 80px; &#125; h1 &#123; margin: 0; padding: 0; font-size: 16px; &#125; .container &#123; display: flex; height: 600px; &#125; .left &#123; background-color: lightgreen; flex: 2; &#125; .main &#123; background-color: lightpink; flex: 8; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var header = &#123; template: &apos;&lt;h1 class=&quot;header&quot;&gt;Header头部区域&lt;/h1&gt;&apos; &#125; var leftBox = &#123; template: &apos;&lt;h1 class=&quot;left&quot;&gt;Left侧边栏区域&lt;/h1&gt;&apos; &#125; var mainBox = &#123; template: &apos;&lt;h1 class=&quot;main&quot;&gt;mainBox主体区域&lt;/h1&gt;&apos; &#125; var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; &apos;default&apos;: header, &apos;left&apos;: leftBox, &apos;main&apos;: mainBox &#125; &#125; ] &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; watch可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstname: &apos;&apos;, lastname: &apos;&apos;, fullname: &apos;&apos; &#125;, methods: &#123;&#125;, watch: &#123; &apos;firstname&apos;: function (newVal, oldVal) &#123; // this.fullname = this.firstname + &apos;-&apos; + this.lastname this.fullname = newVal + &apos;-&apos; + this.lastname &#125;, &apos;lastname&apos;: function (newVal) &#123; this.fullname = this.firstname + &apos;-&apos; + newVal &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; watch监视路由地址的改变 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;h3&gt;这是登录子组件&lt;/h3&gt;&apos; &#125; var register = &#123; template: &apos;&lt;h3&gt;这是注册子组件&lt;/h3&gt;&apos; &#125; var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ] &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, // router: router router, watch: &#123; &apos;$route.path&apos;: function (newVal, oldVal) &#123; // console.log(newVal + &apos; --- &apos; + oldVal) if (newVal === &apos;/login&apos;) &#123; console.log(&apos;欢迎进入登录页面&apos;) &#125; else if (newVal === &apos;/register&apos;) &#123; console.log(&apos;欢迎进入注册页面&apos;) &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; computed计算属性计算属性关键词:computed。computed是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用methods，在重新渲染的时候，函数总会重新调用执行。 在computed中，可以计算属性，本质是一个方法，只不过，我们在使用这些计算属性的时候，是把它们的名称，直接当作属性来使用的,并不会把计算属性，当作方法去调用。 可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;middlename&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstname: &apos;&apos;, lastname: &apos;&apos;, middlename: &apos;&apos; &#125;, methods: &#123;&#125;, computed: &#123; &apos;fullname&apos;: function () &#123; console.log(&apos;ok&apos;) return this.firstname + &apos;-&apos; + this.middlename + &apos;-&apos; + this.lastname &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； webpackwebpack可以解决各个包之间的复杂依赖关系。webpack是基于Node.js开发出来的一个前端项目自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 使用Gulp，是基于task任务的；使用Webpack，是基于整个项目进行构建的。 官网 http://webpack.github.io/ webpack安装的两种方式运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 配置文件打包命令创建webpack.config.js文件： // 导入处理路径的模块 var path = require(&apos;path&apos;); // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = &#123; entry: path.join(__dirname, &apos;src/js/main.js&apos;), // 项目入口文件 output: &#123; // 配置输出选项 path: path.join(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 &#125; &#125; 最后控制台执行webpack。 webpack-dev-server实时打包构建使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 在package.json文件中，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，然后执行npm run dev,发现可以进行实时打包。 但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快。 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了直接访问到index首页，可以指定启动的根目录： &quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 配置package.json修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新，--contentBase src表示直接访问到index首页： &quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open --contentBase src&quot; 配置webpack.config.jswebpack.config.js文件，新增devServer节点如下： devServer:&#123; hot:true, open:true, port:4321, contentBase:&apos;src&apos; &#125; 在头部引入webpack模块： var webpack = require(&apos;webpack&apos;); 在plugins节点下新增： plugins:[ new webpack.HotModuleReplacementPlugin() ] Vue2.5开发去哪儿网AppTODOList 指令，组件化，父子组件的传值，的使用： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TODOList&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-item v-bind:content=&quot;item&quot; v-bind:index = &quot;index&quot; v-for=&quot;(item, index) in list&quot; @delete=&quot;handleItemDelete&quot;&gt; &lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //全局组件 // Vue.component(&quot;TodoItem&quot;, &#123; // props: [&apos;content&apos;], // template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot; // &#125;) //局部组件 var TodoItem = &#123; props: [&apos;content&apos;,&apos;index&apos;], template: &quot;&lt;li @click=&apos;handleItemDelete&apos;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;, methods: &#123; handleItemDelete: function ()&#123; this.$emit(&quot;delete&quot;, this.index); &#125; &#125; &#125; var app = new Vue(&#123; el: &quot;#app&quot;, //局部组件-注册 components: &#123; TodoItem: TodoItem &#125;, data: &#123; list: [], inputValue: &quot;&quot; &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.inputValue) this.inputValue = &apos;&apos; &#125;, handleItemDelete: function (index)&#123; this.list.splice(index, 1) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; setter和getter setter和getter: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot; &#125;, computed: &#123; fullName: &#123; get: function ()&#123; return this.firstName + &quot; &quot; + this.lastName &#125;, set: function (value)&#123; var arr = value.splice(&quot; &quot;); this.firstName = arr[0]; this.lastName = arr[1]; &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 样式的绑定 点击颜色切换。 class方式一：定义class的名字是activated，但是class是否有名字是根据isActivated： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .activated &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div @click=&quot;handleDivClick&quot; :class=&quot;&#123;activated: isActivated&#125;&quot;&gt; Hello World &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; isActivated: false &#125;, methods: &#123; handleDivClick: function ()&#123; this.isActivated = !this.isActivated &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; class方式二：定义class的名字的key是activated，切换名字的value是否为activated和空值： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .activated &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div @click=&quot;handleDivClick&quot; :class=&quot;[activated]&quot;&gt; Hello World &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; activated: &quot;&quot; &#125;, methods: &#123; handleDivClick: function ()&#123; this.activated = this.activated === &quot;activated&quot; ? &quot;&quot; : &quot;activated&quot; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 内联style样式，方式一： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div @click=&quot;handleDivClick&quot; :style=&quot;styleObj&quot;&gt; Hello World &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; styleObj: &#123; color: &quot;black&quot; &#125; &#125;, methods: &#123; handleDivClick: function () &#123; this.styleObj.color = this.styleObj.color === &quot;black&quot; ? &quot;red&quot; : &quot;black&quot; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 内联style样式，方式二： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div @click=&quot;handleDivClick&quot; :style=[styleObj]&gt; Hello World &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; styleObj: &#123; color: &quot;black&quot; &#125; &#125;, methods: &#123; handleDivClick: function () &#123; this.styleObj.color = this.styleObj.color === &quot;black&quot; ? &quot;red&quot; : &quot;black&quot; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件化中的is 组件化中的is使用：当某些标签下必须要固定标签，这时候使用组件化，可以用is： 比如table下的tr，ul下的li，ol下的li，select下的option，等等 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; Vue.component( &quot;row&quot;,&#123; template: &quot;&lt;tr&gt;&lt;td&gt;this is a row&lt;/td&gt;&lt;/tr&gt;&quot; &#125; ) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件化中的refs 子组件通过change通知父组件发生改变，利用refs获取document： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter ref=&quot;one&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt; &lt;counter ref=&quot;two&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component( &quot;counter&quot;,&#123; template: &quot;&lt;div @click=&apos;handlerClick&apos;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&quot;, data: function ()&#123; return &#123;number: 0&#125; &#125;, methods: &#123; handlerClick: function ()&#123; this.number ++ this.$emit(&apos;change&apos;) &#125; &#125; &#125; ) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; total: 0 &#125;, methods: &#123; handleChange: function ()&#123; this.total = this.$refs.one.number + this.$refs.two.number &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父子组件之间传值 父组件通过属性形式，向子组件传值，子组件通过props接收。 单向数据流：父组件向子组件传值的参数，子组件不要修改，可以让子组件用变量接收后，子组件修改变量。 子组件向父组件传值，通过emit事件的形式。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter :count=&quot;3&quot; @inc=&quot;handleIncrease&quot;&gt;&lt;/counter&gt; &lt;counter :count=&quot;2&quot; @inc=&quot;handleIncrease&quot;&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; props: [&apos;count&apos;], data: function ()&#123; return&#123;number: this.count&#125; &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick: function ()&#123; this.number = this.number + 2; this.$emit(&apos;inc&apos;,2) &#125; &#125; &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, components: &#123; counter: counter &#125;, data: &#123; total: 5 &#125;, methods: &#123; handleIncrease: function (step)&#123; this.total += step &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 子组件props 约束父组件传递来的content必须为String： props: &#123; content: String &#125; 另一种写法： props: &#123; content: &#123; type: String &#125; &#125; 约束父组件传递来的content可以为数字或者字符串： props: &#123; content: [Number, String] &#125; 约束父组件必须传content： props: &#123; content: &#123; type: String, required: true &#125; &#125; 设置父组件传递的content有默认值： props: &#123; content: &#123; type: String, required: false, default: &apos;default value&apos; &#125; &#125; 约束父组件传递来的content长度大于5： props: &#123; content: &#123; type: String, validator: function (value)&#123; return (value.length &gt; 5) &#125; &#125; &#125; 组件绑定原生事件 在子组件中实现父组件中的点击事件： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;child @click=&quot;handlerClick&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;, &#123; template: &apos;&lt;div @click=&quot;handlerChildClick&quot;&gt;Child&lt;/div&gt;&apos;, methods: &#123; handlerChildClick: function () &#123; this.$emit(&apos;click&apos;) &#125; &#125; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, methods: &#123; handlerClick: function () &#123; alert(&quot;click&quot;) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件绑定原生事件，另有一种native写法： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;child @click.native=&quot;handlerClick&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;, &#123; template: &apos;&lt;div&gt;Child&lt;/div&gt;&apos; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, methods: &#123; handlerClick: function () &#123; alert(&quot;click&quot;) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 非父子组件传值 Bus/事件总线/发布订阅模式/观察者模式： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;child content=&quot;Dell&quot;&gt;&lt;/child&gt; &lt;child content=&quot;Lee&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue() Vue.component(&apos;child&apos;, &#123; data: function ()&#123; return &#123; selfContent: this.content &#125; &#125;, props: &#123; content: String &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick:function ()&#123; this.bus.$emit(&apos;change&apos;, this.selfContent) &#125; &#125;, mounted: function ()&#123; var this_ = this this.bus.$on(&apos;change&apos;,function (msg)&#123; this_.selfContent = msg &#125;) &#125; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 插槽slot 向子组件中插入标签： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;body-content&gt; &lt;div class=&quot;header&quot; slot=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;footer&quot; slot=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/body-content&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;body-content&apos;, &#123; template: &apos;&lt;div&gt;&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;div class=&quot;content&quot;&gt;content&lt;/div&gt;&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;&lt;/div&gt;&apos; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 作用域插槽slot-scope： 父组件向子组件插入标签，子组件向父组件传值item： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;body-content&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;li&gt;&#123;&#123;props.item&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/body-content&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;body-content&apos;, &#123; data: function ()&#123; return &#123;list:[1,2,3,4]&#125; &#125;, template: &apos;&lt;div&gt;&lt;ul&gt;&lt;slot v-for=&quot;item of list&quot; :item=item&gt;&lt;/slot&gt;&lt;/ul&gt;&lt;/div&gt;&apos; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 项目准备 命令行工具： node -v npm -v git --version npm install --global vue-cli vue init webpack 项目文件夹 //运行项目-项目目录下 npm run dev npm run start 代码结构介绍： package.json---------------------项目依赖 package-lock.json----------------依赖具体版本 index.html-----------------------首页模板文件 .postcssrc.js--------------------postcssrc配置项 .eslintrc.js---------------------规范 .eslintignore--------------------eslint检测忽略 .editorconfig--------------------编译器语法 .babelrc-------------------------babelrc配置 static---------------------------静态资源 node_modules---------------------依赖包 src-main.js----------------------入口 src-App.vue----------------------根组件-单文件组件 src-router-----------------------路由 src-components-------------------小组件 src-assets-----------------------项目图片资源 config-index.js------------------基础配置 config-dev.env.js----------------开发环境配置 config-prod.env.js---------------线上环境配置 build文件------------------------打包配置 fastclick-解决移动端三秒延迟： npm install fastclick --save stylus和stylus-loader： npm install stylus --save npm install stylus-loader --save 轮播插件： npm install vue-awesome-swiper@2.6.7 --save axios： npm install axios --save better-scroll： npm install better-scroll --save vuex: npm install vuex --save babel-polyfill： npm install babel-polyfill --save 打包： npm run build 京东金融项目准备 nvm： //mac https://github.com/nvm-sh/nvm //windows https://github.com/coreybutler/nvm-windows git: https://www.bootcss.com/p/git-guide/ webpack: https://webpack.docschina.org/ https://www.webpackjs.com/ babel: https://www.babeljs.cn/ atom: https://atom.io/ eslint: http://eslint.cn/docs/user-guide/configuring es6: http://es6-features.org/#Constants sass: https://sass.bootcss.com/ vue: https://cn.vuejs.org 项目 swiper： npm i vue-awesome-swiper 打包： npm run build js压缩： npm i -D uglifyjs-webpack-plugin css压缩: //css-loader minimize: true 线上调试 source map 构建工具 webpack.config.js文件中： 入口： entry: &#123; app: &apos;./app/js/main.js&apos; &#125; 配置解析构建： module: &#123; loaders: [ &#123; test: /\\.html$/, loader: &apos;html-loader&apos; &#125;, &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, &#125;, &#123; test: /\\.scss$/, loader: &apos;style-loader!css-loader!sass-loader&apos; &#125; ] &#125;, 插件： plugins:[] 输出： output: &#123; filename: &apos;[name].min.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125; devServer(端口等配置): devServer: &#123; contentBase: &apos;./dist&apos;, hot: true, compress: true, port: 9000, clientLogLevel: &quot;none&quot;, quiet: true &#125;, 配置: const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); resolve: resolve: &#123; extensions: [ &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos; ], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos; &#125; &#125;, 头条初始化项目 脚手架： npm install --global @vue/cli 创建项目： vue create toutiao-vue Vue CLI v4.5.13 ? Please pick a preset: Manually select features ? Check the features needed for your project: (*) Choose Vue version (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex (*) CSS Pre-processors &gt;(*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing ? Choose a version of Vue.js that you want to start the project with 2.x ? Use history mode for router? (Requires proper server setup for index fallback in production) No ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less ? Pick a linter / formatter config: Standard ? Pick additional lint features: (*) Lint on save &gt;(*) Lint and fix on commit (requires Git) ? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files ? Save this as a preset for future projects? (y/N)n 运行项目： npm run serve vant： http://github.com/youzan/vant https://youzan.github.io/vant/#/zh-CN/ Rem 布局适配： npm i amfe-flexible //main.js import &apos;amfe-flexible&apos; //-D 是 --save-dev 的简写 npm install postcss-pxtorem -D npm install postcss-pxtorem@5.1.1 -D //项目根目录中创建 `.postcssrc.js` 文件 module.exports = &#123; plugins: &#123; &apos;autoprefixer&apos;: &#123; browsers: [&apos;Android &gt;= 4.0&apos;, &apos;iOS &gt;= 8&apos;] &#125;, &apos;postcss-pxtorem&apos;: &#123; rootValue: 37.5, propList: [&apos;*&apos;] &#125; &#125; &#125; 注意：该工具的rem转换，行内样式不会转，例如 &lt;div style=&quot;width: 200px;&quot;&gt;&lt;/div&gt;。 网络封装： npm i axios","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"微信小程序开发","slug":"9.微信小程序开发","date":"2019-02-17T13:22:06.325Z","updated":"2021-03-26T14:40:13.822Z","comments":false,"path":"2019/02/17/9.微信小程序开发/","link":"","permalink":"http://yoursite.com/2019/02/17/9.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"调试器断点调试 设置好断点，点击编译，会执行断点，查看Watch可以查看数据。 Stroage缓存信息 AppData页面信息 打印日志console.log(&quot;我是log&quot;) 结构.js配置页面入口，wxml配置页面UI，.json页面的配置文件，wxss类似于css样式。内部的.json和wxss会覆盖外面的。 app.json配置页面&quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ] app.js定义了页面的入口App(&#123; /** * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */ onLaunch: function () &#123; &#125;, /** * 当小程序启动，或从后台进入前台显示，会触发 onShow */ onShow: function (options) &#123; &#125;, /** * 当小程序从前台进入后台，会触发 onHide */ onHide: function () &#123; &#125;, /** * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 */ onError: function (msg) &#123; &#125; &#125;) index.js自己页面的配置Page(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125; &#125;) index.wxml页面的布局文件视图和渲染组件https://developers.weixin.qq.com/miniprogram/dev/component/ 在wxml中 &lt;text&gt;这里是文本内容&lt;/text&gt; &lt;button type=&quot;default&quot; hover-class=&quot;other-button-hover&quot;&gt; default &lt;/button&gt; &lt;button type=&quot;primary&quot;&gt; primary &lt;/button&gt; 数据绑定在wxml中 &lt;button type=&quot;primary&quot;&gt; &#123;&#123;btnText&#125;&#125; &lt;/button&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; 在js中 data: &#123; text:&quot;这里是text内容&quot;, btnText:&quot;这里是btn内容&quot; &#125;, 动态绑定wxml中 &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;btnClick&quot;&gt; 点击 &lt;/button&gt; js中，在page下 btnClick : function()&#123; this.setData(&#123; text:&quot;这是新的内容&quot; &#125;) &#125; 两种渲染标签if、else wxml中 &lt;view wx:if=&quot;&#123;&#123;show&#125;&#125;&quot;&gt; &#123;&#123;text&#125;&#125; 1 &lt;/view&gt; &lt;view wx:else=&quot;&#123;&#123;show&#125;&#125;&quot;&gt; &#123;&#123;text&#125;&#125; 2 &lt;/view&gt; js中 var isShow = this.data.show; this.setData(&#123; text: &quot;这是新的内容&quot;, show : !isShow &#125;) for wxml中 &lt;view wx:for=&quot;&#123;&#123;news&#125;&#125;&quot; wx:for-item=&quot;items&quot; wx:for-index=&quot;ix&quot; &gt; &#123;&#123;ix&#125;&#125;-&#123;&#123;items&#125;&#125; &lt;/view&gt; js中 var newsdata = this.data.news; newsdata.shift(); this.setData(&#123; text: &quot;这是新的内容&quot;, show: !isShow,news:newsdata &#125;) 模板使用wxml中引入公共的wxml &lt;include src=&quot;../templates/header&quot; /&gt; 事件点击tab、长按longtab、触摸（touchstart,touchend,touchmove,touchcancle）等 事件冒泡：点击子view，它本身和他的所有父view都会相应，包括点击，长按，触摸事件。其他都是非冒泡事件。 事件的绑定：bind绑定和catch绑定。比如点击事件bindtap和catchtab，区别就是bindtap会事件冒泡，catchtap不会事件冒泡。 事件的对象：类型type，时间戳timeStamp，事件源组件target，当前组件currentTarget，触摸点数touches，dataset等，代码： btnClick : function(event)&#123; console.log(event); &#125;) 案例点击按钮查询，查询输入框中内容 遇到的问题 https://www.cnblogs.com/wholeworld/p/8361577.html 做好后的效果图 app.json中配置页面，app.js中设置网路，代码 getNameInfo: function (name,cb)&#123; wx.request(&#123; url: &apos;https://shanghaicity.openservice.kankanews.com/citizen/repeat?name=&apos;+name, //接口地址 data: &#123; x: &apos;&apos;, y: &apos;&apos; &#125;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; // 默认值 &#125;, success(res) &#123; //console.log(res.data) cb(res.data) &#125; &#125;) &#125; 页面wxml &lt;view class=&quot;container&quot;&gt; &lt;input placeholder=&quot;请输入您的姓名&quot; bindinput=&quot;nameInput&quot;&gt;&lt;/input&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;btnSearch&quot;&gt;查询&lt;/button&gt; &lt;text wx:if=&quot;&#123;&#123;isShow&#125;&#125;&quot;&gt;查询到上海市姓名是&#123;&#123;resultInfo.name&#125;&#125;的人数为&#123;&#123;resultInfo.count&#125;&#125;人&lt;/text&gt; &lt;/view&gt; 页面wxss input&#123; border: 1px solid red; width: 90%; margin: 5%; padding: 5px; &#125; text&#123; margin-top: 20px; &#125; 页面js var app = getApp() Page(&#123; /*** 页面的初始数据 */ data: &#123; myName:null, resultInfo:null, isShow:false &#125;, btnSearch : function()&#123; var thispage = this; //console.log(this.data.myName) app.getNameInfo(this.data.myName, function (data) &#123;//结果：&#123;count: 0, name: &quot;萧何&quot;&#125; //console.log(data) thispage.setData(&#123;resultInfo : data&#125;) thispage.setData(&#123; isShow: true &#125;); &#125;); &#125;, nameInput : function(e)&#123; this.setData(&#123;myName:e.detail.value&#125;) &#125; &#125;) 配置页面配置，全局配置，tabBar配置，网络超时配置，debug开启配置 全局配置和页面配置 https://developers.weixin.qq.com/miniprogram/dev/framework/config.html 页面json中配置window可以覆盖全局window配置。 tabBar配置 https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html 比如 &#123; &quot;tabBar&quot;: &#123; &quot;custom&quot;: true, &quot;color&quot;: &quot;#000000&quot;, &quot;selectedColor&quot;: &quot;#000000&quot;, &quot;backgroundColor&quot;: &quot;#000000&quot;, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;page/component/index&quot;, &quot;text&quot;: &quot;组件&quot;, &quot;iconPath&quot;:&quot;images/icon1.png&quot;, &quot;selectedIconPath&quot;:&quot;images/icon2.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;page/API/index&quot;, &quot;text&quot;: &quot;接口&quot;, &quot;iconPath&quot;:&quot;images/icon3.png&quot;, &quot;selectedIconPath&quot;:&quot;images/icon4.png&quot; &#125; ] &#125;, &quot;usingComponents&quot;: &#123;&#125; &#125; 在app.json中配置debug &quot;debug&quot;:true","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"IconFont在Android中的使用介绍","slug":"8.IconFont在Android中的使用介绍","date":"2019-01-25T11:52:51.881Z","updated":"2021-03-26T14:40:09.834Z","comments":false,"path":"2019/01/25/8.IconFont在Android中的使用介绍/","link":"","permalink":"http://yoursite.com/2019/01/25/8.IconFont%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"iconfont介绍常用iconfont字体库 https://www.iconfont.cn/ http://fontawesome.dashgame.com/ https://ionicons.com/ 优点： 1.IconFont是矢量图标,可以随意设置大小。 2.体积小可以减小APK的体积。 3.一套图标资源可以在不同平台使用(android ,ios,web) 4.很容易实现图文混排，因为都是Icon也被看做为文字. 缺点： 1.添加图标是需要重新制作ttf文件 2.只能支持单色（不支持渐变色图标） ttf文件中每个图片对应的一个unicode码。TextView设置文字的时候，使用对应的unicode码就能显示出图片。 具体使用下载iconfont.ttf文件，放在项目main/assets/iconfont/下 方式一xml中 &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/home&quot; android:textColor=&quot;@android:color/holo_orange_light&quot; android:textSize=&quot;50sp&quot; /&gt; strings中Unicode &lt;string name=&quot;home&quot;&gt;&amp;#xe664;&lt;/string&gt; 最后直接设置 Typeface iconfont1 = Typeface.createFromAsset(getAssets(), &quot;iconfont/iconfont.ttf&quot;); TextView textview1 = findViewById(R.id.tv1); textview1.setTypeface(iconfont1); 方式二自定义TextView public class IconFontView extends AppCompatTextView &#123; private Context context; private boolean isFirst = true; private String text; private int textColor; private String clicked_text; private int clicked_textColor; public IconFontView(Context context) &#123; this(context, null); &#125; public IconFontView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public IconFontView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); this.context = context; init(attrs); &#125; /** 初始化 */ private void init(AttributeSet attrs)&#123; // 设置字体类型 setTypeface(Typeface.createFromAsset(context.getAssets(), &quot;iconfont/iconfont.ttf&quot;)); // 获取配置信息（text &amp;&amp; textColor） getAttrs(attrs); &#125; /** 获得配置信息 */ private void getAttrs(AttributeSet attrs) &#123; TypedArray taCustom = context.obtainStyledAttributes(attrs, R.styleable.IconFontViewAttr); clicked_text = taCustom.getString(R.styleable.IconFontViewAttr_clicked_text); clicked_textColor = taCustom.getColor(R.styleable.IconFontViewAttr_clicked_textColor, 0); taCustom.recycle(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN)&#123; text = getText().toString(); textColor = getCurrentTextColor(); &#125; return super.onTouchEvent(event); &#125; @Override protected void dispatchSetPressed(boolean pressed) &#123; super.dispatchSetPressed(pressed); if (isDuplicateParentStateEnabled()) &#123; if (pressed)&#123; if(clicked_text != null) this.setText(clicked_text); if(clicked_textColor != 0) this.setTextColor(clicked_textColor); &#125;else &#123; this.setText(text); this.setTextColor(textColor); &#125; &#125; &#125; &#125; 在res/values/attrs中定义属性 &lt;!-- IconFontView属性 --&gt; &lt;declare-styleable name=&quot;IconFontViewAttr&quot;&gt; &lt;attr name=&quot;clicked_text&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;clicked_textColor&quot; format=&quot;color&quot; /&gt; &lt;/declare-styleable&gt; 使用 &lt;com.example.iconfont.IconFontView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hot&quot; android:textColor=&quot;@android:color/holo_red_dark&quot; android:textSize=&quot;50sp&quot; /&gt; strings中Unicode &lt;string name=&quot;hot&quot;&gt;&amp;#xe614;&lt;/string&gt; 补充可以图文混用 &lt;string name=&quot;my&quot;&gt;我可以图文混用&amp;#xe624;啦！！&lt;/string&gt; 使用阿里iconfont可以在demo_index.html文件中查找对应的Unicode fontawesome查找Unicode对照表 https://fontawesome.com/cheatsheet?from=io","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"IconFont","slug":"IconFont","permalink":"http://yoursite.com/tags/IconFont/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"快速入门和详解kotlin","slug":"7.快速入门kotlin","date":"2019-01-23T12:10:22.179Z","updated":"2021-03-26T14:40:05.832Z","comments":false,"path":"2019/01/23/7.快速入门kotlin/","link":"","permalink":"http://yoursite.com/2019/01/23/7.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8kotlin/","excerpt":"","text":"快速入门1、资料官方文档 https://kotlinlang.org/docs/reference/ Kotlin源码 https://github.com/JetBrains/kotlin Kotlin官博 https://blog.jetbrains.com/kotlin/ Kotlin微信公众号 Kotlin 2、HelloWorld第一种写法 fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello World&quot;) &#125; 第二种写法 object HelloWorld &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello&quot;) &#125; &#125; 第三种写法 class HelloWorld &#123; companion object &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello&quot;) &#125; &#125; &#125; 3、基本类型定义var s : String = &quot;Hello&quot; var stringA = &quot;Hello&quot; var int = 5 基本数据类型的定义可以加类型，也可以不加。 lateinit延迟初始化成员变量，先不赋值 private lateinit var string : String val延迟初始化用lazy，使用的时候再赋值,值只在第一次访问的时候计算 val ss : String by lazy &#123; &quot;赋值&quot; &#125; 数据类型转换 .toInt() .toFloat() 字符串比较 == .equals() 4、定义finalconst val stringB = &quot;Hello&quot; val stringC = &quot;Hello&quot; var是一个可变变量,val是一个只读变量，可以省略类型。 const只能用在顶级属性，以及object对象的属性中（伴随对象也是obejct）。 const val就相当于Java中的final，编译期常量。 5、占位符&quot;$&#123;&#125;&quot;var stringG = &quot;IamG&quot; var stringF = &quot;$&#123;stringG&#125;&quot; + &quot;dd&quot; println(stringF)//IamGdd 6、数组和遍历val names: Array&lt;String&gt; = arrayOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) val emptyStrings: Array&lt;String?&gt; = arrayOfNulls(10) String?表示可以为null的String类型 基本数据类型定制版 val ints = intArrayOf(1, 3, 5) 基本操作 names.isNotEmpty() //判断空 names.length //数组的长度 names[i] = &quot;Hello&quot; //给第i个成员赋值 print array[i] //输出第i个成员 for遍历(注意..和until) val ints = intArrayOf(1, 3, 5, 7, 9) for (int in ints) &#123; println(int) &#125; for (i in ints.indices)&#123; print(ints[i]) &#125; for ((index,value) in ints.withIndex())&#123; println(&quot;$index -&gt; $value&quot;) &#125; for (indexedValue in strArrays.withIndex())&#123; println(&quot;$&#123;indexedValue.index&#125; -&gt; $&#123;indexedValue.value&#125;&quot;) &#125; for (i in IntRange(0, ints.size - 1)) &#123; print(ints[i]) &#125; for (i in 0..ints.size - 1) &#123; print(ints[i]) &#125; for (i in 0 until ints.size) &#123; print(ints[i]) &#125; //Lambda方式遍历 ints.forEach&#123; println(it) &#125; ints.forEach(::println) 7、list和mapvar lists = listOf &lt;String&gt;(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;) for (list in lists) &#123; println(list) &#125; for ((index, valu) in lists.withIndex()) &#123;//角标从零开始，角标和值 println(index.toString() + &quot;-----&quot; + valu) &#125; var map = TreeMap&lt;String, String&gt;() map[&quot;姓名&quot;] = &quot;张三&quot; map[&quot;性别&quot;] = &quot;男&quot; map[&quot;年龄&quot;] = &quot;18&quot; map[&quot;爱好&quot;] = &quot;游泳&quot; 8、静态变量、方法companion object &#123; &#125; 9、方法函数定义方法带参及返回类型 fun stringD(string : String):Boolean&#123; //... return true &#125; 参数个数不固定 fun stringE(vararg names: String)&#123; &#125; stringE(*Ints) 简化写法 fun add(num1 : Int ,num2 : Int) : Int&#123; return num1 + num2 &#125; fun add(num1 : Int ,num2 : Int) = num1 + num2 函数作为变量使用 var d = add(1,2) val add = fun(num1: Int, num2: Int): Int &#123; return num1 + num2 &#125; 10、when表达式when用来代替switch fun checkScore(score: Int) : String &#123; var str = when (score) &#123; 100 -&gt;&quot;满分&quot; 99 -&gt; &quot;继续加油&quot; else -&gt;&quot;看好你哦&quot; &#125; return str &#125; 11、实例化类和class实例var data = Date() 不需要new 获得class的实例的两种方式 val clazz1 = DD::class.java val dd = DD() val clazz2 = dd.javaClass 12、继承class Son : Father()&#123; override fun action()&#123; //... &#125; &#125; 13、AS转化as中直接转换：两次shift后输入Convert Java File to Kotlin File。 14、Lambda函数入参 -&gt; 返回值 val add = fun(num1: Int, num2: Int): Int &#123; return num1 + num2 &#125; //可以写成 val add = &#123; num1: Int, num2: Int -&gt; num1 + num2 &#125; 过滤空后的输出结果 var strArrays = arrayOf(&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;) strArrays.filter &#123; it.isNotEmpty() &#125;.forEach&#123; println(it)&#125; 15、空安全String?表示可以为null的String类型。!!表示自己判断不会出现null，但如果出现了null会崩溃。？表示可能会返回null，不会崩溃。 var string: String? = null var len1 = string?.length var len2 = string!!.length//最终会崩溃 16、类 类的创建 class Person(val name:String,val age:Int) 构造方法 class Person(var name: String?, var age:Int) &#123; constructor(name: String):this(name,0) constructor():this(null,0) &#125; get和set var name: String? = null private set// 私有掉set方法 var age: Int = 0 get() &#123; return if (field &lt; 0) 0 else field &#125;//field就是age 类的继承 class QQStepView : View &#123; constructor(context:Context):this(context,null) constructor(context:Context,attrs: AttributeSet?):this(context,attrs,0) constructor(context:Context,attrs: AttributeSet?,defStyleAttr:Int):super(context,attrs,defStyleAttr&#123; // 写内容 获取自定义属性的内容 &#125; &#125; 或者 class QQStepView(context: Context?, attrs: AttributeSet?) : View(context, attrs) 匿名内部类 //匿名内部类 object:xxx httpUtils.get(object: HttpCallback()&#123; override fun onError(e: IOException) &#123; &#125; override fun onSuccess() &#123; Log.e(&quot;TAG&quot;,&quot;onSuccess&quot;)&#125; &#125;) 17、运算符重载 class Counter(val dayIndex: Int)&#123; // 操作符重载 + operator fun plus(counter: Counter):Counter&#123; return Counter(dayIndex+counter.dayIndex) &#125; // 操作符重载 - operator fun minus(counter: Counter):Counter&#123; return Counter(dayIndex-counter.dayIndex) &#125; &#125; 18、方法扩展 // 对类方法进行扩展 val str = &quot;abc&quot; var strMulit = str.mulit(3) Log.e(&quot;TAG&quot;,&quot;strMulit = $strMulit&quot;) // 对一个类的方法进行扩展 operator fun String.mulit(number: Int): String &#123; val stringBuilder = StringBuilder() for (num in 1..number)&#123; stringBuilder.append(this) &#125; return stringBuilder.toString() &#125; 详解kotlin1、数据类型和函数==和=====表示比较内容，类似于java的equals；===表示比较对象是否相同。 open继承如果一个类允许被继承，那么需要使用open声明。方法想被重写也是要加open。 open class People(name: String, sex: String) &#123; &#125; class Man(name: String, sex: String) : People(name, sex) &#123; &#125; initinit代码比构造函数先执行。 open class People(name: String, sex: String) &#123; init &#123; &#125; &#125; isis类似于java中的instance of。 as父类向下转为子类as类型转换，失败则抛异常，as?如果转换失败，则返回null,不抛异常。 val child : Child? = parent as? Child 只能类型转化：父类对象直接引用子类的成员。 Any父类和Unit返回值Any是Kotlin中的父类，类似于java中的Object。 没有返回值时候，其实返回的是Unit，相当于java中的void。 引用包名导包时候替换其他名字 import 包名...类名1 as xxx val name : xxx = xxx() rangerange表示范围，ClosedRange的子类 0..100 表示 [0,100] 0 until 100 表示 [0,100) i in 0..100 判断i是否在[0,100]中 类中的toStringopen class People(var name: String, var sex: String) &#123; override fun toString(): String &#123; return name + sex &#125; &#125; get和set方法默认已经实现了get/set方法，如果要做处理 class Woman&#123; var nameA : String = &quot;翠花&quot; get() &#123; print(&quot;get方法&quot;) return field &#125; set(value) &#123; print(&quot;set方法&quot;) field = value &#125; &#125; if可以作为表达式if可以直接作为表达式 val nameB = if (true)&#123; &quot;NameB&quot; &#125; else &#123; &quot;NameBB&quot; &#125; try...catch、when等也可以作为表达式。 标签Outter@for ((index,value) in strArrays.withIndex())&#123; println(&quot;$index -&gt; $value&quot;) Inner@for (indexedValue in strArrays.withIndex())&#123; if (...)&#123; break@Outter &#125; &#125; &#125; 接口代理interface Child &#123; fun play() &#125; interface Parent &#123; fun eat() &#125; class People : Child, Parent &#123; override fun play() &#123; &#125; override fun eat() &#123; &#125; &#125; class People1(child: Child,parent: Parent) : Child by child, Parent by parent object类只有一个实例的类；不能自定义构造方法；可以实现接口，继承父类；本质上就是单例模式的最基本实现。 object FF &#123; val ffv : String = &quot;ff&quot; &#125; 静态方法和成员companion object包裹起来静态方法；@JvmStatic和@JvmField加上后，java去调用更方便。 class HelloWorld &#123; @JvmField val TAG : String = &quot;TAG&quot; companion object &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello&quot;) &#125; &#125; &#125; 方法重载 方法重载可以用方法上的默认参数代替，想给java用可以加上@JvmOverloads。 @JvmOverloads fun sum(a: Int = 2, b: Int): Int &#123; return a + b &#125; data class类 可以定义javabean，自动有了 toString()、hashCode()、equals()、copy()、componentN()这些方法。 填坑： apply plugin: &apos;kotlin-noarg&apos; apply plugin: &apos;kotlin-allopen&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-noarg:$kotlin_version&quot; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-allopen:$kotlin_version&quot; noArg&#123; annotation(&quot;xxxx&quot;) &#125; 内部类java定义内部类，默认持有外部类的引用，除非定义为静态的内部类。 Kotlin中内部类默认是静态内部类，inner定义的是非静态内部类 inner class Inner&#123; &#125; 匿名内部类可以继承父类或者实现多个接口 interface OnClickListener &#123; fun onClick() &#125; class View &#123; var onclick: OnClickListener? = null &#125; val view = View() view.onclick = object : OnClickListener&#123; override fun onClick() &#123; &#125; &#125; 2、高阶函数对每个元素操作返回新的list val list = listOf(1, 3, 5, 7, 9, 11) val newList = list.map &#123; it * 2 + 3 &#125; 还有 forEach、map、flatMap、reduce、fold、filter、takeWhile、 let、apply、with、use、 joinToString 尾递归 tailrec 3、协程协作程序，解决异步问题。 高阶函数如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数的话，那么该函数就称为高阶函数。 扩展函数-&gt;参考上文，18、方法扩展。 定义函数变量,-&gt;左边是参数类型，右边是返回值，Unit相当于void，无返回值： val a: (String, Int) -&gt; Unit 定义函数 fun num1Andnum2(num1: Int, num2: Int, operation: (Int, Int) -&gt; Int): Int &#123; return operation(num1, num2) &#125; 补充代码：https://github.com/AdamRight/Android2021Code/tree/master/app/src/main/java/com/android/code/kotlin 1、静态函数和属性1.1 顶层函数 顶层函数直接在kotlin文件中定义函数和属性，会直接生成静态的。 在其他kotlin类中可以直接使用函数名，在Java中通过 文件名Kt来使用。 如果在kotlin文件中注解 @file:JvmName(&quot;类名&quot;)，那么在Java中可以通过 类名.函数名 来使用。 1.2 object类 object类直接生成单例例对象，然后通过单例对象访问函数和属性。 在其他kotlin类中可以通过 类名.函数名 使用；在Java中通过 类名.INSTANCE.函数名来使用。 1.3 companion object kotlin类中使用 companion object 生成单例例对象，然后通过单例对象访问函数和属性。 在其他kotlin类中可以通过 类名.函数名 使用；在Java中通过 类名.Companion.函数名来使用。 如果在 companion object 中的函数和属性通过 @JvmStatic 修饰，那么Java中可以用 类名.函数名 直接使用。 2、internal 有多个module模块情况下，可⻅性修饰符internal的作用是，只能被当前module模块访问的到。 3、主构造器 改造前 class User1 &#123; var userName: String? = null var userPassWord: String? = null constructor()&#123; &#125; constructor(name: String, password: String)&#123; this.userName = name this.userPassWord = password &#125; &#125; 改成主构造器： class User1 constructor(name: String?, password: String?) &#123; var userName: String? = null var userPassWord: String? = null constructor() : this(null, null)&#123; &#125; init &#123; this.userName = name this.userPassWord = password &#125; &#125; 进一步修改： class User1 constructor(name: String?, password: String?) &#123; var userName: String? = name var userPassWord: String? = password constructor(): this(null, null) &#125; 再进一步修改： class User1 constructor(var name: String?, var password: String?) &#123; constructor(): this(null, null) &#125; 在主构造参数前面加上 var/val 使构造参数同时成为成员变量。 再进一步修改： class User1 constructor(var name: String? = null, var password: String? = null) &#123; &#125; 4、查看kotlin类的字节码 Tools –&gt; Kotlin –&gt; Show Kotlin Bytecode 5、Elvis操作符 通过 ?: 的操作来简化 if null 的操作。 var myName = user.name if (myName == null)&#123; myName = &quot;kotlin&quot; &#125; 修改后： var myName = user.name ?: &quot;kotlin&quot; 修改前： if (user.name == null || user.name!!.length &lt; 4)&#123; &#125; 修改后： if (user.name?.length ?: 0 &lt; 4)&#123; &#125; 6、forEach和filter forEach： var arrayListUser1 = ArrayList&lt;User1&gt;() var arrayListUser2 = ArrayList&lt;User1&gt;() arrayListUser1.forEach &#123; if (it.name == &quot;kotlin&quot;)&#123; arrayListUser2.add(it) &#125; &#125; filter： var arrayListUser1 = ArrayList&lt;User1&gt;() var arrayListUser2: List&lt;User1&gt; = arrayListUser1.filter &#123; it.name == &quot;kotlin&quot; &#125; 7、let、apply、run、also 返回自身 –&gt; 从 apply 和 also 中选 作用域中使用 this 作为参数 ----&gt; 选择 apply 作用域中使用 it 作为参数 ----&gt; 选择 also 不需要返回自身 -&gt; 从 run 和 let 中选择 作用域中使用 this 作为参数 ----&gt; 选择 run 作用域中使用 it 作为参数 ----&gt; 选择 let","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"强引用、软引用、弱引用、幻象引用","slug":"6.强引用、软引用、弱引用、幻象引用","date":"2019-01-17T12:43:29.131Z","updated":"2021-03-26T14:40:00.839Z","comments":false,"path":"2019/01/17/6.强引用、软引用、弱引用、幻象引用/","link":"","permalink":"http://yoursite.com/2019/01/17/6.%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8/","excerpt":"","text":"Java 程序运行时的内存分配三种空间分别是静态存储区（方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态变量。这块「内存」在程序编译时就已经分配好了，并且在程序整个运行期间都存在。 栈区：当方法被执行时，方法体内的局部变量（包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时。这些局部变量所持有的内存将会自动被释放。 堆区：又称动态内存分配，通常就是指程序运行时直接 new 出来的内存，也就是对象的实例，这部分「内存」在不使用时将会被 Java 垃圾回收器来负责回收。 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储在堆中 —— 因为他们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被 new 出来使用的。 两种算法判断对象需不需要回收：引用计数法(用的少)和GcRoot可达分析算法(大多数)。回收(回收算法)分为两步:需要回收的对象加入队列；调用对象的finalize方法。 常见回收算法 标记清除算法（效率低，节省一些内存） 复制算法 （效率要高，浪费一些内存） 标记整理算法 分代算法 GC回收内存本质上是回收对象，运用可达性分析算法。 在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。 实现的核心是Reference与ReferenceQueue两个类。 强引用Strong Reference就是我们最常见的普通对象引用，Object obj = new Object()中的obj就是强引用。 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。 软引用SoftReference只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出OutOfMemoryError 之前，清理软引用指向的对象。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。 Object aRef = new Object(); SoftReference aSoftRef = new SoftReference(aRef); Object anotherRef = (Object)aSoftRef.get(); ReferenceQueue queue = new ReferenceQueue(); SoftReference ref = new SoftReference(aMyObject, queue); (ref = (EmployeeRef) q.poll()) != null 应用场景：软引用通常用来实现内存敏感的缓存。比如图片缓存框架，从网络上获取图片，然后将获取的图片显示的同时，通过软引用缓存起来。当下次再去网络上获取图片时，首先会检查要获取的图片缓存中是否存在，若存在，直接取出来，不需要再去网络上获取。 View view = findViewById(R.id.button); Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); Drawable drawable = new BitmapDrawable(bitmap); SoftReference&lt;Drawable&gt; drawableSoftReference = new SoftReference&lt;Drawable&gt;(drawable); if(drawableSoftReference != null) &#123; view.setBackground(drawableSoftReference.get()); &#125; 弱引用WeakReference随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。 由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 应用场景：弱应用同样可用于内存敏感的缓存。 在静态内部类中，经常会使用弱引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏。 Glide 图片加载框架的内存缓存就使用到了弱引用缓存机制。 private MyHandler handler = new MyHandler(this); private static class MyHandler extends Handler&#123; WeakReference&lt;FirstActivity&gt; weakReference; MyHandler(FirstActivity activity) &#123; weakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what)&#123; &#125; &#125; &#125; 当一个android主线程被创建的时候，同时会有一个Looper对象被创建，而这个Looper对象会实现一个MessageQueue(消息队列)，当我们创建一个handler对象时，而handler的作用就是放入和取出消息从这个消息队列中，每当我们通过handler将一个msg放入消息队列时，这个msg就会持有一个handler对象的引用。 因此当Activity被结束后，这个msg在被取出来之前，这msg会继续存活，但是这个msg持有handler的引用，而handler在Activity中创建，会持有Activity的引用，因而当Activity结束后，Activity对象并不能够被gc回收，因而出现内存泄漏。 在java中所有非静态的对象都会持有当前类的强引用，而静态对象则只会持有当前类的弱引用。 声明为静态后，handler将会持有一个Activity的弱引用，而弱引用会很容易被gc回收，这样就能解决Activity结束后，gc却无法回收的情况。 幻象引用PhantomReference也叫虚引用，不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被finalize 以后，做某些事情的机制。这种引用的get()方法返回总是null。 幻想引用是针对那些已经执行完析构函数之后，仍然需要在执行一些其它操作的对象：比如资源对象的关闭就可以用到这个引用。 虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ReferenceQueue queue = new ReferenceQueue (); PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。 应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"移动web开发记录","slug":"5.移动web开发记录","date":"2019-01-07T12:26:42.093Z","updated":"2021-03-26T14:39:56.990Z","comments":false,"path":"2019/01/07/5.移动web开发记录/","link":"","permalink":"http://yoursite.com/2019/01/07/5.%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"像素设备独立像素 window.devicePixelRatio 屏幕的物理像素尺寸 window.screen.width window.screen.height 调试模拟调试 谷歌： 火狐： 真机调试：weinre、debuggap、ghostlab。同时保证设备和服务器的网络相通。 视口viewport获取viewport大小 document.documentElement.clientWidth; document.documentElement.clientHeight; pc端:浏览器的可视大小。viewport中子元素当超出viewport的大小时：viewport为具体值时，会出现滚动条；当viewport宽高设为100%时，会自动换行；当子元素也设为百分比，可以不出现滚动条和换行。 移动端：layout viewport和ideal viewport 默认视口大小，layout viewport同样是 document.documentElement.clientWidth; document.documentElement.clientHeight; 理想视口ideal viewport，即设备屏幕区域 window.screen.width window.screen.height 屏幕适配name=&quot;viewport&quot;说明当前meta标签是用来设置viewport的属性的，这个属性只有在移动端才会有效。 控制缩放：nitial-scale = ideal viewport/layout viewport 控制缩放 maximum-scale//最大缩放比例 minimum-scale//最小缩放比例，也是打开默认状态下的 user-scalable//是否可以缩放，yes，no &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,user-scalable=no&quot;&gt; webstorm中快捷键meta:vp+tab &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt;","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"移动web","slug":"移动web","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"安卓自定义安全键盘","slug":"4.安卓自定义安全键盘","date":"2019-01-05T09:16:06.970Z","updated":"2021-03-26T14:39:52.763Z","comments":false,"path":"2019/01/05/4.安卓自定义安全键盘/","link":"","permalink":"http://yoursite.com/2019/01/05/4.%E5%AE%89%E5%8D%93%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E5%85%A8%E9%94%AE%E7%9B%98/","excerpt":"","text":"Keyboard我们只需要用到系统提供的两个类：Keyboard和KeyboardView。 res下新建xml，新建Keyboard文件 Keyboard中 android:keyWidth//每一个按键的宽 android:keyHeight//每一个按键的高 android:verticalGap//行与行之间的间隙 android:horizontalGap//列与列之间的间隙 Row的作用是按键的换行，每一个按键Key都在Row中。 Key中 android:keyLabel//按键上的文字 android:codes//输出的文字，对应ASCII表 android:keyIcon//按键放置图片 android:isRepeatable//删除键长按连续删除 宽高、间距的单位既可以是像素，英寸等，也可以是相对于基础取值的百分比，以%p结尾。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;Keyboard xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:horizontalGap=&quot;0px&quot; android:verticalGap=&quot;0px&quot; android:keyHeight=&quot;7.5%p&quot; android:keyWidth=&quot;30%p&quot;&gt; &lt;Row android:verticalGap=&quot;1%p&quot;&gt; &lt;Key android:codes=&quot;49&quot; android:keyLabel=&quot;1&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;50&quot; android:keyLabel=&quot;2&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;51&quot; android:keyLabel=&quot;3&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;Row android:verticalGap=&quot;1%p&quot;&gt; &lt;Key android:codes=&quot;52&quot; android:keyLabel=&quot;4&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;53&quot; android:keyLabel=&quot;5&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;54&quot; android:keyLabel=&quot;6&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;Row android:verticalGap=&quot;1%p&quot;&gt; &lt;Key android:codes=&quot;55&quot; android:keyLabel=&quot;7&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;56&quot; android:keyLabel=&quot;8&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;57&quot; android:keyLabel=&quot;9&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes=&quot;-2&quot; android:keyLabel=&quot;abc&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;48&quot; android:keyLabel=&quot;0&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;Key android:codes=&quot;-5&quot; android:isRepeatable=&quot;true&quot; android:keyIcon=&quot;@mipmap/ic_delete&quot; android:horizontalGap=&quot;2%p&quot;&gt; &lt;/Key&gt; &lt;/Row&gt; &lt;/Keyboard&gt; KeyboardViewKeyboardView android:keyBackground//键盘背景图 android:keyPreviewLayout//键盘点击时候预览图的布局 android:keyPreviewHeight//键盘点击时候预览图的高度 android:keyTextColor//按键文字的颜色 android:keyTextSize//按键文字大小 android:labelTextSize//如果同时设置了文字+图片的按键 android:shadowColor android:shadowRadius 代码 &lt;android.inputmethodservice.KeyboardView android:id=&quot;@+id/kbv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#999999&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:keyBackground=&quot;@color/colorPrimaryDark&quot; android:keyPreviewHeight=&quot;64dp&quot; android:keyPreviewLayout=&quot;@layout/keyboard_preview&quot; android:keyTextColor=&quot;@android:color/black&quot; android:keyTextSize=&quot;24sp&quot; android:labelTextSize=&quot;18sp&quot; android:paddingTop=&quot;8dip&quot; android:paddingBottom=&quot;8dip&quot; android:shadowColor=&quot;#FFFFFF&quot; android:shadowRadius=&quot;0.0&quot; android:visibility=&quot;gone&quot; /&gt; 使用设置 Keyboard keyboard = new Keyboard(this,R.xml.tea_keyboard_num); keyboardView.setKeyboard(keyboard); keyboardView.setPreviewEnabled(true); keyboardView.setOnKeyboardActionListener(onKeyboardActionListener); OnKeyboardActionListener KeyboardView.OnKeyboardActionListener onKeyboardActionListener = new KeyboardView.OnKeyboardActionListener() &#123; ...... @Override public void onKey(int primaryCode, int[] keyCodes) &#123; if (primaryCode == Keyboard.KEYCODE_CANCEL) &#123;// 完成 &#125; else if (primaryCode == Keyboard.KEYCODE_DELETE) &#123;//回退 Toast.makeText(BoardActivity.this,&quot;delete&quot;,Toast.LENGTH_SHORT).show(); &#125; else if (primaryCode == Keyboard.KEYCODE_SHIFT) &#123;//大小写切换 &#125; else if (primaryCode == Keyboard.KEYCODE_MODE_CHANGE) &#123;//数字键盘切换 &#125; else &#123; &#125; &#125; &#125;; 参考https://github.com/onlyloveyd/LazyKeyboard https://github.com/r17171709/android_demo/tree/master/KeyBoardDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"自定义","slug":"自定义","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"键盘","slug":"键盘","permalink":"http://yoursite.com/tags/%E9%94%AE%E7%9B%98/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp基本使用及网络封装","slug":"3.OkHttp基本使用及网络封装","date":"2018-12-02T13:32:32.973Z","updated":"2021-03-26T14:39:48.613Z","comments":false,"path":"2018/12/02/3.OkHttp基本使用及网络封装/","link":"","permalink":"http://yoursite.com/2018/12/02/3.OkHttp%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85/","excerpt":"","text":"1、网络基础1.2、Cookie 、Session和TokenCookie 、Session、Token：都是用来做持久化处理的，目的就是让客户端和服务端相互认识。Http请求默认是不持久的没有状态的，谁也不认识谁。 Cookie: 是存放在客户端的信息，这个信息是来自于服务器返回的信息，下次请求带过去，如果用户离开网站后，如果Cookie已过期一般是会被清除的。如果Cookie没过期下次访问网站还是会带过去。（相对危险） Session: 是存放在服务器上面的客户端临时信息，用户离开网站是会被清除的。（相对安全，耗资源） Token（App）”令牌”：用户身份的验证，有点类似于Cookie，相对来说更安全。 1.3、Http缓存Cache-Control（缓存策略）：Public、private、no-cache、max-age 、no-store（不缓存） Expires（缓存的过期策略）：指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。 如果有缓存并且过期了那么发起请求，服务端会给我们数据？（不一定会给）服务器的数据没有变动就不会给，状态码会变为304，自己拿之前过期的缓存。 1.5、HttpsHttp和Https的区别： Https = Http + 加密 + 验证身份 + 完整 端口：Http (80) Https (443) Http的缺点：数据是没有加密传输，可能遭遇窃听；不验证通信方的身份，可能会遭遇伪装；无法验证报文的完整性，可能会遭遇篡改。 TLS/SSL协议：加密：对称加密（AES，DES）+ 非对称加密 (RSA，DSA)；证书：要钱（便宜），建立连接的速度会拖慢，TCP由3次握手变为8次握手。 Http/1.1和Http/2.0的区别： Http/2.0采用二进制格式而非文本格式；Http/2.0支持完全的多路复用；Http/2.0使用报头压缩，降低开销Http/2.0让服务器将响应主动推送给客户端，（带内容推送，不带内容推送的通知）。 2、OkHttp异步和同步：跟线程没什么关系，打电话，同步：打电话 -&gt; 处理（没挂断） -&gt; 反馈；异步：打电话 -&gt; 处理（挂断）-&gt; 打回来 网络框架要怎么处理：网络是耗时的，因此需要开线程，用线程池；处理网络，HttpUrlConnection(简单) 或者输入流+Socket(麻烦)；网络请求头信息处理，缓存的处理，文件格式上传的方式（表单提交，拼格式）；路由的一些操作，Http/2.0复用等等。 OkHttp要点——okio：原生的JavaIO+自定义封装，其实就是对于io的封装;Socket:连接；拦截器。 OkHttp流程： 1、Request里面封装了url，method，header等基本信息，然后通过okhttpClient.newCall(request),将Request转化成了RealCall。 2、RealCall里面有enqueue，通过call.enqueue(),转换成了AsyncCall。 3、AsyncCall是RealCall的内部类，AsyncCall继承了Runnable。AsyncCall给了OKhttp的Dispatcher（线程池），executorService().execute(call); 4、最终去执行了AsyncCall.execute()方法，执行getResponseWithInterceptorChain返回 Response。 synchronized void enqueue(AsyncCall call) &#123; //判断当前正在执行的任务数量，最大是64，正在执行的任务中的host,最大是5 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //加入到正在执行 runningAsyncCalls.add(call); // 线程池， executorService().execute(call); &#125; else &#123; // 加入准备执行的集合，等待执行 readyAsyncCalls.add(call); &#125; &#125; 2.1、官网和导入官网 http://square.github.io/okhttp/ 引入 compile &apos;com.squareup.okhttp3:okhttp:3.11.0&apos; 2.2、测试地址http://httpbin.org/ http://httpbin.org/get?id=123 http://httpbin.org/post 2.3、get请求同步请求 OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;http://httpbin.org/get?id=123&quot;).build(); try &#123; Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 异步请求 System.out.println(Thread.currentThread().getId()); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;http://httpbin.org/get?id=123&quot;).build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; System.out.println(Thread.currentThread().getId()); &#125; &#125; &#125;); 2.4、post请求同步请求，提交表单 OkHttpClient client = new OkHttpClient(); FormBody body = new FormBody .Builder() .add(&quot;name&quot;, &quot;shuaige&quot;) .add(&quot;age&quot;, &quot;19&quot;) .build(); Request request = new Request.Builder().url(&quot;http://httpbin.org/post&quot;).post(body).build(); try &#123; Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 异步提交，提交json OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(10,TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .build(); Book book = new Book(); book.setName(&quot;android&quot;); //使用Gson Gson gson = new Gson(); //使用Gson将对象转换为json字符串 String json = gson.toJson(book); //MediaType设置Content-Type 标头中包含的媒体类型值 RequestBody requestBody = FormBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), json); Request request = new Request.Builder() .url(&quot;http://172.20.192.168:8080/getbookByJson&quot;)//请求的url .post(requestBody) .build(); //创建Call Call call = okHttpClient.newCall(request); //加入队列 异步操作 call.enqueue(new Callback() &#123; //请求错误回调方法 @Override public void onFailure(Call call, IOException e) &#123; System.out.println(&quot;连接失败&quot;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; System.out.println(response.body().string()); &#125; 2.5、设置url参数-HttpUrlOkHttpClient client = new OkHttpClient(); HttpUrl httpUrl = HttpUrl.parse(&quot;http://httpbin.org/get&quot;). newBuilder(). addQueryParameter(&quot;city&quot;, &quot;beijing&quot;). addQueryParameter(&quot;id&quot;, &quot;123&quot;). build(); String url = httpUrl.toString(); System.out.println(httpUrl.toString());// http://httpbin.org/get?city=beijing&amp;key=123 Request request = new Request.Builder().url(url).build(); try &#123; Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 2.6、请求头的设置-addHeaderOkHttpClient client = new OkHttpClient(); Request request = new Request.Builder(). url(&quot;http://httpbin.org/get?id=123&quot;). addHeader(&quot;User-Agent&quot;, &quot;this my head&quot;). addHeader(&quot;Accept&quot;, &quot;text/plain, text/html&quot;). build(); try &#123; Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 2.7、上传文件RequestBody imageBody = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;), new File(&quot;文件路径+文件名&quot;)); MultipartBody body = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;name&quot;, &quot;name&quot;) .addFormDataPart(&quot;filename&quot;, &quot;文件名&quot;, imageBody).build(); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;http://192.168.1.6:8080/web/UploadServlet&quot;).post(body).build(); try &#123; Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; boundary 2.8、定义拦截器//定义拦截器 Interceptor interceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; long start = System.currentTimeMillis(); Request request = chain.request(); Response response = chain.proceed(request); long end = System.currentTimeMillis(); System.out.println(&quot;interceptor: cost time = &quot; + (end - start)); return response; &#125; &#125;; // 创建 OkHttpClient 对象 OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(interceptor) .build(); 2.9、缓存使用缓存的前提是服务器支持缓存 // 创建缓存对象，缓存文件和缓存大小 Cache cache = new Cache(new File(&quot;cache.cache&quot;), 1024 * 1024); // 创建 OkHttpClient 对象 OkHttpClient client = new OkHttpClient.Builder() .cache(cache) .build(); // 创建 Request 对象 Request request = new Request.Builder() .url(&quot;http://httpbin.org/get?id=id&quot;) .cacheControl(CacheControl.FORCE_NETWORK)//只从网络读取 //.cacheControl(CacheControl.FORCE_CACHE)//只读取缓存 //.cacheControl(new CacheControl.Builder().noCache().build())//永远不使用缓存 //.cacheControl(new CacheControl.Builder().maxStale(365, TimeUnit.DAYS).build())//最大缓存时效365天 .build(); // OkHttpClient 执行 Request try &#123; Response response = client.newCall(request).execute(); Response responseCache = response.cacheResponse(); Response responseNet = response.networkResponse(); if (responseCache != null) &#123; //从缓存响应 System.out.println(&quot;response from cache&quot;); &#125; if (responseNet != null) &#123; //从网络响应 System.out.println(&quot;response from net&quot;); &#125; System.out.println(&quot;response:&quot; + response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Okhttp实现缓存方式：在CacheInterceptor缓存拦截器中，根据缓存策略CacheStrategy分配。Cache和DiskLruCache。 2.10、文件下载OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(&quot;文件地址&quot;). addHeader(&quot;Accept-Encoding&quot;,&quot;identity&quot;). addHeader(&quot;Range&quot;, &quot;bytes=0-&quot;). build(); try &#123; Response response = client.newCall(request).execute(); System.out.println(&quot;content-length : &quot;+response.body().contentLength()); if (response.isSuccessful()) &#123; Headers headers = response.headers(); for (int i = 0; i &lt; headers.size(); i++) &#123; System.out.println(headers.name(i) + &quot; : &quot; + headers.value(i)); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; content-length和Range。 3、源码分析Volley是基于HttpUrlConnection；OkHttp基于Okio(原生的JavaIO + 自定义封装) + Socket连接。 3.1、OkHttpClient OkHttpClient相当于配置中心，所有的请求都会共享这些配置，比如出错是否重试、共享的连接池。主要配置有： //调度器，主要管理线程，用于调度后台发起的网络请求，有后台总请求数和单主机总请求数的控制。 //private int maxRequests = 64;private int maxRequestsPerHost = 5; final Dispatcher dispatcher; //支持的应用层协议，即HTTP/1.1、HTTP/2等 final List&lt;Protocol&gt; protocols; //应用层支持的Socket设置，即使用明文传输（HTTP）还是某个版本的TLS（用于HTTPS）。 final List&lt;ConnectionSpec&gt; connectionSpecs; //自己定义的拦截器配置 final List&lt;Interceptor&gt; interceptors; //自己定义的和网络请求交互的Interceptor配置。 final List&lt;Interceptor&gt; networkInterceptors; //管理CooKie的控制器 final CookieJar cookieJar; //Cache存储的配置。默认没有，如果要用，需要自己配置存储的文件位置和存储空间上线 final @Nullable Cache cache; //验证HTTPS握手过程中下载到的证书所属者是否和自己要访问的主机名一致 final HostnameVerifier hostnameVerifier; //一般用于防止网站证书被人仿制，开发者可以做自签名 final CertificatePinner certificatePinner; //自动重新认证。配置后，如果401，会直接调用authenticator final Authenticator authenticator; //遇到重定向，是否自动follow在HTTP和HTTPS之间切换重定向 final boolean followSslRedirects; //遇到重定向，是否自动follow final boolean followRedirects; //请求失败是否重试。重试只适用于同一个域名的多个IP切换重试、Socket失效重试等 final boolean retryOnConnectionFailure; //建立连接的超时时间 final int connectTimeout; //发起请求到读到响应数据的超时时间 final int readTimeout; //发起请求并被目标服务器接受的超时时间 final int writeTimeout; CertificatePinner的配置公钥示例： String hostname = &quot;publicobject.com&quot;; CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(hostname, &quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;) .build(); OkHttpClient client = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build(); Request request = new Request.Builder() .url(&quot;https://&quot; + hostname) .build(); client.newCall(request).execute(); 3.2、RealCall newCall(Request)方法会返回一个RealCall对象，它是Call接口的实现。 final class RealCall implements Call &#123; 当调用RealCall.execute()的时候，getResponseWithInterceptorChain()会被调用，它会发起网络请求并拿到返回的响应，装进一个Response对象并作为返回值返回。 Response result = getResponseWithInterceptorChain(); RealCall.enqueue()被调用的时候大同小异，区别在于enqueue会使用Dispatcher的线程池来把请求放在后台线程进行，但实质上使用的同样也是getResponseWithInterceptorChain()方法。 getResponseWithInterceptorChain()方法里做的事：把所有配置好的Interceptor放在一个List里，然后作为参数，创建一个RealInterceptorChain对象，并调用chain.proceed(request)发起请求和获取响应。 RealCall类中的getResponseWithInterceptorChain()方法作用：将请求Request转变成响应Response。 Response getResponseWithInterceptorChain() throws IOException &#123; // 拦截器的一个集合 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 客户端的所有自定义拦截器，可以添加自己定义的 interceptors.addAll(client.interceptors()); // OKhttp 5 个拦截器 ，责任链设计模式，每一个拦截器只处理与他相关的部分 interceptors.add(retryAndFollowUpInterceptor);// 重试 interceptors.add(new BridgeInterceptor(client.cookieJar()));// 基础 interceptors.add(new CacheInterceptor(client.internalCache()));// 缓存 interceptors.add(new ConnectInterceptor(client));// 建立连接,连接服务器 interceptors.add(new CallServerInterceptor(forWebSocket));// 写数据 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125; 3.3、拦截器在RealInterceptorChain中，多个Interceptor会依次调用自己的intercepter方法，方法会做三件事情 1、对请求进行预处理 2、预处理之后，重新调用RealInterceptorChain.proceed()把请求交给下一个Interceptor。 3、在下一个Interceptor处理完成并返回之后，拿到Response进行后续处理 从上到下，每级Interceptor： 1、首先是开发者自己设置的addInterceptor(Interceptor)，在所有其他Interceptor处理之前，进行最早的预处理工作，以及收到Response之后，做最后的善后工作。如果有统一的header要添加，可以在这里设置。 2、RetryAndFollowUpInterceptor： 处理重试的一个拦截器，会去处理一些异常，只要不是致命的异常就会重新发起一次请求（把Request给下级），如果是致命的异常就会抛给上一级；会处理一些重定向等等，比如 3XX 307、407 就会从头部中获取新的路径，生成一个新的请求交给下一级（重新发起一次请求）。 3、BridgeInterceptor 做一个简单的处理，设置一些通用的请求头，Content-Type、Connection、Content-Length的计算和添加、Cookie。做一些返回的处理，如果返回的数据被压缩了采用ZipSource, 保存 Cookie。 4、CacheInterceptor 在缓存可用的情况下，直接读取本地的缓存的数据，如果本地的缓存没有直接去服务器，如果本地的缓存有，首先判断有没有缓存策略，然后判断有没有过期，如果没有过期直接拿缓存，如果过期了需要添加一些之前头部信息如If-Modified-Since,这个时候后台有可能会返回304代表还是可以拿本地缓存，每次读取到新的响应后做一次缓存。 5、ConnectInterceptor findHealthyConnection()找一个连接，首先判断有没有健康的，没有就创建（建立Scoket,握手连接），连接缓存得到一条结论：OkHttp是基于原生的Socket + okio（原生IO的封装）。封装HttpCodec里面封装了okio的Source（输入）和Sink(输出)，我们通过HttpCodec就可以操作 Socket的输入输出，我们就可以像服务器写数据和读取返回数据。 TCP连接（如果是HTTP）或者是建立在TCP连接之上的TLS连接（如果是HTTPS），并且会创建出对应的HttpCodec对象（用于编码解码HTTP请求）。 6、addNetworkInterceptor：开发者自己设置的，这里设置的Interceptor会看到每个请求和响应的数据（包括重定向以及重试的一些中间请求和响应），并且看到的是完整原始数据，而不死没加Content-Length的请求数据，或者Body还没有被gzip解压的响应数据。 7、CallServerInterceptor 它负责实质的请求和响应的I/O操作，即往Socket里写入请求数据和从Socket里读取响应数据。Socket就是TCP的端口。 连接三个核心类（连接复用） RealConnection: 建立连接的一个对象的封装 ConnectionPool：保存了连接 StreamAllocation: 找一些连接，做一下封装 4、Okio程序内部（内存）和外部（本地文件和网络）进行数据交互的过程，就叫输入输出。 从文件里或者从网络上读数据到内存里，就叫输入；从内存里写到文件里或者发送到网络上，就叫输出。Java I/O 作用只有一个：和外界做数据交互。使用流，例如 FileInputStream / FileOutputStream。 Okio特点：基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink，支持 Buffer，可以对 Buffer 进行操作，但不强制使用Buffer。 try (Source source = Okio.buffer(Okio.source(new File(&quot;./io/text.txt&quot;)))) &#123; Buffer buffer = new Buffer(); source.read(buffer, 1024); System.out.println(buffer.readUtf8Line()); System.out.println(buffer.readUtf8Line()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"http://yoursite.com/tags/OkHttp/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"HTML和CSS基础","slug":"2.html和css基础","date":"2018-12-01T12:15:03.995Z","updated":"2021-03-26T14:39:44.103Z","comments":false,"path":"2018/12/01/2.html和css基础/","link":"","permalink":"http://yoursite.com/2018/12/01/2.html%E5%92%8Ccss%E5%9F%BA%E7%A1%80/","excerpt":"","text":"sublime http://www.sublimetext.com/ https://jingyan.baidu.com/article/925f8cb8dedc12c0dce05674.html https://jingyan.baidu.com/article/ce43664935b90c3772afd377.html HTML的全称为：HyperText Mark-up Language, 指的是超文本标记语言。 标记：就是标签，标签大多数都是成对出现的。 所谓超文本，有两层含义:因为网页中还可以图片、视频、音频等内容(超越文本限制);它还可以在网页中跳转到另一个网页，与世界各地主机的网页链接(超链接文本)。 html的基本结构 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页显示内容 &lt;/body&gt; &lt;/html&gt; 标签常用的html标签 &lt;!-- 1、成对出现的标签：--&gt; &lt;h1&gt;h1标题&lt;/h1&gt; &lt;h2&gt;h2标题&lt;/h2&gt; &lt;h3&gt;h3标题&lt;/h3&gt; &lt;h4&gt;h4标题&lt;/h4&gt; &lt;h5&gt;h5标题&lt;/h5&gt; &lt;h6&gt;h6标题&lt;/h6&gt; &lt;div&gt;这是一个div标签&lt;/div&gt; &lt;p&gt;这个一个段落标签&lt;/p&gt; &lt;span&gt;这是一个span标签&lt;/span&gt; &lt;!-- 2、单个出现的标签： --&gt; &lt;br /&gt; //换行 &lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; border=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; &lt;hr /&gt; //分割线 &lt;!-- 3、带属性的标签，如src、alt 和 href等都是属性 --&gt; &lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网&lt;/a&gt; &lt;!-- 4、标签的嵌套 --&gt; &lt;div&gt; &lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网&lt;/a&gt; &lt;/div&gt; 其他标签 加粗 &lt;strong&gt;&lt;/strong&gt; &lt;b&gt;&lt;/b&gt; 倾斜 &lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; 删除线 &lt;s&gt;&lt;/s&gt; &lt;del&gt;&lt;/del&gt; 下划线 &lt;u&gt;&lt;/u&gt; &lt;ins&gt;&lt;/ins&gt; 链接 &lt;a href=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt; 锚点定位（跳转） &lt;a href=&quot;#id&quot;&gt;&lt;/a&gt; base设置整体链接状态 &lt;base target=&quot;_blank&quot; /&gt; 特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ¥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2 (上标2) &amp;sup2; ³ 立方3 (上标3) &amp;sup3; 列表标签 无序列表 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 注意：ul和ol里面之能放li,li里面可以放其他标签。 自定义列表 &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; 表格标签 &lt;table width=&quot;&quot; border=&quot;&quot; align=&quot;&quot; cellpadding=&quot;&quot; cellspacing=&quot;&quot;&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr align=&quot;&quot;&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 属性名 含义 常用属性值 border 设置表格的边框(默认border=”0”无边框) 像素值 ellspacing 设置单元格与单元格边框之间的空白间距 像素值(默认为2像素) cellpadding 设置单元格内容与单元格边框之间的空白间距 像素值(默认为1像素) width 设置表格的宽度 像素值 height 设置表格的高度 像素值 align 设置表格在网页中的水平对齐方式 left、center、 right 合并单元格（rowspan合并行，colspan合并列） &lt;table width=&quot;500&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;13&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;31&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;32&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 效果 表单标签 表单标签是&lt;form&gt;标签,定义整体的表单区域。 input表单 属性 属性值 描述 type text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像形式的提交按钮 file 文件域 name 由用户自定义 控件的名称 value 由用户自定义 input控件中的默认文本值 size 正整数 input控件在页面中的显示宽度 checked checked 定义选择控件默认被选中的项 maxlength 正整数 控件允许输入的最多字符数 注意： 同一组radio中，name要相同。 label标签 &lt;label&gt; 用户名&lt;input type=&quot;text&quot;&gt; &lt;/label&gt; &lt;br /&gt; &lt;label for=&quot;pwd&quot;&gt; 用户名&lt;input type=&quot;text&quot; /&gt; 密码&lt;input type=&quot;password&quot; id=&quot;pwd&quot; /&gt; &lt;/label&gt; textarea标签 &lt;textarea cols=&quot;每行中字符数&quot; rows=&quot;显示的行数&quot;&gt; &lt;/textarea&gt; select标签 &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot; selected=&quot;selected&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;/select&gt; 表单提交 &lt;form action=&quot;提交地址url&quot; method=&quot;提交方式get/post&quot;&gt; 用户名&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;submit&quot; /&gt; &lt;/form&gt; action属性：设置表单数据提交地址。method属性 设置表单提交的方式，一般有“GET”方式和“POST”方式, 不区分大小写。 表单元素属性设置：name属性：设置表单元素的名称，该名称是提交数据时的参数名；value属性：设置表单元素的值，该值是提交数据时参数名所对应的值。 拓展 http://www.w3school.com.cn/ https://developer.mozilla.org/zh-CN/ 引入CSS样式表 css(Cascading Style Sheet)层叠样式表，它是用来美化页面的一种语言。 第一种：行内式（内联样式） &lt;h3 style=&quot;color: pink; font-size: 25px;&quot;&gt;英文版新闻报&lt;/h3&gt; 第二种：内部样式表 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h3 &#123; color: pink; font-size: 60px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;英文版新闻报&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 第三种：外部样式表(外联式) html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;英文版新闻报&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; css文件 h3 &#123; color: pink; font-size: 60px; &#125; CSS选择器之基本选择器标签选择器（元素选择器） 把某类标签全部选出来。 类选择器 .类名 &#123; 属性:属性值; &#125; 注意：可以使用中横线命名，不建议使用下划线_,不能数字开头。 多类名选择器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .colred &#123; color: red; &#125; .font20 &#123; font-size: 50px; color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 class=&quot;colred font20&quot;&gt;英文版新闻报&lt;/h3&gt; &lt;h3 class=&quot;colred&quot;&gt;英文版新闻报&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 注意：空格隔开；样式显示跟类名先后顺序没有关系，受css样式书写的上下顺序有关。 id选择器 #id &#123; 属性:属性值; &#125; 注意：id只能使用一次，class可以使用多次。 第四种：通配符选择器 *代表所有，?代表单个字符。 * &#123; 属性：属性值; &#125; CSS选择器之复合选择器后代选择器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div p &#123; color: pink; &#125; .dd p&#123; font-size: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;英文版新闻报&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;dd&quot;&gt; &lt;p&gt;英文版新闻报&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 子代选择器-选择亲儿子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul li &gt; a &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;一级菜单&lt;/a&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;二级菜单&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 并集选择器 ** &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div,p,span &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;并集选择器&lt;/div&gt; &lt;p&gt;并集选择器&lt;/p&gt; &lt;span&gt;并集选择器&lt;/span&gt; &lt;h1&gt;并集选择器&lt;/h1&gt; &lt;a href=&quot;#&quot;&gt;并集选择器&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 交集选择器(即..又..) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div.red &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;red&quot;&gt;交集选择器&lt;/div&gt; &lt;p class=&quot;red&quot;&gt;交集选择器&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 伪类选择器 链接伪类选择器 link /*未访问的链接*/ visited /*已访问的链接*/ hover /*鼠标移动到链接上*/ active /*选定的链接*/ 代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a:link &#123;&lt;!-- 未访问的链接状态 --&gt; color: #333; text-decoration: none; &#125; a:visited &#123;&lt;!-- 已访问的链接 --&gt; color: pink; &#125; a:hover &#123;&lt;!-- 鼠标经过时候样子 --&gt; color: red; &#125; a:active &#123;&lt;!-- 鼠标按下时候样子 --&gt; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;双十一&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 常见写法 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a &#123; color: #333; text-decoration: none; font-size: 25px; font-weight: 700; &#125; a:hover &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;双十一&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; CSS属性布局常用样式属性 width 设置元素(标签)的宽度，如：width:100px; height 设置元素(标签)的高度，如：height:200px; background 设置元素背景色或者背景图片，如：background:gold; 设置元素的背景色, background: url(images/logo.png); 设置元素的背景图片。 border 设置元素四周的边框，如：border:1px solid black; 设置元素四周边框是1像素宽的黑色实线 以上也可以拆分成四个边的写法，分别设置四个边的： border-top 设置顶边边框，如：border-top:10px solid red; border-left 设置左边边框，如：border-left:10px solid blue; border-right 设置右边边框，如：border-right:10px solid green; border-bottom 设置底边边框，如：border-bottom:10px solid pink; padding 设置元素包含的内容和元素边框的距离，也叫内边距，如padding:20px;padding是同时设置4个边的，也可以像border一样拆分成分别设置四个边:padding-top、padding-left、padding-right、padding-bottom。 margin 设置元素和外界的距离，也叫外边距，如margin:20px;margin是同时设置4个边的，也可以像border一样拆分成分别设置四个边:margin-top、margin-left、margin-right、margin-bottom。 float 设置元素浮动，浮动可以让块元素排列在一行，浮动分为左浮动：float:left; 右浮动：float:right; 文本常用样式属性 color 设置文字的颜色，如： color:red; font-size 设置文字的大小，如：font-size:12px; font-family 设置文字的字体，如：font-family:&apos;微软雅黑&apos;;为了避免中文字不兼容，一般写成：font-family:&apos;Microsoft Yahei&apos;; font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗 line-height 设置文字的行高，如：line-height:24px; 表示文字高度加上文字上下的间距是24px，也就是每一行占有的高度是24px text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉 text-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中 text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24px CSS字体属性 font-size字号大小（px、em）、font-family字体 、font-weight字体粗细 、font-style字体风格（倾斜） font-size: 18px; /*font-family: &quot;宋体&quot;;*/ font-family: &quot;\\5B8B\\4F53&quot;; font-weight: bold; /*font-weight: normal;*/ /*font-style: normal;*/ font-style: italic; bold相当于700，normal为400。 font综合设置 选择器&#123;font: font-style font-weight font-size font-family ;&#125; 注意：不能更换顺序。font-size和font-family不能省略。 CSS外观属性color颜色、line-height行间距、text-align文字水平对齐方式(left ,right,center)、text-indent首行缩进、text-decoration文本的装饰。 color: #FF0000; line-height: 24px; text-align: left; text-indent: 2em; text-decoration: line-through; /*none:无装饰、underline:下划线、line-through:删除线*/ 注意：如果行高line-height等于height高度，文字会垂直居中。 一般居中写法 line-height: (=height);text-align: center; backgroundbackground-color: #fff; background-image: url(); background-repeat /* 平铺方式：repeat、no-repeat、repeat-x、repeat-y*/ background-repeat: repeat-x; background-position /* x轴和y轴位置 ，top、bottom、left、right*/ /* background-position: 12px 12px; */ /* 如果只写一个方位，另一个默认居中 */ /* background-position: bottom; */ background-position: center bottom; background-attachment滚动还是固定，默认滚动 /* fixed */ background-attachment: scroll; background简写,没有强制顺序 background: background-color background-image background-repeat background-attachment background-position background: transparent url(image.jpg) repeat scroll 50% 0; 设置透明，最后一位为alpha background: rgba(0, 0, 0, 0.5); 标签显示模式块级元素和行内元素相互转换： div &#123; display: inline; &#125; span &#123; display: block; &#125; 把行内元素转换为行内快元素： a &#123; display: inline-block; &#125; CSS三大特性1、层叠性 样式冲突，以最后样式为准。样式不冲突，不会重叠。 2、继承性 子标签会继承父标签的某些样式。一般继承文字的样式。 3、优先级 !important(无穷大) &gt; 行内样式(1,0,0,0) &gt; id选择器(0,1,0,0) &gt; 类选择器(伪类)(0,0,1,0) &gt; 标签选择器(0,0,0,1) &gt; *选择器和继承选择器(0,0,0,0) 注意 权重相同，就近原则；权重会叠加； 盒子模型 盒子模型的5个主要样式属性 width：内容的宽度(不是盒子的宽度) height：内容的高度(不是盒子的高度) padding：内边距。 border：边框。 margin：外边距 盒子的真实尺寸只会受到宽度、高度、边框、内边距四个属性的影响，不会受到外边距属性的影响。 盒子边框(border) border-width、border-style、border-color border-width: 1px; border-color: red; /* none无边框、solid实线边框、dashed虚线边框、dotted点线边框 */ border-style: dashed; 连写，没有顺序 border: 1px solid red; 边框可以拆开 border-top: 1px solid red; border-bottom: 1px solid green; 去掉所有边框 border: 0; 表格细线边框 table, td &#123; border-collapse: collapse; &#125; 内边框(padding) padding会撑开带width和height盒子。 padding: 10px; padding-left: 10dp; padding: 10px 20px; /* 上下分别10和左右分别20 */ padding: 10px 20px 30px; /* 上10,左右分别20,下30 */ padding: 10px 20px 30px 40px; /* 顺时针，上右下左 */ 注意：如果盒子没有给定宽高，padding不会影响盒子大小。 外边距(margin) 清除元素内外边距 * &#123; margin: 0; padding: 0; &#125; 清除li中圆点 li &#123; list-style: none; &#125; 让盒子水平居中,注意，必须给块级盒子设置宽度。 margin: 0 auto; 或者 margin-left: auto; margin-right: auto; text-align: center;/* 内容水平居中 */ 相邻块元素垂直外边距合并问题 /* 一个元素是 */ margin-bottom: 100px; /* 另一个元素是 */ margin-top: 50px; /*合并后的距离为100px，即以大的为准 */ 嵌套块元素垂直外边距合并问题 三种解决办法： border-top: 1px solid red; padding-top: 1px; overflow: hidden; 圆角边框和盒子阴影圆角边框 border-radius: 10px;/* 圆角 */ border-radius: 50%;/* 正方形变成圆 */ border-radius: 10px 20px 30px 40px;/* 左上开始顺时针 */ border-radius: 10px 0;/* 左上右下和右上左下 */ 阴影 box-shadow: 0px 15px 30px 2px rgba(0,0,0,0.4); box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影; 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅CSS颜色值。 inset 可选。将外部阴影(outset)改为内部阴影。 浮动作用：使多个div在一行显示，float属性值有left、right、none。 li使用float可以一行排列。 浮动的盒子，不会超过内边距。浮动脱离标准流，不占位置，会影响下面的标准流。浮动只有左右浮动。 注意 ：浮动可以让元素默认转换为行内块元素。 清除浮动本质：解决父级元素因为子级浮动引起内部高度为0的问题。 父元素自动检测子级元素的高度，以最高为准。常用四种解决办法。 1、额外标签法 在最后一个浮动标签后面新添加一个标签，清除浮动。 clear: both; 2、父级添加overflow 给父级元素添加 overflow: hidden; 3、使用after伪元素清除浮动 给父级元素添加类名clearfix .clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; *zoom: 1; /* IE6、7 */ &#125; 4、使用before和after双伪元素清除浮动 给父级元素添加类名clearfix .clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table; &#125; .clearfix:after &#123; clear: both; &#125; .clearfix &#123; *zoom: 1; /* IE6、7 */ &#125; 定位定位属性主要包括定位模式和边偏移两部分。 值 描述 static 自动定位 (默认定位方式) relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元索进行定位 fixed 固定定位，相对于浏览器窗口进行定位 1、相对定位 position: relative; top: 100px; left: 100px; 注意：相对定位可以通过边偏移移动位置，但是原来的所占的位置，继续占有。以自己的左上角为基准点定位。 2、绝对定位 position: absolute; top: 100px; left: 100px; 注意：绝对定位不占位置。若所有父元素都没有定位，以浏览器当前屏幕为基准点定位。 绝对定位依据最近的已经定位的父元素进行定位。 子绝父相。正常情况，子级是绝对定位的话，父级要用相对定位。 定位的盒子居中 position: absolute; left: 50%; margin-left: -(宽度/2); top: 50%; margin-top: -(高度/2); 3、固定定位 position: fixed; left: 0; top: 0; 注意：不管父元素有没有定位，都是以浏览器当前屏幕为基准点定位，和父元素没有关系。 模式转换： 绝对定位和固定定位，元素模式发生转换，都转换为行内快模式。 叠放次序(z-index) z-index: 1; 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准值 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 脱标，占有位置 可以 相对自身位置移动(自恋型) 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置(拼爹型) 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置(认死理型) z-index默认为0，取值越大，越居上，如果取值相同，后来者居上。 只有定位的盒子才有z-index。 没有单位。 鼠标样式、轮廓线、防止拖拽文本域鼠标样式 cursor: default;/*default: 默认、 pointer： 小手、 text： 选择、move： 移动*/ 轮廓线 input &#123; outline: none;/* 取消轮廓线 */ border: 1px solid red; &#125; 防止拖拽文本域 textarea &#123; resize: none;/* 不要重新规定尺寸 */ outline: none;/* 取消轮廓线 */ &#125; vertical-align针对行内元素和行内块元素。控制图片和文字位置 img &#123; vertical-align: middle;/* top、bottom */ &#125; 显示与隐藏 display: none;/* 隐藏 */ display: block;/* 显示 */ display隐藏后不保留位置。 visibility: visible;/* 显示 */ visibility: hidden;/* 隐藏 */ visibility隐藏后保留位置。 overflow: hidden; overflow四个属性auto; scroll; hidden; visible; 溢出文字隐藏 当子元素(标签)的尺寸超过父元素(标签)的尺寸时，此时需要设置父元素显示溢出的子元素的方式，设置的方法是通过overflow属性来完成。 overflow的设置项：visible 默认值, 显示子标签溢出部分。hidden 隐藏子标签溢出部分。auto 如果子标签溢出，则可以滚动查看其余的内容。 white-space: nowrap;/* 强制在同一行内显示所有文本，直到文本结束或者br */ overflow: hidden;/* 超出部分隐藏 */ text-overflow: ellipsis;/* 超出部分显示省略号 */ 注意：做省略号效果，上面三句都需要。 Sprites为了有效地减少服务器接收和发送请求次数，提高页面加载速度。 CSS精灵是一种处理网页背景图像的方式。 滑动门字体图标icomoon字库 https://icomoon.io/ 阿里icon font字库 http://www.iconfont.cn/ sublime快捷键sublime可以快速提高我们代码的书写方式 1.生成标签直接输入标签名按tab键即可 比如div 然后tab键，就可以生成&lt;div&gt;&lt;/div&gt; 2.如果想要生成多个相同标签加上*就可以了比如div*3 就可以快速生成3个div 3.如果有父子级关系的标签，可以用&gt;比如ul&gt; li就可以了 4.如果有兄弟关系的标签，用+就可以了比如div+p 5.如果生成带有类名或者id名字的，直接写 .demo 或者#two tab 键就可以了","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"HTML标签","slug":"HTML标签","permalink":"http://yoursite.com/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]},{"title":"JavaScript基本语法和DOM和BOM","slug":"1.JavaScript基本语法和DOM和BOM","date":"2018-11-25T14:09:07.125Z","updated":"2021-03-27T06:08:23.700Z","comments":false,"path":"2018/11/25/1.JavaScript基本语法和DOM和BOM/","link":"","permalink":"http://yoursite.com/2018/11/25/1.JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8CDOM%E5%92%8CBOM/","excerpt":"","text":"JavaScript介绍 js分为三个部分：ECMAScript标准（js的基本语法）、DOM（文档对象模型）、BOM（浏览器对象模型）。 js是一种脚本语言，解释型语言。 JavaScript三种写法 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;我是第一种写法&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;我是第二种写法&apos;)&quot;/&gt; &lt;script language=&quot;JavaScript&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; test.js alert(&quot;我是第三种写法&quot;); 变量和数据类型 js中声明变量都用var，js中字符串可以使用单引号，也可以使用双引号。 原始数据类型： number、string、boolean、null、undefined、object 获取变量的数据类型(注意，null获取的类型为object) typeof 变量名;//或者 typeof (变量名); 判断是不是数字（不是数字返回true） isNaN(变量名); 判断字符串长度 字符串变量名.length 其他类型转为数字，Number最严格 parseInt(&quot;10&quot;); parseFloat(&quot;10.02&quot;); Number(&quot;10&quot;); 其他类型转为字符串 变量名.toString();//变量名一定要有意义 String(变量名); 其他类型转为布尔() Boolean(变量); 注意:==和===区别，==只进行值的比较，===对比值和类型。 注意:运算符先后顺序，先&amp;&amp;，后||。 if语句 if(条件)&#123; &#125; else if(条件)&#123; &#125; else &#123; &#125; 三元表达式 var 变量 = 表达式1 ? 表达式2 : 表达式3; switch语句 switch (表达式)&#123; case 值1: 代码1; break; case 值2: 代码2; break; ... default: 代码3; break; &#125; while循环(有可能一次都不执行) while(循环的条件)&#123; 循环体; 计数器++; &#125; do…while(至少执行一次) do&#123; //循环体 &#125;while(条件); for循环 先执行表达式1，然后判断表达式2，如果不成立直接跳出循环。如果成立，执行循环体代码，结束后，跳到表达式3，然后判断表达式2。 for (表达式1; 表达式2; 表达式3) &#123; 循环体; &#125; for(var i = 0; i &lt; 10; i++)&#123; &#125; 调试 alert(); console.log(); document.write(&quot;&quot;); 代码调试 数组 var arr1 = new Array();//空数组 var arr2 = new Array(5);//长度为5，每个值是undefined var arr3 = [];//空数组 var arr4 = new Array(10,20,40,55,35);//5个值 var arr5 = [10,30,50,20,40];//5个值 设置某个位置的值 数组名[下标] = 值; 获取某个位置的值 var result = 数组名[下标]; 获取数组长度 数组名.length 数组中存储的数据类型可以不一样。 从数组最后添加和删除数据： var aList = [1,2,3,4]; aList.push(5); alert(aList); //弹出1,2,3,4,5 aList.pop(); alert(aList); // 弹出1,2,3,4 根据下标添加和删除元素 arr.splice(start,num,element1,.....,elementN) 参数解析：start：必需，开始删除的索引。num：可选，删除数组元素的个数。elementN：可选，在start索引位置要插入的新元素。 此方法会删除从start索引开始的num个元素，并将elementN参数插入到start索引位置。 var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; colors.splice(0,1); //删除第一项 alert(colors); //green,blue colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //从第一个索引位置插入两项数据 alert(colors); //green,yellow,organge,blue colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //删除一项，插入两项数据 alert(colors); //green,red,purple,orange,blue 函数 函数的定义 function 函数名()&#123; 函数体 &#125; 函数的调用 函数名(); 函数的参数 function 函数名(参数名)&#123; 函数体 &#125; 注意:参数不需要定义var。形参指函数定义时小括号中的变量。实参指函数在调用时候小括号中传入的值。形参和实参个数可以不一致。 函数的返回值 function getSum(x,y)&#123; return x + y; &#125; var result = getSum(10,30); 函数的数据类型是function arguments对象伪数组arguments可以获取传入的每个参数的值 function f1()&#123; arguments.length; console.log(arguments) &#125; f1(10,20,30,50); 匿名函数（函数表达式）var f1 = function ()&#123; console.log(&quot;dsds&quot;); &#125; //匿名函数不能直接调用 f1(); 函数的自调用（一次性）(function ()&#123; console.log(&quot;ddddds&quot;); &#125;)(); 函数作为参数（回调函数）注意f2不要加括号 function f1(fn)&#123; fn(); &#125; function f2()&#123; console.log(&quot;原来这样&quot;); &#125; f1(f2); 函数作为返回值注意ff(); function f1()&#123; console.log(&quot;原来&quot;); return function ()&#123; console.log(&quot;原来这样&quot;); &#125;; &#125; var ff = f1(); ff(); 作用域全局变量：用var声明的。可以在页面的任何位置使用。页面不关闭，全局变量不会释放，会占空间，消耗内存。 局部变量：函数function中定义的变量。外面不能使用。 块级作用域：一对大括号中声明的变量。在js中，括号外面也能使用块级作用域中的变量。函数除外。 全局作用域：全局变量的适用范围。 局部作用域：局部变量的适用范围。 隐式全局变量：声明变量没有用var。函数中声明的局部变量，函数外面不可以访问。函数中声明的隐式全局变量，函数外面可以访问。 全局变量不能被删除，隐式全局变量可以被删除。使用var是不会被删除，没有var是可以删除。 var num1 = 10; num2 = 20; delete num1; delete num2; console.log(typeof num1);//number console.log(num1 + 10);//20 console.log(typeof num2);//underfine 预解析变量的声明和函数的声明被提前了。 把变量的声明提前了。局部作用域中局部变量声明也会提前，只提前在局部作用域中。 console.log(num);//underfine var num = 10; 函数的声明提前了。 f1(); function f1()&#123; console.log(&quot;dd&quot;);//dd &#125; 注意： 结果为underfine f1(); var num = 20; function f1()&#123; console.log(num);//underfine &#125; 结果为20 var num = 20; function f1()&#123; console.log(num);//20 &#125; f1(); 结果为underfine var num = 20; function f1()&#123; console.log(num);//underfine var num = 30; &#125; f1(); 结果为一个报错，其余为9，因为b和c为隐式全局变量，a是局部变量。 f1(); console.log(c); console.log(b); console.log(a);//报错 function f1()&#123; var a = b = c = 9; console.log(c); console.log(b); console.log(a); 结果为f1();报错，预解析f1是变量，调用f1();报错。 f1(); var f1 = function ()&#123; console.log(a); var a = 9; &#125; 创建对象1、调用系统的构造函数创建对象 var people = new Object(); //添加属性 people.name = &quot;小李&quot;; people.age = 18; //添加方法 people.eat = function()&#123; console.log(&quot;吃&quot;); &#125;; //调用 people.eat(); 获取变量或者对象属于什么类型 instanceof 工厂模式创建对象 function createObject(name,age)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.say = function ()&#123; console.log(&quot;我叫&quot;+this.name+&quot;，今年&quot;+this.age); &#125;; return obj; &#125; var person1 = createObject(&quot;小李&quot;,20); person1.say(); 2、自定义构造函数创建对象 函数和构造函数区别，首字母是不是大写 function Person(name,age)&#123; this.name = name; this.age = age; this.say = function ()&#123; console.log(&quot;我叫&quot;+this.name+&quot;，今年&quot;+this.age); &#125;; &#125; var obj = new Person(&quot;小明&quot;,20); console.log(obj.age); obj.say(); 3、字面量的方式创建对象 var obj = &#123; name : &quot;jsop&quot;, say : function ()&#123; console.log(&quot;I am &quot; + this.name); &#125; &#125;; obj.say(); JSON格式的数据遍历访问属性的另一种写法：[&quot;&quot;] var obj = &#123; name : &quot;jsop&quot;, say : function ()&#123; console.log(&quot;I am &quot; + this.name); &#125; &#125;; obj.say(); 遍历 var json = &#123; &quot;name&quot; : &quot;jsop&quot;, &quot;age&quot; : 18 &#125;; for(var key in json)&#123; console.log(key); console.log(json[key]); &#125; 内置对象(系统提供的)https://developer.mozilla.org/zh-CN/ Math Math.random()//[0,1)范围 Date var dt = new Date();//当前时间 console.log(dt.valueOf());//毫秒值 String .replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;); .slice(开始索引，结束索引)；//截取 .split();//切割 Array .push(值);//给数组追加值，在最后添加，返回值是数组长度 .unshift();//给数组追加值，在最前添加，返回值是数组长度 .pop();//删除数组最后的值，返回删除的值 .shift();//删除数组第一个的值，返回删除的值 DOM-文档对象模型文档：document 元素element：页面中的每个标签，都是一个元素，每个元素都可以看成是一个对象。 节点node：页面中所有的内容都是节点，包括标签，属性，文本。 根元素：html标签。 获取元素对象 document.getElementById(&quot;id&quot;) &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; id=&quot;btn&quot;&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).onclick = function ()&#123; alert(&quot;哈哈&quot;); &#125;; &lt;/script&gt; &lt;/body&gt; document.getElementsByTagName(&quot;标签名&quot;) 返回一个伪数组 var pObjs = document.getElementsByTagName(&quot;p&quot;) for (var i = 0; i &lt; pObjs.length;i++)&#123; pObjs[i].innerText = &quot;哈哈哈&quot;; &#125; 和document.getElementsByTagName类似的有：document.getElementsByName获取的是name伪数组，document.getElementsByClassName获取的是class伪数组 document.getElementsByTagName–排他功能 &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; &gt; &lt;script &gt; var objs = document.getElementsByTagName(&quot;input&quot;) for (var i = 0; i &lt; objs.length;i++)&#123; objs[i].onclick = function () &#123; for (var j = 0; j &lt; objs.length;j++)&#123; objs[j].value = &quot;显示&quot;; &#125; this.value= &quot;点击&quot;; &#125;; &#125; &lt;/script&gt; 根据选择器的方式获取元素 &lt;input type=&quot;button&quot; value=&quot;show&quot; id=&quot;btn&quot; class=&quot;cls&quot;/&gt; &lt;script &gt; document.querySelector(&quot;#btn&quot;).onclick = function()&#123; alert(&quot;哈哈&quot;); &#125;; var objs = document.querySelectorAll(&quot;cls&quot;);//伪数组 &lt;/script&gt; 小结 根据id属性的值获取元素，返回来的是一个元素对象document.getELementById(&quot;id属性的值&quot;); 根据标签名字获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象document.getELementsByTagName(&quot;标签名字&quot;); 下面的几个，有的浏览器不支持 根据name属性的值获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象document.getELementsByName (&quot;name属性的值&quot;) 根据类样式的名字来获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象document.getELementsByClassName(&quot;类样式的名字&quot;)根据选择器获取元素，返回来的是一个元素对象document.querySelector( &quot;选择器的名字&quot;); 对象属性class设置使用className document.getElementById(&quot;dd&quot;).className = &quot;cls&quot;; 获取body、title、html document.body document.title document.documentElement 阻止超链接跳转 &lt;a href=&quot;http://www.baidu.com&quot; id=&quot;ak&quot;&gt;百度&lt;/a&gt; &lt;script &gt; document.getElementById(&quot;ak&quot;).onclick = function ()&#123; alert(&quot;哈啊哈&quot;); return false; &#125;; &lt;/script&gt; 鼠标进入和离开 .onmouseover .onmouseout 文本框获取焦点和失去焦点 .onfocus .onblur 键盘弹起 .onkeyup 获取输入框输入长度value.length &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;txt&quot;/&gt; &lt;script &gt; document.getElementById(&quot;txt&quot;).onblur = function()&#123; alert(this.value.length); &#125;; &lt;/script&gt; innerText和textContent、innerHTML凡是成对的标签，设置文本内容，都使用innerText属性,同样，获取文本内容是.innerText。 document.getElementById(&quot;p1&quot;).innerText=&quot;这是设置文本p&quot;; 单数不兼容。innerText：谷歌，火狐支持，IE8不支持；textContent：谷歌，火狐，IE8都支持。 封装 //设置 function setInnerText(element,text)&#123; if(typeof element.textContent == &quot;underfined&quot;)&#123;//不支持 element.innerText = text; &#125; else&#123;//支持 lement.textContent = text; &#125; &#125; //获取 function getInnerText(element)&#123; if(typeof element.textContent == &quot;underfined&quot;) &#123;//不支持 return element.innerText; &#125; else&#123;//支持 return element.textContent; &#125; &#125; innerText和innerHTML都可以设置设置文本，innerHTML还可以设置标签。 innerText可以获取标签中的文本，但是标签中还有标签，那么最里面的标签文本内容也能获取。innerHTML可以获取标签中的所有文本，包括标签。 .innerHTML = &quot;haha&quot;; .innerHTML = &quot;&lt;p&gt;这是p&lt;/p&gt;&gt;&quot;; 自定义属性自定义属性获取：getAttribute。自定义属性动态设置：setAttribute &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; ul&#123; list-style: none; cursor: pointer; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;王五&lt;/li&gt; &lt;li&gt;赵六&lt;/li&gt; &lt;/ul&gt; &lt;script &gt; var list = document.getElementsByTagName(&quot;li&quot;); for(var i = 0; i &lt; list.length; i ++)&#123; list[i].setAttribute(&quot;score&quot;,(i+1)*10); list[i].onclick = function()&#123; alert(this.getAttribute(&quot;score&quot;)); &#125;; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 移除自定义属性 .removeAttribute(&quot;name&quot;) 移除class .removeAttribute(&quot;class&quot;); 设置backgroundImage .style.backgroundImage = &quot;url(&quot; + src + &quot;)&quot;; 节点节点的类型 nodeType:1、标签，2、属性，3、文本。 节点的名字 nodeName:标签节点：大写的标签名字；属性节点：小写的属性名字；文本节点：#text 节点的值 nodeValue:标签节点：null;属性节点：属性值；文本节点：文本内容。 获取父节点和父元素 .parentNode .parentElement 子节点和子元素 .childNodes .children 第一个子节点和子元素 .firstChild//IE8是元素 .firstElementChild//IE8不支持 最后一个子节点和子元素 .lastChild//IE8是元素 .lastElementChild//IE8不支持 某元素的前一个兄弟节点和元素 .previousSibling//IE8是元素 .previousElementSlbling//IE8不支持 某元素的后一个兄弟节点和元素 .nextSibling//IE8是元素 .nextElementSlbling//IE8不支持 获取节点 .getAttributeNode(&quot;属性名&quot;); 元素的创建三种方式 1、document.write(&quot;标签的代码及内容&quot;) 缺陷：如果是在页面加载完毕后，通过这种方式创建的，页面上存在的所有的内容全部被干掉。 2、对象.innerHTML = &quot;标签及代码&quot; 3、document.createElement(&quot;标签的名字&quot;) 注意：要追加到父级元素，appendChild &lt;input type=&quot;button&quot; value=&quot;追加&quot; id=&quot;btn&quot;/&gt; &lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).onclick = function ()&#123; var pObj = document.createElement(&quot;P&quot;); pObj.innerText = &quot;这是p&quot;; document.getElementById(&quot;dv&quot;).appendChild(pObj); &#125;; &lt;/script&gt; 把新的子元素插到第一个子元素前面 .insertBefore(新元素，旧元素); 移除父级元素中的第一个元素 .removeChild(父元素对象.firstElementChild); 移除父级元素中的所有元素 while(父元素对象.firstElementChild)&#123; .removeChild(父元素对象.firstElementChild); &#125; createElement只创建一个元素 &lt;input type=&quot;button&quot; value=&quot;追加&quot; id=&quot;btn&quot;/&gt; &lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).onclick = function ()&#123; if(!document.getElementById(&quot;dv&quot;).firstElementChild)&#123; var pObj = document.createElement(&quot;P&quot;); pObj.innerText = &quot;这是p&quot;; document.getElementById(&quot;dv&quot;).appendChild(pObj); &#125; &#125;; &lt;/script&gt; 元素绑定多个事件.addEventListener和.attachEvent&lt;input type=&quot;button&quot; value=&quot;多个事件&quot; id=&quot;btn&quot;/&gt; &lt;script &gt; document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;,function()&#123; console.log(&quot;哈哈&quot;); &#125;,false); document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;,function()&#123; console.log(&quot;嘻嘻&quot;); &#125;,false); &lt;/script&gt; 兼容性.addEventListener支持谷歌火狐，.attachEvent支持IE function commonAddEventListener(element,type,fn)&#123; if(element.addEventListener())&#123; element.addEventListener(type,fn,false); &#125; else if (element.attachEvent())&#123; element.attachEvent(&quot;on&quot; + type,fn); &#125; else&#123; element[&quot;on&quot; + type] = fn; &#125; &#125; addEventListener和attachEvent都可以为元素绑定事件。它们的不同点有：参数个数不一样；addEventListener中事件类型没有on,attachEvent中事件类型有on;addEventListener中this指当前绑定的事件，attachEvent中this指window。 元素解绑事件解绑onclick、addEventListener、attachEvent .onclick = null; .removeEventListener(&quot;click&quot;,&quot;解绑函数名&quot;,false); .detachEvent(&quot;onclick&quot;,&quot;解绑函数名&quot;); 事件冒泡指多个元素嵌套，有层次关系，这些元素都注册了相同事件，如果里面的元素事件触发了，那么外面的元素的该事件自动的触发了。 阻止事件冒泡 window.event.cancelBubble = true;//谷歌和IE支持，火狐不支持 window.event.stopPropagation();//谷歌和火狐支持，IE不支持 事件的三个阶段addEventListener第三个参数控制事件阶段的。 1、事件的捕获阶段，从外向内。 2、事件的目标阶段， .eventPhase 3、事件的冒泡阶段，从内向外。 为同一个元素绑定多个不同事件，指定的是同一个事件处理函数 .onclick = f; .onmouseover = f; .onmouseout = f; function f (e)&#123; switch (e.type)&#123; case &quot;click&quot;: break; case &quot;mouseover&quot;: break; case &quot;mouseout&quot;: break; &#125; &#125; BOM浏览器对象模型。 window:浏览器的顶级对象； document:页面中的顶级对象。 页面中的所用内容都是属于浏览器的，页面中的内容也都是window的。 alert() prompt() confirm() onloadonload使用 window.onload = function()&#123; document.getElementById(&quot;btn&quot;).onclick = function ()&#123; &#125;; &#125;; onunload页面关闭后触发的事件；onbeforeunload页面关闭前触发的事件(IE8支持)。 location属性 window.location.hash//#及后面内容 window.location.host//主机名及端口号 window.location.hostname//主机名 window.location.pathname//路径 window.location.port//端口号 window.location.protocol//协议，http window.location.search//？及后面内容 方法 window.location.href = &quot;设置跳转页面地址&quot;;//可后退 window.location.assign(&quot;设置跳转页面地址&quot;);//可后退 window.location.reload();//刷新，重新加载 window.location.replace(&quot;设置跳转页面地址&quot;);//不可后退 historywindow.history.back(); window.history.forward(); window.history.go();//整数和负数代表前进和后退 navigatorwindow.navigator.platform//判断浏览器所在的系统平台类型 window.navigator.userAgent 定时器 js 定时器有两种创建方式：setTimeout和setInterval。 //以指定的时间间隔（以毫秒计）调用一次函数的定时器 setTimeout(func[, delay, param1, param2, ...]) //以指定的时间间隔（以毫秒计）重复调用一个函数的定时器 setInterval(func[, delay, param1, param2, ...]) setTimeout函数的参数说明:func, 表示定时器要执行的函数名；delay, 表示时间间隔，默认是0，单位是毫秒；param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。 setInterval函数的参数说明:func , 表示定时器要执行的函数名;delay, 表示时间间隔，默认是0，单位是毫秒;param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。 反复执行 var timeId = window.setInterval(function()&#123;&#125;,1000);//设置定时 window.clearInterval(timeId);//停止定时 一次性定时器 var timeId = window.setTimeout(function()&#123;&#125;,1000); clearTimeout(timeId);//清除定时缓存空间 offset获取元素的宽和高（包含边框） .offsetWidth;//数字类型，没有px .offsetHeight; 获取元素的left和top， .offsetLeft; .offsetTop; 注意： 没有脱离文档流时，和父级元素的margin、padding、border，自己的margin，有关系。脱离文档流时，和自己的margin、left，有关系。 scroll元素中内容实际的宽和高，不包含边框，没有内容，就是宽高 .scrollWidth; .scrollHeight; 向左或者向上卷曲出去的距离 .scrollLeft; .scrollTop; 滚动事件 .onscroll 滚动距离计算 var top = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var left = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; client可视区域（没有边框）边框内的宽高 .clientWidth; .clientHeight; 左边框和上边框的宽度 .clientLeft; .clientTop; 获取元素的样式属性值window.getComputedStyle(元素对象,null).属性;//谷歌，火狐 元素对象.currentStyle.属性;//IE8 兼容代码 function getStyle(element,attr)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(element,attr)[attr];//谷歌，火狐 &#125; else&#123; return element.currentStyle[attr]; &#125; &#125; 其他透明度 .style.opacity = jQuery介绍 jQuery是对JavaScript的封装，它是免费、开源的JavaScript函数库，jQuery极大地简化了JavaScript编程。 jQuery的作用和JavaScript一样，都是负责网页和用户的交互效果。jQuery的优点就是兼容主流浏览器，代码编写更加简单。 用法 引入 &lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt; 使用js获取标签元素，需要页面加载完成以后再获取，我们通过给onload事件属性设置了一个函数来获取标签元素，而jquery提供了ready函数来解决这个问题，保证获取标签元素没有问题，它的速度比原生的 window.onload 更快。 入口函数示例代码: &lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function()&#123; var oDiv = document.getElementById(&apos;div01&apos;); alert(&apos;原生就是获取的div：&apos; + oDiv); &#125;; $(document).ready(function()&#123; var $div = $(&apos;#div01&apos;); alert(&apos;jquery获取的div：&apos; + $div); &#125;); &lt;/script&gt; &lt;div id=&quot;div01&quot;&gt;这是一个div&lt;/div&gt; 入口函数的简写示例代码: // 上面ready的写法可以简写成下面的形式： $(function()&#123; var $div = $(&apos;#div01&apos;); alert(&apos;jquery获取的div：&apos; + $div); &#125;); 选择器 选择器就是快速选择标签元素，获取标签的，选择规则和css样式一样。 标签选择器、类选择器、id选择器、层级选择器、属性选择器，示例代码: $(&apos;#myId&apos;) //选择id为myId的标签 $(&apos;.myClass&apos;) // 选择class为myClass的标签 $(&apos;li&apos;) //选择所有的li标签 $(&apos;#ul1 li span&apos;) //选择id为ul1标签下的所有li标签下的span标签 $(&apos;input[name=first]&apos;) // 选择name属性等于first的input标签 可以使用length属性来判断标签是否选择成功, 如果length大于0表示选择成功，否则选择失败。 $(function()&#123; result = $(&quot;div&quot;).length; alert(result); &#125;); 选择集过滤 选择集过滤就是在选择标签的集合里面过滤自己需要的标签。 选择集过滤的操作：has(选择器名称)方法，表示选取包含指定选择器的标签；eq(索引)方法，表示选取指定索引的标签。 has方法的示例代码: &lt;script&gt; $(function()&#123; // has方法的使用 var $div = $(&quot;div&quot;).has(&quot;#mytext&quot;); // 设置样式 $div.css(&#123;&quot;background&quot;:&quot;red&quot;&#125;); &#125;); &lt;/script&gt; &lt;div&gt; 这是第一个div &lt;input type=&quot;text&quot; id=&quot;mytext&quot;&gt; &lt;/div&gt; &lt;div&gt; 这是第二个div &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;button&quot;&gt; &lt;/div&gt; eq方法的示例代码: &lt;script&gt; $(function()&#123; // has方法的使用 var $div = $(&quot;div&quot;).has(&quot;#mytext&quot;); // 设置样式 $div.css(&#123;&quot;background&quot;:&quot;red&quot;&#125;); // eq方法的使用 var $div = $(&quot;div&quot;).eq(1); // 设置样式 $div.css(&#123;&quot;background&quot;:&quot;yellow&quot;&#125;); &#125;); &lt;/script&gt; &lt;div&gt; 这是第一个div &lt;input type=&quot;text&quot; id=&quot;mytext&quot;&gt; &lt;/div&gt; &lt;div&gt; 这是第二个div &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;button&quot;&gt; &lt;/div&gt; 选择集转移 选择集转移就是以选择的标签为参照，然后获取转移后的标签。 选择集转移操作： $(&apos;#box&apos;).prev(); 表示选择id是box元素的上一个的同级元素 $(&apos;#box&apos;).prevAll(); 表示选择id是box元素的上面所有的同级元素 $(&apos;#box&apos;).next(); 表示选择id是box元素的下一个的同级元素 $(&apos;#box&apos;).nextAll(); 表示选择id是box元素的下面所有的同级元素 $(&apos;#box&apos;).parent(); 表示选择id是box元素的父元素 $(&apos;#box&apos;).children(); 表示选择id是box元素的所有子元素 $(&apos;#box&apos;).siblings(); 表示选择id是box元素的其它同级元素 $(&apos;#box&apos;).find(&apos;.myClass&apos;); 表示选择id是box元素的class等于myClass的元素 获取和设置元素内容 jquery中的html方法可以获取和设置标签的html内容。 &lt;script&gt; $(function()&#123; var $div = $(&quot;#div1&quot;); // 获取标签的html内容 var result = $div.html(); alert(result); // 设置标签的html内容，之前的内容会清除 $div.html(&quot;&lt;span style=&apos;color:red&apos;&gt;你好&lt;/span&gt;&quot;); // 追加html内容 $div.append(&quot;&lt;span style=&apos;color:red&apos;&gt;你好&lt;/span&gt;&quot;); &#125;); &lt;/script&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;hello&lt;/p&gt; &lt;/div&gt; 获取和设置元素属性 使用css方法可以给标签设置样式属性，那么设置标签的其它属性可以使用prop方法了。 &lt;style&gt; .a01&#123; color:red; &#125; &lt;/style&gt; &lt;script&gt; $(function()&#123; var $a = $(&quot;#link01&quot;); var $input = $(&apos;#input01&apos;) // 获取元素属性 var sId = $a.prop(&quot;id&quot;); alert(sId); // 设置元素属性 $a.prop(&#123;&quot;href&quot;:&quot;http://www.baidu.com&quot;,&quot;title&quot;:&apos;这是去到百度的链接&apos;,&quot;class&quot;:&quot;a01&quot;&#125;); // 获取value属性 // var sValue = $input.prop(&quot;value&quot;); // alert(sValue); // 获取value属性使用val()方法的简写方式 var sValue = $input.val(); alert(sValue); // 设置value值 $input.val(&quot;222222&quot;); &#125;) &lt;/script&gt; &lt;a id=&quot;link01&quot;&gt;这是一个链接&lt;/a&gt; &lt;input type=&quot;text&quot; id=&quot;input01&quot; value=&quot;111111&quot;&gt; jQuery事件 常用事件 click() 鼠标单击 blur() 元素失去焦点 focus() 元素获得焦点 mouseover() 鼠标进入（进入子元素也触发） mouseout() 鼠标离开（离开子元素也触发） ready() DOM加载完成 示例代码: &lt;script&gt; $(function()&#123; var $li = $(&apos;.list li&apos;); var $button = $(&apos;#button1&apos;) var $text = $(&quot;#text1&quot;); var $div = $(&quot;#div1&quot;) // 鼠标点击 $li.click(function()&#123; // this指的是当前发生事件的对象，但是它是一个原生js对象 // this.style.background = &apos;red&apos;; // $(this) 指的是当前发生事件的jquery对象 $(this).css(&#123;&apos;background&apos;:&apos;gold&apos;&#125;); // 获取jquery对象的索引值,通过index() 方法 alert($(this).index()); &#125;); // 一般和按钮配合使用 $button.click(function()&#123; alert($text.val()); &#125;); // 获取焦点 $text.focus(function()&#123; $(this).css(&#123;&apos;background&apos;:&apos;red&apos;&#125;); &#125;); // 失去焦点 $text.blur(function()&#123; $(this).css(&#123;&apos;background&apos;:&apos;white&apos;&#125;); &#125;); // 鼠标进入 $div.mouseover(function()&#123; $(this).css(&#123;&apos;background&apos;:&apos;gold&apos;&#125;); &#125;); // 鼠标离开 $div.mouseout(function() &#123; $(this).css(&#123;&apos;background&apos;:&apos;white&apos;&#125;); &#125;); &#125;); &lt;/script&gt; &lt;div id=&quot;div1&quot;&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;列表文字&lt;/li&gt; &lt;li&gt;列表文字&lt;/li&gt; &lt;li&gt;列表文字&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;button1&quot; value=&quot;点击&quot;&gt; &lt;/div&gt; 事件代理 事件代理就是利用事件冒泡的原理(事件冒泡就是事件会向它的父级一级一级传递),把事件加到父级上，通过判断事件来源，执行相应的子元素的操作，事件代理首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。 事件冒泡代码:当点击子元素div，它的点击事件会向它父元素传递，也会触发了父元素的点击事件，这就是事件冒泡。 &lt;script&gt; $(function()&#123; var $div1 = $(&apos;#div1&apos;); var $div2 = $(&apos;#div2&apos;); $div1.click(function()&#123; alert($(this).html()); &#125;); $div2.click(function()&#123; alert($(this).html()); &#125;); &#125;); &lt;/script&gt; &lt;div id=&quot;div1&quot; style=&quot;width:200px; height:200px; background: red;&quot;&gt; &lt;div id=&quot;div2&quot; style=&quot;width:100px; height:100px;background: yellow;&quot;&gt; 哈哈 &lt;/div&gt; &lt;/div&gt; 事件代理的使用，一般绑定事件的写法: $(function()&#123; $ali = $(&apos;#list li&apos;); $ali.click(function() &#123; $(this).css(&#123;background:&apos;red&apos;&#125;); &#125;); &#125;) &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; 事件代理的写法 $(function()&#123; $list = $(&apos;#list&apos;); // 父元素ul 来代理 子元素li的点击事件 $list.delegate(&apos;li&apos;, &apos;click&apos;, function() &#123; // $(this)表示当前点击的子元素对象 $(this).css(&#123;background:&apos;red&apos;&#125;); &#125;); &#125;) &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; delegate方法参数说明: delegate(childSelector,event,function) //childSelector: 子元素的选择器 //event: 事件名称，比如: &apos;click&apos; //function: 当事件触发执行的函数 JavaScript对象 JavaScript中的所有事物都是对象：字符串、数值、数组、函数等都可以认为是对象，此外，JavaScript 允许自定义对象，对象可以拥有属性和方法。 创建自定义javascript对象有两种方式:通过顶级Object类型来实例化一个对象;通过对象字面量创建一个对象。 Object类创建对象的示例代码: &lt;script&gt; var person = new Object(); // 添加属性： person.name = &apos;tom&apos;; person.age = &apos;25&apos;; // 添加方法： person.sayName = function()&#123; alert(this.name); &#125; // 调用属性和方法： alert(person.age); person.sayName(); &lt;/script&gt; 对象字面量创建对象的示例代码: &lt;script&gt; var person2 = &#123; name:&apos;Rose&apos;, age: 18, sayName:function()&#123; alert(&apos;My name is&apos; + this.name); &#125; &#125; // 调用属性和方法： alert(person2.age); person2.sayName(); &lt;/script&gt; json数据 json本质上是字符串，如果在js中操作json数据，可以将json字符串转化为JavaScript对象。 示例代码: var sJson = &apos;&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18&#125;&apos;; var oPerson = JSON.parse(sJson); // 操作属性 alert(oPerson.name); alert(oPerson.age); ajax ajax 是 Asynchronous JavaScript and XML的简写，ajax一个前后台配合的技术，它可以让 javascript 发送异步的 http 请求，与后台通信进行数据的获取，ajax 最大的优点是实现局部刷新，ajax可以发送http请求，当获取到后台数据的时候更新页面显示数据实现局部刷新，当前端页面想和后台服务器进行数据交互就可以使用ajax了。 jquery将它封装成了一个方法$.ajax()，我们可以直接用这个方法来执行ajax请求。 示例代码: &lt;script&gt; $.ajax(&#123; // 1.url 请求地址 url:&apos;http://t.weather.sojson.com/api/weather/city/101010100&apos;, // 2.type 请求方式，默认是&apos;GET&apos;，常用的还有&apos;POST&apos; type:&apos;GET&apos;, // 3.dataType 设置返回的数据格式，常用的是&apos;json&apos;格式 dataType:&apos;JSON&apos;, // 4.data 设置发送给服务器的数据, 没有参数不需要设置​ // 5.success 设置请求成功后的回调函数 success:function (response) &#123; console.log(response); &#125;, // 6.error 设置请求失败后的回调函数 error:function () &#123; alert(&quot;请求失败,请稍后再试!&quot;); &#125;, // 7.async 设置是否异步，默认值是&apos;true&apos;，表示异步，一般不用写 async:true &#125;); &lt;/script&gt; 同步和异步说明：同步是一个ajax请求完成另外一个才可以请求，需要等待上一个ajax请求完成，好比线程同步。异步是多个ajax同时请求，不需要等待其它ajax请求完成，好比线程异步。 $.ajax按照请求方式可以简写成$.get或者$.post方式。示例代码: &lt;script&gt; $(function()&#123; /* 1. url 请求地址 2. data 设置发送给服务器的数据, 没有参数不需要设置 3. success 设置请求成功后的回调函数 4. dataType 设置返回的数据格式，常用的是&apos;json&apos;格式, 默认智能判断数据格式 */ $.get(&quot;http://t.weather.sojson.com/api/weather/city/101010100&quot;, function(dat,status)&#123; console.log(dat); console.log(status); alert(dat); &#125;).error(function()&#123; alert(&quot;网络异常&quot;); &#125;); /* 1. url 请求地址 2. data 设置发送给服务器的数据, 没有参数不需要设置 3. success 设置请求成功后的回调函数 4. dataType 设置返回的数据格式，常用的是&apos;json&apos;格式, 默认智能判断数据格式 */ $.post(&quot;test.php&quot;, &#123;&quot;func&quot;: &quot;getNameAndTime&quot;&#125;, function(data)&#123; alert(data.name); console.log(data.time); &#125;, &quot;json&quot;).error(function()&#123; alert(&quot;网络异常&quot;); &#125;); &#125;); &lt;/script&gt;","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}]}]}