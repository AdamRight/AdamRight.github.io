<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Spring Boot和maven, Jiang Space">
    <meta name="description" content="mysql介绍
数据库：存储和管理数据的仓库，数据是有组织的进行存储。数据库英文名是 DataBase，简称DB。
数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。
数据库管理系统：管理">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>Spring Boot和maven | Jiang Space</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jiang Space</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jiang Space</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Spring Boot和maven</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/maven/">
                                <span class="chip bg-color">maven</span>
                            </a>
                        
                            <a href="/tags/Spring-Boot/">
                                <span class="chip bg-color">Spring Boot</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>数据库：存储和管理数据的仓库，数据是有组织的进行存储。数据库英文名是 DataBase，简称DB。</p>
<p>数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。</p>
<p>数据库管理系统：管理数据库的大型软件。DataBase Management System，简称 DBMS</p>
<p>我们平时说的MySQL数据库其实是MySQL数据库管理系统。</p>
<p>常见的数据库管理系统：</p>
<pre><code>Oracle：收费的大型数据库，Oracle 公司的产品
==MySQL==： 开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购
SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用
PostgreSQL：开源免费中小型的数据库
DB2：IBM 公司的大型收费数据库产品
SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库
MariaDB：开源免费中小型的数据库
</code></pre>
<p>SQL：英文：Structured Query Language，简称 SQL，结构化查询语言。操作关系型数据库的编程语言。定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用SQL来操作。</p>
<hr>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><hr>
<p>下载：<a target="_blank" rel="noopener" href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p>
<p>配置环境变量</p>
<p>配置文件：</p>
<pre><code>[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8 
[mysqld]
# 设置mysql的安装目录
basedir = E:\mysql-5.7.27-winx64\mysql-5.7.27-winx64
# 设置mysql数据库的数据的存放目录
datadir = E:\mysql-5.7.27-winx64\mysql-5.7.27-winx64\data
# 允许最大连接数
max_connections=200
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 如果需要的存储引擎被禁用或未编译，可以防止自动替换存储引擎
# 为事务存储引擎启用严格模式，也可能为非事务存储引擎启用严格模式
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
# 开启查询缓存
explicit_defaults_for_timestamp=true
</code></pre>
<p>以管理员方式运行,初始化MySQL:</p>
<pre><code>mysqld --initialize-insecure
</code></pre>
<p>注册MySQL服务:</p>
<pre><code>mysqld -install
</code></pre>
<p>启动MySQL服务:</p>
<pre><code>net start mysql
</code></pre>
<p>修改默认账户密码:</p>
<pre><code>mysqladmin -u root password ****
</code></pre>
<p>登陆:</p>
<pre><code>mysql -uroot -p****
</code></pre>
<p>登陆其他机器参数：</p>
<pre><code>mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306)
</code></pre>
<p>退出mysql：</p>
<pre><code>exit
quit
</code></pre>
<hr>
<h3 id="MySQL数据模型"><a href="#MySQL数据模型" class="headerlink" title="MySQL数据模型"></a>MySQL数据模型</h3><hr>
<p>关系型数据库：关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的二维表组成的数据库。</p>
<p>在MySQL中一个数据库对应到磁盘上的一个文件夹。<code>db.frm</code> 是表文件，<code>db.MYD</code> 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。</p>
<p>MySQL中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹；在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件；每张表可以存储多条数据，数据会被存储到磁盘中  MYD 文件中。</p>
<hr>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><hr>
<p>通过SQL语句对数据库、表、数据进行增删改查操作。 英文：Structured Query Language，简称 SQL。结构化查询语言，一门操作关系型数据库的编程语言。</p>
<p>SQL语句可以单行或多行书写，以分号结尾。</p>
<p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p>
<p>注释</p>
<pre><code>单行注释: -- 注释内容 或 #注释内容(MySQL 特有) 

多行注释: /* 注释 */
</code></pre>
<p>SQL分类</p>
<pre><code>DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等
DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改
DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据)
DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户
</code></pre>
<hr>
<h3 id="DDL操作数据库"><a href="#DDL操作数据库" class="headerlink" title="DDL操作数据库"></a>DDL操作数据库</h3><hr>
<p>查询所有的数据库:</p>
<pre><code>SHOW DATABASES;
</code></pre>
<p>创建数据库:</p>
<pre><code>CREATE DATABASE 数据库名称;
</code></pre>
<p>创建数据库(判断，如果不存在则创建):</p>
<pre><code>CREATE DATABASE IF NOT EXISTS 数据库名称;
</code></pre>
<p>删除数据库:</p>
<pre><code>DROP DATABASE 数据库名称;
</code></pre>
<p>删除数据库(判断，如果存在则删除):</p>
<pre><code>DROP DATABASE IF EXISTS 数据库名称;
</code></pre>
<p>使用数据库:</p>
<pre><code>USE 数据库名称;
</code></pre>
<p>查看当前使用的数据库:</p>
<pre><code>SELECT DATABASE();
</code></pre>
<hr>
<h3 id="DDL操作数据表"><a href="#DDL操作数据表" class="headerlink" title="DDL操作数据表"></a>DDL操作数据表</h3><hr>
<p>操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。</p>
<p>查询当前数据库下所有表名称:</p>
<pre><code>SHOW TABLES;
</code></pre>
<p>查询表结构：</p>
<pre><code>DESC 表名称;
</code></pre>
<p>创建表：</p>
<pre><code>CREATE TABLE 表名 (
    字段名1  数据类型1,
    字段名2  数据类型2,
    …
    字段名n  数据类型n
);
</code></pre>
<blockquote>
<p>注意：最后一行末尾，不能加逗号。</p>
</blockquote>
<p>数据类型-MySQL支持多种类型，可以分为三类：</p>
<pre><code>数值:
TINYINT	1 byte	小整数值
SMALLINT	2 bytes	大整数值
MEDIUMINT	3 bytes	大整数值
INT或INTEGER	4 bytes	大整数值
BIGINT	8 bytes	极大整数值
FLOAT	4 bytes	单精度浮点数值
DOUBLE	8 bytes	双精度浮点数值
DECIMAL		小数值

日期:
DATE	3	日期值
TIME	3	时间值或持续时间
YEAR	1	年份值
DATETIME	8	混合日期和时间值
TIMESTAMP	4	混合日期和时间值，时间戳

字符串:
CHAR	0-255 bytes	定长字符串
VARCHAR	0-65535 bytes	变长字符串
TINYBLOB	0-255 bytes	不超过 255 个字符的二进制字符串
TINYTEXT	0-255 bytes	短文本字符串
BLOB	0-65 535 bytes	二进制形式的长文本数据
TEXT	0-65 535 bytes	长文本数据
MEDIUMBLOB	0-16 777 215 bytes	二进制形式的中等长度文本数据
MEDIUMTEXT	0-16 777 215 bytes	中等长度文本数据
LONGBLOB	0-4 294 967 295 bytes	二进制形式的极大文本数据
LONGTEXT	0-4 294 967 295 bytes	极大文本数据
</code></pre>
<p>char： 定长字符串。优点：存储性能高；缺点：浪费空间；name char(10)  如果存储的数据字符个数不足10个，也会占10个的空间。</p>
<p>varchar： 变长字符串。优点：节约空间；缺点：存储性能底；name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间。</p>
<p>double的使用举例，设置分数，0-100，保留两位小数：</p>
<pre><code>score double(总长度, 小数点后保留的位数)
score double(5, 2)
</code></pre>
<p>删除表：</p>
<pre><code>DROP TABLE 表名;
</code></pre>
<p>删除表时判断表是否存在：</p>
<pre><code>DROP TABLE IF EXISTS 表名;
</code></pre>
<p>修改表名：</p>
<pre><code>ALTER TABLE 表名 RENAME TO 新的表名;

# 将表名student修改为stu
alter table student rename to stu;
</code></pre>
<p>添加一列：</p>
<pre><code>ALTER TABLE 表名 ADD 列名 数据类型;

# 给stu表添加一列address，该字段类型是varchar(50)
alter table stu add address varchar(50);
</code></pre>
<p>修改数据类型：</p>
<pre><code>ALTER TABLE 表名 MODIFY 列名 新数据类型;

# 将stu表中的address字段的类型改为 char(50)
alter table stu modify address char(50);
</code></pre>
<p>修改列名和数据类型：</p>
<pre><code>ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;

# 将stu表中的address字段名改为 addr，类型改为varchar(50)
alter table stu change address addr varchar(50);
</code></pre>
<p>删除列：</p>
<pre><code>ALTER TABLE 表名 DROP 列名;

# 将stu表中的addr字段 删除
alter table stu drop addr;
</code></pre>
<hr>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><hr>
<p>DML主要是对数据进行增（insert）删（delete）改（update）操作。</p>
<p>给指定列添加数据：</p>
<pre><code>INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);
</code></pre>
<p>给全部列添加数据：</p>
<pre><code>INSERT INTO 表名 VALUES(值1,值2,…);
</code></pre>
<p>批量添加数据：</p>
<pre><code>INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;
INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;
</code></pre>
<p>练习：</p>
<pre><code>-- 给指定列添加数据
INSERT INTO stu (id, NAME) VALUES (1, &#39;张三&#39;);
-- 给所有列添加数据，列名的列表可以省略的
INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1);

INSERT INTO stu VALUES (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1);

-- 批量添加数据
INSERT INTO stu VALUES 
    (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1),
    (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1),
    (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1);
</code></pre>
<p>修改表数据：</p>
<pre><code>UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;
# 将张三的性别改为女
update stu set sex = &#39;女&#39; where name = &#39;张三&#39;;

# 将张三的生日改为 1999-12-12 分数改为99.99
update stu set birthday = &#39;1999-12-12&#39;, score = 99.99 where name = &#39;张三&#39;;
</code></pre>
<blockquote>
<p>注意：</p>
<ol>
<li>修改语句中如果不加条件，则将所有数据都修改！</li>
<li>像上面的语句中的中括号，表示在写sql语句中可以省略这部分</li>
</ol>
</blockquote>
<p>删除数据:</p>
<pre><code>DELETE FROM 表名 [WHERE 条件] ;

# 删除张三记录
delete from stu where name = &#39;张三&#39;;

# 删除stu表中所有的数据
delete from stu;
</code></pre>
<hr>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><hr>
<p>查询的完整语法：</p>
<pre><code>SELECT 
    字段列表
FROM 
    表名列表 
WHERE 
    条件列表
GROUP BY
    分组字段
HAVING
    分组后条件
ORDER BY
    排序字段
LIMIT
    分页限定
</code></pre>
<p>查询多个字段：</p>
<pre><code>SELECT 字段列表 FROM 表名;
SELECT * FROM 表名; -- 查询所有数据
</code></pre>
<p>去除重复记录：</p>
<pre><code>SELECT DISTINCT 字段列表 FROM 表名;
</code></pre>
<p>起别名：</p>
<pre><code>AS: AS 也可以省略

select name,math 数学成绩,english 英文成绩 from stu;
</code></pre>
<p>条件查询:</p>
<pre><code># 查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学生信息
select * from stu where age &gt;= 20 &amp;&amp;  age &lt;= 30;
select * from stu where age &gt;= 20 and  age &lt;= 30;
select * from stu where age BETWEEN 20 and 30;

# 查询年龄不等于18岁的学生信息
select * from stu where age != 18;
select * from stu where age &lt;&gt; 18;

# 查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学生信息
select * from stu where age = 18 or age = 20 or age = 22;
select * from stu where age in (18,20 ,22);

# 查询英语成绩为 null的学员信息
# null值的比较不能使用 =  或者 != 。需要使用 is  或者 is not
select * from stu where english is null;
select * from stu where english is not null;
</code></pre>
<p>模糊查询：</p>
<p>模糊查询使用like关键字，可以使用通配符进行占位:<code>_</code>: 代表单个任意字符; <code>%</code>: 代表任意个数字符。</p>
<pre><code># 查询姓&#39;马&#39;的学生信息
select * from stu where name like &#39;马%&#39;;

# 查询第二个字是&#39;花&#39;的学生信息  
select * from stu where name like &#39;_花%&#39;;

# 查询名字中包含 &#39;德&#39; 的学生信息
select * from stu where name like &#39;%德%&#39;;
</code></pre>
<p>排序查询：</p>
<pre><code>SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;

排序方式有两种，分别是：ASC ： 升序排列 **（默认值）**，DESC ： 降序排列
注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序

select * from stu order by age ;
select * from stu order by math desc ;
select * from stu order by math desc , english asc ;
</code></pre>
<p>聚合函数:将一列数据作为一个整体，进行纵向计算。</p>
<p>聚合函数分类:</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count(列名)</td>
<td>统计数量（一般选用不为null的列）</td>
</tr>
<tr>
<td>max(列名)</td>
<td>最大值</td>
</tr>
<tr>
<td>min(列名)</td>
<td>最小值</td>
</tr>
<tr>
<td>sum(列名)</td>
<td>求和</td>
</tr>
<tr>
<td>avg(列名)</td>
<td>平均值</td>
</tr>
</tbody></table>
<p>聚合函数语法:</p>
<pre><code>SELECT 聚合函数名(列名) FROM 表;
# 注意：null 值不参与所有聚合函数运算

# 统计班级一共有多少个学生
select count(id) from stu;
select count(*) from stu;

# 查询数学成绩的最高分
select max(math) from stu;
</code></pre>
<p>分组查询:</p>
<pre><code>SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];
# 分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义

# 查询男同学和女同学各自的数学平均分
select sex, avg(math) from stu group by sex;

# 查询男同学和女同学各自的数学平均分，以及各自人数
select sex, avg(math),count(*) from stu group by sex;

# 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组
select sex, avg(math),count(*) from stu where math &gt; 70 group by sex;

# 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的
select sex, avg(math),count(*) from stu where math &gt; 70 group by sex having count(*)  &gt; 2;
</code></pre>
<p><strong>where 和 having 区别：</strong>执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。</p>
<p>分页查询:</p>
<pre><code>SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;
# 上述语句中的起始索引是从0开始

# 从0开始查询，查询3条数据
select * from stu limit 0 , 3;

# 每页显示3条数据，查询第1页数据
select * from stu limit 0 , 3;

# 每页显示3条数据，查询第2页数据
select * from stu limit 3 , 3;

# 公式：
起始索引 = (当前页码 - 1) * 每页显示的条数
</code></pre>
<hr>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><hr>
<p>约束是作用于表中列上的规则，用于限制加入表的数据。约束的存在保证了数据库中数据的正确性、有效性和完整性。</p>
<p>分类：</p>
<pre><code>非空约束： 关键字是 NOT NULL。保证列中所有的数据不能有null值。

唯一约束：关键字是  UNIQUE。保证列中所有数据各不相同。

主键约束： 关键字是  PRIMARY KEY。主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给每张表添加一个主键列用来唯一标识数据。

检查约束： 关键字是  CHECK。 保证列中的值满足某一条件。MySQL不支持检查约束。

默认约束： 关键字是   DEFAULT。保存数据时，未指定值则采用默认值。

外键约束： 关键字是  FOREIGN KEY。外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。
</code></pre>
<p>非空约束:</p>
<pre><code>-- 创建表时添加非空约束
CREATE TABLE 表名(
   列名 数据类型 NOT NULL,
   …
); 

-- 建完表后添加非空约束
ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;

-- 删除约束
ALTER TABLE 表名 MODIFY 字段名 数据类型;
</code></pre>
<p>唯一约束:</p>
<pre><code>-- 创建表时添加唯一约束
CREATE TABLE 表名(
   列名 数据类型 UNIQUE [AUTO_INCREMENT],
   -- AUTO_INCREMENT: 当不指定值时自动增长
   …
); 
CREATE TABLE 表名(
   列名 数据类型,
   …
   [CONSTRAINT] [约束名称] UNIQUE(列名)
); 

-- 建完表后添加唯一约束
ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;

--删除约束
ALTER TABLE 表名 DROP INDEX 字段名;
</code></pre>
<p>主键约束:</p>
<pre><code>-- 创建表时添加主键约束
CREATE TABLE 表名(
   列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],
   …
); 
CREATE TABLE 表名(
   列名 数据类型,
   [CONSTRAINT] [约束名称] PRIMARY KEY(列名)
); 

-- 建完表后添加主键约束
ALTER TABLE 表名 ADD PRIMARY KEY(字段名);

-- 删除约束
ALTER TABLE 表名 DROP PRIMARY KEY;
</code></pre>
<p>默认约束:</p>
<pre><code>-- 创建表时添加默认约束
CREATE TABLE 表名(
   列名 数据类型 DEFAULT 默认值,
   …
); 

-- 建完表后添加默认约束
ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;

-- 删除约束
ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;
</code></pre>
<p>约束练习:</p>
<pre><code>CREATE TABLE emp (
  id INT PRIMARY KEY auto_increment, -- 员工id，主键且自增长
  ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一
  joindate DATE NOT NULL , -- 入职日期，非空
  salary DOUBLE(7,2) NOT NULL , -- 工资，非空
  bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0
);
</code></pre>
<p><strong>默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。</strong></p>
<p><strong>验证自动增长： auto_increment  当列是数字类型 并且唯一约束</strong></p>
<p>外键约束：</p>
<pre><code>-- 创建表时添加外键约束
CREATE TABLE 表名(
   列名 数据类型,
   …
   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) 
); 

-- 建完表后添加外键约束
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);

-- 删除外键约束
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
</code></pre>
<p>员工表和部门表，并添加上外键约束：</p>
<pre><code>-- 部门表
CREATE TABLE dept(
    id int primary key auto_increment,
    dep_name varchar(20),
    addr varchar(20)
);
-- 员工表 
CREATE TABLE emp(
    id int primary key auto_increment,
    name varchar(20),
    age int,
    dep_id int,

    -- 添加外键 dep_id,关联 dept 表的id主键
    CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id)	
);

-- 删除外键
alter table emp drop FOREIGN key fk_emp_dept;

-- 重新添加外键
alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);
</code></pre>
<hr>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><hr>
<p>数据库设计：建立数据库中的表结构以及表与表之间的关联关系的过程。有哪些表？表里有哪些字段？表和表之间有什么关系？</p>
<p>表关系:一对一、一对多、多对多。</p>
<p>一对多的实现方式：在多的一方建立外键，指向一的一方的主键。</p>
<p>多对多的实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。</p>
<p>一对一的实现方式：在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)。</p>
<hr>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><hr>
<p>多表查询都有哪些呢:</p>
<pre><code>连接查询
    内连接查询 ：相当于查询AB交集数据
    外连接查询
        左外连接查询 ：相当于查询A表所有数据和交集部门数据
        右外连接查询 ： 相当于查询B表所有数据和交集部分数据
子查询
</code></pre>
<p>内连接查询：</p>
<pre><code>-- 隐式内连接
SELECT 字段列表 FROM 表1,表2… WHERE 条件;

-- 显示内连接
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;
</code></pre>
<p>隐式内连接：</p>
<pre><code>SELECT
    *
FROM
    emp,
    dept
WHERE
    emp.dep_id = dept.did;

执行上述语句结果如下：
</code></pre>
<p>查询 emp的 name， gender，dept表的dname:</p>
<pre><code>SELECT
    emp. NAME,
    emp.gender,
    dept.dname
FROM
    emp,
    dept
WHERE
    emp.dep_id = dept.did;
</code></pre>
<p>上面语句中使用表名指定字段所属有点麻烦，sql也支持给表指别名，上述语句可以改进为:</p>
<pre><code>SELECT
    t1. NAME,
    t1.gender,
    t2.dname
FROM
    emp t1,
    dept t2
WHERE
    t1.dep_id = t2.did; 
</code></pre>
<hr>
<p>显式内连接:</p>
<pre><code>select * from emp inner join dept on emp.dep_id = dept.did;
-- 上面语句中的inner可以省略，可以书写为如下语句
select * from emp  join dept on emp.dep_id = dept.did;
</code></pre>
<hr>
<p>外连接查询:</p>
<pre><code>-- 左外连接：相当于查询A表所有数据和交集部分数据
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;

-- 右外连接：相当于查询B表所有数据和交集部分数据
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
</code></pre>
<p>查询emp表所有数据和对应的部门信息（左外连接）:</p>
<pre><code>select * from emp left join dept on emp.dep_id = dept.did;
结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据。
</code></pre>
<p>查询dept表所有数据和对应的员工信息（右外连接）:</p>
<pre><code>select * from emp right join dept on emp.dep_id = dept.did;
结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据。
</code></pre>
<hr>
<p>子查询：查询中嵌套查询，称嵌套查询为子查询。</p>
<p>需求：查询工资高于猪八戒的员工信息。来实现这个需求，我们就可以通过二步实现，</p>
<pre><code>第一步：先查询出来 猪八戒的工资
select salary from emp where name = &#39;猪八戒&#39;

第二步：查询工资高于猪八戒的员工信息
select * from emp where salary &gt; 3600;
</code></pre>
<p>查询语句中嵌套查询语句：</p>
<pre><code>select * from emp where salary &gt; (select salary from emp where name = &#39;猪八戒&#39;);
</code></pre>
<p>子查询根据查询结果不同，作用不同：</p>
<pre><code>子查询语句结果是单行单列，子查询语句作为条件值，使用 =  !=  &gt;  &lt;  等进行条件判断
子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断
子查询语句结果是多行多列，子查询语句作为虚拟表
</code></pre>
<p>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息：</p>
<pre><code>-- 查询 &#39;财务部&#39; 或者 &#39;市场部&#39; 所有的员工的部门did
select did from dept where dname = &#39;财务部&#39; or dname = &#39;市场部&#39;;
select * from emp where dep_id in (select did from dept where dname = &#39;财务部&#39; or dname = &#39;市场部&#39;);
</code></pre>
<p>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息：</p>
<pre><code>-- 查询入职日期是 &#39;2011-11-11&#39; 之后的员工信息
select * from emp where join_date &gt; &#39;2011-11-11&#39; ;
-- 将上面语句的结果作为虚拟表和dept表进行内连接查询
select * from (select * from emp where join_date &gt; &#39;2011-11-11&#39; ) t1, dept where t1.dep_id = dept.did;
</code></pre>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><hr>
<p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。事务是一个不可分割的工作逻辑单元。</p>
<p>语法:</p>
<pre><code># 开启事务
START TRANSACTION;
或者  
BEGIN;

# 提交事务
commit;

# 回滚事务
rollback;
</code></pre>
<p>事务的四大特征：</p>
<pre><code>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败

一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态

隔离性（Isolation） :多个事务之间，操作的可见性

持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的
</code></pre>
<p>mysql中事务是自动提交的。也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p>
<p>可以通过下面语句查询默认提交方式：</p>
<pre><code>SELECT @@autocommit;
</code></pre>
<p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p>
<pre><code>set @@autocommit = 0;
</code></pre>
<hr>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="JDBC概念"><a href="#JDBC概念" class="headerlink" title="JDBC概念"></a>JDBC概念</h3><hr>
<p>JDBC就是使用Java语言操作关系型数据库的一套API。全称：( Java DataBase Connectivity ) Java 数据库连接。</p>
<p>JDBC好处：各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；可随时替换底层数据库，访问数据库的Java代码基本不变。</p>
<hr>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><hr>
<pre><code>//1. 注册驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
//2. 获取连接
String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;;
String username = &quot;root&quot;;
String password = &quot;1234&quot;;
Connection conn = DriverManager.getConnection(url, username, password);
//3. 定义sql
String sql = &quot;update account set money = 2000 where id = 1&quot;;
//4. 获取执行sql的对象 Statement
Statement stmt = conn.createStatement();
//5. 执行sql
int count = stmt.executeUpdate(sql);//受影响的行数
//6. 处理结果
System.out.println(count);
//7. 释放资源
stmt.close();
conn.close();
</code></pre>
<hr>
<h3 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h3><hr>
<p>DriverManager（驱动管理类）作用：注册驱动 <code>registerDriver</code> ；获取数据库连接 <code>getConnection</code> 。</p>
<p>Connection（数据库连接对象）作用：获取执行 SQL 的对象；管理事务。</p>
<p>Connection管理事务：</p>
<pre><code>/**
 * JDBC API 详解：Connection
 */
public class JDBCDemo3_Connection &#123;

    public static void main(String[] args) throws Exception &#123;
        //1. 注册驱动
        //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写
        String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;
        String username = &quot;root&quot;;
        String password = &quot;1234&quot;;
        Connection conn = DriverManager.getConnection(url, username, password);
        //3. 定义sql
        String sql1 = &quot;update account set money = 3000 where id = 1&quot;;
        String sql2 = &quot;update account set money = 3000 where id = 2&quot;;
        //4. 获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        try &#123;
            // ============开启事务==========
            // autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。
            conn.setAutoCommit(false);
            //5. 执行sql
            int count1 = stmt.executeUpdate(sql1);//受影响的行数
            //6. 处理结果
            System.out.println(count1);
            int i = 3/0;
            //5. 执行sql
            int count2 = stmt.executeUpdate(sql2);//受影响的行数
            //6. 处理结果
            System.out.println(count2);
            // ============提交事务==========
            //程序运行到此处，说明没有出现任何问题，则需求提交事务
            conn.commit();
        &#125; catch (Exception e) &#123;
            // ============回滚事务==========
            //程序在出现异常时会执行到这个地方，此时就需要回滚事务
            conn.rollback();
            e.printStackTrace();
        &#125;
        //7. 释放资源
        stmt.close();
        conn.close();
    &#125;
&#125;
</code></pre>
<p>Statement对象的作用就是用来执行SQL语句。</p>
<p>执行DML语句:</p>
<pre><code>/**
* 执行DML语句
* @throws Exception
*/
@Test
public void testDML() throws  Exception &#123;
  //1. 注册驱动
  //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
  //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写
  String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;
  String username = &quot;root&quot;;
  String password = &quot;1234&quot;;
  Connection conn = DriverManager.getConnection(url, username, password);
  //3. 定义sql
  String sql = &quot;update account set money = 3000 where id = 1&quot;;
  //4. 获取执行sql的对象 Statement
  Statement stmt = conn.createStatement();
  //5. 执行sql
  int count = stmt.executeUpdate(sql);//执行完DML语句，受影响的行数
  //6. 处理结果
  //System.out.println(count);
  if(count &gt; 0)&#123;
      System.out.println(&quot;修改成功~&quot;);
  &#125;else&#123;
      System.out.println(&quot;修改失败~&quot;);
  &#125;
  //7. 释放资源
  stmt.close();
  conn.close();
&#125;
</code></pre>
<p>执行DDL语句(<strong>执行完DDL语句，可能是0</strong>):</p>
<pre><code>/**
* 执行DDL语句
* @throws Exception
*/
@Test
public void testDDL() throws  Exception &#123;
  //1. 注册驱动
  //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
  //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写
  String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;
  String username = &quot;root&quot;;
  String password = &quot;1234&quot;;
  Connection conn = DriverManager.getConnection(url, username, password);
  //3. 定义sql
  String sql = &quot;drop database db2&quot;;
  //4. 获取执行sql的对象 Statement
  Statement stmt = conn.createStatement();
  //5. 执行sql
  int count = stmt.executeUpdate(sql);//执行完DDL语句，可能是0
  //6. 处理结果
  System.out.println(count);

  //7. 释放资源
  stmt.close();
  conn.close();
&#125;
</code></pre>
<p>ResultSet（结果集对象）作用：封装了SQL查询语句的结果。我们就需要从 <code>ResultSet</code> 对象中获取我们想要的数据。<code>ResultSet</code> 对象提供了操作查询结果数据的方法，如下：</p>
<pre><code>boolean  next():将光标从当前位置向前移动一行;判断当前行是否为有效行

xxx  getXxx(参数)：获取数据
xxx : 数据类型；如： int getInt(参数) ；String getString(参数)
参数:int类型的参数：列的编号，从1开始; String类型的参数： 列的名称 
</code></pre>
<p>执行DQL:</p>
<pre><code>/**
  * 执行DQL
  * @throws Exception
  */
@Test
public void testResultSet() throws  Exception &#123;
    //1. 注册驱动
    //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写
    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;
    String username = &quot;root&quot;;
    String password = &quot;1234&quot;;
    Connection conn = DriverManager.getConnection(url, username, password);
    //3. 定义sql
    String sql = &quot;select * from account&quot;;
    //4. 获取statement对象
    Statement stmt = conn.createStatement();
    //5. 执行sql
    ResultSet rs = stmt.executeQuery(sql);
    //6. 处理结果， 遍历rs中的所有数据
    /* // 6.1 光标向下移动一行，并且判断当前行是否有数据
        while (rs.next())&#123;
            //6.2 获取数据  getXxx()
            int id = rs.getInt(1);
            String name = rs.getString(2);
            double money = rs.getDouble(3);

            System.out.println(id);
            System.out.println(name);
            System.out.println(money);
            System.out.println(&quot;--------------&quot;);

        &#125;*/
    // 6.1 光标向下移动一行，并且判断当前行是否有数据
    while (rs.next())&#123;
        //6.2 获取数据  getXxx()
        int id = rs.getInt(&quot;id&quot;);
        String name = rs.getString(&quot;name&quot;);
        double money = rs.getDouble(&quot;money&quot;);

        System.out.println(id);
        System.out.println(name);
        System.out.println(money);
        System.out.println(&quot;--------------&quot;);
    &#125;

    //7. 释放资源
    rs.close();
    stmt.close();
    conn.close();
&#125;
</code></pre>
<hr>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><hr>
<p>代码模拟SQL注入问题:</p>
<pre><code>@Test
public void testLogin() throws  Exception &#123;
    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写
    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;
    String username = &quot;root&quot;;
    String password = &quot;1234&quot;;
    Connection conn = DriverManager.getConnection(url, username, password);

    // 接收用户输入 用户名和密码
    String name = &quot;sjdljfld&quot;;
    String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;
    String sql = &quot;select * from tb_user where username = &#39;&quot;+name+&quot;&#39; and password = &#39;&quot;+pwd+&quot;&#39;&quot;;
    // 获取stmt对象
    Statement stmt = conn.createStatement();
    // 执行sql
    ResultSet rs = stmt.executeQuery(sql);
    // 判断登录是否成功
    if(rs.next())&#123;
        System.out.println(&quot;登录成功~&quot;);
    &#125;else&#123;
        System.out.println(&quot;登录失败~&quot;);
    &#125;

    //7. 释放资源
    rs.close();
    stmt.close();
    conn.close();
&#125;
</code></pre>
<p>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</p>
<pre><code>select * from tb_user where username = &#39;sjdljfld&#39; and password = &#39;&#39;or &#39;1&#39; = &#39;1&#39;
</code></pre>
<p>从上面语句可以看出条件 <code>username = &#39;sjdljfld&#39; and password = &#39;&#39;</code> 不管是否满足，而 <code>or</code> 后面的 <code>&#39;1&#39; = &#39;1&#39;</code> 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。</p>
<p>接下来我们来学习PreparedStatement对象.</p>
<p>PreparedStatement作用：预编译SQL语句并执行：预防SQL注入问题</p>
<p>获取 PreparedStatement 对象:</p>
<pre><code>// SQL语句中的参数值，使用？占位符替代
String sql = &quot;select * from user where username = ? and password = ?&quot;;
// 通过Connection对象获取，并传入对应的sql语句
PreparedStatement pstmt = conn.prepareStatement(sql);
</code></pre>
<p>上面的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ?  的值。</p>
<pre><code>PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值
Xxx：数据类型 ； 如 setInt (参数1，参数2)
参数：
参数1： ？的位置编号，从1 开始
参数2： ？的值
</code></pre>
<p>执行SQL语句:</p>
<pre><code>executeUpdate();  执行DDL语句和DML语句
executeQuery();  执行DQL语句
注意：调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。
</code></pre>
<p>使用PreparedStatement改进:</p>
<pre><code>@Test
public void testPreparedStatement() throws  Exception &#123;
    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写
    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;
    String username = &quot;root&quot;;
    String password = &quot;1234&quot;;
    Connection conn = DriverManager.getConnection(url, username, password);

    // 接收用户输入 用户名和密码
    String name = &quot;zhangsan&quot;;
    String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;

    // 定义sql
    String sql = &quot;select * from tb_user where username = ? and password = ?&quot;;
    // 获取pstmt对象
    PreparedStatement pstmt = conn.prepareStatement(sql);
    // 设置？的值
    pstmt.setString(1,name);
    pstmt.setString(2,pwd);
    // 执行sql
    ResultSet rs = pstmt.executeQuery();
    // 判断登录是否成功
    if(rs.next())&#123;
        System.out.println(&quot;登录成功~&quot;);
    &#125;else&#123;
        System.out.println(&quot;登录失败~&quot;);
    &#125;
    //7. 释放资源
    rs.close();
    pstmt.close();
    conn.close();
&#125;
</code></pre>
<p>执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下：</p>
<pre><code>select * from tb_user where username = &#39;sjdljfld&#39; and password = &#39;\&#39;or \&#39;1\&#39; = \&#39;1&#39;
</code></pre>
<p>PreparedStatement 好处：预编译SQL，性能更高;防止SQL注入：&#x3D;&#x3D;将敏感字符进行转义&#x3D;&#x3D;.</p>
<p>Java代码操作数据库流程：将sql语句发送到MySQL服务器端;MySQL服务端会对sql语句进行如下操作:检查SQL语句的语法是否正确,将SQL语句编译成可执行的函数,执行SQL语句.</p>
<p>PreparedStatement原理:在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）;执行时就不用再进行这些步骤了，速度更快;如果sql模板一样，则只需要进行一次检查、编译。</p>
<hr>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><hr>
<p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)。它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。</p>
<p>好处：资源重用，提升系统响应速度，避免数据库连接遗漏。</p>
<p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。而数据库使用了数据库连接池后，就能达到Connection对象的复用。</p>
<p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p>
<p>数据库连接池实现：以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p>
<p>常见的数据库连接池：DBCP、C3P0、Druid。</p>
<p>Druid（德鲁伊）：Druid连接池是阿里巴巴开源的数据库连接池项目。功能强大，性能优秀，是Java语言最好的数据库连接池之一。</p>
<p>Driud使用</p>
<pre><code>导入jar包 druid-1.1.12.jar

定义配置文件
    driverClassName=com.mysql.jdbc.Driver
    url=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true
    username=root
    password=1234
    # 初始化连接数量
    initialSize=5
    # 最大连接数
    maxActive=10
    # 最大等待时间
    maxWait=3000

加载配置文件
获取数据库连接池对象
获取连接
</code></pre>
<p>使用druid的代码如下：</p>
<pre><code>/**
 * Druid数据库连接池演示
 */
public class DruidDemo &#123;

    public static void main(String[] args) throws Exception &#123;
        //1.导入jar包
        //2.定义配置文件
        //3. 加载配置文件
        Properties prop = new Properties();
        prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;));
        //4. 获取连接池对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);

        //5. 获取数据库连接 Connection
        Connection connection = dataSource.getConnection();
        System.out.println(connection); //获取到了连接后就可以继续做其他操作了

        //System.out.println(System.getProperty(&quot;user.dir&quot;));
    &#125;
&#125;
</code></pre>
<p>druid配置详解:</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
<th align="center">建议值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url</td>
<td align="center">数据库的jdbc连接地址。一般为连接oracle&#x2F;mysql。示例如下：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">mysql : jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;dbname?option1&amp;option2&amp;…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">oracle : jdbc:oracle:thin:@ip:port:oracle_sid</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">username</td>
<td align="center">登录数据库的用户名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">password</td>
<td align="center">登录数据库的用户密码</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">initialSize</td>
<td align="center">启动程序时，在连接池中初始化多少个连接</td>
<td align="center">10-50已足够</td>
</tr>
<tr>
<td align="center">maxActive</td>
<td align="center">连接池中最多支持多少个活动会话</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">maxWait</td>
<td align="center">程序向连接池中请求连接时,超过maxWait的值后，认为本次请求失败，即连接池</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">没有可用连接，单位毫秒，设置-1时表示无限等待</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">minEvictableIdleTimeMillis</td>
<td align="center">池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时，将</td>
<td align="center">见说明部分</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">回收该连接,要小于防火墙超时设置</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">net.netfilter.nf_conntrack_tcp_timeout_established的设置</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">timeBetweenEvictionRunsMillis</td>
<td align="center">检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">keepAlive</td>
<td align="center">程序没有close连接且空闲时长超过 minEvictableIdleTimeMillis,则会执</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">行validationQuery指定的SQL,以保证该程序连接不会池kill掉,其范围不超</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">过minIdle指定的连接个数。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">minIdle</td>
<td align="center">回收空闲连接时，将保证至少有minIdle个连接.</td>
<td align="center">与initialSize相同</td>
</tr>
<tr>
<td align="center">removeAbandoned</td>
<td align="center">要求程序从池中get到连接后, N 秒后必须close,否则druid 会强制回收该</td>
<td align="center">false,当发现程序有未</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">连接,不管该连接中是活动还是空闲, 以防止进程不会进行close而霸占连接。</td>
<td align="center">正常close连接时设置为true</td>
</tr>
<tr>
<td align="center">removeAbandonedTimeout</td>
<td align="center">设置druid 强制回收连接的时限，当程序从池中get到连接开始算起，超过此</td>
<td align="center">应大于业务运行最长时间</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">值后，druid将强制回收该连接，单位秒。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">logAbandoned</td>
<td align="center">当druid强制回收连接后，是否将stack trace 记录到日志中</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">testWhileIdle</td>
<td align="center">当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效)</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">validationQuery</td>
<td align="center">检查池中的连接是否仍可用的 SQL 语句,drui会连接到数据库执行该SQL, 如果</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">正常返回，则表示连接可用，否则表示连接不可用</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">testOnBorrow</td>
<td align="center">程序 <strong>申请</strong> 连接时,进行连接有效性检查（低效，影响性能）</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">testOnReturn</td>
<td align="center">程序 <strong>返还</strong> 连接时,进行连接有效性检查（低效，影响性能）</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">poolPreparedStatements</td>
<td align="center">缓存通过以下两个方法发起的SQL:</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">public PreparedStatement prepareStatement(String sql)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">public PreparedStatement prepareStatement(String sql,</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int resultSetType, int resultSetConcurrency)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">maxPoolPrepareStatementPerConnectionSize</td>
<td align="center">每个连接最多缓存多少个SQL</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">filters</td>
<td align="center">这里配置的是插件,常用的插件有:</td>
<td align="center">stat,wall,slf4j</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">监控统计: filter:stat</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">日志监控: filter:log4j 或者 slf4j</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">防御SQL注入: filter:wall</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">connectProperties</td>
<td align="center">连接属性。比如设置一些连接池统计方面的配置。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;5000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">比如设置一些数据库连接属性:</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<hr>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Spring Boot是便捷搭建基于Spring的工程脚手架。其最主要作用就是帮助开发人员快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让开发人员关注业务而非配置。</p>
<p>我们可以使用Spring Boot创建java应用，并使用<code>java –jar</code> 启动它，就能得到一个生产级别的web工程。</p>
<hr>
<h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><hr>
<p><code>Spring Initializr</code>（jdk1.8默认即可）–&gt; 完善项目信息 –&gt; <code>spring web starter</code></p>
<p>pom.xml文件：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.1&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;HelloSpringBoot&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;HelloSpringBoot&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>Application文件：</p>
<pre><code>@SpringBootApplication
public class HelloSpringBootApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HelloSpringBootApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>Controller文件：</p>
<pre><code>import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;
    @GetMapping(value=&quot;/hello&quot;)
    public String hello()&#123;
        return &quot;Hello Spring Boot&quot;;
    &#125;
&#125;
</code></pre>
<p>访问<code>http://localhost:8080/hello</code>即可以返回<code>Hello Spring Boot</code>。</p>
<hr>
<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><hr>
<p>引入：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.16&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>写法一：</p>
<p>创建数据库 <code>springboot_test</code> ，在项目resources下新建 <code>jdbc.properties</code> 文件：</p>
<pre><code>jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://192.168.1.13:3306/springboot_test
jdbc.username=root
jdbc.password=123456
</code></pre>
<p><code>JdbcConfig</code> 类:</p>
<pre><code>import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import javax.sql.DataSource;

@Configuration
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JdbcConfig &#123;
    @Value(&quot;$&#123;jdbc.url&#125;&quot;)
    String url;
    @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)
    String driverClassName;
    @Value(&quot;$&#123;jdbc.username&#125;&quot;)
    String username;
    @Value(&quot;$&#123;jdbc.password&#125;&quot;)
    String password;

    @Bean
    public DataSource dataSource() &#123;
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driverClassName);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    &#125;
&#125;
</code></pre>
<p>写法二：<code>@ConfigurationProperties</code>可以在类上，也可以在方法上：</p>
<p>在项目resources下 <code>application.properties</code>：</p>
<pre><code>jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://192.168.1.13:3306/springboot_test
jdbc.username=root
jdbc.password=123456
</code></pre>
<p><code>JdbcConfig</code> 类:</p>
<pre><code>import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import javax.sql.DataSource;

@Configuration
public class JdbcConfig &#123;

    //prefix = &quot;jdbc&quot; 中的jdbc指的是 jdbc.password=123456 中的jdbc
    @Bean
    @ConfigurationProperties(prefix = &quot;jdbc&quot;)
    public DataSource dataSource() &#123;
        return new DruidDataSource();
    &#125;
&#125;
</code></pre>
<p>两种写法写完后，使用：</p>
<pre><code>@Autowired
private DataSource dataSource;

System.out.println(&quot;dataSource: &quot; + dataSource);
</code></pre>
<hr>
<h3 id="yml文件配置"><a href="#yml文件配置" class="headerlink" title="yml文件配置"></a>yml文件配置</h3><hr>
<p>yaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。</p>
<p>yml配置文件的特征：树状层级结构展示配置项；配置项之间如果有关系的话需要分行空两格；配置项如果有值的话，那么需要在 <code>:</code>之后空一格再写配置项值；</p>
<pre><code>jdbc:
  driverClassName: com.mysql.jdbc.Driver
  url: jdbc:mysql://127.0.0.1:3306/hehe
  username: root
  password: 123456

key:
  abc: cba
  def:
    - g
    - h
    - j
</code></pre>
<p>多个yml配置文件，在spring boot中是被允许的。这些配置文件的名称必须为 <code>application-***.yml</code>，并且这些配置文件必须要在<code>application.yml</code>配置文件中激活之后才可以使用。</p>
<pre><code>#激活配置文件;需要指定其它的配置文件名称,abc,def就是application-abc.yml，application-def.yml
spring:
  profiles:
    active: abc,def
</code></pre>
<p>如果properties和yml配置文件同时存在在<code>spring boot</code>项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。</p>
<hr>
<h3 id="lombok应用"><a href="#lombok应用" class="headerlink" title="lombok应用"></a>lombok应用</h3><hr>
<p>添加lombok对应的依赖到项目pom.xml文件:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>在Bean上使用：</p>
<pre><code>@Data ：自动提供getter和setter、hashCode、equals、toString等方法
@Getter：自动提供getter方法
@Setter：自动提供setter方法
@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。
</code></pre>
<hr>
<h3 id="修改项目tomcat端口"><a href="#修改项目tomcat端口" class="headerlink" title="修改项目tomcat端口"></a>修改项目tomcat端口</h3><hr>
<p>yml文件方式</p>
<pre><code>#tomcat端口
server:
  port: 80
</code></pre>
<p><code>application.properties</code>中修改端口和path：</p>
<pre><code>server.port=8082
server.servlet.context-path=/shiyanlou/
</code></pre>
<hr>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><hr>
<p>默认的静态资源路径为：</p>
<pre><code>classpath:/META-INF/resources/
classpath:/resources/
classpath:/static/
classpath:/public
</code></pre>
<hr>
<h3 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h3><hr>
<p>编写拦截器（实现<code>HandlerInterceptor</code>）:</p>
<pre><code>import lombok.extern.slf4j.Slf4j;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Slf4j
public class MyInterceptor implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        log.debug(&quot;这是MyInterceptor的preHandle方法。&quot;);
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        log.debug(&quot;这是MyInterceptor的postHandle方法。&quot;);
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        log.debug(&quot;这是MyInterceptor的afterCompletion方法。&quot;);
    &#125;
&#125;
</code></pre>
<p>编写配置类实现 <code>WebMvcConfigurer</code>，在该类中添加各种组件:</p>
<pre><code>import com.jiangtea.interceptor.MyInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfig implements WebMvcConfigurer &#123;

    //注册拦截器
    @Bean
    public MyInterceptor myInterceptor()&#123;
        return new MyInterceptor();
    &#125;

    //添加拦截器到spring mvc拦截器链
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(myInterceptor()).addPathPatterns(&quot;/*&quot;);
    &#125;
&#125;
</code></pre>
<p>设置日志级别：</p>
<pre><code>#日志记录级别
logging:
  level:
    com.jiangtea: debug
    org.springframework: info
</code></pre>
<hr>
<h3 id="整合事务和连接池"><a href="#整合事务和连接池" class="headerlink" title="整合事务和连接池"></a>整合事务和连接池</h3><hr>
<p>配置Spring Boot自带默认的 <code>hikari</code>数据库连接池和使用 <code>@Transactional</code>注解进行事务配置。</p>
<p>pom.xml文件中：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>application.properties：</p>
<pre><code>spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/springboot_test?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=15
spring.datasource.hikari.auto-commit=true
spring.datasource.hikari.idle-timeout=30000
spring.datasource.hikari.pool-name=hikariCP
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.connection-test-query=SELECT 1
</code></pre>
<p>UserService类：</p>
<pre><code>import com.jiangtea.pojo.User;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService &#123;
    //根据id查询
    public User queryById(Long id)&#123;
        return new User();
    &#125;
    //新增保存用户
    @Transactional
    public void saveUser(User user)&#123;
        System.out.println(&quot;新增用户... &quot;);
    &#125;
&#125;
</code></pre>
<p>使用：</p>
<pre><code>@Autowired
private DataSource dataSource;
</code></pre>
<hr>
<h3 id="Spring-Boot整合Mybatis"><a href="#Spring-Boot整合Mybatis" class="headerlink" title="Spring Boot整合Mybatis"></a>Spring Boot整合Mybatis</h3><hr>
<p>pom.xml文件中：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>application.yml配置：</p>
<pre><code>mybatis:
  # 实体类别名包路径
  type-aliases-package: com.jiangtea.pojo
  # 映射文件路径
  # mapper-locations: classpath:mappers/*.xml
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<p>扫描mybatis所有的业务mapper接口配置：</p>
<pre><code>import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
// 扫描mybatis所有的业务mapper接口
@MapperScan(&quot;com.jiangtea.mapper&quot;)
public class HelloSpringBootApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HelloSpringBootApplication.class, args);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="整合通用Mapper"><a href="#整合通用Mapper" class="headerlink" title="整合通用Mapper"></a>整合通用Mapper</h3><hr>
<p>pom.xml文件中：</p>
<pre><code>&lt;!-- 通用mapper --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>继承<code>Mapper&lt;User&gt;</code>:</p>
<pre><code>import com.jiangtea.pojo.User;
import tk.mybatis.mapper.common.Mapper;

public interface UserMapper extends Mapper&lt;User&gt; &#123;
&#125;
</code></pre>
<p>修改启动引导类Application中的Mapper扫描注解，注意修改成<code>tk.mybatis.spring.annotation.MapperScan</code>:</p>
<pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
// 扫描mybatis所有的业务mapper接口
@MapperScan(&quot;com.jiangtea.mapper&quot;)
public class HelloSpringBootApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HelloSpringBootApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>修改User实体类添加jpa注解:</p>
<pre><code>import lombok.Data;
import tk.mybatis.mapper.annotation.KeySql;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

@Data
@Table(name = &quot;tb_user&quot;)
public class User &#123;
    @Id
    //主键回填
    @KeySql(useGeneratedKeys = true)
    private Long id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private Integer sex;
    private Date birthday;
    private String note;
    private Date created;
    private Date updated;
&#125;
</code></pre>
<p>UserService：</p>
<pre><code>import com.jiangtea.mapper.UserMapper;
import com.jiangtea.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService &#123;
    @Autowired
    private UserMapper userMapper;
    //根据id查询
    public User queryById(Long id)&#123;
        return userMapper.selectByPrimaryKey(id);
    &#125;
    //新增保存用户
    @Transactional
    public void saveUser(User user)&#123;
        System.out.println(&quot;新增用户... &quot;);
        //选择性新增；如果属性为空则该属性不会出现在insert语句上
        userMapper.insertSelective(user);
        int i = 1/0;
    &#125;
&#125;
</code></pre>
<p>编写Controller：</p>
<pre><code>import com.jiangtea.pojo.User;
import com.jiangtea.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import javax.sql.DataSource;

@RestController
public class HelloController &#123;

    @Autowired
    private DataSource dataSource;

    @Autowired
    private UserService userService;

    /**
     * 根据用户id查询用户
     * @param id 用户id
     * @return 用户
     */
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    public User queryById(@PathVariable Long id)&#123;
        return userService.queryById(id);
    &#125;
    @GetMapping(&quot;hello&quot;)
    public String hello()&#123;
        System.out.println(&quot; DataSource = &quot; + dataSource);
        return &quot;Hello, Spring Boot!&quot;;
    &#125;
&#125;
</code></pre>
<p>开始测试-测试地址：<code>http://localhost:8082/user/7</code> :</p>
<hr>
<h3 id="Spring-Boot整合Junit"><a href="#Spring-Boot整合Junit" class="headerlink" title="Spring Boot整合Junit"></a>Spring Boot整合Junit</h3><hr>
<p>添加依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>在类UserService上按 <code>ctrl+shift+T</code> 选择 <code>JUnit4</code> 创建测试类：</p>
<pre><code>import com.jiangtea.pojo.User;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import java.util.Date;
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserServiceTest &#123;
    @Autowired
    private UserService userService;
    @Test
    public void queryById() &#123;
        User user = userService.queryById(8L);
        System.out.println(&quot;user = &quot; + user);
    &#125;
    @Test
    public void saveUser() &#123;
        User user = new User();
        user.setUserName(&quot;test2&quot;);
        user.setName(&quot;test2&quot;);
        user.setAge(13);
        user.setPassword(&quot;123456&quot;);
        user.setSex(1);
        user.setCreated(new Date());
        userService.saveUser(user);
    &#125;
&#125;
</code></pre>
<p>注意添加 <code>@SpringBootTest</code>。</p>
<hr>
<h3 id="Spring-Boot整合redis"><a href="#Spring-Boot整合redis" class="headerlink" title="Spring Boot整合redis"></a>Spring Boot整合redis</h3><hr>
<p>添加依赖:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置application.yml中修改redis的连接参数（redis需要启动）:</p>
<pre><code>spring:
  redis:
    host: localhost
    port: 6379
</code></pre>
<p>编写测试类应用RedisTemplate操作redis中的5种数据类型（string&#x2F;hash&#x2F;list&#x2F;set&#x2F;sorted set）</p>
<pre><code>import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.junit4.SpringRunner;
import java.util.List;
import java.util.Set;

@RunWith(SpringRunner.class)
@SpringBootTest
public class RedisTest &#123;

    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void test()&#123;
        //string 字符串
        //redisTemplate.opsForValue().set(&quot;str&quot;, &quot;hehe&quot;);
        redisTemplate.boundValueOps(&quot;str&quot;).set(&quot;hehe&quot;);
        System.out.println(&quot;str = &quot; + redisTemplate.opsForValue().get(&quot;str&quot;));

        //hash 散列
        redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;name&quot;, &quot;hehe&quot;);
        redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;age&quot;, 13);
        //获取所有域
        Set set = redisTemplate.boundHashOps(&quot;h_key&quot;).keys();
        System.out.println(&quot; hash散列的所有域：&quot; + set);
        //获取所有值
        List list = redisTemplate.boundHashOps(&quot;h_key&quot;).values();
        System.out.println(&quot; hash散列的所有域的值：&quot; + list);

        //list 列表
        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;c&quot;);
        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;b&quot;);
        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;a&quot;);
        //获取全部元素
        list = redisTemplate.boundListOps(&quot;l_key&quot;).range(0, -1);
        System.out.println(&quot; list列表中的所有元素：&quot; + list);

        // set 集合
        redisTemplate.boundSetOps(&quot;s_key&quot;).add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        set = redisTemplate.boundSetOps(&quot;s_key&quot;).members();
        System.out.println(&quot; set集合中的所有元素：&quot; + set);

        // sorted set 有序集合
        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;a&quot;, 30);
        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;b&quot;, 20);
        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;c&quot;, 10);
        set = redisTemplate.boundZSetOps(&quot;z_key&quot;).range(0, -1);
        System.out.println(&quot; zset有序集合中的所有元素：&quot; + set);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="Spring-Boot项目部署"><a href="#Spring-Boot项目部署" class="headerlink" title="Spring Boot项目部署"></a>Spring Boot项目部署</h3><hr>
<p>pom添加打包组件:</p>
<pre><code>&lt;build&gt;
  &lt;plugins&gt;
     &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;
      &lt;plugin&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>可以点击右边栏maven的Lifecycle中的<code>package</code>进行打包。</p>
<p>部署：<code>java -jar 打好的jar包名字</code>。</p>
<hr>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>maven 是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。</p>
<p>依赖管理：就是对jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。</p>
<p>项目构建：通过maven的一个命令就可以完成项目从清理、编译、测试、报告、打包，部署整个过程。</p>
<p>maven常用命令：clean(清理)、compile(编译)、test(测试)、package(打包)、install(安装)。</p>
<p>maven中央仓库：<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></p>
<hr>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><hr>
<p>解压 apache-maven-3.6.1.rar 既安装完成</p>
<p>配置环境变量 MAVEN_HOME 为安装路径的bin目录</p>
<p>配置本地仓库：修改 conf&#x2F;settings.xml 中的 <localRepository> 为一个指定目录</p>
<p>配置阿里云私服：修改 conf&#x2F;settings.xml 中的 <mirrors>标签，为其添加如下子标签：</p>
<pre><code>&lt;mirror&gt;  
    &lt;id&gt;alimaven&lt;/id&gt;  
    &lt;name&gt;aliyun maven&lt;/name&gt;  
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          
&lt;/mirror&gt;
</code></pre>
<p>如果不改本地仓库，默认下载到本地目录：</p>
<pre><code>C:\Users\Admin\.m2\repository
</code></pre>
<p>检查配置版本：</p>
<pre><code>mvn -version
</code></pre>
<hr>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><hr>
<p>Maven 常用命令：</p>
<pre><code>mvn compile ：编译
mvn clean：清理
mvn test：测试
mvn package：打包
mvn install：安装
</code></pre>
<hr>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><hr>
<p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。</p>
<p>Maven 对项目构建的生命周期划分为3套：</p>
<pre><code>clean：清理工作
default：核心工作，例如编译，测试，打包，安装等
site：产生报告，发布站点等
</code></pre>
<p><strong>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</strong></p>
<hr>
<h3 id="IDEA-配置-Maven"><a href="#IDEA-配置-Maven" class="headerlink" title="IDEA 配置 Maven"></a>IDEA 配置 Maven</h3><hr>
<p>配置 Maven：</p>
<pre><code>选择 IDEA中 File --&gt; Settings
搜索 maven 
设置 IDEA 使用本地安装的 Maven，并修改配置文件路径。即maven home path 和 User settings file
</code></pre>
<p>IDEA 导入 Maven 项目：</p>
<pre><code>选择右侧Maven面板，点击 + 号
选中对应项目的pom.xml文件，双击即可
如果没有Maven面板，选择 View -&gt; Appearance -&gt; Tool Window Bars
</code></pre>
<p>Maven Helper插件：</p>
<pre><code>Plugins里面搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept
</code></pre>
<hr>
<h3 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h3><hr>
<p>Maven 中的坐标是资源的唯一标识。使用坐标来定义项目或引入项目中需要的依赖</p>
<p>Maven 坐标主要组成：</p>
<pre><code>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.tea）
artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）
version：定义当前项目版本号
</code></pre>
<p>使用坐标导入 jar 包：</p>
<pre><code>在 pom.xml 中编写 &lt;dependencies&gt; 标签
在 &lt;dependencies&gt; 标签中 使用 &lt;dependency&gt; 引入坐标
定义坐标的 groupId，artifactId，version
点击刷新按钮，使坐标生效
</code></pre>
<p>使用坐标导入 jar 包 – 快捷方式：</p>
<pre><code>在 pom.xml 中 按 alt + insert，选择 Dependency
在弹出的面板中搜索对应坐标，然后双击选中对应坐标
点击刷新按钮，使坐标生效
</code></pre>
<p>使用坐标导入 jar 包 – 自动导入：</p>
<pre><code>选择 IDEA中 File --&gt; Settings
在弹出的面板中找到 Build Tools
选择 Any changes，点击 ok 即可生效
</code></pre>
<hr>
<h3 id="maven的依赖范围"><a href="#maven的依赖范围" class="headerlink" title="maven的依赖范围"></a>maven的依赖范围</h3><hr>
<p>maven的依赖范围：</p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>对于编译classpath有效</th>
<th>对于测试classpath有效</th>
<th>对于运行时classpath有效</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC驱动</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地的，maven仓库之外的类库</td>
</tr>
</tbody></table>
<p>通过<code>scope</code>指定依赖范围，默认是<code>compile</code>：</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre>
<hr>
<h3 id="maven的依赖冲突"><a href="#maven的依赖冲突" class="headerlink" title="maven的依赖冲突"></a>maven的依赖冲突</h3><hr>
<p>排除依赖：可以使用<code>exclusions</code>标签将传递过来的依赖排除出去。</p>
<pre><code>&lt;exclusions&gt;
    &lt;exclusion&gt;
    ....
    &lt;/exclusion&gt;
&lt;/exclusions&gt;
</code></pre>
<p>版本锁定:采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。</p>
<p>版本锁定的使用方式：第一步：在dependencyManagement标签中锁定依赖的版本;第二步：在dependencies标签中声明需要导入的maven坐标。</p>
<pre><code>&lt;!--锁定jar包的版本--&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<hr>
<h3 id="maven分模块构建"><a href="#maven分模块构建" class="headerlink" title="maven分模块构建"></a>maven分模块构建</h3><hr>
<p>分模块父工程的打包方式必须为pom：</p>
<pre><code>&lt;!--父工程的打包方式必须为pom--&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
<p>子工程：</p>
<pre><code>&lt;!--表示当前maven工程继承了maven_parent父工程--&gt;
&lt;parent&gt;
    &lt;artifactId&gt;maven_parent&lt;/artifactId&gt;
    &lt;groupId&gt;com.study&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
<p>当前子工程依赖 子工程maven_dao：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.study&lt;/groupId&gt;
        &lt;artifactId&gt;maven_dao&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>maven工程的聚合：在maven工程的<code>pom.xml</code>文件中可以使用<code>&lt;modules&gt;</code>标签将其他maven工程聚合到一起，聚合的目的是为了进行统一操作。例如拆分后的maven工程有多个，如果要进行打包，就需要针对每个工程分别执行打包命令，操作起来非常繁琐。这时就可以使用<code>&lt;modules&gt;</code>标签将这些工程统一聚合到maven工程中，需要打包的时候，只需要在此工程中执行一次打包命令，其下被聚合的工程就都会被打包了。</p>
<hr>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>官网：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a> </p>
<p>MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。</p>
<p>JavaEE三层架构：表现层、业务层、持久层。持久层：负责将数据到保存到数据库的那一层代码。</p>
<p>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</p>
<hr>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><hr>
<p>创建模块，导入坐标：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.4.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.46&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- 添加slf4j日志api --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.7.25&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 添加logback-classic依赖 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 添加logback-core依赖 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-core&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>编写 MyBatis 核心配置文件：resources&#x2F;mybatis-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!--数据库连接信息--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;******&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>编写 SQL 映射文件:resources&#x2F;UserMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!-- namespace:名称空间--&gt;
&lt;mapper namespace=&quot;test&quot;&gt;
    &lt;!--statement--&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.tea.pojo.User&quot;&gt;
        select *
        from tb_user;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>编码：</p>
<pre><code>public static void main(String[] args) throws IOException &#123;
    //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

    //2. 获取SqlSession对象，用它来执行sql
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //3. 执行sql
    List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);
    System.out.println(users);
    //4. 释放资源
    sqlSession.close();
&#125;
</code></pre>
<hr>
<h3 id="Idea连接数据库"><a href="#Idea连接数据库" class="headerlink" title="Idea连接数据库"></a>Idea连接数据库</h3><hr>
<p>Idea右边栏点击Database，点击加号+，输入用户名，密码，数据库，建立连接。</p>
<hr>
<h3 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h3><hr>
<p>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下：</p>
<pre><code>在java目录下，新建com.tea.mapper.UserMapper接口
在resources目录下，新建com/tea/mapper目录，UserMapper.xml文件。注意用斜杠。
</code></pre>
<p>设置SQL映射文件的namespace属性为Mapper接口全限定名：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!-- namespace:名称空间--&gt;
&lt;mapper namespace=&quot;com.tea.mapper.UserMapper&quot;&gt;
    &lt;!--statement--&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.tea.pojo.User&quot;&gt;
        select *
        from tb_user;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致:</p>
<pre><code>public interface UserMapper &#123;
    List&lt;User&gt; selectAll();
&#125;
</code></pre>
<p>配置mybatis-config.xml：</p>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/tea/mapper/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>编码：</p>
<pre><code>public class MyBatisDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
        //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        //2. 获取SqlSession对象，用它来执行sql
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //3. 执行sql
        //List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);
        //3.1 获取UserMapper接口的代理对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        List&lt;User&gt; users = userMapper.selectAll();

        System.out.println(users);
        //4. 释放资源
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<p>细节：如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载:</p>
<pre><code>&lt;mappers&gt;
    &lt;!--&lt;mapper resource=&quot;com/tea/mapper/UserMapper.xml&quot;/&gt;--&gt;
    &lt;!--mapper代理--&gt;
    &lt;package name=&quot;com.tea.mapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<hr>
<h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><hr>
<p>environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment。</p>
<p>typeAliases-别名：</p>
<pre><code>mybatis-config.xml内：
&lt;typeAliases&gt;
    &lt;package name=&quot;com.tea.pojo&quot;/&gt;
&lt;/typeAliases&gt;

UserMapper.xml内：
可以不用	resultType=&quot;com.tea.pojo.User&quot;
可以直接使用	resultType=&quot;User&quot;
</code></pre>
<p><strong>mybatis-config.xml中配置各个标签时，需要遵守标签前后顺序。</strong></p>
<hr>
<h3 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h3><hr>
<p>MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。</p>
<p>主要功能：XML 和 接口方法 相互跳转;根据接口方法生成 statement。</p>
<hr>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><hr>
<p>查询所有：</p>
<pre><code>//编写接口方法： Mapper接口：（参数：无，结果：List&lt;Brand&gt;）
public interface BrandMapper &#123;
    public List&lt;Brand&gt; selectAll();
&#125;

//编写 SQL语句： SQL映射文件：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!-- namespace:名称空间--&gt;
&lt;mapper namespace=&quot;com.tea.mapper.BrandMapper&quot;&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt;
        select *
        from tb_brand;
    &lt;/select&gt;
&lt;/mapper&gt;

//执行方法，测试
String resource = &quot;mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

SqlSession sqlSession = sqlSessionFactory.openSession();

BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);
List&lt;Brand&gt; brands = brandMapper.selectAll();
System.out.println(brands);
sqlSession.close();
</code></pre>
<hr>
<p>数据库表的字段名称和实体类的属性名称不一样时，解决办法：</p>
<pre><code>//方法1、xml中用别名
&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt;
    select id, brand_name as brandName, company_name as companyName, ordered, description, status
    from tb_brand;
&lt;/select&gt;

//方法2、sql片段抽取
&lt;sql id=&quot;brand_column&quot;&gt;
    id, brand_name as brandName, company_name as companyName, ordered, description, status
&lt;/sql&gt;
&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt;
    select
    &lt;include refid=&quot;brand_column&quot; /&gt;
    from tb_brand;
&lt;/select&gt;

//方法3、resultMap
&lt;!--id：唯一标识、type：映射的类型，支持别名--&gt;
&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt;
    &lt;!--id：完成主键字段的映射、column：表的列名、property：实体类的属性名
        result：完成一般字段的映射、column：表的列名、property：实体类的属性名--&gt;
    &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;
    &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;
    select *
    from tb_brand;
&lt;/select&gt;
</code></pre>
<hr>
<p>根据Id查询：</p>
<pre><code>//编写接口方法： Mapper接口（参数：id、结果：Brand）
public interface BrandMapper &#123;
    Brand selectById(int id);
&#125;

//编写 SQL语句： SQL映射文件
&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt;
    select *
    from tb_brand where id = #&#123;id&#125;;
&lt;/select&gt;

//执行方法，测试
int id = 1;
BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);
Brand brand = brandMapper.selectById(id);
System.out.println(brand);
sqlSession.close();
</code></pre>
<hr>
<p>参数占位符：</p>
<pre><code>#&#123;&#125;:会将其替换为 ?，为了防止SQL注入
$&#123;&#125;：拼sql。会存在SQL注入问题

使用时机：参数传递的时候使用#&#123;&#125;;表名或者列名不固定的情况下使用$&#123;&#125; 

参数类型：parameterType：可以省略。
特殊字符处理： 转义字符；CDATA区。比如&lt;小于号，可以用 &amp;lt; 或者 &lt;![CDATA[&lt;]]&gt; 。
</code></pre>
<hr>
<p>多条件查询：三种方式</p>
<pre><code>散装参数：需要使用@Param(&quot;SQL中的参数名称&quot;)
实体类封装参数:只需要保证SQL中的参数名 和 实体类属性名对应上，即可设置成功
map集合：只需要保证SQL中的参数名 和 map集合的键的名称对应上，即可设置成功

//编写接口方法： Mapper接口(参数：所有查询条件、结果：List&lt;Brand&gt;)
//方式一：
List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;)int status, @Param(&quot;companyName&quot;) String companyName, @Param(&quot;brandName&quot;) String brandName);
//方式二：
List&lt;Brand&gt; selectByCondition(Brand brand);
//方式三：
List&lt;Brand&gt; selectByCondition(Map map);

//编写 SQL语句： SQL映射文件
//方式一：//方式二：//方式三：
&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;
    select * from tb_brand where status = #&#123;status&#125; and company_name like #&#123;companyName&#125; and brand_name like #&#123;brandName&#125;
&lt;/select&gt;

//执行方法，测试
//方式一：
int status = 1;
String companyName = &quot;华为&quot;;
String brandName = &quot;华为&quot;;
companyName = &quot;%&quot; + companyName + &quot;%&quot;;
brandName = &quot;%&quot; + brandName + &quot;%&quot;;

List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName);
System.out.println(brands);
sqlSession.close();
//方式二：
int status = 1;
String companyName = &quot;华为&quot;;
String brandName = &quot;华为&quot;;
companyName = &quot;%&quot; + companyName + &quot;%&quot;;
brandName = &quot;%&quot; + brandName + &quot;%&quot;;
Brand brand = new Brand();
brand.setStatus(status);
brand.setCompanyName(companyName);
brand.setBrandName(brandName);

List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);
System.out.println(brands);
sqlSession.close();
//方式三：
int status = 1;
String companyName = &quot;华为&quot;;
String brandName = &quot;华为&quot;;
companyName = &quot;%&quot; + companyName + &quot;%&quot;;
brandName = &quot;%&quot; + brandName + &quot;%&quot;;
Map map = new HashMap();
map.put(&quot;status&quot;, status);
map.put(&quot;companyName&quot;, companyName);
map.put(&quot;brandName&quot;, brandName);

List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);
System.out.println(brands);
sqlSession.close();
</code></pre>
<hr>
<p><strong>多条件动态条件查询</strong>-动态SQL：</p>
<pre><code>&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;
    select *
    from tb_brand
    &lt;where&gt;
        &lt;if test=&quot;status != null&quot;&gt;
            and status = #&#123;status&#125;
        &lt;/if&gt;
        &lt;if test=&quot;companyName != null and companyName != &#39;&#39; &quot;&gt;
            and company_name like #&#123;companyName&#125;
        &lt;/if&gt;
        &lt;if test=&quot;brandName != null and brandName != &#39;&#39; &quot;&gt;
            and brand_name like #&#123;brandName&#125;
        &lt;/if&gt;
    &lt;/where&gt;

&lt;/select&gt;
</code></pre>
<hr>
<p>单条件动态条件查询:</p>
<pre><code>&lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt;
    select * from tb_brand
    where    
    &lt;choose&gt;  &lt;!--类似于switch--&gt;
        &lt;when test=&quot;status != null&quot;&gt;  &lt;!--类似于case--&gt;
            status = #&#123;status&#125;
        &lt;/when&gt;
        &lt;when test=&quot;companyName != null and companyName !=&#39;&#39;&quot;&gt;
            company_name like #&#123;companyName&#125;
        &lt;/when&gt;
        &lt;when test=&quot;brandName != null and brandName !=&#39;&#39; &quot;&gt;
            brand_name like #&#123;brandName&#125;
        &lt;/when&gt;
        &lt;otherwise&gt;  &lt;!--类似于default--&gt;
            1 = 1
        &lt;/otherwise&gt;
    &lt;/choose&gt;
&lt;/select&gt;

或者
&lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt;
    select *
    from tb_brand
    &lt;where&gt;
        &lt;choose&gt;&lt;!--相当于switch--&gt;
            &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt;
                status = #&#123;status&#125;
            &lt;/when&gt;
            &lt;when test=&quot;companyName != null and companyName != &#39;&#39; &quot;&gt;&lt;!--相当于case--&gt;
                company_name like #&#123;companyName&#125;
            &lt;/when&gt;
            &lt;when test=&quot;brandName != null and brandName != &#39;&#39;&quot;&gt;&lt;!--相当于case--&gt;
                brand_name like #&#123;brandName&#125;
            &lt;/when&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<hr>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><hr>
<p>MyBatis事务：</p>
<pre><code>openSession()：默认开启事务，进行增删改操作后需要使用 sqlSession.commit(); 手动提交事务
openSession(true)：可以设置为自动提交事务（关闭事务）
</code></pre>
<p>添加:</p>
<pre><code>//编写接口方法： Mapper接口（参数：除了id之外的所有数据,结果：void）
public interface BrandMapper &#123;
    void add(Brand brand);
&#125;	

//编写 SQL语句： SQL映射文件
&lt;insert id=&quot;add&quot;&gt;
    insert into tb_brand (brand_name, company_name, ordered, description, status)
    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);
&lt;/insert&gt;

//执行方法，测试
int status = 1;
String companyName = &quot;三星&quot;;
String brandName = &quot;三星&quot;;
String des = &quot;三星三星三星三星三星三星三星三星&quot;;
int ordered = 100;
Brand brand = new Brand();
brand.setStatus(status);
brand.setCompanyName(companyName);
brand.setBrandName(brandName);
brand.setDescription(des);
brand.setOrdered(ordered);

SqlSession sqlSession = sqlSessionFactory.openSession(false);

BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);
brandMapper.add(brand);
sqlSession.commit();
sqlSession.close();
</code></pre>
<p>添加-主键返回：useGeneratedKeys和keyProperty</p>
<pre><code>&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into tb_brand (brand_name, company_name, ordered, description, status)
    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);
&lt;/insert&gt;
</code></pre>
<hr>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><hr>
<p>修改全部字段：</p>
<pre><code>&lt;update id=&quot;update&quot;&gt;
    update tb_brand
    set
        brand_name = #&#123;brandName&#125;,
        company_name = #&#123;companyName&#125;,
        ordered = #&#123;ordered&#125;,
        description = #&#123;description&#125;,
        status = #&#123;status&#125;
    where id = #&#123;id&#125;;
&lt;/update&gt;
</code></pre>
<p>修改动态字段：</p>
<pre><code>&lt;update id=&quot;update&quot;&gt;
    update tb_brand
    &lt;set&gt;
        &lt;if test=&quot;brandName != null and brandName != &#39;&#39;&quot;&gt;
            brand_name = #&#123;brandName&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;companyName != null and companyName != &#39;&#39;&quot;&gt;
            company_name = #&#123;companyName&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;ordered != null&quot;&gt;
            ordered = #&#123;ordered&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;description != null and description != &#39;&#39;&quot;&gt;
            description = #&#123;description&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;status != null&quot;&gt;
            status = #&#123;status&#125;
        &lt;/if&gt;
    &lt;/set&gt;
    where id = #&#123;id&#125;;
&lt;/update&gt;
</code></pre>
<p>注意逗号。</p>
<hr>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><hr>
<p>删除一个：</p>
<pre><code>&lt;delete id=&quot;deleteById&quot;&gt;
    delete from tb_brand where id = #&#123;id&#125;;
&lt;/delete&gt;
</code></pre>
<p>批量删除：</p>
<p>mybatis会将数组参数，封装为一个Map集合。默认：array &#x3D; 数组。使用@Param注解改变map集合的默认key的名称。</p>
<pre><code>//void deleteByIds(@Param(&quot;ids&quot;) int[] ids);	collection=&quot;ids&quot;
void deleteByIds(int[] ids);

&lt;delete id=&quot;deleteByIds&quot;&gt;
    delete from tb_brand where id
    in
        &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot;   close=&quot;)&quot;&gt;
            #&#123;id&#125;
        &lt;/foreach&gt;
         ;
&lt;/delete&gt;
</code></pre>
<hr>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><hr>
<p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p>
<pre><code>单个参数：
    POJO类型：直接使用，属性名 和 参数占位符名称 一致
    Map集合：直接使用，键名 和 参数占位符名称 一致
    Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名
        map.put(&quot;arg0&quot;,collection集合);
        map.put(&quot;collection&quot;,collection集合);
    List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名
        map.put(&quot;arg0&quot;,list集合);
        map.put(&quot;collection&quot;,list集合);
        map.put(&quot;list&quot;,list集合);
    Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名
        map.put(&quot;arg0&quot;,数组);
        map.put(&quot;array&quot;,数组);
    其他类型：直接使用
多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名
    map.put(&quot;arg0&quot;,参数值1)
    map.put(&quot;param1&quot;,参数值1)
    map.put(&quot;param2&quot;,参数值2)
    map.put(&quot;agr1&quot;,参数值2)
    ---------------@Param(&quot;username&quot;)
    map.put(&quot;username&quot;,参数值1)
    map.put(&quot;param1&quot;,参数值1)
    map.put(&quot;param2&quot;,参数值2)
    map.put(&quot;agr1&quot;,参数值2)
</code></pre>
<p>Mybatis提供了ParamNameResolver类来进行参数封装。</p>
<hr>
<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><hr>
<p>使用注解开发会比配置文件开发更加方便。</p>
<pre><code>@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)
public User select(int id);
</code></pre>
<p>注解完成简单功能;配置文件完成复杂功能。</p>
<pre><code>查询：@Select
添加：@Insert
修改：@Update
删除：@Delete
</code></pre>
<p>参数设置：</p>
<pre><code>@Select(value = &quot;select * from tb_user where id = #&#123;id&#125; and username = #&#123;username&#125;&quot;)
public User select(@Param(&quot;id&quot;) int id, @Param(&quot;username&quot;) String username);
</code></pre>
<p>结果集映射：</p>
<pre><code>@Select(value = &quot;select * from tb_user where id = #&#123;id&#125; and username = #&#123;username&#125;&quot;)
@ResultMap(&quot;userResultMap&quot;)
public User select(@Param(&quot;id&quot;) int id, @Param(&quot;username&quot;) String username);
</code></pre>
<hr>
<h3 id="SqlSessionFactory工具类"><a href="#SqlSessionFactory工具类" class="headerlink" title="SqlSessionFactory工具类"></a>SqlSessionFactory工具类</h3><hr>
<pre><code>public class SqlSessionFactoryUtils &#123;

    private static SqlSessionFactory sqlSessionFactory;

    static &#123;
        //静态代码块会随着类的加载而自动执行，且只执行一次
        try &#123;
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static SqlSessionFactory getSqlSessionFactory()&#123;
        return sqlSessionFactory;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><hr>
<p>官网：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> </p>
<p>解决中文乱码，修改配置 <code>conf/logging.properties</code> :</p>
<pre><code>java.util.logging.ConsoleHandler.encoding = GBK
</code></pre>
<p>修改启动端口号：conf&#x2F;server.xml ：</p>
<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>注：HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p>
<hr>
<h3 id="Web项目"><a href="#Web项目" class="headerlink" title="Web项目"></a>Web项目</h3><hr>
<p>Maven Web项目结构</p>
<pre><code>和java同级下有webapp目录，包含html文件夹和WEB-INF文件夹
</code></pre>
<p>编译后的Java字节码文件和resources的资源文件，放到WEB-INF下的classes目录下。pom.xml中依赖坐标对应的jar包，放入WEB-INF下的lib目录下.</p>
<p><strong>使用骨架</strong></p>
<p>创建Maven项目:</p>
<pre><code>勾选Create from archetype
选择maven-archetype-webapp
</code></pre>
<p>删除pom.xml中多余内容:</p>
<pre><code>&lt;build&gt;
    &lt;finalName&gt;tomcatdemo&lt;/finalName&gt;
    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
</code></pre>
<p>补齐Maven Web项目缺失的目录结构:</p>
<pre><code>java
resource
</code></pre>
<hr>
<h3 id="IDEA使用Tomcat"><a href="#IDEA使用Tomcat" class="headerlink" title="IDEA使用Tomcat"></a>IDEA使用Tomcat</h3><hr>
<p>Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。</p>
<p>然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的,如何在IDEA中能快速使用Tomcat呢?</p>
<p>在IDEA中集成使用Tomcat有两种方式，分别是集成本地Tomcat和Tomcat Maven插件。</p>
<p>集成本地Tomcat：</p>
<pre><code>Edit Configurations -&gt; 加号 -&gt; Tomcat Server -&gt; Local -&gt; Configure 

配置TomEE Home:apache-tomcat-8.5.68

Deployment -&gt; 加号 -&gt; Artifat 配置war
</code></pre>
<p>Tomcat Maven 插件：只需要两步，分别是:</p>
<pre><code>在pom.xml中添加Tomcat插件
&lt;build&gt;
   &lt;plugins&gt;
   	&lt;!--Tomcat插件 --&gt;
       &lt;plugin&gt;
           &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
           &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
       &lt;/plugin&gt;
   &lt;/plugins&gt;
&lt;/build&gt;

使用Maven Helper插件快速启动项目，选中项目，右键--&gt;Run Maven --&gt; tomcat7:run
</code></pre>
<p>在IDEA中下载Maven Helper插件，具体的操作方式为: File –&gt; Settings –&gt; Plugins –&gt; Maven Helper —&gt; Install,安装完后按照提示重启IDEA，就可以看到了。</p>
<p><strong>Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用。</strong></p>
<p>使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml:</p>
<pre><code>&lt;build&gt;
    &lt;plugins&gt;
    	&lt;!--Tomcat插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
            &lt;configuration&gt;
            	&lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt;
                &lt;!--项目访问路径
                    未配置访问路径: http://localhost:80/tomcat-demo2/a.html
                    配置/后访问路径: http://localhost:80/a.html
                    如果配置成 /hello,访问路径会变成什么?
                        答案: http://localhost:80/hello/a.html
                --&gt;
                &lt;path&gt;/&lt;/path&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<hr>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Servlet 是 Java提供的一门动态web资源开发技术。</p>
<p>Servlet 是JavaEE 规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet。</p>
<hr>
<h3 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h3><hr>
<p>创建 web项目，导入 Servlet依赖坐标：</p>
<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
  &lt;version&gt;3.1.0&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>创建：定义一个类，实现 Servlet接口，并重写接口中所有方法，并在 service方法中输入一句话:</p>
<pre><code>public class ServletDemo1 implements Servlet &#123;
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;
        System.out.println(&quot;servlet hello vorld&quot;);
    &#125;
&#125;
</code></pre>
<p>配置：在类上使用@WebServlet 注解，配置该 Servlet的访问路径:</p>
<pre><code>@WebServlet(&quot;/demo1&quot;)
public class ServletDemo1 implements Servlet &#123;
</code></pre>
<p>访问：启动 Tomcat，浏览器输入URL 访问该Servlet</p>
<pre><code>http://localhost:8080/web-demo/demo1
</code></pre>
<hr>
<h3 id="Servlet执行流程和生命周期"><a href="#Servlet执行流程和生命周期" class="headerlink" title="Servlet执行流程和生命周期"></a>Servlet执行流程和生命周期</h3><hr>
<p>Servlet 由谁创建？Servlet方法由谁调用？</p>
<p>Servlet由web服务器创建，Servlet方法由web服务器调用。</p>
<p>服务器怎么知道Servlet中一定有service方法？</p>
<p>因为我们自定义的Servlet，必须实现Servlet接口并复写其方法，而Servlet接口中有service方法。</p>
<p>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</p>
<pre><code>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象
初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法**只调用一次**
请求处理：**每次请求**Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。
服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收
</code></pre>
<p>loadOnstartup：</p>
<pre><code>@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)
loadOnstartup的取值有两类情况
    （1）负整数:第一次访问时创建Servlet对象
    （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高
</code></pre>
<p>Servlet 方法介绍：</p>
<pre><code>//初始化方法，在Servlet被创建时执行，只执行一次
void init(ServletConfig config)

//提供服务方法， 每次Servlet被访问，都会调用该方法
void service(ServletRequest req, ServletResponse res) 

//销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁
void destroy()

//获取ServletConfig对象
ServletConfig getServletConfig()

//获取Servlet信息
String getServletInfo() 
</code></pre>
<hr>
<h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><hr>
<p>HttpServlet：对HTTP协议封装的Servlet实现类。</p>
<pre><code>@WebServlet(&quot;/demo4&quot;)
public class ServletDemo4 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;get...&quot;);
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;post...&quot;);
    &#125;
&#125;
</code></pre>
<p>自己封装请求方式：</p>
<pre><code>public class MyHttpServlet implements Servlet &#123;
    @Override
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;
        // 根据请求方式的不同，进行分别的处理
        HttpServletRequest request = (HttpServletRequest) req;
        //1. 获取请求方式
        String method = request.getMethod();
        //2. 判断
        if(&quot;GET&quot;.equals(method))&#123;
            // get方式的处理逻辑
            doGet(req,res);
        &#125;else if(&quot;POST&quot;.equals(method))&#123;
            // post方式的处理逻辑
            doPost(req,res);
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="urlPattern配置"><a href="#urlPattern配置" class="headerlink" title="urlPattern配置"></a>urlPattern配置</h3><hr>
<p>一个Servlet，可以配置多个 urlPattern:</p>
<pre><code>@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)
</code></pre>
<p>urlPattern 配置规则:</p>
<pre><code>//精确匹配
@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;&#125;)

//目录匹配-通配符
@WebServlet(urlPatterns = &quot;/user/*&quot;)

//扩展名匹配-注意没有斜杠
@WebServlet(urlPatterns = &quot;*.do&quot;)

//任意匹配
@WebServlet(urlPatterns = &quot;/&quot;)
@WebServlet(urlPatterns = &quot;/*&quot;)
</code></pre>
<p><code>/</code> 和 <code>/*</code> 区别：当我们的项目中的Servlet配置了“&#x2F;”，会覆盖掉tomcat中的DefaultServlet，当其他的 url-pattern都匹配不上时都会走这个Servlet。当我们的项目中配置了“&#x2F;*”，意味着匹配任意访问路径</p>
<p>优先级：</p>
<pre><code>   精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; /* &gt; /
</code></pre>
<hr>
<h3 id="XML配置方式编写Servlet"><a href="#XML配置方式编写Servlet" class="headerlink" title="XML配置方式编写Servlet"></a>XML配置方式编写Servlet</h3><hr>
<p>Servlet 从3.0版本后开始支持使用注解配置，3.0版本前只支持 XML 配置文件的配置方式。</p>
<p>在 main&#x2F;webapp&#x2F;WEB-INF&#x2F;web.xml中配置该Servlet：</p>
<pre><code>&lt;!--Servlet 全类名 --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.tea.web.ServletDemo13&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;!--Servlet 访问路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<hr>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><hr>
<p>ServletRequest(Java提供的请求对象根接口) -&gt; HttpServletRequest(Java提供的对Http协议封装的请求对象接口<br>) -&gt; RequestFacade(Tomcat 定义的实现类)</p>
<hr>
<h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><hr>
<p>请求行：</p>
<pre><code>String getMethod()：获取请求方式： GET
String getContextPath()：获取虚拟目录(项目访问路径)： /request-demo
StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1
String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1
String getQueryString()：获取请求参数（GET方式）： username=zhangsan&amp;password=123
</code></pre>
<p>请求头:</p>
<pre><code>String getHeader(String name)：根据请求头名称，获取值
</code></pre>
<p>请求体:</p>
<pre><code>ServletInputStream  getInputStream()：获取字节输入流
BufferedReader getReader()：获取字符输入流
</code></pre>
<p>代码：</p>
<pre><code>@WebServlet(&quot;/req1&quot;)
public class RequestDemo1 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // String getMethod()：获取请求方式： GET
        String method = req.getMethod();
        System.out.println(method);//GET
        // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo
        String contextPath = req.getContextPath();
        System.out.println(contextPath);
        // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1
        StringBuffer url = req.getRequestURL();
        System.out.println(url.toString());
        // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1
        String uri = req.getRequestURI();
        System.out.println(uri);
        // String getQueryString()：获取请求参数（GET方式）： username=zhangsan
        String queryString = req.getQueryString();
        System.out.println(queryString);
        //------------
        // 获取请求头：user-agent: 浏览器的版本信息
        String agent = req.getHeader(&quot;user-agent&quot;);
        System.out.println(agent);
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //获取post 请求体：请求参数
        //1. 获取字符输入流
        BufferedReader br = req.getReader();
        //2. 读取数据
        String line = br.readLine();
        System.out.println(line);
    &#125;
&#125;
</code></pre>
<p>Request 通用方式获取请求参数:</p>
<pre><code>//三种方式：
Map&lt;String, String[]&gt; getParameterMap()：获取所有参数Map集合
String[] getParameterValues(String name) ：根据名称获取参数值（数组）
String getParameter(String name)：根据名称获取参数值（单个值）
</code></pre>
<hr>
<h3 id="请求参数中文乱码"><a href="#请求参数中文乱码" class="headerlink" title="请求参数中文乱码"></a>请求参数中文乱码</h3><hr>
<p>POST请求参数解决中文乱码:</p>
<pre><code>request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码
</code></pre>
<p>GET请求参数解决中文乱码，原因:</p>
<pre><code>// 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1
//1. URL编码
String encode = URLEncoder.encode(username, &quot;utf-8&quot;);
System.out.println(encode);
//2. URL解码
String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;);
System.out.println(decode);
</code></pre>
<p>GET请求参数解决中文乱码，解决办法：</p>
<pre><code>//获取username
String username = request.getParameter(&quot;username&quot;);
System.out.println(&quot;解决乱码前：&quot;+username);
//先对乱码数据进行编码：转为字节数组。ISO_8859_1和UTF_8字节数组是一样的。
byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);
//字节数组解码
username = new String(bytes, StandardCharsets.UTF_8);*/
</code></pre>
<p>Tomcat 8.0 之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8。</p>
<hr>
<h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><hr>
<p>请求转发(forward)：一种在服务器内部的资源跳转方式。</p>
<p>demo5转发到demo6：</p>
<pre><code>//存储数据
request.setAttribute(&quot;msg&quot;,&quot;hello&quot;);
//请求转发
request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response);
</code></pre>
<p>请求转发资源间共享数据：使用Request对象：</p>
<pre><code>void setAttribute(String name, Object o)：存储数据到 request域中
Object getAttribute(String name)：根据 key，获取值
void removeAttribute(String name)：根据 key，删除该键值对
</code></pre>
<p>请求转发特点：</p>
<pre><code>浏览器地址栏路径不发生变化
只能转发到当前服务器的内部资源
一次请求，可以在转发的资源间使用request共享数据
</code></pre>
<hr>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="继承体系-1"><a href="#继承体系-1" class="headerlink" title="继承体系"></a>继承体系</h3><hr>
<p>ServletResponse(Java提供的请求对象根接口) -&gt; HttpServletResponse(Java提供的对Http协议封装的请求对象接口<br>) -&gt; ResponseFacade(Tomcat 定义的实现类)</p>
<hr>
<h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><hr>
<p>响应行：</p>
<pre><code>void setStatus(int sc) ：设置响应状态
</code></pre>
<p>响应头：</p>
<pre><code>void setHeader(String name, String value) ：设置响应头键值对
</code></pre>
<p>响应体：</p>
<pre><code>PrintWriter getWriter()：获取字符输出流
ServletOutputStream getOutputStream()：获取字节输出流
</code></pre>
<hr>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><hr>
<p>实现方式：</p>
<pre><code>//方式一：
resp.setStatus(302);
resp.setHeader(“location”,“资源B的路径&quot;);

//方式二：
resp.sendRedirect(&quot;资源B的路径&quot;);
</code></pre>
<p>重定向特点：</p>
<pre><code>浏览器地址栏路径发生变化
可以重定向到任意位置的资源（服务器内部、外部均可）
两次请求，不能在多个资源使用request共享数据
</code></pre>
<p>可以和请求转发对比。</p>
<p>代码：</p>
<pre><code>//重定向
//1.设置响应状态码 302
response.setStatus(302);
//2. 设置响应头 Location
response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;);

//简化方式完成重定向
//动态获取虚拟目录
String contextPath = request.getContextPath();
response.sendRedirect(contextPath+&quot;/resp2&quot;);

response.sendRedirect(&quot;https://www.baidu.com&quot;);
</code></pre>
<hr>
<h3 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h3><hr>
<p>明确路径谁使用：</p>
<pre><code>浏览器使用：需要加虚拟目录(项目访问路径)
服务端使用：不需要加虚拟目录，比如请求转发
</code></pre>
<p>动态获取虚拟目录：</p>
<pre><code>String contextPath = request.getContextPath();
</code></pre>
<hr>
<h3 id="响应字符数据"><a href="#响应字符数据" class="headerlink" title="响应字符数据"></a>响应字符数据</h3><hr>
<pre><code>//中文数据乱码：原因通过Response获取的字符输出流默认编码：ISO-8859-1
response.setContentType(&quot;text/html;charset=utf-8&quot;);
//1. 获取字符输出流
PrintWriter writer = response.getWriter();
//content-type	设置支持html的标签
//response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);

writer.write(&quot;你好&quot;);
writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);
//细节：流不需要关闭
</code></pre>
<hr>
<h3 id="响应字节数据"><a href="#响应字节数据" class="headerlink" title="响应字节数据"></a>响应字节数据</h3><hr>
<p>IOUtils工具类：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;

IOUtils.copy(输入流,输出流);
</code></pre>
<p>响应字节数据:</p>
<pre><code>//通过Response对象获取字节输出流
ServletOutputStream outputStream = resp.getOutputStream();
//写数据
outputStream.write(字节数据);
</code></pre>
<p>代码：</p>
<pre><code>//1. 读取文件
FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;);
//2. 获取response字节输出流
ServletOutputStream os = response.getOutputStream();
//3. 完成流的copy
/* byte[] buff = new byte[1024];
int len = 0;
while ((len = fis.read(buff))!= -1)&#123;
    os.write(buff,0,len);
&#125;*/
IOUtils.copy(fis,os);
fis.close();
</code></pre>
<hr>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><hr>
<p>JSP：Java Server Pages，Java服务端页面。一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容。</p>
<p>JSP &#x3D; HTML + Java</p>
<p>JSP的作用：简化开发，避免了在Servlet中直接输出HTML标签。</p>
<p>缺点：</p>
<pre><code>书写麻烦：特别是复杂的页面
阅读麻烦
复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE…
占内存和磁盘：JSP会自动生成.java和.class文件占磁盘，运行的是.class文件占内存
调试困难：出错后，需要找到自动生成的.java文件进行调试
不利于团队协作：前端人员不会 Java，后端人员不精 HTML
</code></pre>
<hr>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><hr>
<p>导入JSP坐标：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>创建JSP文件：</p>
<pre><code>new -&gt; jsp/jspx
</code></pre>
<p>编写 HTML标签 和 Java代码:</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;hello jsp&lt;/h1&gt;
    &lt;%
        System.out.println(&quot;hello,jsp~&quot;);
    %&gt;
&lt;/body&gt;
</code></pre>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr>
<p>JSP 本质上就是一个 Servlet.</p>
<p>JSP 在被访问时，由JSP容器(Tomcat)将其转换为 Java文件(Servlet)，在由JSP容器(Tomcat)将其编译，最终对外提供服务的其实就是这个字节码文件.</p>
<hr>
<h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><hr>
<p>JSP 脚本分类：</p>
<pre><code>&lt;%...%&gt;：内容会直接放到_jspService()方法之中
&lt;%=…%&gt;：内容会放到out.print()中，作为out.print()的参数
&lt;%!…%&gt;：内容会放到_jspService()方法之外，被类直接包含
</code></pre>
<p>代码：</p>
<pre><code>&lt;%
    System.out.println(&quot;hello,jsp~&quot;);
    int i = 3;
%&gt;

&lt;%=&quot;hello&quot;%&gt;
&lt;%=i%&gt;

&lt;%!
    void  show()&#123;&#125;
    String name = &quot;zhangsan&quot;;
%&gt;
</code></pre>
<hr>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><hr>
<p>jsp代码是可以截断的：</p>
<pre><code>&lt;%
    for (int i = 0; i &lt; brands.size(); i++) &#123;
        Brand brand = brands.get(i);
%&gt;

&lt;tr align=&quot;center&quot;&gt;
    &lt;td&gt;&lt;%=brand.getId()%&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=brand.getBrandName()%&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=brand.getCompanyName()%&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=brand.getOrdered()%&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=brand.getDescription()%&gt;&lt;/td&gt;

    &lt;%
        if(brand.getStatus() == 1)&#123;
            //显示启用
    %&gt;
        &lt;td&gt;&lt;%=&quot;启用&quot;%&gt;&lt;/td&gt;
    &lt;%
        &#125;else &#123;
            // 显示禁用
    %&gt;
        &lt;td&gt;&lt;%=&quot;禁用&quot;%&gt;&lt;/td&gt;
    &lt;%
        &#125;
    %&gt;

    &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;%
    &#125;
%&gt;
</code></pre>
<hr>
<h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><hr>
<p>Expression Language 表达式语言，用于简化 JSP页面内的Java代码。</p>
<p>主要功能：获取数据。</p>
<p>语法：</p>
<pre><code>$&#123;expression&#125;

$&#123;brands&#125;	获取域中存储的key为brands的数据
$&#123;cookie.key.value&#125; // key指存储在cookie中的键名称
</code></pre>
<p>JavaWeb中的四大域对象：</p>
<pre><code>page：当前页面有效
request：当前请求有效
session：当前会话有效
application：当前应用有效
</code></pre>
<p>el表达式获取数据，会依次从这4个域中寻找，直到找到为止。</p>
<p>示例代码：</p>
<pre><code>//1. 准备数据
List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;();
brands.add(new Brand(1,&quot;三只松鼠&quot;,&quot;三只松鼠&quot;,100,&quot;三只松鼠，好吃不上火&quot;,1));
brands.add(new Brand(2,&quot;优衣库&quot;,&quot;优衣库&quot;,200,&quot;优衣库，服适人生&quot;,0));
brands.add(new Brand(3,&quot;小米&quot;,&quot;小米科技有限公司&quot;,1000,&quot;为发烧而生&quot;,1));
//2. 存储到request域中
request.setAttribute(&quot;brands&quot;,brands);
request.setAttribute(&quot;status&quot;,1);
//3. 转发到 el-demo.jsp
request.getRequestDispatcher(&quot;/el-demo.jsp&quot;).forward(request,response);

//jsp代码：
&lt;body&gt;
    $&#123;brands&#125;
&lt;/body&gt;
</code></pre>
<hr>
<h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><hr>
<p>JSP标准标签库(Jsp Standarded Tag Library) ，使用标签取代JSP页面上的Java代码。</p>
<p>导入坐标：</p>
<pre><code>&lt;!--jstl--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在JSP页面上引入JSTL标签库：</p>
<pre><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<p>c:if代码：</p>
<pre><code>&lt;%--c:if：来完成逻辑判断，替换java  if else--%&gt;
&lt;c:if test=&quot;$&#123;status ==1&#125;&quot;&gt;
    启用
&lt;/c:if&gt;
&lt;c:if test=&quot;$&#123;status ==0&#125;&quot;&gt;
    禁用
&lt;/c:if&gt;
</code></pre>
<p>c:forEach代码：</p>
<pre><code>&lt;%--&lt;c:forEach&gt;：相当于 for 循环--%&gt;
&lt;c:forEach items=&quot;$&#123;brands&#125;&quot; var=&quot;brand&quot; varStatus=&quot;status&quot;&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;%--&lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;--%&gt;
        &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;brand.ordered&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;
        &lt;c:if test=&quot;$&#123;brand.status == 1&#125;&quot;&gt;
            &lt;td&gt;启用&lt;/td&gt;
        &lt;/c:if&gt;
        &lt;c:if test=&quot;$&#123;brand.status != 1&#125;&quot;&gt;
            &lt;td&gt;禁用&lt;/td&gt;
        &lt;/c:if&gt;
        &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre>
<hr>
<h2 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><hr>
<p>会话跟踪技术：</p>
<p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</p>
<p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p>
<p>HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享。</p>
<p>实现方式：</p>
<pre><code>客户端会话跟踪技术：Cookie
服务端会话跟踪技术：Session
</code></pre>
<hr>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><hr>
<p>基本使用：</p>
<pre><code>//创建Cookie对象，设置数据
Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);
//发送Cookie到客户端：使用response对象
response.addCookie(cookie);

//获取客户端携带的所有Cookie，使用request对象
Cookie[] cookies = request.getCookies();
//遍历数组，获取每一个Cookie对象：for
//使用Cookie对象方法获取数据
cookie.getName();
cookie.getValue();
</code></pre>
<p>原理：</p>
<pre><code>Cookie的实现是基于HTTP协议的
响应头：set-cookie
请求头：cookie
</code></pre>
<p>使用细节：</p>
<pre><code>Cookie 存活时间：默认情况下，Cookie 存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁

setMaxAge(int seconds)：设置Cookie存活时间
正数：将 Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除
负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则 Cookie被销毁
零：删除对应 Cookie

Cookie 不能直接存储中文。如需要存储，则需要进行转码：URL编码
</code></pre>
<p>代码示例：</p>
<pre><code>@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //发送Cookie
    //1. 创建Cookie对象
    //Cookie cookie = new Cookie(&quot;username&quot;,&quot;zs&quot;);
    String value = &quot;张三&quot;;
    //URL编码
    value = URLEncoder.encode(value, &quot;UTF-8&quot;);
    System.out.println(&quot;存储数据：&quot;+value);
    Cookie cookie = new Cookie(&quot;username&quot;,value);
    //设置存活时间   ，1周 7天
    cookie.setMaxAge(60*60*24*7);
    //2. 发送Cookie，response
    response.addCookie(cookie);
&#125;

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //获取Cookie
    //1. 获取Cookie数组
    Cookie[] cookies = request.getCookies();
    //2. 遍历数组
    for (Cookie cookie : cookies) &#123;
        //3. 获取数据
        String name = cookie.getName();
        if(&quot;username&quot;.equals(name))&#123;
            String value = cookie.getValue();
            //URL解码
            value = URLDecoder.decode(value,&quot;UTF-8&quot;);
            System.out.println(name+&quot;:&quot;+value);
            break;
        &#125;
    &#125;
</code></pre>
<hr>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><hr>
<p>服务端会话跟踪技术：将数据保存到服务端。JavaEE 提供 HttpSession接口，来实现一次会话的多次请求间数据共享功能。</p>
<p>基本使用：</p>
<pre><code>//获取Session对象
HttpSession session = request.getSession();
//Session对象功能：
void setAttribute(String name, Object o)：存储数据到 session 域中
Object getAttribute(String name)：根据 key，获取值
void removeAttribute(String name)：根据 key，删除该键值对
</code></pre>
<p>原理：</p>
<pre><code>Session是基于Cookie实现的
</code></pre>
<p>使用细节:</p>
<pre><code>服务器重启后，Session中的数据是否还在？
钝化：在服务器正常关闭后， Tomcat会自动将 Session数据写入硬盘的文件中
活化：再次启动服务器后，从文件中加载数据到Session中

Seesion 销毁：默认情况下，无操作，30分钟自动销毁。
web.xml手动配置时间：
&lt;session-config&gt;
    &lt;session-timeout&gt;100&lt;/session-timeout&gt;
&lt;/session-config&gt;
手动销毁：调用 Session对象的 invalidate()方法
</code></pre>
<p>代码示例：</p>
<pre><code>@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //存储到Session中
    //1. 获取Session对象
    HttpSession session = request.getSession();
    System.out.println(session);
    //2. 存储数据
    session.setAttribute(&quot;username&quot;,&quot;zs&quot;);
&#125;

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //获取数据，从session中
    //1. 获取Session对象
    HttpSession session = request.getSession();
    System.out.println(session);
    // 销毁
    //session.invalidate();
    //2. 获取数据
    Object username = session.getAttribute(&quot;username&quot;);
    System.out.println(username);
&#125;
</code></pre>
<hr>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><hr>
<p>Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的。</p>
<p>区别：</p>
<pre><code>存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端
安全性：Cookie 不安全，Session 安全
数据大小：Cookie 最大3KB，Session 无大小限制
存储时间：Cookie 可以长期存储，Session 默认30分钟
服务器性能：Cookie 不占服务器资源，Session 占用服务器资源
</code></pre>
<hr>
<h2 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h2><hr>
<pre><code>import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.Arrays;
import java.util.Random;

/**
 * 生成验证码工具类
 */
public class CheckCodeUtil &#123;

    public static final String VERIFY_CODES = &quot;123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    private static Random random = new Random();


    public static void main(String[] args) throws IOException &#123;
        OutputStream fos = new FileOutputStream(&quot;d://a.jpg&quot;);
        String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4);

        System.out.println(checkCode);
    &#125;


    /**
     * 输出随机验证码图片流,并返回验证码值（一般传入输出流，响应response页面端，Web项目用的较多）
     *
     * @param width 图片宽度
     * @param height 图片高度
     * @param os  输出流
     * @param verifySize 数据长度
     * @return 验证码数据
     * @throws IOException
     */
    public static String outputVerifyImage(int width, int height, OutputStream os, int verifySize) throws IOException &#123;
        String verifyCode = generateVerifyCode(verifySize);
        outputImage(width, height, os, verifyCode);
        return verifyCode;
    &#125;

    /**
     * 使用系统默认字符源生成验证码
     * @param verifySize 验证码长度
     * @return
     */
    public static String generateVerifyCode(int verifySize) &#123;
        return generateVerifyCode(verifySize, VERIFY_CODES);
    &#125;

    /**
     * 使用指定源生成验证码
     *
     * @param verifySize 验证码长度
     * @param sources    验证码字符源
     * @return
     */
    public static String generateVerifyCode(int verifySize, String sources) &#123;
        // 未设定展示源的字码，赋默认值大写字母+数字
        if (sources == null || sources.length() == 0) &#123;
            sources = VERIFY_CODES;
        &#125;
        int codesLen = sources.length();
        Random rand = new Random(System.currentTimeMillis());
        StringBuilder verifyCode = new StringBuilder(verifySize);
        for (int i = 0; i &lt; verifySize; i++) &#123;
            verifyCode.append(sources.charAt(rand.nextInt(codesLen - 1)));
        &#125;
        return verifyCode.toString();
    &#125;

    /**
     * 生成随机验证码文件,并返回验证码值 (生成图片形式，用的较少)
     *
     * @param w
     * @param h
     * @param outputFile
     * @param verifySize
     * @return
     * @throws IOException
     */
    public static String outputVerifyImage(int w, int h, File outputFile, int verifySize) throws IOException &#123;
        String verifyCode = generateVerifyCode(verifySize);
        outputImage(w, h, outputFile, verifyCode);
        return verifyCode;
    &#125;

    /**
     * 生成指定验证码图像文件
     *
     * @param w
     * @param h
     * @param outputFile
     * @param code
     * @throws IOException
     */
    public static void outputImage(int w, int h, File outputFile, String code) throws IOException &#123;
        if (outputFile == null) &#123;
            return;
        &#125;
        File dir = outputFile.getParentFile();
        //文件不存在
        if (!dir.exists()) &#123;
            //创建
            dir.mkdirs();
        &#125;
        try &#123;
            outputFile.createNewFile();
            FileOutputStream fos = new FileOutputStream(outputFile);
            outputImage(w, h, fos, code);
            fos.close();
        &#125; catch (IOException e) &#123;
            throw e;
        &#125;
    &#125;

    /**
     * 输出指定验证码图片流
     *
     * @param w
     * @param h
     * @param os
     * @param code
     * @throws IOException
     */
    public static void outputImage(int w, int h, OutputStream os, String code) throws IOException &#123;
        int verifySize = code.length();
        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
        Random rand = new Random();
        Graphics2D g2 = image.createGraphics();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // 创建颜色集合，使用java.awt包下的类
        Color[] colors = new Color[5];
        Color[] colorSpaces = new Color[]&#123;Color.WHITE, Color.CYAN,
                Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
                Color.PINK, Color.YELLOW&#125;;
        float[] fractions = new float[colors.length];
        for (int i = 0; i &lt; colors.length; i++) &#123;
            colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)];
            fractions[i] = rand.nextFloat();
        &#125;
        Arrays.sort(fractions);
        // 设置边框色
        g2.setColor(Color.GRAY);
        g2.fillRect(0, 0, w, h);

        Color c = getRandColor(200, 250);
        // 设置背景色
        g2.setColor(c);
        g2.fillRect(0, 2, w, h - 4);

        // 绘制干扰线
        Random random = new Random();
        // 设置线条的颜色
        g2.setColor(getRandColor(160, 200));
        for (int i = 0; i &lt; 20; i++) &#123;
            int x = random.nextInt(w - 1);
            int y = random.nextInt(h - 1);
            int xl = random.nextInt(6) + 1;
            int yl = random.nextInt(12) + 1;
            g2.drawLine(x, y, x + xl + 40, y + yl + 20);
        &#125;

        // 添加噪点
        // 噪声率
        float yawpRate = 0.05f;
        int area = (int) (yawpRate * w * h);
        for (int i = 0; i &lt; area; i++) &#123;
            int x = random.nextInt(w);
            int y = random.nextInt(h);
            // 获取随机颜色
            int rgb = getRandomIntColor();
            image.setRGB(x, y, rgb);
        &#125;
        // 添加图片扭曲
        shear(g2, w, h, c);

        g2.setColor(getRandColor(100, 160));
        int fontSize = h - 4;
        Font font = new Font(&quot;Algerian&quot;, Font.ITALIC, fontSize);
        g2.setFont(font);
        char[] chars = code.toCharArray();
        for (int i = 0; i &lt; verifySize; i++) &#123;
            AffineTransform affine = new AffineTransform();
            affine.setToRotation(Math.PI / 4 * rand.nextDouble() * (rand.nextBoolean() ? 1 : -1), (w / verifySize) * i + fontSize / 2, h / 2);
            g2.setTransform(affine);
            g2.drawChars(chars, i, 1, ((w - 10) / verifySize) * i + 5, h / 2 + fontSize / 2 - 10);
        &#125;

        g2.dispose();
        ImageIO.write(image, &quot;jpg&quot;, os);
    &#125;

    /**
     * 随机颜色
     *
     * @param fc
     * @param bc
     * @return
     */
    private static Color getRandColor(int fc, int bc) &#123;
        if (fc &gt; 255) &#123;
            fc = 255;
        &#125;
        if (bc &gt; 255) &#123;
            bc = 255;
        &#125;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    &#125;

    private static int getRandomIntColor() &#123;
        int[] rgb = getRandomRgb();
        int color = 0;
        for (int c : rgb) &#123;
            color = color &lt;&lt; 8;
            color = color | c;
        &#125;
        return color;
    &#125;

    private static int[] getRandomRgb() &#123;
        int[] rgb = new int[3];
        for (int i = 0; i &lt; 3; i++) &#123;
            rgb[i] = random.nextInt(255);
        &#125;
        return rgb;
    &#125;

    private static void shear(Graphics g, int w1, int h1, Color color) &#123;
        shearX(g, w1, h1, color);
        shearY(g, w1, h1, color);
    &#125;

    private static void shearX(Graphics g, int w1, int h1, Color color) &#123;

        int period = random.nextInt(2);

        boolean borderGap = true;
        int frames = 1;
        int phase = random.nextInt(2);

        for (int i = 0; i &lt; h1; i++) &#123;
            double d = (double) (period &gt;&gt; 1)
                    * Math.sin((double) i / (double) period
                    + (6.2831853071795862D * (double) phase)
                    / (double) frames);
            g.copyArea(0, i, w1, 1, (int) d, 0);
            if (borderGap) &#123;
                g.setColor(color);
                g.drawLine((int) d, i, 0, i);
                g.drawLine((int) d + w1, i, w1, i);
            &#125;
        &#125;

    &#125;

    private static void shearY(Graphics g, int w1, int h1, Color color) &#123;
        int period = random.nextInt(40) + 10; // 50;
        boolean borderGap = true;
        int frames = 20;
        int phase = 7;
        for (int i = 0; i &lt; w1; i++) &#123;
            double d = (double) (period &gt;&gt; 1)
                    * Math.sin((double) i / (double) period
                    + (6.2831853071795862D * (double) phase)
                    / (double) frames);
            g.copyArea(i, 0, 1, h1, 0, (int) d);
            if (borderGap) &#123;
                g.setColor(color);
                g.drawLine(i, (int) d, i, 0);
                g.drawLine(i, (int) d + h1, i, h1);
            &#125;

        &#125;

    &#125;
&#125;
</code></pre>
<hr>
<h2 id="Filter和Listener"><a href="#Filter和Listener" class="headerlink" title="Filter和Listener"></a>Filter和Listener</h2><h3 id="Filter介绍"><a href="#Filter介绍" class="headerlink" title="Filter介绍"></a>Filter介绍</h3><hr>
<p>概念：Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。</p>
<p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</p>
<p>过滤器一般完成一些通用的操作，比如：权限控制、统一编码处理、敏感字符处理等等…</p>
<hr>
<h3 id="Filter快速入门"><a href="#Filter快速入门" class="headerlink" title="Filter快速入门"></a>Filter快速入门</h3><hr>
<p>定义类，实现 Filter接口，并重写其所有方法。配置Filter拦截资源的路径：在类上定义 <code>@WebFilter</code> 注解。在doFilter方法中输出一句话，并放行。</p>
<pre><code>import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;
@WebFilter(&quot;/*&quot;)
public class FilterDemo implements Filter &#123;
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //1. 放行前，对 request数据进行处理
        System.out.println(&quot;1.FilterDemo...&quot;);
        //放行
        chain.doFilter(request,response);
        //2. 放行后，对Response 数据进行处理
        System.out.println(&quot;5.FilterDemo...&quot;);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;
    @Override
    public void destroy() &#123;
    &#125;
&#125;
</code></pre>
<p>放行后访问对应资源，资源访问完成后，还会回到Filter中吗？<strong>会</strong></p>
<p>如果回到Filter中，是重头执行还是执行放行后的逻辑呢？<strong>执行放行后的</strong></p>
<pre><code>执行放行前逻辑 -&gt; 放行 -&gt; 访问资源 -&gt; 执行放行后逻辑
</code></pre>
<hr>
<h3 id="Filter使用细节"><a href="#Filter使用细节" class="headerlink" title="Filter使用细节"></a>Filter使用细节</h3><hr>
<p>Filter 可以根据需求，配置不同的拦截资源路径：</p>
<pre><code>拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截。
目录拦截：/user/*：访问/user下的所有资源，都会被拦截。
后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截。
拦截所有：/*：访问所有资源，都会被拦截
</code></pre>
<p>过滤器链：一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p>
<p>注解配置的Filter，优先级按照过滤器**类名(字符串)**的自然排序。</p>
<p>登录验证案例代码：</p>
<pre><code>@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;
    HttpServletRequest req = (HttpServletRequest) request;
    //判断访问资源路径是否和登录注册相关
    String[] urls = &#123;&quot;/login.jsp&quot;,&quot;/imgs/&quot;,&quot;/css/&quot;,&quot;/loginServlet&quot;,&quot;/register.jsp&quot;,&quot;/registerServlet&quot;,&quot;/checkCodeServlet&quot;&#125;;
    // 获取当前访问的资源路径
    String url = req.getRequestURL().toString();
    //循环判断
    for (String u : urls) &#123;
        if(url.contains(u))&#123;
            //找到了-放行
            chain.doFilter(request, response);
            //break;
            return;
        &#125;
    &#125;
    //1. 判断session中是否有user
    HttpSession session = req.getSession();
    Object user = session.getAttribute(&quot;user&quot;);

    //2. 判断user是否为null
    if(user != null)&#123;
        // 登录过了-放行
        chain.doFilter(request, response);
    &#125;else &#123;
        // 没有登陆，存储提示信息，跳转到登录页面
        req.setAttribute(&quot;login_msg&quot;,&quot;您尚未登陆！&quot;);
        req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,response);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><hr>
<p>概念：Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。</p>
<p>监听器可以监听就是在application,session,request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>
<p>Listener分类：JavaWeb中提供了8个监听器</p>
<p>ServletContextListener 使用：</p>
<pre><code>@WebListener
public class ContextLoaderListener implements ServletContextListener &#123;
    @Override
    public void contextInitialized(ServletContextEvent sce) &#123;
        //加载资源
        System.out.println(&quot;ContextLoaderListener...&quot;);
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent sce) &#123;
        //释放资源
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>概念：AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。</p>
<p>AJAX作用：</p>
<pre><code>与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据。使用了AJAX和服务器进行通信，就可以使用 HTML+AJAX来替换JSP页面了。

异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验，等等…
</code></pre>
<p>同步发送请求过程：浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。</p>
<p>异步发送请求：浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</p>
<hr>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><hr>
<pre><code>&lt;script&gt;
    //1. 创建核心对象
    var xhttp;
    if (window.XMLHttpRequest) &#123;
        xhttp = new XMLHttpRequest();
    &#125; else &#123;
        // code for IE6, IE5
        xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    &#125;
    //2. 发送请求
    xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/ajaxServlet&quot;);
    xhttp.send();

    //3. 获取响应
    xhttp.onreadystatechange = function() &#123;
        if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;
               alert(this.responseText);
        &#125;
    &#125;;
&lt;/script&gt;
</code></pre>
<hr>
<h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><hr>
<p>Axios 异步框架。Axios 对原生的AJAX进行封装，简化书写。官网：<a target="_blank" rel="noopener" href="https://www.axios-http.cn/">https://www.axios-http.cn</a></p>
<p>使用：</p>
<pre><code>引入 axios 的 js 文件
&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    //1. get
    axios(&#123;
        method:&quot;get&quot;,
        url:&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;
    &#125;).then(function (resp) &#123;
        alert(resp.data);
    &#125;)

    //2. post
    axios(&#123;
        method:&quot;post&quot;,
        url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;,
        data:&quot;username=zhangsan&quot;
    &#125;).then(function (resp) &#123;
        alert(resp.data);
    &#125;)
&lt;/script&gt;
</code></pre>
<p>别名方式：</p>
<pre><code>&lt;script&gt;
    //1. get
    axios.get(&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;).then(function (resp) &#123;
        alert(resp.data);
    &#125;)

    //2. post
   axios.post(&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;,&quot;username=zhangsan&quot;).then(function (resp) &#123;
        alert(resp.data);
    &#125;)
&lt;/script&gt;
</code></pre>
<p>Axios中，JSON字符串和JS对象自动进行转换。</p>
<hr>
<h3 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h3><hr>
<p>Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，是目前Java语言中最快的JSON库，可以实现Java对象和JSON字符串的相互转换。</p>
<p>导入坐标：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.62&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Java对象转JSON:</p>
<pre><code>String jsonStr = JSON.toJSONString(obj);
</code></pre>
<p>JSON字符串转Java对象:</p>
<pre><code>User user = JSON.parseObject(jsonStr, User.class);
</code></pre>
<hr>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h3><hr>
<p>Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;90%。简化开发（IoC、AOP、事务处理），降低企业级开发的复杂性。框架整合，高效整合其他技术，提高企业级应用开发与运行效率。</p>
<p>官网：spring.io</p>
<p>Spring发展到今天已经形成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能。</p>
<pre><code>Spring Framework
Spring Boot
Spring Cloud
等等。。。
</code></pre>
<p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p>
<pre><code>Core Container：核心容器

AOP：面向切面编程
Aspects：AOP思想实现

Data Access：数据访问
Data Integration：数据集成

Web：Web开发

Test：单元测试与集成测试
</code></pre>
<p>使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象。<strong>IoC（Inversion of Control）控制反转</strong>：对象的创建控制权由程序转移到外部，这种思想称为控制反转。</p>
<p>Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的“外部”。IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean。</p>
<p><strong>DI（Dependency Injection）依赖注入</strong>：在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。</p>
<p>最终效果：使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</p>
<p>原始代码：</p>
<pre><code>public interface BookDao &#123;
    public void save();
&#125;

public class BookDaoImpl implements BookDao &#123;
    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);
    &#125;
&#125;

public interface BookService &#123;
    public void save();
&#125;

public class BookServiceImpl implements BookService &#123;
    private BookDao bookDao = new BookDaoImpl();
    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
    &#125;
&#125;

public class App &#123;
    public static void main(String[] args) &#123;
        BookService bookService = new BookServiceImpl();
        bookService.save();
    &#125;
&#125;
//输出
//book service save ...
//book dao save ...
</code></pre>
<p>Ioc入门：</p>
<pre><code>&lt;!--导入spring的坐标--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--新建xml：resources -&gt; new -&gt; xml configuration File -&gt; Spring Config--&gt;
&lt;!--配置bean--&gt;
    &lt;!--bean标签标示配置bean
    id属性标示给bean起名字
    class属性表示给bean定义类型--&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.tea.web.dao.impl.BookDaoImpl&quot;/&gt;
    &lt;bean id=&quot;bookService&quot; class=&quot;com.tea.web.service.impl.BookServiceImpl&quot; /&gt;
&lt;/beans&gt;

public class App2 &#123;
    public static void main(String[] args) &#123;
        //获取IoC容器
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;);
        bookService.save();
    &#125;
&#125;
//输出
//book service save ...
//book dao save ...
</code></pre>
<p>DI入门:</p>
<pre><code>//改造BookServiceImpl
public class BookServiceImpl implements BookService &#123;
    //5.删除业务层中使用new的方式创建的dao对象
    private BookDao bookDao;
    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
    &#125;
    //6.提供对应的set方法
    public void setBookDao(BookDao bookDao) &#123;
        this.bookDao = bookDao;
    &#125;
&#125;

&lt;!--设置xml--&gt;
&lt;bean id=&quot;bookDao&quot; class=&quot;com.tea.web.dao.impl.BookDaoImpl&quot;/&gt;
&lt;bean id=&quot;bookService&quot; class=&quot;com.tea.web.service.impl.BookServiceImpl&quot;&gt;
    &lt;!--7.配置server与dao的关系--&gt;
    &lt;!--name：BookServiceImpl类中的成员变量bookDao。ref：上面的id-bookDao--&gt;
    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<hr>
<h3 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h3><hr>
<p>xml中bean基础配置：</p>
<pre><code>id：bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一
class：bean的类型，即配置的bean的全路径类名
</code></pre>
<p>bean别名配置：</p>
<pre><code>定义bean的别名，可定义多个，使用逗号(,)分号(;)空格( )分隔

&lt;bean id=&quot;bookDao&quot; name=&quot;dao bookDaoImpl&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;/&gt;
&lt;bean name=&quot;service,bookServiceImpl&quot; class=&quot;com.service.impl.BookServiceImpl&quot;/&gt;
</code></pre>
<p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常 <code>NoSuchBeanDefinitionException</code> 。</p>
<p>bean作用范围配置：</p>
<pre><code>scope:定义bean的作用范围，可选范围如下
singleton：单例（默认）
prototype：非单例

&lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot; /&gt;
</code></pre>
<p>bean是如何创建的:</p>
<pre><code>bean实例化:bean本质上就是对象，创建bean使用构造方法完成
</code></pre>
<p>实例化bean的三种方式:</p>
<p>实例化bean的三种方式————构造方法（常用）:</p>
<pre><code>public class BookDaoImpl implements BookDao &#123;

    //public BookDaoImpl() &#123;
    //    System.out.println(&quot;book dao constructor is running ....&quot;);
    //&#125;

    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);
    &#125;
&#125;

&lt;bean id=&quot;bookDao&quot;  class=&quot;com.dao.impl.BookDaoImpl&quot;/&gt;

无参构造方法如果不存在，将抛出异常BeanCreationException
</code></pre>
<p>实例化bean的三种方式————静态工厂（了解）:</p>
<pre><code>//静态工厂创建对象
public class OrderDaoFactory &#123;
    public static OrderDao getOrderDao()&#123;
        System.out.println(&quot;factory setup....&quot;);
        return new OrderDaoImpl();
    &#125;
&#125;

&lt;!--方式二：使用静态工厂实例化bean--&gt;
&lt;bean id=&quot;orderDao&quot; class=&quot;com.factory.OrderDaoFactory&quot; factory-method=&quot;getOrderDao&quot;/&gt;
</code></pre>
<p>实例化bean的三种方式————实例工厂（了解）:</p>
<pre><code>//实例工厂创建对象
public class UserDaoFactory &#123;
    public UserDao getUserDao()&#123;
        return new UserDaoImpl();
    &#125;
&#125;
&lt;!--方式三：使用实例工厂实例化bean--&gt;
&lt;bean id=&quot;userFactory&quot; class=&quot;com.factory.UserDaoFactory&quot;/&gt;
&lt;bean id=&quot;userDao&quot; factory-method=&quot;getUserDao&quot; factory-bean=&quot;userFactory&quot;/&gt;
</code></pre>
<p>实例化bean的第四种方式FactoryBean(实用):</p>
<pre><code>import org.springframework.beans.factory.FactoryBean;
//FactoryBean创建对象
public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; &#123;
    //代替原始实例工厂中创建对象的方法
    public UserDao getObject() throws Exception &#123;
        return new UserDaoImpl();
    &#125;
    public Class&lt;?&gt; getObjectType() &#123;
        return UserDao.class;
    &#125;
    //设置是否单例：实现方法isSingleton即可
&#125;

&lt;!--方式四：使用FactoryBean实例化bean--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.factory.UserDaoFactoryBean&quot;/&gt;
</code></pre>
<p>bean的生命周期-方式一在xml中配置对应方法：</p>
<pre><code>&lt;!--init-method：设置bean初始化生命周期回调函数--&gt;
&lt;!--destroy-method：设置bean销毁生命周期回调函数，仅适用于单例对象--&gt;
&lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;

public class BookDaoImpl implements BookDao &#123;
    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);
    &#125;
    //表示bean初始化对应的操作
    public void init()&#123;
        System.out.println(&quot;init...&quot;);
    &#125;
    //表示bean销毁前对应的操作
    public void destory()&#123;
        System.out.println(&quot;destory...&quot;);
    &#125;
&#125;
</code></pre>
<p>bean的生命周期-方式二InitializingBean和DisposableBean：</p>
<pre><code>import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;
    private BookDao bookDao;
    public void setBookDao(BookDao bookDao) &#123;
        System.out.println(&quot;set .....&quot;);
        this.bookDao = bookDao;
    &#125;
    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
    &#125;

    public void destroy() throws Exception &#123;
        System.out.println(&quot;service destroy&quot;);
    &#125;

    public void afterPropertiesSet() throws Exception &#123;
        System.out.println(&quot;service init&quot;);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><hr>
<p>向一个类中传递数据的方式：普通方法（set方法）和 构造方法。</p>
<p>传递数据的类型：引用类型和简单类型（基本数据类型与String）。</p>
<p>依赖注入方式：</p>
<pre><code>setter注入
    简单类型
    引用类型
构造器注入
    简单类型
    引用类型
</code></pre>
<p>setter注入-引用类型：</p>
<pre><code>public class BookServiceImpl implements BookService&#123;
    private BookDao bookDao;
    private UserDao userDao;
    //setter注入需要提供要注入对象的set方法
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
    //setter注入需要提供要注入对象的set方法
    public void setBookDao(BookDao bookDao) &#123;
        this.bookDao = bookDao;
    &#125;
    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
        userDao.save();
    &#125;
&#125;

&lt;bean id=&quot;userDao&quot; class=&quot;com.dao.impl.UserDaoImpl&quot;/&gt;
&lt;bean id=&quot;bookDao&quot; class=&quot;com..dao.impl.BookDaoImpl&quot;/&gt;
&lt;!--注入引用类型--&gt;
&lt;bean id=&quot;bookService&quot; class=&quot;com.service.impl.BookServiceImpl&quot;&gt;
    &lt;!--property标签：设置注入属性--&gt;
    &lt;!--name属性：设置注入的属性名，实际是set方法对应的名称--&gt;
    &lt;!--ref属性：设置注入引用类型bean的id或name--&gt;
    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>setter注入-简单类型：</p>
<pre><code>public class BookDaoImpl implements BookDao &#123;
    private String databaseName;
    private int connectionNum;
    //setter注入需要提供要注入对象的set方法
    public void setConnectionNum(int connectionNum) &#123;
        this.connectionNum = connectionNum;
    &#125;
    //setter注入需要提供要注入对象的set方法
    public void setDatabaseName(String databaseName) &#123;
        this.databaseName = databaseName;
    &#125;
    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;+databaseName+&quot;,&quot;+connectionNum);
    &#125;
&#125;

&lt;!--注入简单类型--&gt;
&lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;&gt;
    &lt;!--property标签：设置注入属性--&gt;
    &lt;!--name属性：设置注入的属性名，实际是set方法对应的名称--&gt;
    &lt;!--value属性：设置注入简单类型数据值--&gt;
    &lt;property name=&quot;connectionNum&quot; value=&quot;100&quot;/&gt;
    &lt;property name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>构造器注入-简单类型和引用类型：</p>
<pre><code>public class BookDaoImpl implements BookDao &#123;
    private String databaseName;
    private int connectionNum;

    public BookDaoImpl(String databaseName, int connectionNum) &#123;
        this.databaseName = databaseName;
        this.connectionNum = connectionNum;
    &#125;

    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;+databaseName+&quot;,&quot;+connectionNum);
    &#125;
&#125;

public class BookServiceImpl implements BookService&#123;
    private BookDao bookDao;
    private UserDao userDao;

    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;
        this.bookDao = bookDao;
        this.userDao = userDao;
    &#125;

    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
        userDao.save();
    &#125;
&#125;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;!--
    标准书写
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;&gt;
        根据构造方法参数名称注入
        &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;10&quot;/&gt;
        &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.dao.impl.UserDaoImpl&quot;/&gt;

    &lt;bean id=&quot;bookService&quot; class=&quot;com.service.impl.BookServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;
--&gt;
&lt;!--
    解决形参名称的问题，与形参名不耦合
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;&gt;
        根据构造方法参数类型注入
        &lt;constructor-arg type=&quot;int&quot; value=&quot;10&quot;/&gt;
        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.dao.impl.UserDaoImpl&quot;/&gt;

    &lt;bean id=&quot;bookService&quot; class=&quot;com.service.impl.BookServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;--&gt;

    &lt;!--解决参数类型重复问题，使用位置解决参数匹配--&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;&gt;
        &lt;!--根据构造方法参数位置注入--&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;100&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.dao.impl.UserDaoImpl&quot;/&gt;

    &lt;bean id=&quot;bookService&quot; class=&quot;com.service.impl.BookServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>强制依赖使用构造器进行。使用setter注入有概率不进行注入导致null对象出现。可选依赖使用setter注入进行，灵活性强。Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨。自己开发的模块推荐使用setter注入。</p>
<hr>
<p>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为<strong>自动装配</strong>。自动装配方式：按类型（常用）、按名称、按构造方法、不启用自动装配。</p>
<p>依赖自动装配：配置中使用bean标签autowire属性设置自动装配的类型</p>
<pre><code>&lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;/&gt;
&lt;bean id=&quot;bookService&quot; class=&quot;com.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;
</code></pre>
<p>自动装配用于引用类型依赖注入，不能对简单类型进行操作。使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用。<br>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用。</p>
<p>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效。</p>
<hr>
<p>集合注入：</p>
<pre><code>public class BookDaoImpl implements BookDao &#123;

    private int[] array;
    private List&lt;String&gt; list;
    private Set&lt;String&gt; set;
    private Map&lt;String,String&gt; map;
    private Properties properties;
    public void setArray(int[] array) &#123;
        this.array = array;
    &#125;
    public void setList(List&lt;String&gt; list) &#123;
        this.list = list;
    &#125;
    public void setSet(Set&lt;String&gt; set) &#123;
        this.set = set;
    &#125;
    public void setMap(Map&lt;String, String&gt; map) &#123;
        this.map = map;
    &#125;
    public void setProperties(Properties properties) &#123;
        this.properties = properties;
    &#125;

    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);
        System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array));
        System.out.println(&quot;遍历List&quot; + list);
        System.out.println(&quot;遍历Set&quot; + set);
        System.out.println(&quot;遍历Map&quot; + map);
        System.out.println(&quot;遍历Properties&quot; + properties);
    &#125;
&#125;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.dao.impl.BookDaoImpl&quot;&gt;
        &lt;!--数组注入--&gt;
        &lt;property name=&quot;array&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;100&lt;/value&gt;
                &lt;value&gt;200&lt;/value&gt;
                &lt;value&gt;300&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list集合注入--&gt;
        &lt;property name=&quot;list&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;it&lt;/value&gt;
                &lt;value&gt;fghf&lt;/value&gt;
                &lt;value&gt;ghf&lt;/value&gt;
                &lt;value&gt;hgfd&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--set集合注入--&gt;
        &lt;property name=&quot;set&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;jgf&lt;/value&gt;
                &lt;value&gt;jh&lt;/value&gt;
                &lt;value&gt;jhfg&lt;/value&gt;
                &lt;value&gt;nv&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--map集合注入--&gt;
        &lt;property name=&quot;map&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;country&quot; value=&quot;china&quot;/&gt;
                &lt;entry key=&quot;province&quot; value=&quot;henan&quot;/&gt;
                &lt;entry key=&quot;city&quot; value=&quot;kaifeng&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--Properties注入--&gt;
        &lt;property name=&quot;properties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;country&quot;&gt;china&lt;/prop&gt;
                &lt;prop key=&quot;province&quot;&gt;henan&lt;/prop&gt;
                &lt;prop key=&quot;city&quot;&gt;kaifeng&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<h3 id="druid和ComboPooledDataSource配置"><a href="#druid和ComboPooledDataSource配置" class="headerlink" title="druid和ComboPooledDataSource配置"></a>druid和ComboPooledDataSource配置</h3><hr>
<p>加载properties配置文件信息：</p>
<pre><code>不加载系统属性
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;

加载多个properties文件
&lt;context:property-placeholder location=&quot;jdbc.properties,msg.properties&quot;/&gt;

加载所有properties文件
&lt;context:property-placeholder location=&quot;*.properties&quot;/&gt;

加载properties文件标准格式
&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt;

从类路径或jar包中搜索并加载properties文件
&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt;
</code></pre>
<p>Spring管理第三方资源：DruidDataSource和ComboPooledDataSource。</p>
<p>坐标：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.1.16&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;c3p0&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.1.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>applicationContext.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            &quot;&gt;
&lt;!--    管理DruidDataSource对象--&gt;
&lt;!--    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;maxPoolSize&quot; value=&quot;1000&quot;/&gt;
    &lt;/bean&gt;--&gt;

&lt;!--    1.开启context命名空间--&gt;
&lt;!--    2.使用context空间加载properties文件--&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;
&lt;!--    3.使用属性占位符$&#123;&#125;读取properties文件中的属性--&gt;
&lt;!--    说明：idea自动识别$&#123;&#125;加载的属性值，需要手工点击才可以查阅原始书写格式--&gt;
    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>jdbc.properties:</p>
<pre><code>jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db
jdbc.username=root
jdbc.password=root
</code></pre>
<p>执行代码：</p>
<pre><code>public class App &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;);
        System.out.println(dataSource);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>创建容器的两种方式：</p>
<pre><code>方式一：类路径加载配置文件
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

方式二：文件路径加载配置文件
ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;D:\\applicationContext.xml&quot;);

加载多个配置文件
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;, &quot;bean2.xml&quot;);
</code></pre>
<p>获取bean的三种方式:</p>
<pre><code>方式一：使用bean名称获取
BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);

方式二：使用bean名称获取并指定类型
BookDao bookDao = ctx.getBean(&quot;bookDao&quot;, BookDao.class);

方式三：使用bean类型获取
BookDao bookDao = ctx.getBean(BookDao.class);
</code></pre>
<p>BeanFactory初始化:</p>
<pre><code>Resource resources = new ClassPathResource(&quot;applicationContext.xml&quot;);
BeanFactory bf = new XmlBeanFactory(resources);
BookDao bookDao = bf.getBean(&quot;bookDao&quot;, BookDao.class);
bookDao.save();
</code></pre>
<p>BeanFactory是顶层接口。BeanFactory创建完毕后，所有的bean均为延迟加载（即new XmlBeanFactory之后，bean的构造方法不加载）。</p>
<p>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载。ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载。</p>
<p>bean相关：</p>
<pre><code>&lt;bean
    id=&quot;bookDao&quot;	&lt;!--bean的Id	--&gt;
    name=&quot;dao bookDaoImpl daoImpl&quot;	&lt;!--bean别名	--&gt;
    class=&quot;com.dao.impl.BookDaoImpl&quot;	&lt;!--bean类型，静态工厂类，FactoryBean类	--&gt;
    scope=&quot;singleton&quot;	&lt;!--控制bean的实例数量	--&gt;
    init-method=&quot;init&quot;	&lt;!--生命周期初始化方法	--&gt;
    destroy-method=&quot;destory&quot;	&lt;!--生命周期销毁方法	--&gt;
    autowire=&quot;byType&quot;	&lt;!--自动装配类型	--&gt;
    factory-method=&quot;getInstance&quot;	&lt;!--bean工厂方法，应用于静态工厂或实例工厂	--&gt;
    factory-bean=&quot;com.factory.BookDaoFactory&quot;	&lt;!--实例工厂bean	--&gt;
    lazy-init=&quot;true&quot; /&gt;	&lt;!--控制bean延迟加载	--&gt;
</code></pre>
<p>依赖注入相关:</p>
<pre><code>&lt;bean id=&quot;bookService&quot; class=&quot;com.service.impl.BookServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;		&lt;!--构造器注入引用类型	--&gt;
    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg name=&quot;msg&quot; value=&quot;WARN&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; index=&quot;3&quot; value=&quot;WARN&quot;/&gt;		&lt;!--构造器注入简单类型,类型匹配与索引匹配	--&gt;
    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;		&lt;!--setter注入引用类型	--&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;property name=&quot;msg&quot; value=&quot;WARN&quot;/&gt;		&lt;!--setter注入简单类型	--&gt;
    &lt;property name=&quot;names&quot;&gt;		&lt;!--setter注入集合类型	--&gt;
        &lt;list&gt;
            &lt;value&gt;dsafas&lt;/value&gt;
            &lt;ref bean=&quot;dataSource&quot;/&gt;		&lt;!--集合注入引用类型	--&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<hr>
<h3 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h3><hr>
<p>注解开发定义bean：</p>
<pre><code>&lt;bean id=&quot;bookService&quot; class=&quot;com.tea.service.impl.BookServiceImpl&quot;/&gt;

//使用注解实现
@Component(&quot;bookService&quot;)
public class BookServiceImpl implements BookService &#123;&#125;
//xml:核心配置文件中通过组件扫描加载bean
&lt;context:component-scan base-package=&quot;com.tea&quot;/&gt;
</code></pre>
<p>Spring提供 <code>@Component</code> 注解的三个衍生注解:</p>
<pre><code>@Controller：用于表现层bean定义
@Service：用于业务层bean定义
@Repository：用于数据层bean定义
</code></pre>
<p>Spring3.0升级了纯注解开发模式，使用Java类替代xml配置文件，开启了Spring快速开发赛道:</p>
<pre><code>//配置类
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
//声明当前类为Spring配置类
@Configuration
//设置bean扫描路径，多个路径书写为字符串数组格式
@ComponentScan(&#123;&quot;com.tea.service&quot;,&quot;com.tea.dao&quot;&#125;)
public class SpringConfig &#123;
&#125;

//使用配置
public class AppForAnnotation &#123;
    public static void main(String[] args) &#123;
        //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //按类型获取bean
        BookService bookService = ctx.getBean(BookService.class);
        System.out.println(bookService);
    &#125;
&#125;
</code></pre>
<p><code>@Configuration</code> 注解用于设定当前类为配置类。</p>
<p><code>@ComponentScan</code> 注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式。</p>
<p>bean作用范围（Scope）和生命周期的注解（PostConstruct、PreDestroy）：</p>
<pre><code>@Repository
//@Scope设置bean的作用范围
@Scope(&quot;singleton&quot;)
public class BookDaoImpl implements BookDao &#123;
    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);
    &#125;
    //@PostConstruct设置bean的初始化方法
    @PostConstruct
    public void init() &#123;
        System.out.println(&quot;init ...&quot;);
    &#125;
    //@PreDestroy设置bean的销毁方法
    @PreDestroy
    public void destroy() &#123;
        System.out.println(&quot;destroy ...&quot;);
    &#125;
&#125;
</code></pre>
<p>依赖注入（Autowired）：</p>
<pre><code>@Service
public class BookServiceImpl implements BookService &#123;
    //@Autowired：注入引用类型，自动装配模式，默认按类型装配
    @Autowired
    //@Qualifier：自动装配bean时按bean名称装配
    @Qualifier(&quot;bookDao&quot;)
    private BookDao bookDao;
    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
    &#125;
&#125;
</code></pre>
<p>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。</p>
<p>注意：自动装配建议使用无参构造方法创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法。</p>
<p>使用 <code>@Qualifier</code> 注解开启指定名称装配bean。注意：<code>@Qualifier</code> 注解无法单独使用，必须配合 <code>@Autowired</code> 注解使用。</p>
<p>简单类型注入(Value):</p>
<pre><code>@Repository(&quot;bookDao&quot;)
public class BookDaoImpl implements BookDao &#123;
    @Value(&quot;100&quot;)
    private String connectionNum;
&#125;
</code></pre>
<p>加载properties文件(PropertySource):</p>
<pre><code>@Configuration
@ComponentScan(&quot;com.tea&quot;)
//@PropertySource加载properties配置文件
@PropertySource(&#123;&quot;jdbc.properties&quot;&#125;)
public class SpringConfig &#123;
&#125;

@Repository(&quot;bookDao&quot;)
public class BookDaoImpl implements BookDao &#123;
    //@Value：注入简单类型（无需提供set方法）
    @Value(&quot;$&#123;name&#125;&quot;)
    private String name;
    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot; + name);
    &#125;
&#125;

//resources下jdbc.properties文件
name=tea
</code></pre>
<hr>
<h3 id="第三方bean管理"><a href="#第三方bean管理" class="headerlink" title="第三方bean管理"></a>第三方bean管理</h3><hr>
<p>坐标：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;druid&lt;/artifactId&gt;
      &lt;version&gt;1.1.16&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>定义单独配置类：</p>
<pre><code>public class JdbcConfig &#123;
    //1.定义一个方法获得要管理的对象
    @Value(&quot;com.mysql.jdbc.Driver&quot;)
    private String driver;
    @Value(&quot;jdbc:mysql://localhost:3306/spring_db&quot;)
    private String url;
    @Value(&quot;root&quot;)
    private String userName;
    @Value(&quot;root&quot;)
    private String password;
    //2.添加@Bean，表示当前方法的返回值是一个bean
    //@Bean修饰的方法，形参根据类型自动装配
    @Bean
    public DataSource dataSource(BookDao bookDao)&#123;
        System.out.println(bookDao);
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    &#125;
&#125;
</code></pre>
<p>上面的<code>BookDao</code> 参数，引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。</p>
<pre><code>@Repository
public class BookDaoImpl implements BookDao &#123;
    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);
    &#125;
&#125;
</code></pre>
<p>配置类导入单独配置：</p>
<pre><code>@Configuration
@ComponentScan(&quot;com.tea&quot;)
//@Import:导入配置信息
@Import(&#123;JdbcConfig.class&#125;)
public class SpringConfig &#123;
&#125;
</code></pre>
<p>使用：</p>
<pre><code>public class App &#123;
    public static void main(String[] args) &#123;
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        DataSource dataSource = ctx.getBean(DataSource.class);
        System.out.println(dataSource);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="XML配置比对注解配置"><a href="#XML配置比对注解配置" class="headerlink" title="XML配置比对注解配置"></a>XML配置比对注解配置</h3><hr>
<table>
<thead>
<tr>
<th>功能</th>
<th>XML配置</th>
<th>注解</th>
</tr>
</thead>
<tbody><tr>
<td>定义bean</td>
<td>bean标签:id属性、class属性</td>
<td>@Component（@Controller、@Service、@Repository）、@ComponentScan</td>
</tr>
<tr>
<td>设置依赖注入</td>
<td>setter注入(set方法)、构造器注入(构造方法)、自动装配</td>
<td>@Autowired@Qualifier@Value</td>
</tr>
<tr>
<td>配置第三方bean</td>
<td>bean标签：静态工厂、实例工厂、FactoryBean</td>
<td>@Bean</td>
</tr>
<tr>
<td>作用范围</td>
<td>scope属性</td>
<td>@Scope</td>
</tr>
<tr>
<td>生命周期</td>
<td>标准接口：init-method、destroy-method</td>
<td>@PostConstructor、@PreDestroy</td>
</tr>
</tbody></table>
<hr>
<h3 id="Spring整合mybatis"><a href="#Spring整合mybatis" class="headerlink" title="Spring整合mybatis"></a>Spring整合mybatis</h3><hr>
<p>在pom.xml中添加基础依赖:</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;druid&lt;/artifactId&gt;
      &lt;version&gt;1.1.16&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.5.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
      &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>service层代码:</p>
<pre><code>public interface AccountService &#123;
    void save(Account account);
    void delete(Integer id);
    void update(Account account);
    List&lt;Account&gt; findAll();
    Account findById(Integer id);
&#125;
@Service
public class AccountServiceImpl implements AccountService &#123;
    @Autowired
    private AccountDao accountDao;
    public void save(Account account) &#123;
        accountDao.save(account);
    &#125;
    public void update(Account account)&#123;
        accountDao.update(account);
    &#125;
    public void delete(Integer id) &#123;
        accountDao.delete(id);
    &#125;
    public Account findById(Integer id) &#123;
        return accountDao.findById(id);
    &#125;
    public List&lt;Account&gt; findAll() &#123;
        return accountDao.findAll();
    &#125;
&#125;
</code></pre>
<p>dao层基础代码:</p>
<pre><code>public interface AccountDao &#123;
    @Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)
    void save(Account account);
    @Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)
    void delete(Integer id);
    @Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)
    void update(Account account);
    @Select(&quot;select * from tbl_account&quot;)
    List&lt;Account&gt; findAll();
    @Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)
    Account findById(Integer id);
&#125;
</code></pre>
<p>domain包下：</p>
<pre><code>public class Account implements Serializable &#123;
    private Integer id;
    private String name;
    private Double money;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Double getMoney() &#123;
        return money;
    &#125;
    public void setMoney(Double money) &#123;
        this.money = money;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Account&#123;&quot; +&quot;id=&quot; + id +&quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +&quot;, money=&quot; + money +&#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>创建JdbcConfig配置DataSource数据源:</p>
<pre><code>//resources文件下jdbc.properties文件
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false
jdbc.username=root
jdbc.password=root

public class JdbcConfig &#123;
    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)
    private String driver;
    @Value(&quot;$&#123;jdbc.url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;jdbc.username&#125;&quot;)
    private String userName;
    @Value(&quot;$&#123;jdbc.password&#125;&quot;)
    private String password;
    @Bean
    public DataSource dataSource()&#123;
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    &#125;
&#125;
</code></pre>
<p>创建MybatisConfig整合mybatis:</p>
<pre><code>public class MybatisConfig &#123;
    //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage(&quot;com.tea.domain&quot;);
        ssfb.setDataSource(dataSource);
        return ssfb;
    &#125;
    //定义bean，返回MapperScannerConfigurer对象
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer()&#123;
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage(&quot;com.tea.dao&quot;);
        return msc;
    &#125;
&#125;
</code></pre>
<p>创建SpringConfig主配置类进行包扫描和加载其他配置类:</p>
<pre><code>@Configuration
@ComponentScan(&quot;com.tea&quot;)
//@PropertySource：加载类路径jdbc.properties文件
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import(&#123;JdbcConfig.class, MybatisConfig.class&#125;)
public class SpringConfig &#123;
&#125;
</code></pre>
<p>定义测试类进行测试:</p>
<pre><code>public class App &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);
        Account ac = accountService.findById(1);
        System.out.println(ac);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="Spring整合Junit单元测试"><a href="#Spring整合Junit单元测试" class="headerlink" title="Spring整合Junit单元测试"></a>Spring整合Junit单元测试</h3><hr>
<p>导入整合的依赖坐标:</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--spring整合junit--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>使用Spring整合Junit专用的类加载器，加载配置文件或者配置类：</p>
<pre><code>//使用Spring整合Junit专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
//加载配置文件或者配置类
@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) //加载配置类
//@ContextConfiguration(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载配置文件
public class AccountServiceTest &#123;
    //支持自动装配注入bean
    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById()&#123;
        System.out.println(accountService.findById(1));
    &#125;

    @Test
    public void testFindAll()&#123;
        System.out.println(accountService.findAll());
    &#125;
&#125;
</code></pre>
<p>注意：junit的依赖至少要是4.12版本,可以是4.13等版本,否则出现异常。</p>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><hr>
<p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。</p>
<p>OOP(Object Oriented Programming)面向对象编程。</p>
<p>AOP作用：在不惊动原始设计的基础上为其进行功能增强。简单的说就是在不改变方法源代码的基础上对方法进行功能增强。</p>
<p>连接点（JoinPoint）：正在执行的方法，例如：update()、delete()、select()等都是连接点。</p>
<p>切入点（Pointcut）：进行功能增强了的方法，例如:update()、delete()方法，select()方法没有被增强所以不是切入点，但是是连接点。在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法。一个具体方法：com.tea.dao包下的BookDao接口中的无形参无返回值的save方法。匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法。</p>
<p>通知（Advice）：在切入点前后执行的操作，也就是增强的共性功能。在SpringAOP中，功能最终以方法的形式呈现。</p>
<p>通知类：通知方法所在的类叫做通知类。</p>
<p>切面（Aspect）：描述通知与切入点的对应关系，也就是哪些通知方法对应哪些切入点方法。</p>
<p>AOP工作流程:</p>
<pre><code>//导入aop相关坐标：
&lt;dependencies&gt;
    &lt;!--spring核心依赖，会将spring-aop传递进来--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--切入点表达式依赖，目的是找到切入点方法，也就是找到要增强的方法--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

//定义dao接口与实现类：
public interface BookDao &#123;
    public void save();
    public void update();
&#125;
@Repository
public class BookDaoImpl implements BookDao &#123;
    public void save() &#123;
        System.out.println(System.currentTimeMillis());
        System.out.println(&quot;book dao save ...&quot;);
    &#125;
    public void update()&#123;
        System.out.println(&quot;book dao update ...&quot;);
    &#125;
&#125;

//定义通知类，制作通知方法:
//定义切入点表达式、配置切面(绑定切入点与通知关系):
//通知类必须配置成Spring管理的bean
@Component
//设置当前类为切面类类
@Aspect
public class MyAdvice &#123;
    //设置切入点，@Pointcut注解要求配置在方法上方
    @Pointcut(&quot;execution(void com.tea.dao.BookDao.update())&quot;)
    private void pt()&#123;&#125;

    //设置在切入点pt()的前面运行当前操作(前置通知)
    @Before(&quot;pt()&quot;)
    public void method()&#123;
        System.out.println(System.currentTimeMillis());
    &#125;
&#125;

//在配置类中进行Spring注解包扫描和开启AOP功能
@Configuration
@ComponentScan(&quot;com.tea&quot;)
//开启注解开发AOP功能
@EnableAspectJAutoProxy
public class SpringConfig &#123;
&#125;

//测试类和运行结果
public class App &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class);
        bookDao.update();
    &#125;
&#125;
</code></pre>
<p>AOP工作流程:</p>
<pre><code>Spring容器启动
读取所有切面配置中的切入点
初始化bean，判定bean对应的类中的方法是否匹配到任意切入点
   - 匹配失败，创建原始对象
   - 匹配成功，创建原始对象（目标对象）的代理对象
获取bean执行方法
   - 获取的bean是原始对象时，调用方法并执行，完成操作
   - 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作
</code></pre>
<p>AOP核心概念:</p>
<pre><code>目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。
代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。
</code></pre>
<p>AOP切入点表达式，语法格式：</p>
<pre><code>//切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）
execution(public User com.tea.service.UserService.findById(int))

动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点
访问修饰符：public，private等，可以省略
返回值：写返回值类型
包名：多级包使用点连接
类/接口名：
方法名：
参数：直接写参数的类型，多个类型用逗号隔开
异常名：方法定义中抛出指定异常，可以省略
</code></pre>
<p>通配符:</p>
<pre><code>* ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现

匹配com.tea包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法
execution（public * com.tea.*.UserService.find*(*))

.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写

匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法
execution（public User com..UserService.findById(..))

+：专用于匹配子类类型

execution(* *..*Service+.*(..))
</code></pre>
<p>AOP通知共分为5种类型：</p>
<pre><code>前置通知：在切入点方法执行之前执行
后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。
环绕通知(重点)：手动调用切入点方法并对其进行增强的通知方式。
返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。
抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。

前置通知：@Before
后置通知：@After
返回后通知：@AfterReturning（了解）
抛出异常后通知：@AfterThrowing（了解）
环绕通知：@Around（重点，常用）

@Around(&quot;pt()&quot;)
public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    System.out.println(&quot;around before advice ...&quot;);
    Object ret = pjp.proceed();
    System.out.println(&quot;around after advice ...&quot;);
    return ret;
&#125;
</code></pre>
<p>环绕通知注意事项：</p>
<pre><code>环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。

环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。

//获取执行的签名对象
Signature signature = pjp.getSignature();
//获取接口/类全限定名
String className = signature.getDeclaringTypeName();
//获取方法名
String methodName = signature.getName();
</code></pre>
<p>AOP切入点数据获取-获取参数:</p>
<pre><code>JoinPoint：适用于前置、后置、返回后、抛出异常后通知
ProceedJointPoint：适用于环绕通知

@Before(&quot;pt()&quot;)
public void before(JoinPoint jp) &#123;
    Object[] args = jp.getArgs(); //获取连接点方法的参数们
    System.out.println(Arrays.toString(args));
&#125;

@Around(&quot;pt()&quot;)
public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    Object[] args = pjp.getArgs(); //获取连接点方法的参数们
    System.out.println(Arrays.toString(args));
    Object ret = pjp.proceed();
    return ret;
&#125;
</code></pre>
<p>AOP切入点数据获取-获取切入点方法返回值:</p>
<pre><code>返回后通知
环绕通知

@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)
public void afterReturning(Object ret) &#123; //变量名要和returning=&quot;ret&quot;的属性值一致
    System.out.println(&quot;afterReturning advice ...&quot;+ret);
&#125;

@Around(&quot;pt()&quot;)
public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    // 手动调用连接点方法，返回值就是连接点方法的返回值
    Object ret = pjp.proceed();
    return ret;
&#125;
</code></pre>
<p>AOP切入点数据获取-获取切入点方法运行异常信息:</p>
<pre><code>抛出异常后通知
环绕通知

@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)
public void afterThrowing(Throwable t) &#123;//变量名要和throwing = &quot;t&quot;的属性值一致
    System.out.println(&quot;afterThrowing advice ...&quot;+ t);
&#125;

@Around(&quot;pt()&quot;)
public Object around(ProceedingJoinPoint pjp)  &#123;
    Object ret = null;
    //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常
    try &#123;
        ret = pjp.proceed();
    &#125; catch (Throwable t) &#123;
        t.printStackTrace();
    &#125;
    return ret;
&#125;
</code></pre>
<hr>
<h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><hr>
<p>实现步骤一-在业务层接口上添加Spring事务管理</p>
<pre><code>public interface AccountService &#123;
    //配置当前接口方法具有事务
    @Transactional
    public void transfer(String out,String in ,Double money) ;
&#125;
</code></pre>
<p>注意事项:Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合。注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务。</p>
<p>实现步骤二-设置事务管理器(将事务管理器添加到IOC容器中)：</p>
<pre><code>//可以在JdbcConfig中配置事务管理器
//配置事务管理器，mybatis使用的是jdbc事务
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource)&#123;
    DataSourceTransactionManager dtm = new DataSourceTransactionManager();
    transactionManager.setDataSource(dataSource);
    return transactionManager;
&#125;
</code></pre>
<p>注意事项:事务管理器要根据实现技术进行选择;MyBatis框架使用的是JDBC事务。</p>
<p>实现步骤三-开启注解式事务驱动:</p>
<pre><code>@Configuration
@ComponentScan(&quot;com.itheima&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)
//开启注解式事务驱动
@EnableTransactionManagement
public class SpringConfig &#123;
&#125;
</code></pre>
<p>Spring事务角色：</p>
<pre><code>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法
事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法
</code></pre>
<p>Spring事务相关配置：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>readOnly</td>
<td>设置是否为只读事务</td>
<td>readOnly&#x3D;true 只读事务</td>
</tr>
<tr>
<td>timeout</td>
<td>设置事务超时时间</td>
<td>timeout &#x3D; -1（永不超时）</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>设置事务回滚异常（class）</td>
<td>rollbackFor &#x3D; {NullPointException.class}</td>
</tr>
<tr>
<td>propagation</td>
<td>设置事务传播行为</td>
<td></td>
</tr>
</tbody></table>
<p>propagation传播属性：REQUIRED（默认）、REQUIRES_NEW、SUPPORTS、NOT_SUPPORTED、MANDATORY、NEVER、NESTED。</p>
<hr>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><hr>
<p>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架。优点：使用简单，开发便捷（相比于Servlet）；灵活性强。</p>
<hr>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><hr>
<p>导入SpringMVC坐标与Servlet坐标：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
      &lt;version&gt;3.1.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;port&gt;80&lt;/port&gt;
          &lt;path&gt;/&lt;/path&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>创建SpringMVC控制器类（等同于Servlet功能）：</p>
<pre><code>import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
//定义表现层控制器bean
@Controller
public class UserController &#123;
    //设置映射路径为/save，即外部访问路径
    @RequestMapping(&quot;/save&quot;)
    //设置当前操作返回结果为指定json数据（本质上是一个字符串信息）
    @ResponseBody
    public String save()&#123;
        return &quot;&#123;&#39;info&#39;:&#39;springmvc&#39;&#125;&quot;;
    &#125;
&#125;
</code></pre>
<p>设定SpringMVC加载对应的bean:</p>
<pre><code>//springmvc配置类，本质上还是一个spring配置类
@Configuration
@ComponentScan(&quot;com.tea.controller&quot;)
public class SpringMvcConfig &#123;
&#125;
</code></pre>
<p>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC请求拦截的路径:</p>
<pre><code>import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;

//web容器配置类
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;
    //加载springmvc配置类，产生springmvc容器（本质还是spring容器）
    protected WebApplicationContext createServletApplicationContext() &#123;
        //初始化WebApplicationContext对象
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        //加载指定配置类
        ctx.register(SpringMvcConfig.class);
        return ctx;
    &#125;

    //设置由springmvc控制器处理的请求映射路径
    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;/&quot;&#125;;
    &#125;

    //加载spring配置类
    protected WebApplicationContext createRootApplicationContext() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>运行：</p>
<pre><code>访问：http://localhost/save
返回：&#123;&#39;info&#39;:&#39;springmvc&#39;&#125;
</code></pre>
<p><code>@RequestMapping</code> ：方法注解，设置当前控制器方法请求访问路径。</p>
<p><code>@ResponseBody</code> : 方法注解，设置当前控制器方法响应内容为当前返回值，无需解析。</p>
<p>AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类。AbstractDispatcherServletInitializer提供三个接口方法供用户实现。</p>
<p><code>createServletApplicationContext()</code>方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围。</p>
<p><code>getServletMappings()</code>方法，设定SpringMVC对应的请求映射路径，设置为<code>/</code>表示拦截所有请求，任意请求都将转入到SpringMVC进行处理。</p>
<p><code>createRootApplicationContext()</code>方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，使用方式同createServletApplicationContext()。</p>
<hr>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer"></a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://adamright.github.io/2021/03/01/45.Spring%20Boot%E5%92%8Cmaven/">https://adamright.github.io/2021/03/01/45.Spring%20Boot%E5%92%8Cmaven/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank"></a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/maven/">
                                    <span class="chip bg-color">maven</span>
                                </a>
                            
                                <a href="/tags/Spring-Boot/">
                                    <span class="chip bg-color">Spring Boot</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/04/07/46.%E9%87%8F%E5%8C%96%E6%9D%82%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="量化杂记">
                        
                        <span class="card-title">量化杂记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-04-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/python/" class="post-category">
                                    python
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%87%8F%E5%8C%96/">
                        <span class="chip bg-color">量化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/11/06/44.JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="JVM虚拟机底层原理">
                        
                        <span class="card-title">JVM虚拟机底层原理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-11-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/jvm/">
                        <span class="chip bg-color">jvm</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank"></a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/adamright" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1131045891@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1131045891" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1131045891" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
